# Building Blocks
___
#### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:
##### 1) Обработка даты, времени, текста, числовых и логических значений
+ Используйте примитивы и классы-оболочки, включая Math API,
  скобки, продвижение типа и приведение для оценки
  арифметические и логические выражения
##### 2) Использование объектно-ориентированного подхода Java
+ Объявление и создание экземпляров объектов Java, включая вложенный класс
  объекты и объяснить жизненный цикл объекта
  включая создание,
  переназначение ссылок и сборка мусора
+ Понимать области действия переменных, использовать вывод типа локальной переменной,
  применить инкапсуляцию и сделать объекты неизменяемыми
___
Добро пожаловать в начало вашего пути к Java
17 сертификация. Мы предполагаем, что это не первая книга по программированию на Java, которую вы читаете.
Хотя мы говорим об основах, мы делаем это только потому, что хотим убедиться, что вы владеете всей терминологией и 
подробностями, необходимыми для экзамена. Если вы никогда раньше не писали программы на Java, мы рекомендуем вам 
приобрести вводную книгу по Java 8 или более поздней версии. Примеры включают Head First Java, 3-е издание 
(O’Reilly Media, 2022 г.) и «Начало программирования на Java для чайников» (For Dummies, 2021 г.). 
Затем вернитесь к этому учебному пособию по сертификации.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как говорится в старой поговорке, прежде чем бегать, нужно научиться ходить. 
Точно так же вы должны изучить основы Java, прежде чем сможете создавать сложные программы. В этой главе мы 
представляем основы пакетов, классов, переменных и типов данных Java, а также аспекты каждого из них, которые вам 
необходимо знать для экзамена. Например, вы можете использовать Java каждый день, но не знать, что вы не можете создать 
переменную с именем 3dMap или this. Экзамен предполагает, что вы знаете и понимаете правила, лежащие в основе этих 
принципов. Хотя большую часть этой главы следует повторить, некоторые аспекты языка Java могут быть для вас новыми, 
поскольку они не часто встречаются на практике.

## Изучение окружающей среды
Среда Java состоит из понимания ряда технологий. В следующих разделах мы рассмотрим ключевые термины и сокращения, 
которые вам необходимо знать, а затем обсудим, какое программное обеспечение вам нужно изучить для подготовки к 
экзамену.

#### Основные компоненты Java
Комплект Java Development Kit (JDK) содержит минимальное программное обеспечение, необходимое для разработки Java. 
Ключевые команды включают в себя:
+ javac: конвертирует исходные файлы .java в байт-код .class.
+ java: выполняет программу
+ jar: упаковывает файлы вместе
+ javadoc: cоздает документацию

Программа javac генерирует инструкции в специальном формате, называемом байт-кодом, который может выполнять 
команда java. Затем java запускает виртуальную машину Java (JVM) перед запуском кода. JVM знает, как запускать байт-код 
на той машине, на которой он находится. Вы можете думать о JVM как о специальном волшебном ящике на вашем компьютере, 
который знает, как запустить ваш файл .class в вашей конкретной операционной системе и оборудовании.
___
##### Where Did the JRE Go?
В Java 8 и более ранних версиях вы могли загрузить среду выполнения Java (JRE) вместо полного JDK. JRE была 
подмножеством JDK, которое использовалось для запуска программы, но не могло ее скомпилировать. Теперь люди могут 
использовать полный JDK при запуске программы Java. В качестве альтернативы разработчики могут предоставить исполняемый 
файл, содержащий необходимые части, которые были бы в JRE.

При написании программы есть общие функции и алгоритмы, которые нужны разработчикам. К счастью, нам не нужно писать 
каждый из них самостоятельно. Java поставляется с большим набором интерфейсов прикладного программирования (API), 
которые вы можете использовать. Например, есть класс StringBuilder для создания большой строки и метод в Collections 
для сортировки списка. При написании программы полезно определить, какие части вашего задания могут быть выполнены с 
помощью существующих API.
___

Вы могли заметить, что мы сказали, что JDK содержит минимально необходимое программное обеспечение. Многие разработчики 
используют интегрированную среду разработки (IDE), чтобы упростить написание и выполнение кода. Хотя мы не рекомендуем 
использовать их во время подготовки к экзамену, все же полезно знать, что они существуют. Общие IDE для Java включают 
Eclipse, IntelliJ IDEA и Visual Studio Code.

#### Загрузка JDK

Каждые шесть месяцев Oracle выпускает новую версию Java. Java 17 вышла в сентябре 2021 года. Это означает, что Java 17 
не будет последней версией, когда вы загружаете JDK для подготовки к экзамену. Тем не менее, вы все равно должны 
использовать Java 17 для обучения, так как это экзамен по Java 17. Правила и поведение могут измениться в более поздних 
версиях Java. Вы бы не хотели получить неправильный вопрос, потому что вы изучали другую версию Java!

Вы можете загрузить Oracle JDK на веб-сайте Oracle, используя ту же учетную запись, которую вы использовали для 
регистрации на экзамен. Существует множество доступных JDK, наиболее популярным из которых, помимо JDK Oracle, 
является OpenJDK.

Многие версии Java включают функции предварительного просмотра, которые по умолчанию отключены, но вы можете включить 
их. Функции предварительного просмотра не включены в экзамен. Чтобы избежать путаницы в отношении того, когда функция 
была добавлена в язык, мы будем говорить «была официально представлена», чтобы обозначить, когда она была удалена из 
предварительного просмотра.
___
##### Проверьте свою версию Java
Прежде чем мы пойдем дальше, воспользуйтесь этой возможностью, чтобы убедиться, что у вас есть правильная версия Java 
на вашем пути.

+ javac -version
+ java -version

Обе эти команды должны включать номер версии 17.
___
## Понимание структуры класса
В программах Java классы являются основными строительными блоками. При определении класса вы описываете все части и 
характеристики одного из этих строительных блоков. В последующих главах вы увидите другие строительные блоки, такие как
интерфейсы, записи и перечисления. Чтобы использовать большинство классов, вы должны создавать объекты. 
Объект — это экземпляр класса в памяти во время выполнения. Объект часто называют экземпляром, поскольку он 
представляет собой единственное представление класса. Все различные объекты всех различных классов представляют 
состояние вашей программы. Ссылка — это переменная, указывающая на объект. В следующих разделах мы рассмотрим поля, 
методы и комментарии. Мы также исследуем отношения между классами и файлами.

### Поля и методы
Классы Java имеют два основных элемента: `методы`, часто называемые функциями или процедурами в других языках, и `поля`, 
более известные как переменные. Вместе они называются членами класса. Переменные хранят состояние программы, а методы 
работают с этим состоянием. Если изменение важно запомнить, переменная сохраняет это изменение. Это все, что 
действительно делают классы. Задача программиста — создать и расположить эти элементы таким образом, чтобы полученный 
код был полезен и, в идеале, легок для понимания другими программистами.

Самый простой класс Java, который вы можете написать, выглядит так:
```
1: public class Animal {
2: }
```
Java называет слово со специальным значением ключевым словом, которое мы выделили жирным шрифтом в предыдущем 
фрагменте. На протяжении всей книги мы часто выделяем фрагменты кода жирным шрифтом, чтобы привлечь к ним внимание. 
Строка 1 включает ключевое слово public, позволяющее использовать его другим классам. Ключевое слово class указывает, 
что вы определяете класс. Animal дает имя класса. Конечно, это не интересный класс, так что давайте добавим ваше 
первое поле.

```
1: public class Animal {
2: String name;
3: }
```
---
##### Примечание: Номера строк не являются частью программы; они нужны только для того, чтобы о коде было легче говорить.

---

В строке 2 мы определяем переменную с именем name. Мы также объявляем тип этой переменной как String. 
Строка — это значение, в которое мы можем поместить текст, например «это строка».
String также является классом, поставляемым с Java. Далее мы можем добавить методы.

```
1: public class Animal {
2:     String name;
3:     public String getName() {
4:        return name;
5:     }
6:     public void setName(String newName) {
7:        name = newName;
8:     }
9: }
```
В строках 3–5 мы определяем метод. Метод — это операция, которую можно вызвать. Опять же, public используется для 
обозначения того, что этот метод может быть вызван из других классов. Далее идет тип возвращаемого значения — в
в этом случае метод возвращает строку. В строках 6–8 находится еще один метод.
У этого есть специальный возвращаемый тип, называемый void. Ключевое слово void означает, что вообще не возвращается 
никакого значения. Этот метод требует, чтобы информация была предоставлена ему от вызывающего метода;
эта информация называется параметром. Метод setName() имеет один параметр с именем newName и имеет тип String. Это 
означает, что вызывающая сторона должна передать один строковый параметр и ничего не ожидать.

Имя метода и типы параметров называются сигнатурой метода. В этом примере можете ли вы определить имя и параметры 
метода?

```
public int numberVisitors(int month) {
    return 10;
}
```
Имя метода — numberVisitors. Есть один параметр с именем month, который имеет тип int, который является числовым типом. 
Следовательно, сигнатура метода — numberVisitors(int).

### Комментарии
Другая распространенная часть кода называется комментарием. Поскольку комментарии не являются исполняемым кодом, их 
можно размещать во многих местах. Комментарии могут облегчить чтение вашего кода.
Хотя создатели экзамена пытаются сделать код труднее для чтения, они по-прежнему используют комментарии, чтобы привлечь
внимание к номерам строк. Мы надеемся, что вы используете комментарии в своем собственном коде. В Java есть три типа 
комментариев. Первый называется однострочным комментарием:
```
// comment until end of line или комментарий до конца строки
```
Однострочный комментарий начинается с двух косых черт. Компилятор игнорирует все, что вы вводите после этого в той же 
строке. Далее следует многострочный комментарий:
```
/* 
* Многострочный
* комментарий
*/
```
Многострочный комментарий (также известный как многострочный комментарий) включает в себя все, что начинается с 
символа /* до символа */. Люди часто ставят звездочку (*) в начале каждой строки многострочного комментария, чтобы его 
было легче читать, но это не обязательно. Наконец, у нас есть комментарий Javadoc:
```
/**
* Многострочный Javadoc
комментарий
* @author Жанна и Скотт
*/
```
Этот комментарий похож на многострочный комментарий, за исключением того, что он начинается с /**. Этот специальный 
синтаксис указывает инструменту Javadoc обратить внимание на комментарий. Комментарии Javadoc имеют
определенную структуру, которую инструмент Javadoc умеет читать. Вы, вероятно, не увидите комментарий Javadoc на 
экзамене. Просто помните, что он существует, чтобы вы могли прочитать о нем в Интернете, когда начнете писать программы 
для использования другими.

В качестве практики, можете ли вы определить, к какому типу комментария относится каждое из следующих шести слов? 
Это однострочный?  или многострочный комментарий?
```
/*
* // anteater
*/

// bear

// // cat

// /* dog */

/* elephant */
/*
  * /* ferret */
*/
```
Вы внимательно смотрели? Некоторые из них сложны. Несмотря на то, что технически комментарии не входят в экзамен, 
полезно попрактиковаться в внимательном просмотре кода.

Ладно, к ответам. Комментарий, содержащий муравьед, находится в многострочном комментарии. Все, что находится 
между /* и */, является частью многострочного комментария, даже если оно включает однострочный комментарий.
комментарий внутри него! Комментарий, содержащий медведя, является вашим основным однострочным комментарием. 
Комментарии, содержащие кошку и собаку, также являются однострочными. Все от // до конца строки является частью 
комментария, даже если это комментарий другого типа. Комментарий, содержащий слона, является вашим основным 
многострочным комментарием, даже если он занимает всего одну строку.

Строка с ferret интересна тем, что не компилируется. Все от первого /* до первого */ является частью комментария, 
что означает, что компилятор увидит что-то вроде этого:
```
/* */ */
```
У нас есть проблемы. Есть лишний */. Это недопустимый синтаксис — факт, о котором компилятор с радостью вам сообщит.
### Классы и исходные файлы
В большинстве случаев каждый класс Java определяется в собственном файле .java. В этой главе единственным типом 
ерхнего уровня является класс. Тип верхнего уровня — это структура данных, которую можно определить независимо в 
исходном файле. На протяжении большей части книги мы работаем с классами как с типом верхнего уровня,
но в главе 7 «Помимо классов» мы представляем другие типы верхнего уровня, а также вложенные типы.

Класс верхнего уровня часто является общедоступным, что означает, что его может вызывать любой код. Интересно, что 
Java не требует, чтобы тип был общедоступным. Например, этот класс просто прекрасен:
```
1: class Animal {
2:     String name;
3: }
```
Вы даже можете поместить два типа в один и тот же файл. При этом не более одного из типов верхнего уровня в файле может 
быть общедоступным. Это означает, что файл, содержащий следующее, также подходит:
```
1: public class Animal {
2:     private String name;
3: }
4: class Animal2 {}
```

Если у вас есть общедоступный тип, он должен соответствовать имени файла. Объявление общедоступного класса Animal2 не 
будет компилироваться в файл с именем Animal.java. В главе 5, «Методы», мы обсуждаем, какие варианты доступа доступны, 
кроме общедоступных.
___
Заметили закономерность? Эта глава содержит многочисленные ссылки на темы, которые мы рассмотрим более подробно в 
последующих главах. Если вы опытный Java-разработчик, то заметите, что многие примеры и правила в этой главе упрощены. 
Не волнуйся; у нас есть оставшаяся часть книги, чтобы представить больше правил и сложных пограничных случаев!
___

## Написание метода main()
Программа Java начинает выполнение со своего метода main(). В этом разделе вы узнаете, как создать его, передать 
параметр и запустить программу. Метод main() часто называют точкой входа в программу, потому что это начальная точка, 
которую JVM ищет, когда начинает запускать новую программу.

### Создание метода main()
Метод main() позволяет JVM вызывать наш код. Самый простой возможный класс с методом main() выглядит так:
```
1: public class Zoo {
2:    public static void main(String[] args) {
3:       System.out.println("Hello World");
4:    }
5: }
```

Этот код печатает Hello World. Чтобы скомпилировать и выполнить этот код, введите его в файл с именем Zoo.java и 
выполните следующее:
```
javac Zoo.java
java Zoo
```
Если он печатает Hello World, вы добились успеха. Если вы получаете сообщения об ошибках, убедитесь, что вы установили 
Java 17 JDK, добавили его в PATH и не сделать опечатки в примере. Если у вас возникли какие-либо из этих проблем и вы 
не знаете, что делать, задайте вопрос с сообщением об ошибке, которое вы получили, на форуме Beginning Java на 
CodeRanch:
```
www.coderanch.com/forums/f-33/java
```
Чтобы скомпилировать код Java с помощью команды javac, файл должен иметь расширение .java. Имя файла должно совпадать 
с именем публичного класса. Результатом является файл байт-кода с тем же именем, но с расширением имени файла .class. 
Помните, что байт-код состоит из инструкций, которые JVM умеет выполнять. Обратите внимание, что мы должны опустить 
расширение .class для запуска Zoo.class.

Правила того, что содержит файл Java и в каком порядке, являются более подробными, чем то, что мы объясняли до сих пор 
(подробнее об этой теме далее в этой главе). Чтобы не усложнять задачу, мы следуем этому подмножеству правил:

+ Каждый файл может содержать только один общедоступный класс.
+ Имя файла должно соответствовать имени класса, включая регистр, и иметь расширение .java.
+ Если класс Java является точкой входа для программы, он должен содержать допустимый метод main().

Давайте сначала рассмотрим слова в сигнатуре метода main(), по одному. Ключевое слово public — это то, что называется 
модификатором доступа. Он объявляет уровень воздействия этого метода на потенциальных абонентов в программе. 
Естественно, публичный означает полный доступ из любой точки программы. Вы узнаете больше о модификаторах доступа в 
главе 5.

Ключевое слово static связывает метод с его классом, поэтому его можно вызывать только по имени класса, как, например, 
в Zoo.main(). Java не нужно создавать объект для вызова метода main() — и это хорошо, поскольку вы еще не научились 
создавать объекты! На самом деле, JVM делает это более или менее при загрузке данного имени класса. Если метод main() 
не имеет правильных ключевых слов, вы получите сообщение об ошибке при попытке его запуска. Вы снова видите static в 
главе 6, «Проектирование классов».

Ключевое слово void представляет возвращаемый тип. Метод, который не возвращает никаких данных, автоматически 
возвращает управление вызывающей стороне. В общем, рекомендуется использовать void для методов, которые изменяют 
состояние объекта. В этом смысле метод main() изменяет состояние программы с запущенного на завершенное.
Мы также исследуем типы возврата в главе 5. (Вы уже с нетерпением ждете пятую главу?)

Наконец, мы приходим к списку параметров метода main(), представленному в виде массива объектов java.lang.String. 
Вы можете использовать любое допустимое имя переменной вместе с любым из этих трех форматов:
```
String[] args
String options[]
String... friends
```
Компилятор принимает любой из них. Имя переменной args является общим, поскольку оно намекает, что этот список содержит 
значения, которые были прочитаны (аргументы) при запуске JVM. Символы [] являются скобками и представляют собой массив. 
представляет собой список фиксированного размера элементов одного типа. Символы ... называются varargs (переменные 
списки аргументов). В этой главе вы узнаете о String. Массивы — в главе 4, «Основные API», а переменные — в главе 5.
___
##### Необязательные модификаторы в методах main()
Хотя большинство модификаторов, таких как public и static, требуются для методов main(), разрешены некоторые 
необязательные модификаторы.
```
public final static void main(final String[] args) {} 
(прим. final выделить жирным)
```
В этом примере оба модификатора final являются необязательными, а метод main() является допустимой точкой входа с ними 
или без них. Мы раскрываем значение конечных методов и параметров в главе 6.

### Передача параметров в программу Java
Давайте посмотрим, как отправлять данные в метод main() нашей программы. Во-первых, мы модифицируем программу Zoo, 
чтобы распечатать первые два переданных аргумента:
```
public class Zoo {
  public static void main(String[] args) {
    System.out.println(args[0]);
    System.out.println(args[1]);
  }
}
```
Код args[0] обращается к первому элементу массива. Правильно: индексы массива начинаются с 0 в Java. 
Чтобы запустить его, введите следующее:
```
javac Zoo.java
java Zoo Bronx Zoo
```
Вывод - это то, что вы могли ожидать:
```
Bronx
Zoo
```
Программа правильно идентифицирует первые два «слова» как аргументы. Пробелы используются для разделения аргументов. 
Если вам нужны пробелы внутри аргумента, вам нужно использовать кавычки, как в этом примере:
```
javac Zoo.java
java Zoo "San Diego" Zoo
```
Теперь у нас есть пробел в выводе:
```
San Diego
Zoo
```
Наконец, что произойдет, если вы не передадите достаточно аргументов?
```
javac Zoo.java
java Zoo Zoo
```
Чтение args[0] проходит нормально, и Zoo распечатывается. Тогда Java паникует. Второго аргумента нет! Что делать? 
Java выводит исключение, говорящее вам, что он понятия не имеет, что делать с этим аргументом в позиции 1. 
(Вы узнаете об исключениях в главе 11, «Исключения и локализация».)
```
Zoo
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException:
  Index 1 out of bounds for length 1
  at Zoo.main(Zoo.java:4)
```
Для обзора, JDK содержит компилятор. Файлы классов Java выполняются на JVM и, следовательно, работают на любой машине с 
Java, а не только на машине или операционной системе, на которой они были скомпилированы.
___
##### Однофайловый исходный код
Если вам надоело вводить как javac, так и java каждый раз, когда вы хотите попробовать пример кода, есть ярлык. 
Вместо этого вы можете запустить
```
java Zoo.java Bronx Zoo
```
Здесь есть ключевое отличие. При первой компиляции вы пропустили расширение .java при запуске java. Пропуская шаг явной 
компиляции, вы включаете это
расширение. Эта функция называется запуском однофайловых программ с исходным кодом и полезна для тестирования или для 
небольших программ. Название разумно говорит вам, что оно предназначено для случаев, когда ваша программа представляет 
собой один файл.
___
## Понимание объявлений пакетов и импорт
Java поставляется с тысячами встроенных классов, и таких разработчиков, как вы, бесчисленное множество. Со всеми этими 
классами Java нуждается в способе их организации. Он обрабатывает это так же, как картотечный шкаф. Вы складываете все 
свои бумажки в папки. Java помещает классы в пакеты. Это логические группировки классов.

Мы бы не поставили вас перед картотекой и не сказали бы найти конкретную бумагу. Вместо этого мы бы сказали вам, в 
какой папке искать. Java работает точно так же. Ему нужно, чтобы вы сказали ему, в каких пакетах искать код.

Предположим, вы пытаетесь скомпилировать этот код:
```
public class NumberPicker {
  public static void main(String[] args) {
    Random r = new Random(); // DOES NOT COMPILE
    System.out.println(r.nextInt(10));
  }
}
```
Компилятор Java услужливо выдает вам ошибку, которая выглядит следующим образом:
```
error: cannot find symbol
```
Эта ошибка может означать, что вы допустили опечатку в названии класса. Вы перепроверяете и обнаруживаете, что это не 
так. Другой причиной этой ошибки является пропуск необходимого оператора импорта. Оператор — это инструкция, а 
операторы импорта сообщают Java, в каких пакетах искать классы. Поскольку вы не указали Java, где искать Random, она 
понятия не имеет.

Повторная попытка импорта позволяет скомпилировать код.

```
import java.util.Random; // import tells us where to find Random (import говорит нам, где найти Random)
public class NumberPicker {
  public static void main(String[] args) {
    Random r = new Random();
    System.out.println(r.nextInt(10)); // a number 0-9
  }
}
```
Теперь код работает; он выводит случайное число от 0 до 9. Как и массивы, Java любит начинать счет с 0.

---
В главе 5 мы рассмотрим другой тип импорта, называемый статическим импортом. Это позволяет вам сделать статические 
члены класса известными, часто поэтому вы можете использовать имена переменных и методов без необходимости указывать 
имя класса.
---

### Пакеты
Как вы видели в предыдущем примере, классы Java сгруппированы в пакеты. Оператор import сообщает компилятору, в каком 
пакете искать класс. Это похоже на то, как работает рассылка писем. Представьте, что вы отправляете письмо по адресу 
Мейн-стрит, 123, квартира 9. Почтальон сначала приносит письмо на Мейн-стрит, 123. Затем перевозчик ищет почтовый ящик 
квартиры номер 9. Адрес похож на название пакета на Java. Номер квартиры похож на имя класса в Java. Подобно тому, как 
почтальон смотрит только на номера квартир в здании, Java ищет в пакете только имена классов.

Имена пакетов также иерархичны, как и почта. Почтовая служба начинается с верхнего уровня, в первую очередь глядя на 
вашу страну. Вы также начинаете читать имя пакета в начале. Например, если он начинается с java, это означает, что он 
поставляется с JDK. Если он начинается с что-то еще, это, вероятно, показывает, откуда оно взялось, используя имя 
веб-сайта в обратном порядке. Например, com.wiley.javabook сообщает нам, что код связан с веб-сайтом или организацией 
wiley.com. После названия сайта  вы можете добавить все, что хотите. Например, com.wiley.java.my.name также 
произошло от wiley.com. Java называет более подробные пакеты дочерними пакетами. Пакет com.wiley.javabook является 
дочерним пакетом com.wiley. Вы можете сказать, потому что он длиннее и, следовательно, более конкретен.

На экзамене вы увидите имена пакетов, которые не соответствуют этому соглашению. Не удивляйтесь, увидев такие имена 
пакетов, как a.b.c. Правило для имен пакетов состоит в том, что они в основном состоят из букв или цифр, разделенных 
точками (.). Технически, вам разрешено несколько других  символов между точками (.). Вы даже можете использовать 
имена пакетов веб-сайтов, которыми вы не владеете, если хотите, например com.wiley, хотя люди, читающие ваш код, 
могут быть сбиты с толку! Правила такие же, как и для имен переменных, которые вы увидите далее в этой главе.
экзамен может попытаться обмануть вас с недопустимыми именами переменных. К счастью, он не пытается обмануть вас, 
давая неверные имена пакетов.

В следующих разделах мы рассмотрим импорт с подстановочными знаками, конфликты имен с импортом, как создать 
собственный пакет и как экзамен форматирует код.

### Подстановочные знаки
Классы в одном пакете часто импортируются вместе. Вы можете использовать ярлык для импорта всех классов в пакете.
```
import java.util.*; // imports java.util.Random among other things

public class NumberPicker {
   public static void main(String[] args) {
      Random r = new Random();
      System.out.println(r.nextInt(10));
   }
}
```
В этом примере мы импортировали java.util.Random и кучу других классов. * — это подстановочный знак, который 
соответствует всем классам в пакете. Каждый класс в пакете java.util доступен для этой программы, когда Java его 
компилирует. Оператор импорта не вводит дочерние пакеты, поля или методы; он импортирует только классы непосредственно 
в пакете. Предположим, вы хотите использовать класс AtomicInteger (вы узнаете об этом в главе 13, «Параллелизм») в 
пакете java.util.concurrent.atomic. Какой импорт или импорт поддерживают это?

```
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
```
Только последний импорт позволяет распознать класс, потому что дочерние пакеты не включены в первые два.
Вы можете подумать, что включение такого количества классов замедляет выполнение вашей программы, но это не так. 
Компилятор выясняет, что на самом деле нужно. Какой подход вы выберете, зависит от личных предпочтений или командных 
предпочтений, если вы работаете с другими в команде. Листинг используемые классы облегчают чтение кода, особенно для 
начинающих программистов. Использование подстановочного знака может сократить список импорта. Вы увидите оба подхода 
на экзамене.
### Избыточный импорт
Подождите минуту! Мы ссылались на System без импорта каждый раз, когда печатали текст, и Java с этим справлялся. 
В мире Java есть один специальный пакет, который называется java.lang. Этот пакет особенный тем, что он автоматически 
импортируется. Вы можете ввести этот пакет в операторе импорта, но это не обязательно. Как вы думаете, сколько импортов 
в следующем коде является избыточным?
```
1: import java.lang.System;
2: import java.lang.*;
3: import java.util.Random;
4: import java.util.*;
5: public class NumberPicker {
6:    public static void main(String[] args) {
7:      Random r = new Random();
8:      System.out.println(r.nextInt(10));
9:    }
10: }
```
Ответ заключается в том, что три импорта являются избыточными. Строки 1 и 2 избыточны, потому что все в java.lang 
импортируется автоматически. Строка 4 также избыточна в этом примере, поскольку Random уже импортирован из 
java.util.Random. Однако, если бы строки 3 не было, java.util.* не был бы лишним, поскольку он покрывал бы 
импорт Random.

Другой случай избыточности включает импорт класса, который находится в том же пакете, что и класс, который его 
импортирует. Java автоматически ищет в текущем пакете другие классы. Давайте рассмотрим еще один пример, чтобы 
убедиться, что вы понимаете крайние случаи импорта. В этом примере файлы и пути находятся в пакете java.nio.file. 
На экзамене могут использоваться пакеты, которые вы никогда раньше не видели. Вопрос позволит вам узнать, в каком 
пакете находится класс, если вам нужно это знать, чтобы ответить на вопрос.

Как вы думаете, какие операторы импорта помогут скомпилировать этот код?
```
public class InputImports {
  public void read(Files files) {
    Paths.get("name");
  }
}
```
Есть два возможных ответа. Более короткий - использовать подстановочный знак для одновременного импорта обоих.
```
import java.nio.file.*;
```
Другой ответ - явно импортировать оба класса.
```
import java.nio.file.Files;
import java.nio.file.Paths;
```
Теперь давайте рассмотрим некоторые импорты, которые не работают.
```
import java.nio.*;         // NO GOOD -a wildcard only matches
                          // class names, not "file.Files"

import java.nio.*.*;     // NO GOOD -you can only have one wildcard
                        // and it must be at the end                       
                        
import java.nio.file.Paths.*;  // NO GOOD -youcannot import methods
                              // only class names
```
### Конфликты имен
Одна из причин использования пакетов заключается в том, что имена классов не должны быть уникальными во всей Java. 
Это означает, что иногда вам может понадобиться импортировать класс, который можно найти в нескольких местах. 
Типичным примером этого является класс Date. Java предоставляет реализации java.util.Date и java.sql.Date. 
Какой оператор импорта мы можем использовать, если нам нужна версия java.util.Date?
```
public class Conflicts {
    Date date;
    // some more code
}
```
Ответ должен быть легким к настоящему времени. Вы можете написать либо import java.util.*; или импортируйте 
java.util.Date;. Сложные случаи возникают, когда присутствует другой импорт.
```
import java.util.*;
import java.sql.*; // causes Date declaration to not compile
```
Когда имя класса встречается в нескольких пакетах, Java выдает ошибку компилятора. В нашем примере решение 
простое — удалить ненужный нам import java.sql.*. Но что делать, если нам нужна целая куча других классов в пакете 
java.sql?
```
import java.util.Date;
import java.sql.*;
```
А, теперь работает! Если вы явно импортируете имя класса, оно имеет приоритет над любыми подстановочными знаками. 
Java думает: «Программист действительно хочет, чтобы я использовал класс java.util.Date».

Еще один пример. Что Java делает со «связями» для приоритета?
```
import java.util.Date;
import java.sql.Date;
```

Java достаточно умен, чтобы определить, что этот код никуда не годится. Как программист, вы заявили, что явно хотите, 
чтобы по умолчанию были реализации как java.util.Date, так и java.sql.Date. Поскольку не может быть двух значений по 
умолчанию, компилятор сообщает вам, что импорт неоднозначен.

---
#### Если вам действительно нужно использовать два класса с одинаковым именем

Иногда вам действительно нужно использовать Date из двух разных пакетов. Когда это происходит, вы можете выбрать один 
для использования в операторе импорта и использовать полное имя класса другого. Или вы можете отказаться от обоих 
операторов импорта и всегда использовать полное имя класса.
```
public class Conflicts {
  java.util.Date date;
  java.sql.Date sqlDate;
}
```

### Создание нового пакета

До сих пор весь код, который мы написали в этой главе, находился в пакете по умолчанию. Это специальный безымянный 
пакет, который следует использовать только для одноразового кода. Вы можете сказать, что код находится в пакете по 
умолчанию, потому что нет имени пакета. На экзамене вы увидите, что пакет по умолчанию часто используется для экономии 
места в листингах кода. В реальной жизни всегда называйте свои пакеты, чтобы избежать конфликтов имен и позволить 
другим повторно использовать ваш код.

Теперь пришло время создать новый пакет. Структура каталогов на вашем компьютере связана с именем пакета. 
В этом разделе просто читайте вместе. Мы рассмотрим, как скомпилировать и запустить код в следующем разделе.

Предположим, у нас есть эти два класса:

```
package packagea;
public class ClassA {}

package packageb;
import packagea.ClassA;
public class ClassB {
  public static void main(String[] args) {
    ClassA a;
    System.out.println("Got it");
  }
}
```

Когда вы запускаете программу на Java, Java знает, где искать эти имена пакетов. В этом случае запуск из 
C:\temp работает, потому что под ним находятся и packagea, и packageb.

### Компиляция и запуск кода с пакетами

Вам будет намного легче изучать Java, используя командную строку для компиляции и тестирования ваших примеров. Как 
только вы хорошо изучите синтаксис Java, вы можете переключиться на IDE. Но на экзамене ваша цель — узнать подробности 
о языке, а не позволить IDE скрыть их от вас.

Следуйте этому примеру, чтобы убедиться, что вы знаете, как использовать командную строку. Если у вас возникли 
проблемы с выполнением этой процедуры, задайте вопрос на форуме Beginning Java на CodeRanch. Опишите, что вы 
пробовали и что говорит об ошибке.

```
www.coderanch.com/forums/f-33/java
```

Первый шаг — создать два файла из предыдущего раздела. В таблице 1.1 показаны ожидаемые полные имена файлов и 
команда для входа в каталог для следующих шагов.

#### Таблица 1.1 - Процедура настройки по операционной системе
**Шаг**| |**Windows**| |**Mac/Linux**
:-----:|:-----:|:-----:|:-----:|:-----:
1. Создать первый класс.| |C:\temp\packagea\ClassA.java| |/tmp/packagea/ClassA.java
| | | |
2. Создать второй класс.| |C:\temp\packageb\ClassB.java| |/tmp/packageb/ClassB.java
| | | |
3. Перейти в каталог.| |cd C:\temp| |cd /tmp

Теперь пришло время скомпилировать код. К счастью, это одинаково независимо от операционной системы. Для компиляции 
введите следующую команду:
```
javac packagea/ClassA.java packageb/ClassB.java
```

Если эта команда не работает, вы получите сообщение об ошибке. Внимательно проверьте свои файлы на наличие опечаток 
в предоставленных файлах. Если команда сработает, будут созданы два новых файла: packagea/ClassA.class и 
packageb/ClassB.class.

___
#### Компиляция с подстановочными знаками

Вы можете использовать звездочку, чтобы указать, что вы хотите включить все файлы Java в каталог. Это удобно, когда 
у вас много файлов в пакете. Мы можем переписать предыдущую команду javac следующим образом:

```
javac packagea/*.java packageb/*.java
```

Однако вы не можете использовать подстановочный знак для включения подкаталогов. Если бы вы написали javac *.java, 
код в пакетах не подхватился бы.
___

Теперь, когда ваш код скомпилирован, вы можете запустить его, введя следующую команду:
```
java packageb.ClassB
```
Если это сработает, вы увидите сообщение «Напечатано». Вы могли заметить, что мы ввели ClassB, а не ClassB.class. 
Как обсуждалось ранее, вы не передаете расширение при запуске программы.

На рис. 1.1 показано, где в структуре каталогов были созданы файлы .class.

#### Рис. 1.1 - Компиляция с пакетами
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/images/figure%201.1.PNG)

### Компиляция в другой каталог

По умолчанию команда javac помещает скомпилированные классы в тот же каталог, что и исходный код. Он также 
предоставляет возможность поместить файлы классов в другой каталог. Параметр -d указывает этот целевой каталог.

___
Параметры Java чувствительны к регистру. Это означает, что вы не можете передать -D вместо -d.
___

Если вы следуете инструкциям, удалите файлы ClassA.class и ClassB.class, созданные в предыдущем разделе. Как вы 
думаете, где эта команда создаст файл ClassA.class?

````
javac -d classes packagea/ClassA.java packageb/ClassB.java
````

Правильный ответ находится в классах/пакете a/Class A.class. Структура пакета сохраняется в запрошенном целевом 
каталоге. На рис. 1.2 показана эта новая структура.

#### Рис. 1.2 - Компиляция с пакетами и каталогами
ссылку на рисунок!

Чтобы запустить программу, вы указываете путь к классам, чтобы Java знала, где найти классы. Есть три варианта, 
которые вы можете использовать. Все три из них делают одно и то же:

```
java -cp classes packageb.ClassB
java -classpath classes packageb.ClassB
java --class-path classes packageb.ClassB
```
Обратите внимание, что для последнего требуется два тире (--), а для первых двух требуется один тире (-). Если у вас 
неправильное количество тире, программа не запустится.

___
### Три варианта пути к классам

Вы можете задаться вопросом, почему существует три варианта пути к классам. Опция -cp является короткой формой. 
Разработчики часто выбирают краткую форму, потому что мы ленивые машинистки. Версии -classpath и -- class-path могут 
быть более четкими для чтения, но требуют большего набора текста.

___

В Таблице 1.2 и Таблице 1.3 приведены параметры, которые вам необходимо знать для экзамена. Есть много других 
доступных вариантов! А в Главе 12, «Модули», вы узнаете о дополнительных опциях, специфичных для модулей.

#### Таблица 1.2 - Важные параметры javac

#### Таблица 1.3 - Важные параметры javac

### Компиляция с файлами JAR

Как и в случае с каталогом классов в предыдущем примере, вы также можете явно указать расположение других файлов, 
используя путь к классам. Этот метод полезен, когда файлы классов расположены в другом месте или в специальных файлах 
JAR. Файл архива Java (JAR) подобен ZIP-файлу, состоящему в основном из файлов классов Java.

В Windows введите следующее:

```
java -cp ".;C:\temp\someOtherLocation;c:\temp\myJar.jar" myPackage.MyClass
```

В macOS/Linux введите следующее:

```
java -cp ".:/tmp/someOtherLocation:/tmp/myJar.jar" myPackage.MyClass
```

Точка (.) указывает, что вы хотите включить текущий каталог в путь к классам. Остальная часть команды говорит искать 
свободные файлы классов (или пакеты) в someOtherLocation и в myJar.jar. Windows использует точку с запятой (;) для 
разделения частей пути к классам; другие операционные системы используют двоеточие.

Как и при компиляции, вы можете использовать подстановочный знак (*) для сопоставления всех JAR-файлов в каталоге. 
Вот пример:

```
java -cp "C:\temp\directoryWithJars\*" myPackage.MyClass
```

Эта команда добавит в classpath все файлы JAR, которые находятся в directoryWithJars. Он не будет включать никакие 
JAR-файлы в путь к классам, которые находятся в подкаталоге directoryWithJars.

### Создание JAR-файла

Некоторые JAR-файлы созданы другими, например загружены из Интернета или созданы товарищем по команде. Кроме того, вы 
можете создать файл JAR самостоятельно. Для этого вы используете команду jar. Простейшие команды создают банку, 
содержащую файлы в текущем каталоге. Вы можете использовать краткую или полную форму для каждого варианта.

```
jar -cvf myNewFile.jar .
jar --create --verbose --file myNewFile.jar .
```
Кроме того, вы можете указать каталог вместо использования текущего каталога.

```
jar -cvf myNewFile.jar -C dir .
```

Длинной формы опции -C не существует. В Таблице 1.4 перечислены параметры, необходимые для использования команды jar 
для создания файла JAR. В главе 12 вы снова видите jar для модулей.

#### Таблица 1.4 - Важные параметры jar

### Упорядочивание элементов в классе

Теперь, когда вы ознакомились с наиболее распространенными частями класса, давайте рассмотрим правильный порядок их 
ввода в файл. Комментарии могут располагаться в любом месте кода. Кроме того, вам необходимо запомнить правила из 
таблицы 1.5.

#### Таблица 1.5 - Порядок объявления класса


Давайте рассмотрим несколько примеров, которые помогут вам запомнить это. Первый пример содержит по одному из каждого 
элемента:

```
package structure; // package must be first non-comment
import java.util.*; // import must come after package

public class Meerkat { // then comes the class
   double weight; // fields and methods can go in either order
   public double getWeight() {
       return weight; }
   double height; // another field -they don't need to be together
}
```

Все идет нормально. Это обычная схема, с которой вы должны быть знакомы. Как насчет этого?

```
/* header */

package structure;

// class Meerkat
public class Meerkat { }
```

Все еще хорошо. Мы можем размещать комментарии где угодно, пустые строки игнорируются, а импорт необязателен. 
В следующем примере у нас есть проблема:

```
import java.util.*;
package structure; // DOES NOT COMPILE
String name; // DOES NOT COMPILE
public class Meerkat { } // DOES NOT COMPILE
```

Здесь есть две проблемы. Во-первых, операторы package и import меняются местами. Хотя оба являются необязательными, 
пакет должен предшествовать импорту, если он присутствует. Другая проблема заключается в том, что поле пытается 
объявить вне класса. Это не разрешено. Поля и методы должны находиться внутри класса.

Получил все это? Подумайте об аббревиатуре PIC (изображение): пакет, импорт и класс. Поля и методы легче запомнить, 
потому что они просто должны находиться внутри класса.

___
На протяжении всей этой книги, если вы видите два общедоступных класса в фрагменте кода или вопросе, вы можете 
предположить, что они находятся в разных файлах, если только не указано, что они находятся в одном и том же файле .java.
___

Теперь вы знаете, как создать и организовать класс. В последующих главах показано, как создавать классы с более 
мощными операциями.

## Создание объектов

Наши программы не смогли бы сделать ничего полезного, если бы у нас не было возможности создавать новые объекты. 
Помните, что объект является экземпляром класса. В следующих разделах мы рассмотрим конструкторы, поля объектов, 
инициализаторы экземпляров и порядок, в котором инициализируются значения.

### Вызов конструкторов

Чтобы создать экземпляр класса, все, что вам нужно сделать, это написать new перед именем класса и добавить круглые 
скобки после него. Вот пример:

```
Park p = new Park();
```

Сначала вы объявляете тип, который будете создавать (Park), и даете переменной имя (p). Это дает Java место для разрыва 
ссылки на объект. Затем вы пишете new Park() для фактического создания объекта.

Park() выглядит как метод, поскольку за ним следуют круглые скобки. Он называется конструктором и представляет собой 
особый тип метода, который создает новый объект. Теперь пришло время определить собственный конструктор:

```
public class Chick {
  public Chick() {
    System.out.println("in constructor");
  }
}
``` 
В отношении конструктора необходимо отметить два ключевых момента: имя конструктора совпадает с именем класса и тип 
возвращаемого значения отсутствует. На экзамене вы можете увидеть такой метод:

```
public class Chick {
  public void Chick() { } // NOT A CONSTRUCTOR
}
```

Когда вы видите имя метода, начинающееся с заглавной буквы и имеющее возвращаемый тип, обратите на него особое 
внимание. Это не конструктор, так как есть возвращаемый тип. Это обычный метод, который компилируется, но не вызывается 
при написании новой функции Chick().

Цель конструктора — инициализировать поля, хотя вы можете поместить туда любой код. Другой способ инициализировать 
поля — сделать это непосредственно в строке, в которой они объявлены. В этом примере показаны оба подхода:

```
public class Chicken {
    int numEggs = 12; // initialize on line
    String name;
    
    public Chicken() {
       name = "Duke"; // initialize in constructor
     }
}
```

Для большинства классов вам не нужно кодировать конструктор — компилятор предоставит вам «ничего не делающий» 
конструктор по умолчанию. Есть несколько сценариев, которые требуют объявления конструктора. Вы узнаете о них все 
в главе 6.

### Чтение и запись полей 

Переменные экземпляра можно читать и записывать непосредственно из вызывающего объекта. В этом примере лебедь-мать 
откладывает яйца:

```
public class Swan {
    int numberEggs;     // instance variable
    
    public static void main(String[] args) {
        Swan mother = new Swan();
        mother.numberEggs = 1;    // set variable
        System.out.println(mother.numberEggs);    // read variable
    }
}
```

«Вызывающим» в данном случае является метод main(), который может находиться в том же классе или в другом классе. 
Этот класс устанавливает numberEggs равным 1, а затем считывает numberEggs напрямую, чтобы распечатать его. В главе 
5 вы узнаете, как использовать инкапсуляцию для защиты класса Swan от того, чтобы кто-то задал отрицательное число яиц.

Вы даже можете прочитать значения уже инициализированных полей в строке, инициализирующей новое поле:

```
1: public class Name {
2:    String first = "Theodore";
3:    String last = "Moose";
4:    String full = first + last;
5: }
```

Строки 2 и 3 записывают в поля. Строка 4 читает и записывает данные. Он читает поля первым и последним. Затем он пишет 
поле заполнено.

### Executing Instance Initializer Blocks (Выполнение блоков инициализатора экземпляра)

Когда вы узнали о методах, вы увидели фигурные скобки ({}). Код между фигурными скобками (иногда называемый «внутри 
фигурных скобок») называется блоком кода. Везде, где вы видите фигурные скобки, это блок кода.

Иногда блоки кода находятся внутри метода. Они запускаются при вызове метода. В других случаях блоки кода появляются 
вне метода. Они называются инициализаторами экземпляра (instance initializers). В главе 6 вы узнаете, как использовать 
статический  инициализатор (static initializer).

Сколько блоков вы видите в следующем примере? Сколько инициализаторов экземпляров вы видите?

```
1: public class Bird {
2:    public static void main(String[] args) {
3:       { System.out.println("Feathers"); }
4:    }
5:    { System.out.println("Snowy"); } // инициализатор экземпляра
6: }
```

В этом примере четыре блока кода: определение класса, объявление метода, внутренний блок и инициализатор экземпляра. 
Подсчет блоков кода прост: вы просто подсчитываете количество пар фигурных скобок. Если количество открывающих ({) и 
закрывающих (}) фигурных скобок неодинаково или они не определены в правильном порядке, код не компилируется. 
Например, вы не можете использовать закрывающую фигурную скобку (}), если нет соответствующей открывающей скобки ({), 
которая соответствует написанному ранее в коде. В программировании это называется проблемой сбалансированных скобок и 
часто возникает в вопросах на собеседовании.

Когда вы считаете инициализаторы экземпляров, имейте в виду, что они не могут существовать внутри метода. 
Строка 5 представляет собой инициализатор экземпляра, фигурные скобки которого находятся вне метода. С другой стороны, 
строка 3 не является инициализатором экземпляра, поскольку она вызывается только при выполнении метода main(). 
В строках 1 и 6 есть еще один набор фигурных скобок, составляющих объявление класса.

### Following the Order of Initialization (Следование порядку инициализации)

При написании кода, инициализирующего поля в нескольких местах, необходимо следить за порядком инициализации. Это 
просто порядок, в котором вызываются различные методы, конструкторы или блоки при создании экземпляра класса. 
Мы добавим еще несколько правил в порядок инициализации в главе 6. А пока вам нужно помнить:

+ Поля и блоки инициализатора экземпляра запускаются в том порядке, в котором они появляются в файле.
+ Конструктор запускается после выполнения всех полей и блоков инициализатора экземпляра.

Давайте посмотрим на пример:

```
1: public class Chick {
2:    private String name = "Fluffy";
3:    { System.out.println("setting field"); }

4:    public Chick() {
5:        name = "Tiny";
6:        System.out.println("setting constructor");
7:    }

8:    public static void main(String[] args) {
9:       Chick chick = new Chick();
10:      System.out.println(chick.name); } }
```

Запуск этого примера печатает это:

```
setting field
setting constructor
Tiny
```

Давайте посмотрим, что здесь происходит. Мы начинаем с метода main(), потому что именно с него начинается выполнение 
Java. В строке 9 мы вызываем конструктор Chick. Java создает новый объект. Сначала он инициализирует имя "Fluffy" в 
строке 2. Затем он выполняет оператор println() в инициализаторе экземпляра в строке 3. После того, как все поля и 
инициализаторы экземпляра запущены, Java возвращается к конструктору. Строка 5 изменяет значение name на «Tiny», а 
строка 6 выводит другое выражение. На этом конструктор завершается, а затем выполнение возвращается к оператору 
println() в строке 10.

Порядок имеет значение для полей и блоков кода. Вы не можете ссылаться на переменную до того, как она будет определена:

```
{ System.out.println(name); } // DOES NOT COMPILE
private String name = "Fluffy";
```

Вы должны ожидать увидеть вопрос об инициализации на экзамене. Давайте попробуем ещё один. Как вы думаете, что выводит 
этот код?

```
public class Egg {
  public Egg() {
    number = 5;
  }
  
  public static void main(String[] args) {
      Egg egg = new Egg();
      System.out.println(egg.number);
  }
  
  private int number = 3;
  { number = 4; } }
```

Если вы ответили 5, вы все сделали правильно. Поля и блоки запускаются сначала по порядку, присваивая номеру 3, а 
затем 4. Затем запускается конструктор, присваивая номеру значение 5. Гораздо больше правил и примеров, описывающих 
порядок инициализации, вы найдете в главе 6. Здесь мы рассмотрим только основы, поэтому вы можете следовать порядку 
инициализации для простых программ.

## Understanding Data Types (Понимание типов данных)

Приложения Java содержат два типа данных: примитивные типы и ссылочные типы. В этом разделе мы обсудим различия между 
примитивным типом и ссылочным типом.

### Using Primitive Types (Использование примитивных типов) 

Java имеет восемь встроенных типов данных, называемых примитивными типами Java. Эти восемь типов данных представляют 
собой строительные блоки для объектов Java, поскольку все объекты Java представляют собой просто сложный набор этих 
примитивных типов данных. Тем не менее, примитив не является объектом в Java и не представляет объект. 
Примитив — это просто одно значение в памяти, например, число или символ.

### Примитивные типы

Экзамен предполагает, что вы хорошо разбираетесь в восьми примитивных типах данных, их относительных размерах и том, 
что в них можно хранить. В таблице 1.6 показаны примитивные типы Java вместе с их размером в битах и диапазоном 
значений, которые каждый содержит.

#### Таблица 1.6 - Примитивные типы


___
##### Является ли String примитивом?

Нет. Тем не менее, String часто ошибочно принимают за девятый примитив, потому что Java включает встроенную поддержку 
строковых литералов и операторов. Вы узнаете больше о String в главе 4, а пока просто помните, что это объект, а не 
примитив.
___

В Таблице 1.6 содержится много информации. Давайте рассмотрим некоторые ключевые моменты:

+ Типы byte, short, int и long используются для целых значений без десятичной точки.
+ Каждый числовой тип использует в два раза больше битов, чем меньший аналогичный тип. Например, тип short использует 
в два раза больше битов, чем byte.
+ Все числовые типы имеют знак и резервируют один из своих битов для охвата отрицательного диапазона. Например, вместо 
байта, охватывающего от 0 до 255 (или даже от 1 до 256), он на самом деле охватывает диапазон от -128 до 127.
+ Для числа с плавающей запятой требуется буква f или F, следующая за числом, чтобы Java знала, что это число с 
плавающей запятой. Без f или F Java интерпретирует десятичное значение как double.
+ Для типа long требуется буква l или L, следующая за номером, чтобы Java знала, что это тип long. Без l или L Java 
интерпретирует число без десятичной точки как int в большинстве сценариев.

Вас не будут спрашивать о точных размерах этих типов, хотя вы должны иметь общее представление о размере меньших типов, 
таких как byte и short. Распространенный вопрос среди новых разработчиков Java: каков размер логического значения в 
битах? Ответ таков: он не указан и зависит от JVM, на которой выполняется код.

___
### Signed and Unsigned: short and char (Подписанный и неподписанный: short and char)

Для экзамена вы должны знать, что short и char тесно связаны, так как оба хранятся как целочисленные типы с одинаковой 
16-битной длиной. Основное отличие заключается в том, что тип short имеет знак, что означает, что он разделяет свой 
диапазон на положительные и отрицательные целые числа. В качестве альтернативы, char не имеет знака, что означает, 
что его диапазон строго положительный, включая 0.

Часто значения short и char могут быть приведены друг к другу, потому что размер базовых данных одинаков. 
Вы узнаете больше о приведение типов (Casting) в главе 2, «Операторы».
___

### Написание литералов (Writing Literals)

Есть еще несколько вещей, которые вы должны знать о числовых примитивах. Когда в коде присутствует число, оно 
называется литералом. По умолчанию Java предполагает, что вы определяете значение int с числовым литералом. В следующем 
примере указанное число больше, чем помещается в int. Помните, что вы не должны запоминать максимальное значение для 
int. Экзамен включит его в вопрос, если он возникнет.

```
long max = 3123456789; // DOES NOT COMPILE
```

Java жалуется, что число вне допустимого диапазона. И это - для int. Однако у нас нет int. Решение состоит в том, 
чтобы добавить символ L к числу:

```
long max = 3123456789L; // Now Java knows it is a long
```

Кроме того, вы можете добавить строчную букву l к номеру. Но, пожалуйста, используйте заглавную букву L. Строчная 
буква l выглядит как цифра 1.

Другой способ указать числа — изменить «базу». Когда вы научились считать, вы изучили цифры от 0 до 9. Эта система 
счисления называется по основанию 10, поскольку для каждой цифры существует 10 возможных значений. Она также известна 
как десятичная система счисления. Java позволяет указывать цифры в нескольких других форматах:

+ Восьмеричный (цифры 0–7), в котором в качестве префикса используется число 0, например 017.
+ Шестнадцатеричный (цифры 0–9 и буквы A–F/a–f), который использует 0x или 0X в качестве префикса, например, 0xFF, 
0xff, 0XFf. Шестнадцатеричное число нечувствительно к регистру, поэтому все эти примеры означают одно и то же значение.
+ Двоичный (цифры 0–1), в котором в качестве префикса используется число 0, за которым следует b или B, например 
0b10, 0B10.

Вам не нужно будет конвертировать между системами счисления на экзамене. Вам придется распознавать допустимые 
литеральные значения, которые могут быть присвоены числам.

### Литералы и символ подчеркивания (Literals and the Underscore Character)

Последнее, что вам нужно знать о числовых литералах, это то, что вы можете иметь недостатки в цифрах, чтобы облегчить 
их чтение:

```
int million1 = 1000000;
int million2 = 1_000_000;
```

Мы бы предпочли прочитать последнее, потому что нули не идут вместе. Вы можете добавлять символы подчеркивания где 
угодно, кроме как в начале литерала, в конце литерала, прямо перед десятичной точкой или сразу после десятичной точки. 
Вы даже можете разместить несколько символов подчеркивания рядом друг с другом, хотя мы не рекомендуем это делать.

Давайте посмотрим на несколько примеров:

```
double notAtStart = _1000.00; // DOES NOT COMPILE
double notAtEnd = 1000.00_; // DOES NOT COMPILE
double notByDecimal = 1000_.00; // DOES NOT COMPILE
double annoyingButLegal = 1_00_0.0_0; // Ugly, but compiles
double reallyUgly = 1__________2; // Also compiles
```

### Использование ссылочных типов (Using Reference Types)

Ссылочный тип относится к объекту (экземпляру класса). В отличие от примитивных типов, которые хранят свои значения в 
памяти, где размещена переменная, ссылки не содержат значения объекта, на который они ссылаются. Вместо этого ссылка 
«указывает» на объект, сохраняя адрес памяти, где находится объект, концепция, называемая указателем. В отличие от 
других языков, Java не позволяет узнать, что такое адрес физической памяти. Вы можете использовать ссылку только для 
ссылки на объект.

Давайте рассмотрим несколько примеров объявления и инициализации ссылочных типов. Предположим, мы объявляем ссылку типа 
String:

```
String greeting;
```

Переменная приветствия — это ссылка, которая может указывать только на объект String. Значение присваивается ссылке 
одним из двух способов:
+ Ссылка может быть назначена другому объекту того же или совместимого типа.
+ Ссылку можно присвоить новому объекту с помощью нового ключевого слова new.

Например, следующий оператор присваивает эту ссылку новому объекту:

```
greeting = new String("How are you?");
```

Ссылка greeting указывает на новый объект String, «How are you?». Объект String не имеет имени и доступен только 
через соответствующую ссылку.

### Различие между примитивами и ссылочными типами (Distinguishing between Primitives and Reference Types)

Есть несколько важных различий между примитивами и ссылочными типами, которые вы должны знать. Во-первых, обратите 
внимание, что все примитивные типы имеют имена в нижнем регистре. Все классы, поставляемые с Java, начинаются с 
прописных букв. Хотя это и не требуется, это стандартная практика, и вы также должны следовать этому соглашению для 
создаваемых вами классов.

Далее, ссылочные типы можно использовать для вызова методов, предполагая, что ссылка не является null. Примитивы 
не имеют объявленных на них методов. В этом примере мы можем вызвать метод на ссылку, так как она имеет ссылочный тип. 
Вы можете сказать, что length — это метод, потому что после него стоит (). Посмотрите, сможете ли вы понять, почему 
следующий фрагмент кода не компилируется:

```
4: String reference = "hello";
5: int len = reference.length();
6: int bad = len.length(); // DOES NOT COMPILE
```

6 строка - (бред). Для len не существует методов, потому что это примитив типа int. У примитивов нет методов. Помните, 
что String не является примитивом, поэтому вы можете вызывать такие методы, как length() для ссылки на String, как мы 
это делали в строке 5.

Наконец, ссылочным типам может быть присвоено значение null, что означает, что в данный момент они не ссылаются на 
объект. Примитивные типы дадут вам ошибку компилятора, если вы попытаетесь присвоить им значение null. В этом примере 
значение не может указывать на null, поскольку оно имеет тип int:

```
int value = null; // DOES NOT COMPILE
String name = null;
```

Но что, если вы не знаете значение int и хотите присвоить ему значение null? В этом случае вы должны использовать 
числовой класс-оболочку, такой как Integer, вместо int.

### Создание классов-оболочек (Creating Wrapper Classes)

Каждый примитивный тип имеет класс-оболочку, который является типом объекта, соответствующим примитиву. В таблице 1.7 
перечислены все классы-оболочки и способы их создания.

#### Таблица 1.7 - Классы-оболочки


Существует также вариант valueOf(), который преобразует String в класс-оболочку. Например:

```
int primitive = Integer.parseInt("123");
Integer wrapper = Integer.valueOf("123");
```
Первая строка преобразует String в примитив типа int. Второй преобразует String в класс-оболочку Integer.

Все числовые классы в таблице 1.7 расширяют класс Number, что означает, что все они имеют несколько полезных 
вспомогательных методов: byteValue(), shortValue(), intValue(), longValue(), floatValue(), and doubleValue().
Boolean и Character классы-оболочки включают booleanValue() и charValue() соответственно.

Как вы, наверное, догадались, эти методы возвращают примитивное значение экземпляра оболочки в запрошенном типе.

```
Double apple = Double.valueOf("200.99");
System.out.println(apple.byteValue());  // -56
System.out.println(apple.intValue());  // 200
System.out.println(apple.doubleValue());  // 200.99
```

Эти вспомогательные методы делают вс` возможное для преобразования значений, но могут привести к потере точности. В 
первом примере в байтах нет 200, поэтому он заменяется на -56. Во втором примере значение усекается, что означает, 
что все числа после запятой отбрасываются. В главе 5 мы применяем автоупаковку и распаковку, чтобы показать, насколько 
легко Java позволяет работать с примитивными значениями и значениями-оболочками.

Некоторые классы-оболочки содержат дополнительные вспомогательные методы для работы с числами. Вам не нужно запоминать 
их; вы можете предположить, что все, что вам дано, является действительным. Например, Integer имеет:

+ max(int num1, int num2), который возвращает наибольшее из двух чисел;
+ min(int num1, int num2), который возвращает наименьшее из двух чисел;
+ sum(int num1, int num2), который суммирует два числа.

### Определение текстовых блоков (Defining Text Blocks)

Ранее мы видели простой String со значением «hello». Что, если мы хотим иметь String с чем-то более сложным? Например, 
давайте разберемся, как создать String с этим значением:

```
"Java Study Guide"
      by Scott & Jeanne
```

Создание этого как строки требует двух вещей, которые вы еще не изучили. Синтаксис \" позволяет вам сказать, что вы 
хотите ", а не заканчивать строку, а \n говорит, что вам нужна новая строка. Оба они называются escape-символами, 
потому что обратная косая черта имеет особое значение. С помощью этих двух новых навыков мы можем написать

```
String eyeTest = "\"Java Study Guide\"\n by Scott & Jeanne";
```

Хотя это работает, это трудно читать. К счастью, в Java есть текстовые блоки, также известные как многострочные строки. 
См. рисунок 1.3 для эквивалента текстового блока.

#### Рис. 1.3 - Текстовый блок


Текстовый блок начинается и заканчивается тремя двойными кавычками (" " "), и содержимое не нужно экранировать. Это 
гораздо легче читать. Обратите внимание, что тип по-прежнему String. Это означает, что методы, о которых вы узнали в 
Главе 4 для строк (String) работает как для обычной строки, так и для текстового блока.

Возможно, вы заметили на рисунке слова «случайный» и «существенный пробел». Это что? Основные пробелы являются частью 
вашей строки и важны для вас. Случайные пробелы нужны только для того, чтобы код было легче читать. Вы можете 
переформатировать свой код и изменить количество случайных пробелов без какого-либо влияния на значение вашей строки.

Представьте себе вертикальную линию, нарисованную на крайнем левом непробельном символе в текстовом блоке. Все, что 
слева от него, — это случайные пробелы, а все, что справа — это существенные пробелы. Давайте попробуем пример. 
Сколько строк получается при этом и сколько случайных и необходимых пробельных символов начинается в каждой строке?

```
14: String pyramid = """
15:    *
16:   * *
17:  * * *
18: """;
19: System.out.print(pyramid);
```

Есть четыре строки вывода. Строки 15–17 отмечены звездочками. Строка 18 — это строка без каких-либо символов.
Закрывающая тройка "должна быть в строке 17, если нам не нужна эта пустая строка. Здесь нет случайных пробелов.
Закрывающие """ в строке 18 являются крайними левыми символами, поэтому строка рисуется в крайнем левом положении.
В строке 15 есть два обязательных пробельных символа для начала строки, а в строке 16 — один. Этот пробел заполняет 
строку, нарисованную так, чтобы соответствовать строке 18.

В таблице 1.8 показаны некоторые специальные последовательности форматирования и сравнивается их работа в обычной 
строке и текстовом блоке.

#### Таблица 1.8 - Форматирование текстового блока


Давайте попробуем несколько примеров. Во-первых, вы понимаете, почему это не компилируется?

```
String block = """doe"""; // DOES NOT COMPILE
```

Текстовые блоки требуют разрыва строки после открывающего """, что делает этот вариант недействительным. Теперь давайте 
попробуем допустимый. Как вы думаете, сколько строк в этом текстовом блоке?

```
String block = """
  doe \
  deer""";
```

Только один. Вывод — олень, так как \ говорит Java не добавлять новую строку перед оленем. Попробуем определить 
количество строк в другом текстовом блоке:

```
String block = """
    doe \n
    deer
    """;
```

На этот раз у нас четыре линии. Так как текстовый блок имеет закрывающую """ в отдельной строке, у нас есть три строки 
для строк в текстовом блоке плюс явный \n. Давайте попробуем еще один. Как вы думаете, что это выводит?

```
String block = """
    "doe\"\"\"
    \"deer\"""
   """;
  System.out.print("*"+ block + "*");

The answer is
* "doe"""
 "deer"""
*
```
Все "убежать" (All of the \" escape the ". ). На линиях лани и оленя есть одно свободное пространство. Все остальные 
начальные пробелы являются  второстепенными пробелами.

## Объявление переменных (Declaring Variables)

Вы уже видели некоторые переменные. Переменная — это имя части памяти, в которой хранятся данные. Когда вы объявляете 
переменную, вам нужно указать тип переменной вместе с именем. Присвоение переменной значения называется инициализацией 
переменной. Чтобы инициализировать переменную, вы просто вводите имя переменной, за которым следует знак равенства, а 
затем желаемое значение. В этом примере показано объявление и инициализация переменной в одной строке:

```
String zooName = "The Best Zoo";
```

В следующих разделах мы рассмотрим, как правильно определять переменные в одной или нескольких строках.

### Идентификация идентификаторов (Identifying Identifiers)

Вероятно, вас не удивит, что в Java есть четкие правила относительно имен идентификаторов. 
Идентификатор — это имя переменной, метода, класса, интерфейса или пакета. К счастью, правила для идентификаторов 
переменных применимы ко всем другим типам, которые вы можете назвать. 

Для легальных идентификаторов нужно помнить всего четыре правила:
+ Идентификаторы должны начинаться с буквы, символа валюты или символа _. Символы валюты включают доллар ($), юань (¥), 
евро (€) и так далее.
+ Идентификаторы могут включать числа, но не начинаться с них.
+ Одиночное подчеркивание _ не допускается в качестве идентификатора.
+ Вы не можете использовать то же имя, что и зарезервированное слово Java. Зарезервированное слово — это специальное 
слово, которое Java отложила в сторону, чтобы вам не разрешалось его использовать.
+ Помните, что язык Java чувствителен к регистру, поэтому вы можете использовать версии ключевых слов, которые 
отличаются только регистром. Пожалуйста, не надо.

Не беспокойтесь — вам не нужно запоминать полный список зарезервированных слов. Экзамен спросит вас только о тех, 
которые обычно используются, например, о class и for. В таблице 1.9 перечислены все зарезервированные слова в Java. 

#### Таблица 1.9 - Зарезервированные слова 

Есть и другие имена, которые вы не можете использовать. Например, true, false и null — это буквальные значения, поэтому 
они не могут быть именами переменных. Кроме того, есть контекстные ключевые слова, такие как module в главе 12. 
Приготовьтесь к проверке этих правил. Следующие примеры являются законными:

```
long okidentifier;
float $OK2Identifier;
boolean _alsoOK1d3ntifi3r;
char __SStillOkbutKnotsonice$;
```

Эти примеры незаконны:

```
int 3DPointClass;    // identifiers cannot begin with a number
byte hollywood@vine; // @ is not a letter, digit, $ or _
String *$coffee;     // * is not a letter, digit, $ or _
double public;       // public is a reserved word
short _;             // a single underscore is not allowed
```

---
### camelCase and snake_case

Хотя вы можете делать сумасшедшие вещи с именами идентификаторов, пожалуйста, не делайте этого. В Java есть соглашения, 
чтобы код был читабельным и последовательным. Например, в верблюжьем регистре первая буква каждого слова заглавная.
Имена методов и переменных обычно пишутся верблюжьим регистром с первой строчной буквой, например toUpper().
Имена классов и интерфейсов также пишутся верблюжьим регистром, с прописной первой буквой, например ArrayList.

Другой стиль называется змеиным футляром. Он просто использует подчеркивание (_) для разделения слов. Java обычно 
использует заглавные буквы для констант и значений перечисления, таких как NUMBER_FLAGS. 

Экзамен не всегда будет следовать этим соглашениям, чтобы усложнить вопросы об идентификаторах. 
Напротив, вопросы по другим темам обычно соответствуют стандартным соглашениям. 
Мы рекомендуем вам следовать этим правилам на работе.
---

### Объявление нескольких переменных (Declaring Multiple Variables)

Вы также можете объявить и инициализировать несколько переменных в одном операторе. Как вы думаете, сколько переменных 
объявлено и инициализировано в следующем примере?

```
void sandFence() {
   String s1, s2;
   String s3 = "yes", s4 = "no";
}
```

Были объявлены четыре строковые переменные: s1, s2, s3 и s4. Вы можете объявить много переменных в одном объявлении, 
если они все одного типа. Вы также можете инициализировать любое или все эти значения встроенными. В предыдущем примере 
у нас есть две инициализированные переменные: s3 и s4. Две другие переменные остаются объявленными, но еще не 
инициализированными.

Вот где это становится сложно. Обратите внимание на сложные вещи! Экзамен попытается обмануть вас. Опять же, как вы 
думаете, сколько переменных объявлено и инициализировано в следующем коде?

```
void paintFence() {
  int i1, i2, i3 = 0;
}
```

Как и следовало ожидать, были объявлены три переменные: i1, i2 и i3. Однако было инициализировано только одно из этих 
значений: i3. Два других остаются объявленными, но еще не инициализированными. В этом вся хитрость. Каждый фрагмент, 
разделенный запятой, представляет собой небольшое объявление. Инициализация i3 применяется только к i3. Он не 
имеет ничего общего с i1 или i2, несмотря на то, что находится в том же утверждении. Как вы увидите в следующем 
разделе, вы не можете использовать i1 или i2 до тех пор, пока они не будут инициализированы.

Другой способ, которым экзамен может попытаться обмануть вас, — это показать вам код, подобный этой строке:

```
int num, String value; // DOES NOT COMPILE
```

Этот код не компилируется, потому что он пытается объявить несколько переменных разных типов в одном операторе. Ярлык 
для объявления нескольких переменных в одном операторе допустим, только если они имеют общий тип.

---
Легальный, действительный и компилируемый — все это синонимы в мире экзаменов по Java. Мы стараемся использовать всю 
терминологию, с которой вы можете столкнуться на экзамене.
---

Чтобы убедиться, что вы понимаете это, посмотрите, сможете ли вы выяснить, какие из следующих утверждений 
являются юридическими:

```
4: boolean b1, b2;
5: String s1 = "1", s2;
6: double d1, double d2;
7: int i1; int i2;
8: int i3; i4;
```

Строки 4 и 5 являются законными. Каждая из них объявляет две переменные. В строке 4 не инициализируется ни одна 
переменная, а в строке 5 инициализируется только одна. Строка 7 также является законной. Хотя int появляется дважды, 
каждое из них находится в отдельном выражении. Операторы в Java разделяются точкой с запятой (;). Так уж получилось, 
что в одной строке два совершенно разных утверждения.

Строка 6 незаконна. Java не позволяет объявлять два разных типа в одном выражении. Подождите минуту! Переменные d1 и 
d2 относятся к одному типу. Они оба типа double. Хотя это правда, это все еще не разрешено. Если вы хотите объявить 
несколько переменных в одном операторе, они должны использовать одно и то же объявление типа и не повторять его.

Строка 8 незаконна. Опять же, у нас есть два совершенно разных утверждения в одной строке. Второе объявление в строке 8 
не является допустимым объявлением, поскольку в нем не указан тип. Когда вы видите на экзамене странно расположенную 
точку с запятой, представьте, что код находится в отдельных строках, и подумайте, компилируется ли код таким образом. 
В этом случае последние две строки кода можно было бы переписать следующим образом:

```
int i1;
int i2;
int i3;
i4;
```

Глядя на последнюю строку отдельно, вы можете легко увидеть, что объявление недействительно. И да, экзамен 
действительно впихивает несколько операторов в одну строку — отчасти для того, чтобы обмануть вас, а отчасти для 
того, чтобы на экране поместилось больше кода. В реальном мире, пожалуйста, ограничьтесь одним объявлением на 
оператор и строку. Ваши товарищи по команде будут благодарны вам за читаемый код.

## Инициализация переменных (Initializing Variables)

Прежде чем вы сможете использовать переменную, ей нужно значение. Для некоторых типов переменных это значение 
устанавливается автоматически, а для других требуется, чтобы его указал программист. В следующих разделах мы 
рассмотрим различия между значениями по умолчанию для локальных переменных, переменных экземпляра и класса.

### Создание локальных переменных (Creating Local Variables)

Локальная переменная — это переменная, определенная в конструкторе, методе или блоке инициализатора. Для простоты мы 
сосредоточимся в первую очередь на локальных переменных в методах в этом разделе, хотя правила для остальных те же.

### Окончательные локальные переменные (Final Local Variables)

Ключевое слово final может применяться к локальным переменным и эквивалентно объявлению констант в других языках. 
Рассмотрим этот пример:

```
5: final int y = 10;
6: int x = 20;
7: y = x + 10; // DOES NOT COMPILE
```

Обе переменные установлены, но y использует ключевое слово final. По этой причине строка 7 вызывает ошибку компилятора, 
поскольку значение нельзя изменить. 

Модификатор final также можно применять к ссылкам на локальные переменные. В следующем примере используется объект 
массива int[], о котором вы узнаете в главе 4.

```
5: final int[] favoriteNumbers = new int[10];
6: favoriteNumbers[0] = 10;
7: favoriteNumbers[1] = 20;
8: favoriteNumbers = null; // DOES NOT COMPILE
```

Обратите внимание, что мы можем изменить содержимое или данные в массиве. Ошибка компилятора возникает только в 
строке 8, когда мы пытаемся изменить значение ссылки favoriteNumbers.

### Неинициализированные локальные переменные (Uninitialized Local Variables)

Локальные переменные не имеют значения по умолчанию и должны быть инициализированы перед использованием. Кроме того, 
компилятор сообщит об ошибке, если вы попытаетесь прочитать неинициализированное значение. Например, следующий код 
генерирует ошибку компилятора:

```
4: public int notValid() {
5:    int y = 10;
6:    int x;
7:    int reply = x + y;  // DOES NOT COMPILE
8:    return reply;
9: }
```

Переменная y инициализируется значением 10. Напротив, переменная x не инициализируется до того, как она будет 
использована в выражении в строке 7, и компилятор выдаст ошибку. Компилятор достаточно умен, чтобы распознавать 
переменные, которые были инициализированы после их объявления, но до их использования. Вот пример:

```
public int valid() {
  int y = 10;
  int x; // x is declared here
  x = 3; // x is initialized here
  int z; // z is declared here but never initialized or used
  int reply = x + y;
  return reply;
}
```

В этом примере x объявляется, инициализируется и используется в отдельных строках. Кроме того, z объявлен, но никогда 
не используется, поэтому его не требуется инициализировать.

Компилятор также достаточно умен, чтобы распознавать более сложные инициализации. В этом примере есть две ветки кода:

```
public void findAnswer(boolean check) {
   int answer;
   int otherAnswer;
   int onlyOneBranch;
   if (check) {
      onlyOneBranch = 1;
      answer = 1;
   } else {
      answer = 2;
   }
   System.out.println(answer);
   System.out.println(onlyOneBranch); // DOES NOT COMPILE
}
```

Переменная ответа инициализируется в обеих ветвях оператора if, так что компилятор вполне доволен. Он знает, что 
независимо от того, является ли проверка истинной или ложной, значение ответа будет установлено в какое-либо значение 
до того, как оно будет использовано. Переменная otherAnswer не инициализируется, но никогда не используется, и 
компилятор в равной степени доволен. Помните, что компилятор беспокоится только в том случае, если вы пытаетесь 
использовать неинициализированные локальные переменные; это не возражает против тех, которые вы никогда не используете.

Переменная onlyOneBranch инициализируется, только если проверка оказывается истинной. Компилятор знает, что проверка 
может оказаться ложной, что приведет к неинициализированному коду, и выдаст ошибку компилятора. Вы узнаете больше 
об операторе if в главе 3 «Принятие решений (Making Decisions)».

---
На экзамене будьте осторожны с любой локальной переменной, которая объявлена, но не инициализирована в одной строке. 
Это обычное место на экзамене, которое может привести к ответу «Не компилируется». Перед использованием на экзамене 
убедитесь, что он инициализирован.
---

### Передача параметров конструктора и метода (Passing Constructor and Method Parameters)

Переменные, передаваемые конструктору или методу, называются параметрами конструктора или параметрами метода 
соответственно. Эти параметры похожи на локальные переменные, которые были предварительно инициализированы. 
Правила инициализации параметров конструктора и метода одинаковы, поэтому мы сосредоточимся в первую очередь на 
параметрах метода.

В предыдущем примере check является параметром метода. 

```
public void findAnswer(boolean check) {}
    Take a look at the following method checkAnswer() in the same class:
public void checkAnswer() {
  boolean value;
  findAnswer(value); // DOES NOT COMPILE
}
```

Вызов findAnswer() не компилируется, поскольку он пытается использовать неинициализированную переменную. В то время 
как вызывающая сторона метода checkAnswer() должна быть обеспокоена инициализацией переменной, оказавшись внутри 
метода findAnswer(), мы можем предположить, что локальная переменная была инициализирована некоторым значением.

### Определение переменных экземпляра и класса (Defining Instance and Class Variables)

Переменные, не являющиеся локальными переменными, определяются либо как переменные экземпляра, либо как переменные 
класса. Переменная экземпляра, часто называемая полем, представляет собой значение, определенное в конкретном 
экземпляре объекта. Допустим, у нас есть класс Person с переменной экземпляра name типа String. Каждый экземпляр 
класса будет иметь собственное значение name, например Elysia или Sarah. Два экземпляра могут иметь одинаковое 
значение name, но изменение значения для одного не изменяет другого.

С другой стороны, переменная класса — это переменная, определенная на уровне класса и совместно используемая всеми 
экземплярами класса. Он даже может быть общедоступным для классов вне класса и не требует экземпляра для использования.
В нашем предыдущем примере Person переменная общего класса могла использоваться для представления списка людей в 
зоопарке сегодня. Вы можете сказать, что переменная является переменной класса, потому что перед ней стоит ключевое 
слово static. Вы узнаете об этом в главе 5. А пока просто знайте, что переменная является переменной класса, если в её 
объявлении есть ключевое слово static.

Переменные экземпляра и класса не требуют их инициализации. Как только вы объявляете эти переменные, им присваивается 
значение по умолчанию. Компилятор не знает, какое значение использовать, и поэтому хочет самое простое значение, 
которое он может дать типу: null для объекта, 0 для числовых типов, и false для логического значения. Вам не нужно 
знать значение по умолчанию для char, но если вам интересно, это '\u0000' (NUL).

### Определение типа с помощью var (Inferring the Type with var)

У вас есть возможность использовать ключевое слово var вместо типа при объявлении локальных переменных при 
определенных условиях. Чтобы использовать эту функцию, вы просто набираете var вместо примитивного или ссылочного типа.
Вот пример: 

```
public class Zoo {
    public void whatTypeAmI() {
       var name = "Hello";
       var size = 7;
    }
}
```

Формальное название этой функции — вывод типа локальной переменной. Давайте разберем это. Сначала идет локальная 
переменная. Это означает именно то, на что это похоже. Вы можете использовать эту функцию только для локальных 
переменных. Экзамен может попытаться обмануть вас с помощью такого кода: 

```
public class VarKeyword {
    var tricky = "Hello"; // DOES NOT COMPILE
}
```

Подождите минуту! Мы только что узнали разницу между экземпляром и локальными переменными. Переменная «tricky» — это 
переменная экземпляра. Вывод типа локальной переменной работает с локальными переменными, а не с переменными 
экземпляра.

### Вывод типа var (Type Inference of var) 

Теперь, когда вы понимаете, что такое локальная переменная, пора перейти к тому, что означает вывод типа. Хорошая 
новость заключается в том, что это также означает то, на что это похоже. Когда вы вводите var, вы даёте компилятору 
указание определить тип за вас. Компилятор просматривает код в строке объявления и использует его для определения типа. 
Взгляните на этот пример:

```
7: public void reassignment() {
8:    var number = 7;
9:    number = 4;
10:   number = "five"; // DOES NOT COMPILE
11: }
```
В строке 8 компилятор определяет, что нам нужна переменная типа int. В строке 9 у нас нет проблем с присвоением ей 
другого int. В строке 10 у Java есть проблема. Мы попросили его присвоить String переменной int. Это не разрешено.
Это эквивалентно вводу этого:

```
int number = "five";
```

---
Если вы знаете такой язык, как JavaScript, вы можете ожидать, что var будет означать переменную, которая может 
принимать любой тип во время выполнения. В Java var по-прежнему является особым типом, определенным во время компиляции. 
Он не меняет тип во время выполнения.
---

Для простоты при обсуждении var мы будем предполагать, что оператор объявления переменной завершается одной строкой.
Вы можете вставить разрыв строки между именем переменной и её значением инициализации, как в следующем примере:

```
7: public void breakingDeclaration() {
8:    var silly
9:        = 1;
10: }
```

Этот пример корректен и компилируется, но мы считаем, что объявление и инициализация глупости происходят в одной строке.

### Примеры с var