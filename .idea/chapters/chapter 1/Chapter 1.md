# Building Blocks
___
#### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:
##### 1) Обработка даты, времени, текста, числовых и логических значений
+ Используйте примитивы и классы-оболочки, включая Math API,
  скобки, продвижение типа и приведение для оценки
  арифметические и логические выражения
##### 2) Использование объектно-ориентированного подхода Java
+ Объявление и создание экземпляров объектов Java, включая вложенный класс
  объекты и объяснить жизненный цикл объекта
  включая создание,
  переназначение ссылок и сборка мусора
+ Понимать области действия переменных, использовать вывод типа локальной переменной,
  применить инкапсуляцию и сделать объекты неизменяемыми
___
Добро пожаловать в начало вашего пути к Java
17 сертификация. Мы предполагаем, что это не первая книга по программированию на Java, которую вы читаете.
Хотя мы говорим об основах, мы делаем это только потому, что хотим убедиться, что вы владеете всей терминологией и 
подробностями, необходимыми для экзамена. Если вы никогда раньше не писали программы на Java, мы рекомендуем вам 
приобрести вводную книгу по Java 8 или более поздней версии. Примеры включают Head First Java, 3-е издание 
(O’Reilly Media, 2022 г.) и «Начало программирования на Java для чайников» (For Dummies, 2021 г.). 
Затем вернитесь к этому учебному пособию по сертификации.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как говорится в старой поговорке, прежде чем бегать, нужно научиться ходить. 
Точно так же вы должны изучить основы Java, прежде чем сможете создавать сложные программы. В этой главе мы 
представляем основы пакетов, классов, переменных и типов данных Java, а также аспекты каждого из них, которые вам 
необходимо знать для экзамена. Например, вы можете использовать Java каждый день, но не знать, что вы не можете создать 
переменную с именем 3dMap или this. Экзамен предполагает, что вы знаете и понимаете правила, лежащие в основе этих 
принципов. Хотя большую часть этой главы следует повторить, некоторые аспекты языка Java могут быть для вас новыми, 
поскольку они не часто встречаются на практике.

## Изучение окружающей среды
Среда Java состоит из понимания ряда технологий. В следующих разделах мы рассмотрим ключевые термины и сокращения, 
которые вам необходимо знать, а затем обсудим, какое программное обеспечение вам нужно изучить для подготовки к 
экзамену.

#### Основные компоненты Java
Комплект Java Development Kit (JDK) содержит минимальное программное обеспечение, необходимое для разработки Java. 
Ключевые команды включают в себя:
+ javac: конвертирует исходные файлы .java в байт-код .class.
+ java: выполняет программу
+ jar: упаковывает файлы вместе
+ javadoc: cоздает документацию

Программа javac генерирует инструкции в специальном формате, называемом байт-кодом, который может выполнять 
команда java. Затем java запускает виртуальную машину Java (JVM) перед запуском кода. JVM знает, как запускать байт-код 
на той машине, на которой он находится. Вы можете думать о JVM как о специальном волшебном ящике на вашем компьютере, 
который знает, как запустить ваш файл .class в вашей конкретной операционной системе и оборудовании.
___
##### Where Did the JRE Go?
В Java 8 и более ранних версиях вы могли загрузить среду выполнения Java (JRE) вместо полного JDK. JRE была 
подмножеством JDK, которое использовалось для запуска программы, но не могло ее скомпилировать. Теперь люди могут 
использовать полный JDK при запуске программы Java. В качестве альтернативы разработчики могут предоставить исполняемый 
файл, содержащий необходимые части, которые были бы в JRE.

При написании программы есть общие функции и алгоритмы, которые нужны разработчикам. К счастью, нам не нужно писать 
каждый из них самостоятельно. Java поставляется с большим набором интерфейсов прикладного программирования (API), 
которые вы можете использовать. Например, есть класс StringBuilder для создания большой строки и метод в Collections 
для сортировки списка. При написании программы полезно определить, какие части вашего задания могут быть выполнены с 
помощью существующих API.
___

Вы могли заметить, что мы сказали, что JDK содержит минимально необходимое программное обеспечение. Многие разработчики 
используют интегрированную среду разработки (IDE), чтобы упростить написание и выполнение кода. Хотя мы не рекомендуем 
использовать их во время подготовки к экзамену, все же полезно знать, что они существуют. Общие IDE для Java включают 
Eclipse, IntelliJ IDEA и Visual Studio Code.

#### Загрузка JDK

Каждые шесть месяцев Oracle выпускает новую версию Java. Java 17 вышла в сентябре 2021 года. Это означает, что Java 17 
не будет последней версией, когда вы загружаете JDK для подготовки к экзамену. Тем не менее, вы все равно должны 
использовать Java 17 для обучения, так как это экзамен по Java 17. Правила и поведение могут измениться в более поздних 
версиях Java. Вы бы не хотели получить неправильный вопрос, потому что вы изучали другую версию Java!

Вы можете загрузить Oracle JDK на веб-сайте Oracle, используя ту же учетную запись, которую вы использовали для 
регистрации на экзамен. Существует множество доступных JDK, наиболее популярным из которых, помимо JDK Oracle, 
является OpenJDK.

Многие версии Java включают функции предварительного просмотра, которые по умолчанию отключены, но вы можете включить 
их. Функции предварительного просмотра не включены в экзамен. Чтобы избежать путаницы в отношении того, когда функция 
была добавлена в язык, мы будем говорить «была официально представлена», чтобы обозначить, когда она была удалена из 
предварительного просмотра.
___
##### Проверьте свою версию Java
Прежде чем мы пойдем дальше, воспользуйтесь этой возможностью, чтобы убедиться, что у вас есть правильная версия Java 
на вашем пути.

+ javac -version
+ java -version

Обе эти команды должны включать номер версии 17.
___
## Понимание структуры класса
В программах Java классы являются основными строительными блоками. При определении класса вы описываете все части и 
характеристики одного из этих строительных блоков. В последующих главах вы увидите другие строительные блоки, такие как
интерфейсы, записи и перечисления. Чтобы использовать большинство классов, вы должны создавать объекты. 
Объект — это экземпляр класса в памяти во время выполнения. Объект часто называют экземпляром, поскольку он 
представляет собой единственное представление класса. Все различные объекты всех различных классов представляют 
состояние вашей программы. Ссылка — это переменная, указывающая на объект. В следующих разделах мы рассмотрим поля, 
методы и комментарии. Мы также исследуем отношения между классами и файлами.

### Поля и методы
Классы Java имеют два основных элемента: `методы`, часто называемые функциями или процедурами в других языках, и `поля`, 
более известные как переменные. Вместе они называются членами класса. Переменные хранят состояние программы, а методы 
работают с этим состоянием. Если изменение важно запомнить, переменная сохраняет это изменение. Это все, что 
действительно делают классы. Задача программиста — создать и расположить эти элементы таким образом, чтобы полученный 
код был полезен и, в идеале, легок для понимания другими программистами.

Самый простой класс Java, который вы можете написать, выглядит так:
```
1: public class Animal {
2: }
```
Java называет слово со специальным значением ключевым словом, которое мы выделили жирным шрифтом в предыдущем 
фрагменте. На протяжении всей книги мы часто выделяем фрагменты кода жирным шрифтом, чтобы привлечь к ним внимание. 
Строка 1 включает ключевое слово public, позволяющее использовать его другим классам. Ключевое слово class указывает, 
что вы определяете класс. Animal дает имя класса. Конечно, это не интересный класс, так что давайте добавим ваше 
первое поле.

```
1: public class Animal {
2: String name;
3: }
```
---
##### Примечание: Номера строк не являются частью программы; они нужны только для того, чтобы о коде было легче говорить.

---

В строке 2 мы определяем переменную с именем name. Мы также объявляем тип этой переменной как String. 
Строка — это значение, в которое мы можем поместить текст, например «это строка».
String также является классом, поставляемым с Java. Далее мы можем добавить методы.

```
1: public class Animal {
2:     String name;
3:     public String getName() {
4:        return name;
5:     }
6:     public void setName(String newName) {
7:        name = newName;
8:     }
9: }
```
В строках 3–5 мы определяем метод. Метод — это операция, которую можно вызвать. Опять же, public используется для 
обозначения того, что этот метод может быть вызван из других классов. Далее идет тип возвращаемого значения — в
в этом случае метод возвращает строку. В строках 6–8 находится еще один метод.
У этого есть специальный возвращаемый тип, называемый void. Ключевое слово void означает, что вообще не возвращается 
никакого значения. Этот метод требует, чтобы информация была предоставлена ему от вызывающего метода;
эта информация называется параметром. Метод setName() имеет один параметр с именем newName и имеет тип String. Это 
означает, что вызывающая сторона должна передать один строковый параметр и ничего не ожидать.

Имя метода и типы параметров называются сигнатурой метода. В этом примере можете ли вы определить имя и параметры 
метода?

```
public int numberVisitors(int month) {
    return 10;
}
```
Имя метода — numberVisitors. Есть один параметр с именем month, который имеет тип int, который является числовым типом. 
Следовательно, сигнатура метода — numberVisitors(int).

### Комментарии
Другая распространенная часть кода называется комментарием. Поскольку комментарии не являются исполняемым кодом, их 
можно размещать во многих местах. Комментарии могут облегчить чтение вашего кода.
Хотя создатели экзамена пытаются сделать код труднее для чтения, они по-прежнему используют комментарии, чтобы привлечь
внимание к номерам строк. Мы надеемся, что вы используете комментарии в своем собственном коде. В Java есть три типа 
комментариев. Первый называется однострочным комментарием:
```
// comment until end of line или комментарий до конца строки
```
Однострочный комментарий начинается с двух косых черт. Компилятор игнорирует все, что вы вводите после этого в той же 
строке. Далее следует многострочный комментарий:
```
/* 
* Многострочный
* комментарий
*/
```
Многострочный комментарий (также известный как многострочный комментарий) включает в себя все, что начинается с 
символа /* до символа */. Люди часто ставят звездочку (*) в начале каждой строки многострочного комментария, чтобы его 
было легче читать, но это не обязательно. Наконец, у нас есть комментарий Javadoc:
```
/**
* Многострочный Javadoc
комментарий
* @author Жанна и Скотт
*/
```
Этот комментарий похож на многострочный комментарий, за исключением того, что он начинается с /**. Этот специальный 
синтаксис указывает инструменту Javadoc обратить внимание на комментарий. Комментарии Javadoc имеют
определенную структуру, которую инструмент Javadoc умеет читать. Вы, вероятно, не увидите комментарий Javadoc на 
экзамене. Просто помните, что он существует, чтобы вы могли прочитать о нем в Интернете, когда начнете писать программы 
для использования другими.

В качестве практики, можете ли вы определить, к какому типу комментария относится каждое из следующих шести слов? 
Это однострочный?  или многострочный комментарий?
```
/*
* // anteater
*/

// bear

// // cat

// /* dog */

/* elephant */
/*
  * /* ferret */
*/
```
Вы внимательно смотрели? Некоторые из них сложны. Несмотря на то, что технически комментарии не входят в экзамен, 
полезно попрактиковаться в внимательном просмотре кода.

Ладно, к ответам. Комментарий, содержащий муравьед, находится в многострочном комментарии. Все, что находится 
между /* и */, является частью многострочного комментария, даже если оно включает однострочный комментарий.
комментарий внутри него! Комментарий, содержащий медведя, является вашим основным однострочным комментарием. 
Комментарии, содержащие кошку и собаку, также являются однострочными. Все от // до конца строки является частью 
комментария, даже если это комментарий другого типа. Комментарий, содержащий слона, является вашим основным 
многострочным комментарием, даже если он занимает всего одну строку.

Строка с ferret интересна тем, что не компилируется. Все от первого /* до первого */ является частью комментария, 
что означает, что компилятор увидит что-то вроде этого:
```
/* */ */
```
У нас есть проблемы. Есть лишний */. Это недопустимый синтаксис — факт, о котором компилятор с радостью вам сообщит.
### Классы и исходные файлы
В большинстве случаев каждый класс Java определяется в собственном файле .java. В этой главе единственным типом 
ерхнего уровня является класс. Тип верхнего уровня — это структура данных, которую можно определить независимо в 
исходном файле. На протяжении большей части книги мы работаем с классами как с типом верхнего уровня,
но в главе 7 «Помимо классов» мы представляем другие типы верхнего уровня, а также вложенные типы.

Класс верхнего уровня часто является общедоступным, что означает, что его может вызывать любой код. Интересно, что 
Java не требует, чтобы тип был общедоступным. Например, этот класс просто прекрасен:
```
1: class Animal {
2:     String name;
3: }
```
Вы даже можете поместить два типа в один и тот же файл. При этом не более одного из типов верхнего уровня в файле может 
быть общедоступным. Это означает, что файл, содержащий следующее, также подходит:
```
1: public class Animal {
2:     private String name;
3: }
4: class Animal2 {}
```

Если у вас есть общедоступный тип, он должен соответствовать имени файла. Объявление общедоступного класса Animal2 не 
будет компилироваться в файл с именем Animal.java. В главе 5, «Методы», мы обсуждаем, какие варианты доступа доступны, 
кроме общедоступных.
___
Заметили закономерность? Эта глава содержит многочисленные ссылки на темы, которые мы рассмотрим более подробно в 
последующих главах. Если вы опытный Java-разработчик, то заметите, что многие примеры и правила в этой главе упрощены. 
Не волнуйся; у нас есть оставшаяся часть книги, чтобы представить больше правил и сложных пограничных случаев!
___

## Написание метода main()
Программа Java начинает выполнение со своего метода main(). В этом разделе вы узнаете, как создать его, передать 
параметр и запустить программу. Метод main() часто называют точкой входа в программу, потому что это начальная точка, 
которую JVM ищет, когда начинает запускать новую программу.

### Создание метода main()
Метод main() позволяет JVM вызывать наш код. Самый простой возможный класс с методом main() выглядит так:
```
1: public class Zoo {
2:    public static void main(String[] args) {
3:       System.out.println("Hello World");
4:    }
5: }
```

Этот код печатает Hello World. Чтобы скомпилировать и выполнить этот код, введите его в файл с именем Zoo.java и 
выполните следующее:
```
javac Zoo.java
java Zoo
```
Если он печатает Hello World, вы добились успеха. Если вы получаете сообщения об ошибках, убедитесь, что вы установили 
Java 17 JDK, добавили его в PATH и не сделать опечатки в примере. Если у вас возникли какие-либо из этих проблем и вы 
не знаете, что делать, задайте вопрос с сообщением об ошибке, которое вы получили, на форуме Beginning Java на 
CodeRanch:
```
www.coderanch.com/forums/f-33/java
```
Чтобы скомпилировать код Java с помощью команды javac, файл должен иметь расширение .java. Имя файла должно совпадать 
с именем публичного класса. Результатом является файл байт-кода с тем же именем, но с расширением имени файла .class. 
Помните, что байт-код состоит из инструкций, которые JVM умеет выполнять. Обратите внимание, что мы должны опустить 
расширение .class для запуска Zoo.class.

Правила того, что содержит файл Java и в каком порядке, являются более подробными, чем то, что мы объясняли до сих пор 
(подробнее об этой теме далее в этой главе). Чтобы не усложнять задачу, мы следуем этому подмножеству правил:

+ Каждый файл может содержать только один общедоступный класс.
+ Имя файла должно соответствовать имени класса, включая регистр, и иметь расширение .java.
+ Если класс Java является точкой входа для программы, он должен содержать допустимый метод main().

Давайте сначала рассмотрим слова в сигнатуре метода main(), по одному. Ключевое слово public — это то, что называется 
модификатором доступа. Он объявляет уровень воздействия этого метода на потенциальных абонентов в программе. 
Естественно, публичный означает полный доступ из любой точки программы. Вы узнаете больше о модификаторах доступа в 
главе 5.

Ключевое слово static связывает метод с его классом, поэтому его можно вызывать только по имени класса, как, например, 
в Zoo.main(). Java не нужно создавать объект для вызова метода main() — и это хорошо, поскольку вы еще не научились 
создавать объекты! На самом деле, JVM делает это более или менее при загрузке данного имени класса. Если метод main() 
не имеет правильных ключевых слов, вы получите сообщение об ошибке при попытке его запуска. Вы снова видите static в 
главе 6, «Проектирование классов».

Ключевое слово void представляет возвращаемый тип. Метод, который не возвращает никаких данных, автоматически 
возвращает управление вызывающей стороне. В общем, рекомендуется использовать void для методов, которые изменяют 
состояние объекта. В этом смысле метод main() изменяет состояние программы с запущенного на завершенное.
Мы также исследуем типы возврата в главе 5. (Вы уже с нетерпением ждете пятую главу?)

Наконец, мы приходим к списку параметров метода main(), представленному в виде массива объектов java.lang.String. 
Вы можете использовать любое допустимое имя переменной вместе с любым из этих трех форматов:
```
String[] args
String options[]
String... friends
```
Компилятор принимает любой из них. Имя переменной args является общим, поскольку оно намекает, что этот список содержит 
значения, которые были прочитаны (аргументы) при запуске JVM. Символы [] являются скобками и представляют собой массив. 
представляет собой список фиксированного размера элементов одного типа. Символы ... называются varargs (переменные 
списки аргументов). В этой главе вы узнаете о String. Массивы — в главе 4, «Основные API», а переменные — в главе 5.
___
##### Необязательные модификаторы в методах main()
Хотя большинство модификаторов, таких как public и static, требуются для методов main(), разрешены некоторые 
необязательные модификаторы.
```
public final static void main(final String[] args) {} 
(прим. final выделить жирным)
```
В этом примере оба модификатора final являются необязательными, а метод main() является допустимой точкой входа с ними 
или без них. Мы раскрываем значение конечных методов и параметров в главе 6.

### Передача параметров в программу Java
Давайте посмотрим, как отправлять данные в метод main() нашей программы. Во-первых, мы модифицируем программу Zoo, 
чтобы распечатать первые два переданных аргумента:
```
public class Zoo {
  public static void main(String[] args) {
    System.out.println(args[0]);
    System.out.println(args[1]);
  }
}
```
Код args[0] обращается к первому элементу массива. Правильно: индексы массива начинаются с 0 в Java. 
Чтобы запустить его, введите следующее:
```
javac Zoo.java
java Zoo Bronx Zoo
```
Вывод - это то, что вы могли ожидать:
```
Bronx
Zoo
```
Программа правильно идентифицирует первые два «слова» как аргументы. Пробелы используются для разделения аргументов. 
Если вам нужны пробелы внутри аргумента, вам нужно использовать кавычки, как в этом примере:
```
javac Zoo.java
java Zoo "San Diego" Zoo
```
Теперь у нас есть пробел в выводе:
```
San Diego
Zoo
```
Наконец, что произойдет, если вы не передадите достаточно аргументов?
```
javac Zoo.java
java Zoo Zoo
```
Чтение args[0] проходит нормально, и Zoo распечатывается. Тогда Java паникует. Второго аргумента нет! Что делать? 
Java выводит исключение, говорящее вам, что он понятия не имеет, что делать с этим аргументом в позиции 1. 
(Вы узнаете об исключениях в главе 11, «Исключения и локализация».)
```
Zoo
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException:
  Index 1 out of bounds for length 1
  at Zoo.main(Zoo.java:4)
```
Для обзора, JDK содержит компилятор. Файлы классов Java выполняются на JVM и, следовательно, работают на любой машине с 
Java, а не только на машине или операционной системе, на которой они были скомпилированы.
___
##### Однофайловый исходный код
Если вам надоело вводить как javac, так и java каждый раз, когда вы хотите попробовать пример кода, есть ярлык. 
Вместо этого вы можете запустить
```
java Zoo.java Bronx Zoo
```
Здесь есть ключевое отличие. При первой компиляции вы пропустили расширение .java при запуске java. Пропуская шаг явной 
компиляции, вы включаете это
расширение. Эта функция называется запуском однофайловых программ с исходным кодом и полезна для тестирования или для 
небольших программ. Название разумно говорит вам, что оно предназначено для случаев, когда ваша программа представляет 
собой один файл.
___
## Понимание объявлений пакетов и импорт
Java поставляется с тысячами встроенных классов, и таких разработчиков, как вы, бесчисленное множество. Со всеми этими 
классами Java нуждается в способе их организации. Он обрабатывает это так же, как картотечный шкаф. Вы складываете все 
свои бумажки в папки. Java помещает классы в пакеты. Это логические группировки классов.

Мы бы не поставили вас перед картотекой и не сказали бы найти конкретную бумагу. Вместо этого мы бы сказали вам, в 
какой папке искать. Java работает точно так же. Ему нужно, чтобы вы сказали ему, в каких пакетах искать код.

Предположим, вы пытаетесь скомпилировать этот код:
```
public class NumberPicker {
  public static void main(String[] args) {
    Random r = new Random(); // DOES NOT COMPILE
    System.out.println(r.nextInt(10));
  }
}
```
Компилятор Java услужливо выдает вам ошибку, которая выглядит следующим образом:
```
error: cannot find symbol
```
Эта ошибка может означать, что вы допустили опечатку в названии класса. Вы перепроверяете и обнаруживаете, что это не 
так. Другой причиной этой ошибки является пропуск необходимого оператора импорта. Оператор — это инструкция, а 
операторы импорта сообщают Java, в каких пакетах искать классы. Поскольку вы не указали Java, где искать Random, она 
понятия не имеет.

Повторная попытка импорта позволяет скомпилировать код.

```
import java.util.Random; // import tells us where to find Random (import говорит нам, где найти Random)
public class NumberPicker {
  public static void main(String[] args) {
    Random r = new Random();
    System.out.println(r.nextInt(10)); // a number 0-9
  }
}
```
Теперь код работает; он выводит случайное число от 0 до 9. Как и массивы, Java любит начинать счет с 0.

---
В главе 5 мы рассмотрим другой тип импорта, называемый статическим импортом. Это позволяет вам сделать статические 
члены класса известными, часто поэтому вы можете использовать имена переменных и методов без необходимости указывать 
имя класса.
---

### Пакеты
Как вы видели в предыдущем примере, классы Java сгруппированы в пакеты. Оператор import сообщает компилятору, в каком 
пакете искать класс. Это похоже на то, как работает рассылка писем. Представьте, что вы отправляете письмо по адресу 
Мейн-стрит, 123, квартира 9. Почтальон сначала приносит письмо на Мейн-стрит, 123. Затем перевозчик ищет почтовый ящик 
квартиры номер 9. Адрес похож на название пакета на Java. Номер квартиры похож на имя класса в Java. Подобно тому, как 
почтальон смотрит только на номера квартир в здании, Java ищет в пакете только имена классов.

Имена пакетов также иерархичны, как и почта. Почтовая служба начинается с верхнего уровня, в первую очередь глядя на 
вашу страну. Вы также начинаете читать имя пакета в начале. Например, если он начинается с java, это означает, что он 
поставляется с JDK. Если он начинается с что-то еще, это, вероятно, показывает, откуда оно взялось, используя имя 
веб-сайта в обратном порядке. Например, com.wiley.javabook сообщает нам, что код связан с веб-сайтом или организацией 
wiley.com. После названия сайта  вы можете добавить все, что хотите. Например, com.wiley.java.my.name также 
произошло от wiley.com. Java называет более подробные пакеты дочерними пакетами. Пакет com.wiley.javabook является 
дочерним пакетом com.wiley. Вы можете сказать, потому что он длиннее и, следовательно, более конкретен.

На экзамене вы увидите имена пакетов, которые не соответствуют этому соглашению. Не удивляйтесь, увидев такие имена 
пакетов, как a.b.c. Правило для имен пакетов состоит в том, что они в основном состоят из букв или цифр, разделенных 
точками (.). Технически, вам разрешено несколько других  символов между точками (.). Вы даже можете использовать 
имена пакетов веб-сайтов, которыми вы не владеете, если хотите, например com.wiley, хотя люди, читающие ваш код, 
могут быть сбиты с толку! Правила такие же, как и для имен переменных, которые вы увидите далее в этой главе.
экзамен может попытаться обмануть вас с недопустимыми именами переменных. К счастью, он не пытается обмануть вас, 
давая неверные имена пакетов.

В следующих разделах мы рассмотрим импорт с подстановочными знаками, конфликты имен с импортом, как создать 
собственный пакет и как экзамен форматирует код.

### Подстановочные знаки
Классы в одном пакете часто импортируются вместе. Вы можете использовать ярлык для импорта всех классов в пакете.
```
import java.util.*; // imports java.util.Random among other things

public class NumberPicker {
   public static void main(String[] args) {
      Random r = new Random();
      System.out.println(r.nextInt(10));
   }
}
```
В этом примере мы импортировали java.util.Random и кучу других классов. * — это подстановочный знак, который 
соответствует всем классам в пакете. Каждый класс в пакете java.util доступен для этой программы, когда Java его 
компилирует. Оператор импорта не вводит дочерние пакеты, поля или методы; он импортирует только классы непосредственно 
в пакете. Предположим, вы хотите использовать класс AtomicInteger (вы узнаете об этом в главе 13, «Параллелизм») в 
пакете java.util.concurrent.atomic. Какой импорт или импорт поддерживают это?

```
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
```
Только последний импорт позволяет распознать класс, потому что дочерние пакеты не включены в первые два.
Вы можете подумать, что включение такого количества классов замедляет выполнение вашей программы, но это не так. 
Компилятор выясняет, что на самом деле нужно. Какой подход вы выберете, зависит от личных предпочтений или командных 
предпочтений, если вы работаете с другими в команде. Листинг используемые классы облегчают чтение кода, особенно для 
начинающих программистов. Использование подстановочного знака может сократить список импорта. Вы увидите оба подхода 
на экзамене.
### Избыточный импорт
Подождите минуту! Мы ссылались на System без импорта каждый раз, когда печатали текст, и Java с этим справлялся. 
В мире Java есть один специальный пакет, который называется java.lang. Этот пакет особенный тем, что он автоматически 
импортируется. Вы можете ввести этот пакет в операторе импорта, но это не обязательно. Как вы думаете, сколько импортов 
в следующем коде является избыточным?
```
1: import java.lang.System;
2: import java.lang.*;
3: import java.util.Random;
4: import java.util.*;
5: public class NumberPicker {
6:    public static void main(String[] args) {
7:      Random r = new Random();
8:      System.out.println(r.nextInt(10));
9:    }
10: }
```
Ответ заключается в том, что три импорта являются избыточными. Строки 1 и 2 избыточны, потому что все в java.lang 
импортируется автоматически. Строка 4 также избыточна в этом примере, поскольку Random уже импортирован из 
java.util.Random. Однако, если бы строки 3 не было, java.util.* не был бы лишним, поскольку он покрывал бы 
импорт Random.

Другой случай избыточности включает импорт класса, который находится в том же пакете, что и класс, который его 
импортирует. Java автоматически ищет в текущем пакете другие классы. Давайте рассмотрим еще один пример, чтобы 
убедиться, что вы понимаете крайние случаи импорта. В этом примере файлы и пути находятся в пакете java.nio.file. 
На экзамене могут использоваться пакеты, которые вы никогда раньше не видели. Вопрос позволит вам узнать, в каком 
пакете находится класс, если вам нужно это знать, чтобы ответить на вопрос.

Как вы думаете, какие операторы импорта помогут скомпилировать этот код?
```
public class InputImports {
  public void read(Files files) {
    Paths.get("name");
  }
}
```
Есть два возможных ответа. Более короткий - использовать подстановочный знак для одновременного импорта обоих.
```
import java.nio.file.*;
```
Другой ответ - явно импортировать оба класса.
```
import java.nio.file.Files;
import java.nio.file.Paths;
```
Теперь давайте рассмотрим некоторые импорты, которые не работают.
```
import java.nio.*;         // NO GOOD -a wildcard only matches
                          // class names, not "file.Files"

import java.nio.*.*;     // NO GOOD -you can only have one wildcard
                        // and it must be at the end                       
                        
import java.nio.file.Paths.*;  // NO GOOD -youcannot import methods
                              // only class names
```
### Конфликты имен
Одна из причин использования пакетов заключается в том, что имена классов не должны быть уникальными во всей Java. 
Это означает, что иногда вам может понадобиться импортировать класс, который можно найти в нескольких местах. 
Типичным примером этого является класс Date. Java предоставляет реализации java.util.Date и java.sql.Date. 
Какой оператор импорта мы можем использовать, если нам нужна версия java.util.Date?
```
public class Conflicts {
    Date date;
    // some more code
}
```
Ответ должен быть легким к настоящему времени. Вы можете написать либо import java.util.*; или импортируйте 
java.util.Date;. Сложные случаи возникают, когда присутствует другой импорт.
```
import java.util.*;
import java.sql.*; // causes Date declaration to not compile
```
Когда имя класса встречается в нескольких пакетах, Java выдает ошибку компилятора. В нашем примере решение 
простое — удалить ненужный нам import java.sql.*. Но что делать, если нам нужна целая куча других классов в пакете 
java.sql?
```
import java.util.Date;
import java.sql.*;
```
А, теперь работает! Если вы явно импортируете имя класса, оно имеет приоритет над любыми подстановочными знаками. 
Java думает: «Программист действительно хочет, чтобы я использовал класс java.util.Date».

Еще один пример. Что Java делает со «связями» для приоритета?
```
import java.util.Date;
import java.sql.Date;
```

Java достаточно умен, чтобы определить, что этот код никуда не годится. Как программист, вы заявили, что явно хотите, 
чтобы по умолчанию были реализации как java.util.Date, так и java.sql.Date. Поскольку не может быть двух значений по 
умолчанию, компилятор сообщает вам, что импорт неоднозначен.

---
#### Если вам действительно нужно использовать два класса с одинаковым именем

Иногда вам действительно нужно использовать Date из двух разных пакетов. Когда это происходит, вы можете выбрать один 
для использования в операторе импорта и использовать полное имя класса другого. Или вы можете отказаться от обоих 
операторов импорта и всегда использовать полное имя класса.
```
public class Conflicts {
  java.util.Date date;
  java.sql.Date sqlDate;
}
```

### Создание нового пакета

До сих пор весь код, который мы написали в этой главе, находился в пакете по умолчанию. Это специальный безымянный 
пакет, который следует использовать только для одноразового кода. Вы можете сказать, что код находится в пакете по 
умолчанию, потому что нет имени пакета. На экзамене вы увидите, что пакет по умолчанию часто используется для экономии 
места в листингах кода. В реальной жизни всегда называйте свои пакеты, чтобы избежать конфликтов имен и позволить 
другим повторно использовать ваш код.

Теперь пришло время создать новый пакет. Структура каталогов на вашем компьютере связана с именем пакета. 
В этом разделе просто читайте вместе. Мы рассмотрим, как скомпилировать и запустить код в следующем разделе.

Предположим, у нас есть эти два класса:

```
package packagea;
public class ClassA {}

package packageb;
import packagea.ClassA;
public class ClassB {
  public static void main(String[] args) {
    ClassA a;
    System.out.println("Got it");
  }
}
```

Когда вы запускаете программу на Java, Java знает, где искать эти имена пакетов. В этом случае запуск из 
C:\temp работает, потому что под ним находятся и packagea, и packageb.

### Компиляция и запуск кода с пакетами

Вам будет намного легче изучать Java, используя командную строку для компиляции и тестирования ваших примеров. Как 
только вы хорошо изучите синтаксис Java, вы можете переключиться на IDE. Но на экзамене ваша цель — узнать подробности 
о языке, а не позволить IDE скрыть их от вас.

Следуйте этому примеру, чтобы убедиться, что вы знаете, как использовать командную строку. Если у вас возникли 
проблемы с выполнением этой процедуры, задайте вопрос на форуме Beginning Java на CodeRanch. Опишите, что вы 
пробовали и что говорит об ошибке.

```
www.coderanch.com/forums/f-33/java
```

Первый шаг — создать два файла из предыдущего раздела. В таблице 1.1 показаны ожидаемые полные имена файлов и 
команда для входа в каталог для следующих шагов.

#### Таблица 1.1 - Процедура настройки по операционной системе
**Шаг**| |**Windows**| |**Mac/Linux**
:-----:|:-----:|:-----:|:-----:|:-----:
1. Создать первый класс.| |C:\temp\packagea\ClassA.java| |/tmp/packagea/ClassA.java
| | | |
2. Создать второй класс.| |C:\temp\packageb\ClassB.java| |/tmp/packageb/ClassB.java
| | | |
3. Перейти в каталог.| |cd C:\temp| |cd /tmp

Теперь пришло время скомпилировать код. К счастью, это одинаково независимо от операционной системы. Для компиляции 
введите следующую команду:
```
javac packagea/ClassA.java packageb/ClassB.java
```

Если эта команда не работает, вы получите сообщение об ошибке. Внимательно проверьте свои файлы на наличие опечаток 
в предоставленных файлах. Если команда сработает, будут созданы два новых файла: packagea/ClassA.class и 
packageb/ClassB.class.

___
#### Компиляция с подстановочными знаками

Вы можете использовать звездочку, чтобы указать, что вы хотите включить все файлы Java в каталог. Это удобно, когда 
у вас много файлов в пакете. Мы можем переписать предыдущую команду javac следующим образом:

```
javac packagea/*.java packageb/*.java
```

Однако вы не можете использовать подстановочный знак для включения подкаталогов. Если бы вы написали javac *.java, 
код в пакетах не подхватился бы.
___

Теперь, когда ваш код скомпилирован, вы можете запустить его, введя следующую команду:
```
java packageb.ClassB
```
Если это сработает, вы увидите сообщение «Напечатано». Вы могли заметить, что мы ввели ClassB, а не ClassB.class. 
Как обсуждалось ранее, вы не передаете расширение при запуске программы.

На рис. 1.1 показано, где в структуре каталогов были созданы файлы .class.

#### Рис. 1.1 - Компиляция с пакетами
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/images/figure%201.1.PNG)

### Компиляция в другой каталог

