# Строительные блоки
___
#### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:
##### 1) Обработка даты, времени, текста, числовых и логических значений
+ Используйте примитивы и классы-оболочки, включая Math API, круглые скобки, расширение типов и приведение типов 
  для вычисления арифметических и логических выражений
##### 2) Использование объектно-ориентированного подхода Java
+ Объявлять и создавать экземпляры объектов Java, включая объекты вложенных классов, а также объяснять жизненный цикл 
  объекта, включая создание, переназначение ссылок и сборку мусора.
+ Понимать области действия переменных, использовать вывод типа локальной переменной,
  применить инкапсуляцию и сделать объекты неизменяемыми
___
Добро пожаловать в начало вашего пути к получению сертификата Java 17. Мы предполагаем, что это не первая книга по 
программированию на Java, которую вы читаете. Хотя мы говорим об основах, мы делаем это только потому, что хотим 
убедиться, что вы владеете всей терминологией и подробностями, необходимыми для экзамена. Если вы никогда раньше не 
писали программы на Java, мы рекомендуем вам приобрести вводную книгу по Java 8 или более поздней версии. 
Примеры включают Head First Java, 3-е издание (O’Reilly Media, 2022 г.) и «Начало программирования на Java для 
чайников» (For Dummies, 2021 г.). Затем вернитесь к этому учебному пособию по сертификации.

Как говорится в старой поговорке, прежде чем бегать, нужно научиться ходить. 
Точно так же вы должны изучить основы Java, прежде чем сможете создавать сложные программы. В этой главе мы 
представляем основы пакетов, классов, переменных и типов данных Java, а также аспекты каждого из них, которые вам 
необходимо знать для экзамена. Например, вы можете использовать Java каждый день, но не знать, что вы не можете создать 
переменную с именем 3dMap или this. Экзамен предполагает, что вы знаете и понимаете правила, лежащие в основе этих 
принципов. Хотя большую часть этой главы следует повторить, некоторые аспекты языка Java могут быть для вас новыми, 
поскольку они не часто встречаются на практике.

## Изучение окружающей среды
Среда Java состоит из понимания ряда технологий. В следующих разделах мы рассмотрим ключевые термины и сокращения, 
которые вам необходимо знать, а затем обсудим, какое программное обеспечение вам нужно изучить для подготовки к 
экзамену.

#### Основные компоненты Java
Комплект Java Development Kit (JDK) содержит минимальное программное обеспечение, необходимое для разработки Java. 
Ключевые команды включают в себя:
+ javac: конвертирует исходные файлы .java в байт-код .class.
+ java: выполняет программу
+ jar: упаковывает файлы вместе
+ javadoc: cоздает документацию

Программа javac генерирует инструкции в специальном формате, называемом байт-кодом, который может выполнять 
команда java. Затем java запускает виртуальную машину Java (JVM) перед запуском кода. JVM знает, как запускать байт-код 
на той машине, на которой он находится. Вы можете думать о JVM как о специальном волшебном ящике на вашем компьютере, 
который знает, как запустить ваш файл .class в вашей конкретной операционной системе и оборудовании.

___
##### Куда пропал JRE?
В Java 8 и более ранних версиях вы могли загрузить среду выполнения Java (JRE) вместо полного JDK. JRE была 
подмножеством JDK, которое использовалось для запуска программы, но не могло ее скомпилировать. Теперь люди могут 
использовать полный JDK при запуске программы Java. В качестве альтернативы разработчики могут предоставить исполняемый 
файл, содержащий необходимые части, которые были бы в JRE.

При написании программы есть общие функции и алгоритмы, которые нужны разработчикам. К счастью, нам не нужно писать 
каждый из них самостоятельно. Java поставляется с большим набором интерфейсов прикладного программирования (API), 
которые вы можете использовать. Например, есть класс StringBuilder для создания большой строки и метод в Collections 
для сортировки списка. При написании программы полезно определить, какие части вашего задания могут быть выполнены с 
помощью существующих API.
___

Вы могли заметить, что мы сказали, что JDK содержит минимально необходимое программное обеспечение. Многие разработчики 
используют интегрированную среду разработки (IDE), чтобы упростить написание и выполнение кода. Хотя мы не рекомендуем 
использовать их во время подготовки к экзамену, все же полезно знать, что они существуют. Общие IDE для Java включают 
Eclipse, IntelliJ IDEA и Visual Studio Code.

#### Загрузка JDK

Каждые шесть месяцев Oracle выпускает новую версию Java. Java 17 вышла в сентябре 2021 года. Это означает, что Java 17 
не будет последней версией, когда вы загружаете JDK для подготовки к экзамену. Тем не менее, вы все равно должны 
использовать Java 17 для обучения, так как это экзамен по Java 17. Правила и поведение могут измениться в более поздних 
версиях Java. Вы бы не хотели получить неправильный вопрос, потому что вы изучали другую версию Java!

Вы можете загрузить Oracle JDK на веб-сайте Oracle, используя ту же учетную запись, которую вы использовали для 
регистрации на экзамен. Существует множество доступных JDK, наиболее популярным из которых, помимо JDK Oracle, 
является OpenJDK.

Многие версии Java включают функции предварительного просмотра, которые по умолчанию отключены, но вы можете включить 
их. Функции предварительного просмотра не включены в экзамен. Чтобы избежать путаницы в отношении того, когда функция 
была добавлена в язык, мы будем говорить «была официально представлена», чтобы обозначить, когда она была удалена из 
предварительного просмотра.
___
##### Проверьте свою версию Java
Прежде чем мы пойдем дальше, воспользуйтесь этой возможностью, чтобы убедиться, что у вас есть правильная версия Java 
на вашем пути.

+ javac -version
+ java -version

Обе эти команды должны включать номер версии 17.
___
## Понимание структуры класса
В программах Java классы являются основными строительными блоками. При определении класса вы описываете все части и 
характеристики одного из этих строительных блоков. В последующих главах вы увидите другие строительные блоки, такие как
интерфейсы, записи и перечисления. Чтобы использовать большинство классов, вы должны создавать объекты. 
Объект — это экземпляр класса в памяти во время выполнения. Объект часто называют экземпляром, поскольку он 
представляет собой единственное представление класса. Все различные объекты всех различных классов представляют 
состояние вашей программы. Ссылка — это переменная, указывающая на объект. В следующих разделах мы рассмотрим поля, 
методы и комментарии. Мы также исследуем отношения между классами и файлами.

### Поля и методы
Классы Java имеют два основных элемента: `методы`, часто называемые функциями или процедурами в других языках, и `поля`, 
более известные как переменные. Вместе они называются членами класса. Переменные хранят состояние программы, а методы 
работают с этим состоянием. Если изменение важно запомнить, переменная сохраняет это изменение. Это все, что 
действительно делают классы. Задача программиста — создать и расположить эти элементы таким образом, чтобы полученный 
код был полезен и, в идеале, легок для понимания другими программистами.

Самый простой класс Java, который вы можете написать, выглядит так:
```
1: public class Animal {
2: }
```
Java называет слово со специальным значением ключевым словом, которое мы выделили жирным шрифтом в предыдущем 
фрагменте. На протяжении всей книги мы часто выделяем фрагменты кода жирным шрифтом, чтобы привлечь к ним внимание. 
Строка 1 включает ключевое слово public, позволяющее использовать его другим классам. Ключевое слово class указывает, 
что вы определяете класс. Animal дает имя класса. Конечно, это не интересный класс, так что давайте добавим ваше 
первое поле.

```
1: public class Animal {
2: String name;
3: }
```
---
##### Примечание: Номера строк не являются частью программы; они нужны только для того, чтобы о коде было легче говорить.

---

В строке 2 мы определяем переменную с именем name. Мы также объявляем тип этой переменной как String. 
Строка — это значение, в которое мы можем поместить текст, например «это строка».
String также является классом, поставляемым с Java. Далее мы можем добавить методы.

```
1: public class Animal {
2:     String name;
3:     public String getName() {
4:        return name;
5:     }
6:     public void setName(String newName) {
7:        name = newName;
8:     }
9: }
```
В строках 3–5 мы определяем метод. Метод — это операция, которую можно вызвать. Опять же, public используется для 
обозначения того, что этот метод может быть вызван из других классов. Далее идет тип возвращаемого значения — в
этом случае метод возвращает строку. В строках 6–8 находится еще один метод.
У этого есть специальный возвращаемый тип, называемый void. Ключевое слово void означает, что вообще не возвращается 
никакого значения. Этот метод требует, чтобы информация была предоставлена ему от вызывающего метода;
эта информация называется параметром. Метод setName() имеет один параметр с именем newName и имеет тип String. Это 
означает, что вызывающая сторона должна передать один строковый параметр и ничего не ожидать.

Имя метода и типы параметров называются сигнатурой метода. В этом примере можете ли вы определить имя и параметры 
метода?

```
public int numberVisitors(int month) {
    return 10;
}
```
Имя метода — numberVisitors. Есть один параметр с именем month, который имеет тип int, который является числовым типом. 
Следовательно, сигнатура метода — numberVisitors(int).

### Комментарии
Другая распространенная часть кода называется комментарием. Поскольку комментарии не являются исполняемым кодом, их 
можно размещать во многих местах. Комментарии могут облегчить чтение вашего кода.
Хотя создатели экзамена пытаются сделать код труднее для чтения, они по-прежнему используют комментарии, чтобы привлечь
внимание к номерам строк. Мы надеемся, что вы используете комментарии в своем собственном коде. В Java есть три типа 
комментариев. Первый называется однострочным комментарием:
```
// комментарий до конца строки
```
Однострочный комментарий начинается с двух косых черт. Компилятор игнорирует все, что вы вводите после этого в той же 
строке. Далее следует многострочный комментарий:
```
/* 
* Многострочный
* комментарий
*/
```
Многострочный комментарий  включает в себя все, что начинается с символа /* до символа * /. Люди часто ставят звездочку 
(*) в начале каждой строки многострочного комментария, чтобы его было легче читать, но это не обязательно. Наконец, у 
нас есть комментарий Javadoc:
```
/**
* Многострочный Javadoc
комментарий
* @author Жанна и Скотт
*/
```
Этот комментарий похож на многострочный комментарий, за исключением того, что он начинается с /**. Этот специальный 
синтаксис указывает инструменту Javadoc обратить внимание на комментарий. Комментарии Javadoc имеют
определенную структуру, которую инструмент Javadoc умеет читать. Вы, вероятно, не увидите комментарий Javadoc на 
экзамене. Просто помните, что он существует, чтобы вы могли прочитать о нем в Интернете, когда начнете писать программы 
для использования другими.

В качестве практики, можете ли вы определить, к какому типу комментария относится каждое из следующих шести слов? 
Это однострочный?  или многострочный комментарий?
```
/*
* // anteater
*/

// bear

// // cat

// /* dog */

/* elephant */
/*
  * /* ferret */
*/
```
Вы внимательно смотрели? Некоторые из них сложны. Несмотря на то, что технически комментарии не входят в экзамен, 
полезно попрактиковаться в внимательном просмотре кода.

Ладно, к ответам. Комментарий, содержащий муравьед, находится в многострочном комментарии. Все, что находится 
между /* и */, является частью многострочного комментария, даже если оно включает однострочный комментарий! Комментарий, 
содержащий медведя, является вашим основным однострочным комментарием. 
Комментарии, содержащие кошку и собаку, также являются однострочными. Все от // до конца строки является частью 
комментария, даже если это комментарий другого типа. Комментарий, содержащий слона, является вашим основным 
многострочным комментарием, даже если он занимает всего одну строку.

Строка с ferret интересна тем, что не компилируется. Все от первого /* до первого */ является частью комментария, 
что означает, что компилятор увидит что-то вроде этого:
```
/* */ */
```
У нас есть проблемы. Есть лишний */. Это недопустимый синтаксис — факт, о котором компилятор с радостью вам сообщит.

### Классы и исходные файлы

В большинстве случаев каждый класс Java определяется в собственном файле .java. В этой главе единственным типом 
верхнего уровня является класс. Тип верхнего уровня — это структура данных, которую можно определить независимо в 
исходном файле. На протяжении большей части книги мы работаем с классами как с типом верхнего уровня,
но в главе 7 «Помимо классов» мы представляем другие типы верхнего уровня, а также вложенные типы.

Класс верхнего уровня часто является общедоступным, что означает, что его может вызывать любой код. Интересно, что 
Java не требует, чтобы тип был общедоступным. Например, этот класс просто прекрасен:
```
1: class Animal {
2:     String name;
3: }
```
Вы даже можете поместить два типа в один и тот же файл. При этом не более одного из типов верхнего уровня в файле может 
быть общедоступным. Это означает, что файл, содержащий следующее, также подходит:
```
1: public class Animal {
2:     private String name;
3: }
4: class Animal2 {}
```

Если у вас есть общедоступный тип, он должен соответствовать имени файла. Объявление общедоступного класса Animal2 не 
будет компилироваться в файл с именем Animal.java. В главе 5, «Методы», мы обсуждаем, какие варианты доступа доступны, 
кроме public.
___
Заметили закономерность? Эта глава содержит многочисленные ссылки на темы, которые мы рассмотрим более подробно в 
последующих главах. Если вы опытный Java-разработчик, то заметите, что многие примеры и правила в этой главе упрощены. 
Не волнуйтесь; у нас есть оставшаяся часть книги, чтобы представить больше правил и сложных пограничных случаев!
___

## Написание метода main()
Программа Java начинает выполнение со своего метода main(). В этом разделе вы узнаете, как создать его, передать 
параметр и запустить программу. Метод main() часто называют точкой входа в программу, потому что это начальная точка, 
которую JVM ищет, когда начинает запускать новую программу.

### Создание метода main()
Метод main() позволяет JVM вызывать наш код. Самый простой возможный класс с методом main() выглядит так:
```
1: public class Zoo {
2:    public static void main(String[] args) {
3:       System.out.println("Hello World");
4:    }
5: }
```

Этот код печатает Hello World. Чтобы скомпилировать и выполнить этот код, введите его в файл с именем Zoo.java и 
выполните следующее:
```
javac Zoo.java
java Zoo
```
Если он печатает Hello World, вы добились успеха. Если вы получаете сообщения об ошибках, убедитесь, что вы установили 
Java 17 JDK, добавили его в PATH и не допустили опечатки в примере. Если у вас возникли какие-либо из этих проблем и вы 
не знаете, что делать, задайте вопрос с сообщением об ошибке, которое вы получили, на форуме Beginning Java на 
CodeRanch:
```
www.coderanch.com/forums/f-33/java
```
Чтобы скомпилировать код Java с помощью команды javac, файл должен иметь расширение .java. Имя файла должно совпадать 
с именем публичного класса. Результатом является файл байт-кода с тем же именем, но с расширением имени файла .class. 
Помните, что байт-код состоит из инструкций, которые JVM умеет выполнять. Обратите внимание, что мы должны опустить 
расширение .class для запуска Zoo.class.

Правила того, что содержит файл Java и в каком порядке, являются более подробными, чем то, что мы объясняли до сих пор 
(подробнее об этой теме далее в этой главе). Чтобы не усложнять задачу, мы следуем этому подмножеству правил:

+ Каждый файл может содержать только один общедоступный класс.
+ Имя файла должно соответствовать имени класса, включая регистр, и иметь расширение .java.
+ Если класс Java является точкой входа для программы, он должен содержать допустимый метод main().

Давайте сначала рассмотрим слова в сигнатуре метода main(), по одному. Ключевое слово public — это то, что называется 
модификатором доступа. Он объявляет уровень воздействия этого метода на потенциальных абонентов в программе. 
Естественно, публичный означает полный доступ из любой точки программы. Вы узнаете больше о модификаторах доступа в 
главе 5.

Ключевое слово static связывает метод с его классом, поэтому его можно вызывать только по имени класса, как, например, 
в Zoo.main(). Java не нужно создавать объект для вызова метода main() — и это хорошо, поскольку вы еще не научились 
создавать объекты! На самом деле, JVM делает это более или менее при загрузке данного имени класса. Если метод main() 
не имеет правильных ключевых слов, вы получите сообщение об ошибке при попытке его запуска. Вы снова увидите static в 
главе 6, «Проектирование классов».

Ключевое слово void представляет возвращаемый тип. Метод, который не возвращает никаких данных, автоматически 
возвращает управление вызывающей стороне. В общем, рекомендуется использовать void для методов, которые изменяют 
состояние объекта. В этом смысле метод main() изменяет состояние программы с запущенного на завершенное.
Мы также исследуем типы возврата в главе 5. (Вы уже с нетерпением ждете пятую главу?)

Наконец, мы приходим к списку параметров метода main(), представленному в виде массива объектов java.lang.String. 
Вы можете использовать любое допустимое имя переменной вместе с любым из этих трех форматов:
```
String[] args
String options[]
String... friends
```
Компилятор принимает любой из них. Имя переменной args является общим, поскольку оно намекает, что этот список содержит 
значения, которые были прочитаны (аргументы) при запуске JVM. Символы [] являются скобками и представляют собой массив. 
представляет собой список фиксированного размера элементов одного типа. Символы ... называются varargs (переменные 
списки аргументов). В этой главе вы узнаете о String. Массивы — в главе 4, «Основные API», а переменные — в главе 5.
___

##### Необязательные модификаторы в методах main()
Хотя большинство модификаторов, таких как public и static, требуются для методов main(), разрешены некоторые 
необязательные модификаторы.
```
public final static void main(final String[] args) {} 
```
В этом примере оба модификатора final являются необязательными, а метод main() является допустимой точкой входа с ними 
или без них. Мы раскрываем значение конечных методов и параметров в главе 6.

### Передача параметров в программу Java
Давайте посмотрим, как отправлять данные в метод main() нашей программы. Во-первых, мы модифицируем программу Zoo, 
чтобы распечатать первые два переданных аргумента:
```
public class Zoo {
  public static void main(String[] args) {
    System.out.println(args[0]);
    System.out.println(args[1]);
  }
}
```
Код args[0] обращается к первому элементу массива. Правильно: индексы массива начинаются с 0 в Java. 
Чтобы запустить его, введите следующее:
```
javac Zoo.java
java Zoo Bronx Zoo
```
Вывод - это то, что вы могли ожидать:
```
Bronx
Zoo
```
Программа правильно идентифицирует первые два «слова» как аргументы. Пробелы используются для разделения аргументов. 
Если вам нужны пробелы внутри аргумента, вам нужно использовать кавычки, как в этом примере:
```
javac Zoo.java
java Zoo "San Diego" Zoo
```
Теперь у нас есть пробел в выводе:
```
San Diego
Zoo
```
Наконец, что произойдет, если вы не передадите достаточно аргументов?
```
javac Zoo.java
java Zoo Zoo
```
Чтение args[0] проходит нормально, и Zoo распечатывается. Тогда Java паникует. Второго аргумента нет! Что делать? 
Java выводит исключение, говорящее вам, что он понятия не имеет, что делать с этим аргументом в позиции 1. 
(Вы узнаете об исключениях в главе 11, «Исключения и локализация».)
```
Zoo
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException:
  Index 1 out of bounds for length 1
  at Zoo.main(Zoo.java:4)
```
Для обзора, JDK содержит компилятор. Файлы классов Java выполняются на JVM и, следовательно, работают на любой машине с 
Java, а не только на машине или операционной системе, на которой они были скомпилированы.
___
##### Однофайловый исходный код
Если вам надоело вводить как javac, так и java каждый раз, когда вы хотите попробовать пример кода, есть ярлык. 
Вместо этого вы можете запустить
```
java Zoo.java Bronx Zoo
```
Здесь есть ключевое отличие. При первой компиляции вы пропустили расширение .java при запуске java. Пропуская шаг явной 
компиляции, вы включаете это
расширение. Эта функция называется запуском однофайловых программ с исходным кодом и полезна для тестирования или для 
небольших программ. Название разумно говорит вам, что оно предназначено для случаев, когда ваша программа представляет 
собой один файл.
___

## Понимание объявлений о пакетов и импорта
Java поставляется с тысячами встроенных классов, и таких разработчиков, как вы, бесчисленное множество. Со всеми этими 
классами Java нуждается в способе их организации. Он обрабатывает это так же, как картотечный шкаф. Вы складываете все 
свои бумажки в папки. Java помещает классы в пакеты. Это логические группировки классов.

Мы бы не поставили вас перед картотекой и не сказали бы найти конкретную бумагу. Вместо этого мы бы сказали вам, в 
какой папке искать. Java работает точно так же. Ему нужно, чтобы вы сказали ему, в каких пакетах искать код.

Предположим, вы пытаетесь скомпилировать этот код:
```
public class NumberPicker {
  public static void main(String[] args) {
    Random r = new Random();  // НЕ КОМПИЛИРУЕТСЯ
    System.out.println(r.nextInt(10));
  }
}
```
Компилятор Java услужливо выдает вам ошибку, которая выглядит следующим образом:
```
error: cannot find symbol
```
Эта ошибка может означать, что вы допустили опечатку в названии класса. Вы перепроверяете и обнаруживаете, что это не 
так. Другой причиной этой ошибки является пропуск необходимого оператора импорта. Оператор — это инструкция, а 
операторы импорта сообщают Java, в каких пакетах искать классы. Поскольку вы не указали Java, где искать Random, она 
понятия не имеет.

Повторная попытка импорта позволяет скомпилировать код.

```
import java.util.Random; // import говорит нам, где найти Random
public class NumberPicker {
  public static void main(String[] args) {
    Random r = new Random();
    System.out.println(r.nextInt(10)); // число 0-9
  }
}
```
Теперь код работает; он выводит случайное число от 0 до 9. Как и массивы, Java любит начинать счет с 0.

---

В главе 5 мы рассмотрим другой тип импорта, называемый статическим импортом. Это позволяет вам сделать статические 
члены класса известными, часто поэтому вы можете использовать имена переменных и методов без необходимости указывать 
имя класса.

---

### Пакеты

Как вы видели в предыдущем примере, классы Java сгруппированы в пакеты. Оператор import сообщает компилятору, в каком 
пакете искать класс. Это похоже на то, как работает рассылка писем. Представьте, что вы отправляете письмо по адресу 
Мейн-стрит, 123, квартира 9. Почтальон сначала приносит письмо на Мейн-стрит, 123. Затем перевозчик ищет почтовый ящик 
квартиры номер 9. Адрес похож на название пакета на Java. Номер квартиры похож на имя класса в Java. Подобно тому, как 
почтальон смотрит только на номера квартир в здании, Java ищет в пакете только имена классов.

Имена пакетов также иерархичны, как и почта. Почтовая служба начинается с верхнего уровня, в первую очередь глядя на 
вашу страну. Вы также начинаете читать имя пакета в начале. Например, если он начинается с java, это означает, что он 
поставляется с JDK. Если он начинается с что-то еще, это, вероятно, показывает, откуда оно взялось, используя имя 
веб-сайта в обратном порядке. Например, com.wiley.javabook сообщает нам, что код связан с веб-сайтом или организацией 
wiley.com. После названия сайта  вы можете добавить все, что хотите. Например, com.wiley.java.my.name также 
произошло от wiley.com. Java называет более подробные пакеты дочерними пакетами. Пакет com.wiley.javabook является 
дочерним пакетом com.wiley. Вы можете сказать, потому что он длиннее и, следовательно, более конкретен.

На экзамене вы увидите имена пакетов, которые не соответствуют этому соглашению. Не удивляйтесь, увидев такие имена 
пакетов, как a.b.c. Правило для имен пакетов состоит в том, что они в основном состоят из букв или цифр, разделенных 
точками (.). Технически, вам разрешено несколько других  символов между точками (.). Вы даже можете использовать 
имена пакетов веб-сайтов, которыми вы не владеете, если хотите, например com.wiley, хотя люди, читающие ваш код, 
могут быть сбиты с толку! Правила такие же, как и для имен переменных, которые вы увидите далее в этой главе.
Экзамен может попытаться обмануть вас с недопустимыми именами переменных. К счастью, он не пытается обмануть вас, 
давая неверные имена пакетов.

В следующих разделах мы рассмотрим импорт с подстановочными знаками, конфликты имен с импортом, как создать 
собственный пакет и как экзамен форматирует код.

### Подстановочные знаки

Классы в одном пакете часто импортируются вместе. Вы можете использовать ярлык для импорта всех классов в пакете.
```
import java.util.*; // импортирует, среди прочего, java.util.Random

public class NumberPicker {
   public static void main(String[] args) {
      Random r = new Random();
      System.out.println(r.nextInt(10));
   }
}
```
В этом примере мы импортировали java.util.Random и кучу других классов. * — это подстановочный знак, который 
соответствует всем классам в пакете. Каждый класс в пакете java.util доступен для этой программы, когда Java его 
компилирует. Оператор импорта не вводит дочерние пакеты, поля или методы; он импортирует только классы непосредственно 
в пакете. Предположим, вы хотите использовать класс AtomicInteger (вы узнаете об этом в главе 13, «Параллелизм») в 
пакете java.util.concurrent.atomic. Какой импорт или импорт поддерживают это?

```
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
```
Только последний импорт позволяет распознать класс, потому что дочерние пакеты не включены в первые два.
Вы можете подумать, что включение такого количества классов замедляет выполнение вашей программы, но это не так. 
Компилятор выясняет, что на самом деле нужно. Какой подход вы выберете, зависит от личных предпочтений или командных 
предпочтений, если вы работаете с другими в команде. Перечисление используемых классов облегчает чтение кода, особенно 
для начинающих программистов. Использование подстановочного знака может сократить список импорта. Вы увидите оба подхода 
на экзамене.

### Избыточный импорт

Подождите минуту! Мы ссылались на System без импорта каждый раз, когда печатали текст, и Java с этим справлялся. 
В мире Java есть один специальный пакет, который называется java.lang. Этот пакет особенный тем, что он автоматически 
импортируется. Вы можете ввести этот пакет в операторе импорта, но это не обязательно. Как вы думаете, сколько импортов 
в следующем коде является избыточным?
```
1: import java.lang.System;
2: import java.lang.*;
3: import java.util.Random;
4: import java.util.*;
5: public class NumberPicker {
6:    public static void main(String[] args) {
7:      Random r = new Random();
8:      System.out.println(r.nextInt(10));
9:    }
10: }
```
Ответ заключается в том, что три импорта являются избыточными. Строки 1 и 2 избыточны, потому что все в java.lang 
импортируется автоматически. Строка 4 также избыточна в этом примере, поскольку Random уже импортирован из 
java.util.Random. Однако, если бы строки 3 не было, java.util.* не был бы лишним, поскольку он покрывал бы 
импорт Random.

Другой случай избыточности включает импорт класса, который находится в том же пакете, что и класс, который его 
импортирует. Java автоматически ищет в текущем пакете другие классы. Давайте рассмотрим еще один пример, чтобы 
убедиться, что вы понимаете крайние случаи импорта. В этом примере файлы и пути находятся в пакете java.nio.file. 
На экзамене могут использоваться пакеты, которые вы никогда раньше не видели. Вопрос позволит вам узнать, в каком 
пакете находится класс, если вам нужно это знать, чтобы ответить на вопрос.

Как вы думаете, какие операторы импорта помогут скомпилировать этот код?
```
public class InputImports {
  public void read(Files files) {
    Paths.get("name");
  }
}
```
Есть два возможных ответа. Более короткий - использовать подстановочный знак для одновременного импорта обоих.
```
import java.nio.file.*;
```
Другой ответ - явно импортировать оба класса.
```
import java.nio.file.Files;
import java.nio.file.Paths;
```
Теперь давайте рассмотрим некоторые импорты, которые не работают.
```
import java.nio.*;         // НЕ ХОРОШО – подстановочный знак соответствует только 
                          // именам классов, а не «file.Files»

import java.nio.*.*;     // НЕ ХОРОШО - вы можете использовать только один подстановочный знак
                        // и он должен быть в конце                       
                        
import java.nio.file.Paths.*;  // НЕ ХОРОШО – вы не можете импортировать методы
                              // только имена классов
```

### Конфликты имен
Одна из причин использования пакетов заключается в том, что имена классов не должны быть уникальными во всей Java. 
Это означает, что иногда вам может понадобиться импортировать класс, который можно найти в нескольких местах. 
Типичным примером этого является класс Date. Java предоставляет реализации java.util.Date и java.sql.Date. 
Какой оператор импорта мы можем использовать, если нам нужна версия java.util.Date?
```
public class Conflicts {
    Date date;
    // еще немного кода
}
```
Ответ должен быть легким к настоящему времени. Вы можете написать либо import java.util.*; или импортируйте 
java.util.Date;. Сложные случаи возникают, когда присутствует другой импорт.
```
import java.util.*;
import java.sql.*; // приводит к тому, что объявление даты не компилируется
```
Когда имя класса встречается в нескольких пакетах, Java выдает ошибку компилятора. В нашем примере решение 
простое — удалить ненужный нам import java.sql.*. Но что делать, если нам нужна целая куча других классов в пакете 
java.sql?
```
import java.util.Date;
import java.sql.*;
```
А, теперь работает! Если вы явно импортируете имя класса, оно имеет приоритет над любыми подстановочными знаками. 
Java думает: «Программист действительно хочет, чтобы я использовал класс java.util.Date».

Еще один пример. Что Java делает со «связями» для приоритета?
```
import java.util.Date;
import java.sql.Date;
```

Java достаточно умен, чтобы определить, что этот код никуда не годится. Как программист, вы заявили, что явно хотите, 
чтобы по умолчанию были реализации как java.util.Date, так и java.sql.Date. Поскольку не может быть двух значений по 
умолчанию, компилятор сообщает вам, что импорт неоднозначен.

---
#### Если вам действительно нужно использовать два класса с одинаковым именем

Иногда вам действительно нужно использовать Date из двух разных пакетов. Когда это происходит, вы можете выбрать один 
для использования в операторе импорта и использовать полное имя класса другого. Или вы можете отказаться от обоих 
операторов импорта и всегда использовать полное имя класса.
```
public class Conflicts {
  java.util.Date date;
  java.sql.Date sqlDate;
}
```

### Создание нового пакета

До сих пор весь код, который мы написали в этой главе, находился в пакете по умолчанию. Это специальный безымянный 
пакет, который следует использовать только для одноразового кода. Вы можете сказать, что код находится в пакете по 
умолчанию, потому что нет имени пакета. На экзамене вы увидите, что пакет по умолчанию часто используется для экономии 
места в листингах кода. В реальной жизни всегда называйте свои пакеты, чтобы избежать конфликтов имен и позволить 
другим повторно использовать ваш код.

Теперь пришло время создать новый пакет. Структура каталогов на вашем компьютере связана с именем пакета. 
В этом разделе просто читайте вместе. Мы рассмотрим, как скомпилировать и запустить код в следующем разделе.

Предположим, у нас есть эти два класса:

```
package packagea;
public class ClassA {}

package packageb;
import packagea.ClassA;
public class ClassB {
  public static void main(String[] args) {
    ClassA a;
    System.out.println("Got it");
  }
}
```

Когда вы запускаете программу на Java, Java знает, где искать эти имена пакетов. В этом случае запуск из 
C:\temp работает, потому что под ним находятся и packagea, и packageb.

### Компиляция и запуск кода с пакетами

Вам будет намного легче изучать Java, используя командную строку для компиляции и тестирования ваших примеров. Как 
только вы хорошо изучите синтаксис Java, вы можете переключиться на IDE. Но на экзамене ваша цель — узнать подробности 
о языке, а не позволить IDE скрыть их от вас.

Следуйте этому примеру, чтобы убедиться, что вы знаете, как использовать командную строку. Если у вас возникли 
проблемы с выполнением этой процедуры, задайте вопрос на форуме Beginning Java на CodeRanch. Опишите, что вы 
пробовали и о чем говорит ошибка.

```
www.coderanch.com/forums/f-33/java
```

Первый шаг — создать два файла из предыдущего раздела. В таблице 1.1 показаны ожидаемые полные имена файлов и 
команда для входа в каталог для следующих шагов.

#### Таблица 1.1 - Процедура настройки по операционной системе
|           Шаг            |           Windows            |         Mac/Linux         |
|:------------------------:|:----------------------------:|:-------------------------:|
| 1. Создать первый класс. | C:\temp\packagea\ClassA.java | /tmp/packagea/ClassA.java |
| 2. Создать второй класс. | C:\temp\packageb\ClassB.java | /tmp/packageb/ClassB.java |
| 3. Перейти в каталог.    |          cd C:\temp          |          cd /tmp          |

Теперь пришло время скомпилировать код. К счастью, это одинаково независимо от операционной системы. Для компиляции 
введите следующую команду:
```
javac packagea/ClassA.java packageb/ClassB.java
```

Если эта команда не работает, вы получите сообщение об ошибке. Внимательно проверьте свои файлы на наличие опечаток 
в предоставленных файлах. Если команда сработает, будут созданы два новых файла: packagea/ClassA.class и 
packageb/ClassB.class.

___
#### Компиляция с подстановочными знаками

Вы можете использовать звездочку, чтобы указать, что вы хотите включить все файлы Java в каталог. Это удобно, когда 
у вас много файлов в пакете. Мы можем переписать предыдущую команду javac следующим образом:

```
javac packagea/*.java packageb/*.java
```

Однако вы не можете использовать подстановочный знак для включения подкаталогов. Если бы вы написали javac *.java, 
код в пакетах не подхватился бы.
___

Теперь, когда ваш код скомпилирован, вы можете запустить его, введя следующую команду:
```
java packageb.ClassB
```
Если это сработает, вы увидите сообщение «Got it». Вы могли заметить, что мы ввели ClassB, а не ClassB.class. 
Как обсуждалось ранее, вы не передаете расширение при запуске программы.

На рис. 1.1 показано, где в структуре каталогов были созданы файлы .class.

#### Рис. 1.1 - Компиляция с пакетами
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/chapter%201/image%201/figure%201.1.JPG)

### Компиляция в другой каталог

По умолчанию команда javac помещает скомпилированные классы в тот же каталог, что и исходный код. Он также 
предоставляет возможность поместить файлы классов в другой каталог. Параметр -d указывает этот целевой каталог.

___
Параметры Java чувствительны к регистру. Это означает, что вы не можете передать -D вместо -d.
___

Если вы следуете инструкциям, удалите файлы ClassA.class и ClassB.class, созданные в предыдущем разделе. Как вы 
думаете, где эта команда создаст файл ClassA.class?

````
javac -d classes packagea/ClassA.java packageb/ClassB.java
````

Правильный ответ находится в classes/packagea/ClassA.class. Структура пакета сохраняется в запрошенном целевом 
каталоге. На рис. 1.2 показана эта новая структура.

#### Рис. 1.2 - Компиляция с пакетами и каталогами
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/chapter%201/image%201/figure%201.2.JPG)

Чтобы запустить программу, вы указываете путь к классам, чтобы Java знала, где найти классы. Есть три варианта, 
которые вы можете использовать. Все три из них делают одно и то же:

```
java -cp classes packageb.ClassB
java -classpath classes packageb.ClassB
java --class-path classes packageb.ClassB
```
Обратите внимание, что для последнего требуется два тире (--), а для первых двух требуется один тире (-). Если у вас 
неправильное количество тире, программа не запустится.

___
### Три варианта пути к классам

Вы можете задаться вопросом, почему существует три варианта пути к классам. Опция -cp является короткой формой. 
Разработчики часто выбирают краткую форму, потому что мы ленивые машинисты. Версии -classpath и -- class-path могут 
быть более четкими для чтения, но требуют большего набора текста.

___

В Таблице 1.2 и Таблице 1.3 приведены параметры, которые вам необходимо знать для экзамена. Есть много других 
доступных вариантов! А в Главе 12, «Модули», вы узнаете о дополнительных опциях, специфичных для модулей.

#### Таблица 1.2 - Важные параметры javac
| Вариант                          | Описание                                                           |
|:---------------------------------|:-------------------------------------------------------------------|
| -cp &#60;classpath&#62;          | Расположение классов, необходимых для компиляции программы         |
| -classpath &#60;classpath&#62;   |                                                                    | 
| --class-path &#60;classpath&#62; |                                                                    |
| -d &#60;dir&#62;                 | Каталог, в который следует поместить сгенерированные файлы классов |

#### Таблица 1.3 - Важные параметры javac
| Вариант                          | Описание                                                           |
|:---------------------------------|:-------------------------------------------------------------------|
| -cp &#60;classpath&#62;          | Расположение классов, необходимых для запуска программы            |
| -classpath &#60;classpath&#62;   |                                                                    | 
| --class-path &#60;classpath&#62; |                                                                    |

### Компиляция с файлами JAR

Как и в случае с каталогом классов в предыдущем примере, вы также можете явно указать расположение других файлов, 
используя путь к классам. Этот метод полезен, когда файлы классов расположены в другом месте или в специальных файлах 
JAR. Файл архива Java (JAR) подобен ZIP-файлу, состоящему в основном из файлов классов Java.

В Windows введите следующее:

```
java -cp ".;C:\temp\someOtherLocation;c:\temp\myJar.jar" myPackage.MyClass
```

В macOS/Linux введите следующее:

```
java -cp ".:/tmp/someOtherLocation:/tmp/myJar.jar" myPackage.MyClass
```

Точка (.) указывает, что вы хотите включить текущий каталог в путь к классам. Остальная часть команды говорит искать 
свободные файлы классов (или пакеты) в someOtherLocation и в myJar.jar. Windows использует точку с запятой (;) для 
разделения частей пути к классам; другие операционные системы используют двоеточие.

Как и при компиляции, вы можете использовать подстановочный знак (*) для сопоставления всех JAR-файлов в каталоге. 
Вот пример:

```
java -cp "C:\temp\directoryWithJars\*" myPackage.MyClass
```

Эта команда добавит в classpath все файлы JAR, которые находятся в directoryWithJars. Он не будет включать никакие 
JAR-файлы в путь к классам, которые находятся в подкаталоге directoryWithJars.

### Создание JAR-файла

Некоторые JAR-файлы созданы другими, например загружены из Интернета или созданы товарищем по команде. Кроме того, вы 
можете создать файл JAR самостоятельно. Для этого вы используете команду jar. Простейшие команды создают банку, 
содержащую файлы в текущем каталоге. Вы можете использовать краткую или полную форму для каждого варианта.

```
jar -cvf myNewFile.jar .
jar --create --verbose --file myNewFile.jar .
```
Кроме того, вы можете указать каталог вместо использования текущего каталога.

```
jar -cvf myNewFile.jar -C dir .
```

Длинной формы опции -C не существует. В Таблице 1.4 перечислены параметры, необходимые для использования команды jar 
для создания файла JAR. В главе 12 вы снова видите jar для модулей.

#### Таблица 1.4 - Важные параметры jar
| Вариант                   | Описание                                                                 |
|---------------------------|--------------------------------------------------------------------------|
| -c                        | Создает новый файл JAR                                                   |
| --create                  |                                                                          | 
| -v                        | Распечатывает детали при работе с файлами JAR                            |                                
| --verbose                 |                                                                          |  
| -f &#60;fileName&#62;     | имя JAR-файла                                                            |
| --file &#60;fileName&#62; |                                                                          |
| -C &#60;directory&#62;    | Каталог, содержащий файлы, которые будут использоваться для создания JAR |

### Упорядочивание элементов в классе

Теперь, когда вы ознакомились с наиболее распространенными частями класса, давайте рассмотрим правильный порядок их 
ввода в файл. Комментарии могут располагаться в любом месте кода. Кроме того, вам необходимо запомнить правила из 
таблицы 1.5.

#### Таблица 1.5 - Порядок объявления класса
| Элемент                                   | Пример              | Необходимый? | Куда это идет?                                                      |
|:------------------------------------------|---------------------|:------------:|:--------------------------------------------------------------------|
| Декларация пакета                         | package abc;        |     Нет      | Первая строка в файле <br/>(исключая комментарии или пустые строки) |
| import statements<br/>(операторы импорта) | import java.util.*; |     Нет      | Сразу после упаковки (если есть)                                    |
| Объявление типа верхнего уровня           | public class C      |      Да      | Сразу после импорта (если есть)                                     |                               |
| Объявления полей                          | int value;          |     Нет      | Любой элемент верхнего уровня в классе                              |                                                                     |
| Объявления методов                        | void method()       |     Нет      | Любой элемент верхнего уровня в классе                              |                                                                    |


Давайте рассмотрим несколько примеров, которые помогут вам запомнить это. Первый пример содержит по одному из каждого 
элемента:

```
package structure; // пакет должен быть первым, без комментариев
import java.util.*; // импорт должен идти после упаковки

public class Meerkat { // затем начинается класс
   double weight; // поля и методы могут идти в любом порядке
   public double getWeight() {
       return weight; }
   double height; // другое поле - им не обязательно быть вместе
}
```

Все идет нормально. Это обычная схема, с которой вы должны быть знакомы. Как насчет этого?

```
/* header */

package structure;

// class Meerkat
public class Meerkat { }
```

Все еще хорошо. Мы можем размещать комментарии где угодно, пустые строки игнорируются, а импорт необязателен. 
В следующем примере у нас есть проблема:

```
import java.util.*;
package structure; // НЕ КОМПИЛИРУЕТСЯ
String name; // НЕ КОМПИЛИРУЕТСЯ
public class Meerkat { } // НЕ КОМПИЛИРУЕТСЯ
```

Здесь есть две проблемы. Во-первых, операторы package и import меняются местами. Хотя оба являются необязательными, 
пакет должен предшествовать импорту, если он присутствует. Другая проблема заключается в том, что поле пытается 
объявить вне класса. Это не разрешено. Поля и методы должны находиться внутри класса.

Получил все это? Подумайте об аббревиатуре PIC (изображение): пакет, импорт и класс. Поля и методы легче запомнить, 
потому что они просто должны находиться внутри класса.

___
На протяжении всей этой книги, если вы видите два общедоступных класса в фрагменте кода или вопросе, вы можете 
предположить, что они находятся в разных файлах, если только не указано, что они находятся в одном и том же файле .java.
___

Теперь вы знаете, как создать и организовать класс. В последующих главах показано, как создавать классы с более 
мощными операциями.

## Создание объектов

Наши программы не смогли бы сделать ничего полезного, если бы у нас не было возможности создавать новые объекты. 
Помните, что объект является экземпляром класса. В следующих разделах мы рассмотрим конструкторы, поля объектов, 
инициализаторы экземпляров и порядок, в котором инициализируются значения.

### Вызов конструкторов

Чтобы создать экземпляр класса, все, что вам нужно сделать, это написать new перед именем класса и добавить круглые 
скобки после него. Вот пример:

```
Park p = new Park();
```

Сначала вы объявляете тип, который будете создавать (Park), и даете переменной имя (p). Это дает Java место для разрыва 
ссылки на объект. Затем вы пишете new Park() для фактического создания объекта.

Park() выглядит как метод, поскольку за ним следуют круглые скобки. Он называется конструктором и представляет собой 
особый тип метода, который создает новый объект. Теперь пришло время определить собственный конструктор:

```
public class Chick {
  public Chick() {
    System.out.println("in constructor");
  }
}
``` 
В отношении конструктора необходимо отметить два ключевых момента: имя конструктора совпадает с именем класса и тип 
возвращаемого значения отсутствует. На экзамене вы можете увидеть такой метод:

```
public class Chick {
  public void Chick() { } // НЕ КОНСТРУКТОР
}
```

Когда вы видите имя метода, начинающееся с заглавной буквы и имеющее возвращаемый тип, обратите на него особое 
внимание. Это не конструктор, так как есть возвращаемый тип. Это обычный метод, который компилируется, но не вызывается 
при написании новой функции Chick().

Цель конструктора — инициализация полей, хотя вы можете поместить туда любой код. Другой способ инициализировать 
поля — сделать это непосредственно в строке, в которой они объявлены. В этом примере показаны оба подхода:

```
public class Chicken {
    int numEggs = 12; // инициализация в строке
    String name;
    
    public Chicken() {
       name = "Duke"; // инициализация в конструкторе 
     }
}
```

Для большинства классов вам не нужно кодировать конструктор — компилятор предоставит вам «ничего не делающий» 
конструктор по умолчанию. Есть несколько сценариев, которые требуют объявления конструктора. Вы узнаете о них все 
в главе 6.

### Чтение и запись полей 

Переменные экземпляра можно читать и записывать непосредственно из вызывающего объекта. В этом примере лебедь-мать 
откладывает яйца:

```
public class Swan {
    int numberEggs;     // переменная экземпляра
    
    public static void main(String[] args) {
        Swan mother = new Swan();
        mother.numberEggs = 1;    // установить переменную
        System.out.println(mother.numberEggs);    // чтение переменной
    }
}
```

«Вызывающим» в данном случае является метод main(), который может находиться в том же классе или в другом классе. 
Этот класс устанавливает numberEggs равным 1, а затем считывает numberEggs напрямую, чтобы распечатать его. В главе 
5 вы узнаете, как использовать инкапсуляцию для защиты класса Swan от того, чтобы кто-то задал отрицательное число яиц.

Вы даже можете прочитать значения уже инициализированных полей в строке, инициализирующей новое поле:

```
1: public class Name {
2:    String first = "Theodore";
3:    String last = "Moose";
4:    String full = first + last;
5: }
```

Строки 2 и 3 записывают в поля. Строка 4 читает и записывает данные. Он читает поля первым и последним. Затем он пишет 
поле заполнено.

### Выполнение блоков инициализатора экземпляра

Когда вы узнали о методах, вы увидели фигурные скобки ({}). Код между фигурными скобками (иногда называемый «внутри 
фигурных скобок») называется блоком кода. Везде, где вы видите фигурные скобки, это блок кода.

Иногда блоки кода находятся внутри метода. Они запускаются при вызове метода. В других случаях блоки кода появляются 
вне метода. Они называются инициализаторами экземпляра (instance initializers). В главе 6 вы узнаете, как использовать 
статический  инициализатор (static initializer).

Сколько блоков вы видите в следующем примере? Сколько инициализаторов экземпляров вы видите?

```
1: public class Bird {
2:    public static void main(String[] args) {
3:       { System.out.println("Feathers"); }
4:    }
5:    { System.out.println("Snowy"); } // инициализатор экземпляра
6: }
```

В этом примере четыре блока кода: определение класса, объявление метода, внутренний блок и инициализатор экземпляра. 
Подсчет блоков кода прост: вы просто подсчитываете количество пар фигурных скобок. Если количество открывающих ({) и 
закрывающих (}) фигурных скобок неодинаково или они не определены в правильном порядке, код не компилируется. 
Например, вы не можете использовать закрывающую фигурную скобку (}), если нет соответствующей открывающей скобки ({), 
которая соответствует написанному ранее в коде. В программировании это называется проблемой сбалансированных скобок и 
часто возникает в вопросах на собеседовании.

Когда вы считаете инициализаторы экземпляров, имейте в виду, что они не могут существовать внутри метода. 
Строка 5 представляет собой инициализатор экземпляра, фигурные скобки которого находятся вне метода. С другой стороны, 
строка 3 не является инициализатором экземпляра, поскольку она вызывается только при выполнении метода main(). 
В строках 1 и 6 есть еще один набор фигурных скобок, составляющих объявление класса.

### Соблюдение порядка инициализации

При написании кода, инициализирующего поля в нескольких местах, необходимо следить за порядком инициализации. Это 
просто порядок, в котором вызываются различные методы, конструкторы или блоки при создании экземпляра класса. 
Мы добавим еще несколько правил в порядок инициализации в главе 6. А пока вам нужно помнить:

+ Поля и блоки инициализатора экземпляра запускаются в том порядке, в котором они появляются в файле.
+ Конструктор запускается после выполнения всех полей и блоков инициализатора экземпляра.

Давайте посмотрим на пример:

```
1: public class Chick {
2:    private String name = "Fluffy";
3:    { System.out.println("setting field"); }

4:    public Chick() {
5:        name = "Tiny";
6:        System.out.println("setting constructor");
7:    }

8:    public static void main(String[] args) {
9:       Chick chick = new Chick();
10:      System.out.println(chick.name); } }
```

Запуск этого примера печатает это:

```
setting field
setting constructor
Tiny
```

Давайте посмотрим, что здесь происходит. Мы начинаем с метода main(), потому что именно с него начинается выполнение 
Java. В строке 9 мы вызываем конструктор Chick. Java создает новый объект. Сначала он инициализирует имя "Fluffy" в 
строке 2. Затем он выполняет оператор println() в инициализаторе экземпляра в строке 3. После того, как все поля и 
инициализаторы экземпляра запущены, Java возвращается к конструктору. Строка 5 изменяет значение name на «Tiny», а 
строка 6 выводит другое выражение. На этом конструктор завершается, а затем выполнение возвращается к оператору 
println() в строке 10.

Порядок имеет значение для полей и блоков кода. Вы не можете ссылаться на переменную до того, как она будет определена:

```
{ System.out.println(name); } // НЕ КОМПИЛИРУЕТСЯ
private String name = "Fluffy";
```

Вы должны ожидать увидеть вопрос об инициализации на экзамене. Давайте попробуем ещё один. Как вы думаете, что выводит 
этот код?

```
public class Egg {
  public Egg() {
    number = 5;
  }
  
  public static void main(String[] args) {
      Egg egg = new Egg();
      System.out.println(egg.number);
  }
  
  private int number = 3;
  { number = 4; } }
```

Если вы ответили 5, вы все сделали правильно. Поля и блоки запускаются сначала по порядку, присваивая номеру 3, а 
затем 4. Затем запускается конструктор, присваивая номеру значение 5. Гораздо больше правил и примеров, описывающих 
порядок инициализации, вы найдете в главе 6. Здесь мы рассмотрим только основы, поэтому вы можете следовать порядку 
инициализации для простых программ.

## Понимание типов данных

Приложения Java содержат два типа данных: примитивные типы и ссылочные типы. В этом разделе мы обсудим различия между 
примитивным типом и ссылочным типом.

### Использование примитивных типов 

Java имеет восемь встроенных типов данных, называемых примитивными типами Java. Эти восемь типов данных представляют 
собой строительные блоки для объектов Java, поскольку все объекты Java представляют собой просто сложный набор этих 
примитивных типов данных. Тем не менее, примитив не является объектом в Java и не представляет объект. 
Примитив — это просто одно значение в памяти, например, число или символ.

### Примитивные типы

Экзамен предполагает, что вы хорошо разбираетесь в восьми примитивных типах данных, их относительных размерах и том, 
что в них можно хранить. В таблице 1.6 показаны примитивные типы Java вместе с их размером в битах и диапазоном 
значений, которые каждый содержит.

#### Таблица 1.6 - Примитивные типы
| Ключевое слово | Тип                                         | Мин. значение  | Макс. значение | Значение по умолчанию | Example |
|:--------------:|---------------------------------------------|:--------------:|:--------------:|:---------------------:|:-------:|
|    boolean     | true или false                              |      n/a       |      n/a       |         false         |  true   |
|      byte      | 8-битное<br/> интегральное значение         |      -127      |      128       |           0           |   123   |
|     short      | 16-битное<br/> интегральное значение        |    -32,768     |     32,767     |           0           |   123   |
|      int       | 32-битное<br/> интегральное значение        | -2,147,483,648 | 2,147,483,647  |           0           |   123   |
|      long      | 64-битное<br/> интегральное значение        |    -2^(-63)    |   2^(63) - 1   |          0L           |  123L   |
|     float      | 32-битное<br/> значение с плавающей запятой |      n/a       |      n/a       |         0.0f          | 123.45f |
|     double     | 64-битное<br/> значение с плавающей запятой |      n/a       |      n/a       |          0.0          | 123.456 |
|      char      | 16-битное значение Unicode                  |       0        |     65,535     |        \u0000         |   'a'   |

___
##### Является ли String примитивом?

Нет. Тем не менее, String часто ошибочно принимают за девятый примитив, потому что Java включает встроенную поддержку 
строковых литералов и операторов. Вы узнаете больше о String в главе 4, а пока просто помните, что это объект, а не 
примитив.
___

В Таблице 1.6 содержится много информации. Давайте рассмотрим некоторые ключевые моменты:

+ Типы byte, short, int и long используются для целых значений без десятичной точки.
+ Каждый числовой тип использует в два раза больше битов, чем меньший аналогичный тип. Например, тип short использует 
в два раза больше битов, чем byte.
+ Все числовые типы имеют знак и резервируют один из своих битов для охвата отрицательного диапазона. Например, вместо 
байта, охватывающего от 0 до 255 (или даже от 1 до 256), он на самом деле охватывает диапазон от -128 до 127.
+ Для числа с плавающей точкой требуется буква f или F, следующая за числом, чтобы Java знала, что это число с 
плавающей точкой. Без f или F Java интерпретирует десятичное значение как double.
+ Для типа long требуется буква l или L, следующая за номером, чтобы Java знала, что это тип long. Без l или L Java 
интерпретирует число без десятичной точки как int в большинстве сценариев.

Вас не будут спрашивать о точных размерах этих типов, хотя вы должны иметь общее представление о размере меньших типов, 
таких как byte и short. Распространенный вопрос среди новых разработчиков Java: каков размер логического значения в 
битах? Ответ таков: он не указан и зависит от JVM, на которой выполняется код.

___
### Подписанные и неподписанные: short и char

Для экзамена вы должны знать, что short и char тесно связаны, так как оба хранятся как целочисленные типы с одинаковой 
16-битной длиной. Основное отличие заключается в том, что тип short имеет знак, что означает, что он разделяет свой 
диапазон на положительные и отрицательные целые числа. В качестве альтернативы, char не имеет знака, что означает, 
что его диапазон строго положительный, включая 0.

Часто значения short и char могут быть преобразованы друг в друга, поскольку базовый размер данных один и тот же. 
Вы узнаете больше о приведение типов (Casting) в главе 2, «Операторы».
___

### Написание литералов

Есть еще несколько вещей, которые вы должны знать о числовых примитивах. Когда в коде присутствует число, оно 
называется литералом. По умолчанию Java предполагает, что вы определяете значение int с числовым литералом. В следующем 
примере указанное число больше, чем помещается в int. Помните, что вы не должны запоминать максимальное значение для 
int. Экзамен включит его в вопрос, если он возникнет.

```
long max = 3123456789; // НЕ КОМПИЛИРУЕТСЯ
```

Java жалуется, что число вне допустимого диапазона. И это - для int. Однако у нас нет int. Решение состоит в том, 
чтобы добавить символ L к числу:

```
long max = 3123456789L; // Теперь Java знает, что это long
```

Кроме того, вы можете добавить строчную букву l к номеру. Но, пожалуйста, используйте заглавную букву L. Строчная 
буква l выглядит как цифра 1.

Другой способ указать числа — изменить «основание». Когда вы научились считать, вы изучили цифры от 0 до 9. Эта система 
счисления называется по основанию 10, поскольку для каждой цифры существует 10 возможных значений. Она также известна 
как десятичная система счисления. Java позволяет указывать цифры в нескольких других форматах:

+ Восьмеричный (цифры 0–7), в котором в качестве префикса используется число 0, например 017.
+ Шестнадцатеричный (цифры 0–9 и буквы A–F/a–f), который использует 0x или 0X в качестве префикса, например, 0xFF, 
0xff, 0XFf. Шестнадцатеричное число нечувствительно к регистру, поэтому все эти примеры означают одно и то же значение.
+ Двоичный (цифры 0–1), в котором в качестве префикса используется число 0, за которым следует b или B, например 
0b10, 0B10.

Вам не нужно будет конвертировать между системами счисления на экзамене. Вам придется распознавать допустимые 
литеральные значения, которые могут быть присвоены числам.

### Литералы и символ подчеркивания

Последнее, что вам нужно знать о числовых литералах, это то, что вы можете иметь недостатки в цифрах, чтобы облегчить 
их чтение:

```
int million1 = 1000000;
int million2 = 1_000_000;
```

Мы бы предпочли прочитать последнее, потому что нули не идут вместе. Вы можете добавлять символы подчеркивания где 
угодно, кроме как в начале литерала, в конце литерала, прямо перед десятичной точкой или сразу после десятичной точки. 
Вы даже можете разместить несколько символов подчеркивания рядом друг с другом, хотя мы не рекомендуем это делать.

Давайте посмотрим на несколько примеров:

```
double notAtStart = _1000.00; // НЕ КОМПИЛИРУЕТСЯ
double notAtEnd = 1000.00_; // НЕ КОМПИЛИРУЕТСЯ
double notByDecimal = 1000_.00; // НЕ КОМПИЛИРУЕТСЯ
double annoyingButLegal = 1_00_0.0_0; // Некрасиво, но компилируется
double reallyUgly = 1__________2; // Также компилирует
```

### Использование ссылочных типов

Ссылочный тип относится к объекту (экземпляру класса). В отличие от примитивных типов, которые хранят свои значения в 
памяти, где размещена переменная, ссылки не содержат значения объекта, на который они ссылаются. Вместо этого ссылка 
«указывает» на объект, сохраняя адрес памяти, где находится объект, концепция, называемая указателем. В отличие от 
других языков, Java не позволяет узнать, что такое адрес физической памяти. Вы можете использовать ссылку только для 
ссылки на объект.

Давайте рассмотрим несколько примеров объявления и инициализации ссылочных типов. Предположим, мы объявляем ссылку типа 
String:

```
String greeting;
```

Переменная greeting — это ссылка, которая может указывать только на объект String. Значение присваивается ссылке 
одним из двух способов:
+ Ссылка может быть назначена другому объекту того же или совместимого типа.
+ Ссылку можно присвоить новому объекту с помощью нового ключевого слова new.

Например, следующий оператор присваивает эту ссылку новому объекту:

```
greeting = new String("How are you?");
```

Ссылка greeting указывает на новый объект String, «How are you?». Объект String не имеет имени и доступен только 
через соответствующую ссылку.

### Различие между примитивами и ссылочными типами

Есть несколько важных различий между примитивами и ссылочными типами, которые вы должны знать. Во-первых, обратите 
внимание, что все примитивные типы имеют имена в нижнем регистре. Все классы, поставляемые с Java, начинаются с 
прописных букв. Хотя это и не требуется, это стандартная практика, и вы также должны следовать этому соглашению для 
создаваемых вами классов.

Далее, ссылочные типы можно использовать для вызова методов, предполагая, что ссылка не является null. Примитивы 
не имеют объявленных на них методов. В этом примере мы можем вызвать метод на ссылку, так как она имеет ссылочный тип. 
Вы можете сказать, что length — это метод, потому что после него стоит (). Посмотрите, сможете ли вы понять, почему 
следующий фрагмент кода не компилируется:

```
4: String reference = "hello";
5: int len = reference.length();
6: int bad = len.length(); // НЕ КОМПИЛИРУЕТСЯ
```

6 строка - (бред). Для len не существует методов, потому что это примитив типа int. У примитивов нет методов. Помните, 
что String не является примитивом, поэтому вы можете вызывать такие методы, как length() для ссылки на String, как мы 
это делали в строке 5.

Наконец, ссылочным типам может быть присвоено значение null, что означает, что в данный момент они не ссылаются на 
объект. Примитивные типы дадут вам ошибку компилятора, если вы попытаетесь присвоить им значение null. В этом примере 
значение не может указывать на null, поскольку оно имеет тип int:

```
int value = null; // НЕ КОМПИЛИРУЕТСЯ
String name = null;
```

Но что, если вы не знаете значение int и хотите присвоить ему значение null? В этом случае вы должны использовать 
числовой класс-оболочку, такой как Integer, вместо int.

### Создание классов-оболочек

Каждый примитивный тип имеет класс-оболочку, который является типом объекта, соответствующим примитиву. В таблице 1.7 
перечислены все классы-оболочки и способы их создания.

#### Таблица 1.7 - Классы-оболочки
| Примитивный тип | Класс-оболочка | Класс-оболочка наследует номер? | Пример создания            | 
|:---------------:|:--------------:|:-------------------------------:|:---------------------------|
|     boolean     |    Boolean     |               Нет               | Boolean.valueOf(true)      |
|      byte       |      Byte      |               Да                | Byte.valueOf((byte) 1)     |
|      short      |     Short      |               Да                | Short.valueOf((short) 1)   |
|       int       |    Integer     |               Да                | Integer.valueOf(1)         |
|      long       |      Long      |               Да                | Long.valueOf(1)            |
|      float      |     Float      |               Да                | Float.valueOf((float) 1.0) |
|     double      |     Double     |               Да                | Double.valueOf(1.0)        |
|      char       |   Character    |               Нет               | Character.valueOf('c')     |

Существует также вариант valueOf(), который преобразует String в класс-оболочку. Например:

```
int primitive = Integer.parseInt("123");
Integer wrapper = Integer.valueOf("123");
```
Первая строка преобразует String в примитив типа int. Второй преобразует String в класс-оболочку Integer.

Все числовые классы в таблице 1.7 расширяют класс Number, что означает, что все они имеют несколько полезных 
вспомогательных методов: byteValue(), shortValue(), intValue(), longValue(), floatValue(), and doubleValue().
Boolean и Character классы-оболочки включают booleanValue() и charValue() соответственно.

Как вы, наверное, догадались, эти методы возвращают примитивное значение экземпляра оболочки в запрошенном типе.

```
Double apple = Double.valueOf("200.99");
System.out.println(apple.byteValue());  // -56
System.out.println(apple.intValue());  // 200
System.out.println(apple.doubleValue());  // 200.99
```

Эти вспомогательные методы делают все возможное для преобразования значений, но могут привести к потере точности. В 
первом примере в байтах нет 200, поэтому он заменяется на -56. Во втором примере значение усекается, что означает, 
что все числа после запятой отбрасываются. В главе 5 мы применяем автоупаковку и распаковку, чтобы показать, насколько 
легко Java позволяет работать с примитивными значениями и значениями-оболочками.

Некоторые классы-оболочки содержат дополнительные вспомогательные методы для работы с числами. Вам не нужно запоминать 
их; вы можете предположить, что все, что вам дано, является действительным. Например, Integer имеет:

+ max(int num1, int num2), который возвращает наибольшее из двух чисел;
+ min(int num1, int num2), который возвращает наименьшее из двух чисел;
+ sum(int num1, int num2), который суммирует два числа.

### Определение текстовых блоков

Ранее мы видели простой String со значением «hello». Что, если мы хотим иметь String с чем-то более сложным? Например, 
давайте разберемся, как создать String с этим значением:

```
"Java Study Guide"
      by Scott & Jeanne
```

Создание этого как строки требует двух вещей, которые вы еще не изучили. Синтаксис \" позволяет вам сказать, что вы 
хотите ", а не заканчивать строку, а \n говорит, что вам нужна новая строка. Оба они называются escape-символами, 
потому что обратная косая черта имеет особое значение. С помощью этих двух новых навыков мы можем написать

```
String eyeTest = "\"Java Study Guide\"\n by Scott & Jeanne";
```

Хотя это работает, это трудно читать. К счастью, в Java есть текстовые блоки, также известные как многострочные строки. 
См. рисунок 1.3 для эквивалента текстового блока.

#### Рис. 1.3 - Текстовый блок
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/chapter%201/image%201/figure%201.3.JPG)

Текстовый блок начинается и заканчивается тремя двойными кавычками (" " "), и содержимое не нужно экранировать. Это 
гораздо легче читать. Обратите внимание, что тип по-прежнему String. Это означает, что методы, о которых вы узнаете в 
Главе 4 для строк (String) работают как для обычной строки, так и для текстового блока.

Возможно, вы заметили на рисунке слова «случайный» и «основной пробел». Это что? Основные пробелы являются частью 
вашей строки и важны для вас. Случайные пробелы нужны только для того, чтобы код было легче читать. Вы можете 
переформатировать свой код и изменить количество случайных пробелов без какого-либо влияния на значение вашей строки.

Представьте себе вертикальную линию, нарисованную на крайнем левом непробельном символе в текстовом блоке. Все, что 
слева от него, — это случайные пробелы, а все, что справа — это существенные пробелы. Давайте попробуем пример. 
Сколько строк получается при этом и сколько случайных и необходимых пробельных символов начинается в каждой строке?

```
14: String pyramid = """
15:    *
16:   * *
17:  * * *
18: """;
19: System.out.print(pyramid);
```

Есть четыре строки вывода. Строки 15–17 отмечены звездочками. Строка 18 — это строка без каких-либо символов.
Закрывающая тройка "должна быть в строке 17, если нам не нужна эта пустая строка. Здесь нет случайных пробелов.
Закрывающие """ в строке 18 являются крайними левыми символами, поэтому строка рисуется в крайнем левом положении.
В строке 15 есть два обязательных пробельных символа для начала строки, а в строке 16 — один. Этот пробел заполняет 
строку, нарисованную так, чтобы соответствовать строке 18.

В таблице 1.8 показаны некоторые специальные последовательности форматирования и сравнивается их работа в обычной 
строке и текстовом блоке.

#### Таблица 1.8 - Форматирование текстового блока
|     Форматирование      |                        Значение в обычной строке                         |      Значение в текстовом блоке       |
|:-----------------------:|:------------------------------------------------------------------------:|:-------------------------------------:|
|           \ "           |                                    "                                     |                   "                   |
|         \ " " "         |                              n/a – Invalid                               |                 " " "                 |
|       \ " \ " \ "       |                                  " " "                                   |                 " " "                 |
| Пробел (в конце строки) |                                  Пробел                                  |             Игнорируется              |
|           \s            | Два пробела (\s является пробелом и сохраняет начальный пробел в строке) |              Два пробела              |
|   \ (в конце строки)    |                              n/a – Invalid                               | Пропускает новую строку в этой строке |

Давайте попробуем несколько примеров. Во-первых, вы понимаете, почему это не компилируется?

```
String block = """doe"""; // НЕ КОМПИЛИРУЕТСЯ
```

Текстовые блоки требуют разрыва строки после открывающего """, что делает этот вариант недействительным. Теперь давайте 
попробуем допустимый. Как вы думаете, сколько строк в этом текстовом блоке?

```
String block = """
  doe \
  deer""";
```

Только один. Вывод — deer, так как \ говорит Java не добавлять новую строку перед оленем. Попробуем определить 
количество строк в другом текстовом блоке:

```
String block = """
    doe \n
    deer
    """;
```

На этот раз у нас четыре линии. Так как текстовый блок имеет закрывающую """ в отдельной строке, у нас есть три строки 
для строк в текстовом блоке плюс явный \n. Давайте попробуем еще один. Как вы думаете, что это выводит?

```
String block = """
    "doe\"\"\"
    \"deer\"""
   """;
  System.out.print("*"+ block + "*");

The answer is
* "doe"""
 "deer"""
*
```
Все "убежать" (All of the \" escape the ". ). На линиях лани и оленя есть одно свободное пространство. Все остальные 
начальные пробелы являются  второстепенными пробелами.

## Объявление переменных

Вы уже видели некоторые переменные. Переменная — это имя части памяти, в которой хранятся данные. Когда вы объявляете 
переменную, вам нужно указать тип переменной вместе с именем. Присвоение переменной значения называется инициализацией 
переменной. Чтобы инициализировать переменную, вы просто вводите имя переменной, за которым следует знак равенства, а 
затем желаемое значение. В этом примере показано объявление и инициализация переменной в одной строке:

```
String zooName = "The Best Zoo";
```

В следующих разделах мы рассмотрим, как правильно определять переменные в одной или нескольких строках.

### Идентификация идентификаторов

Вероятно, вас не удивит, что в Java есть четкие правила относительно имен идентификаторов. 
Идентификатор — это имя переменной, метода, класса, интерфейса или пакета. К счастью, правила для идентификаторов 
переменных применимы ко всем другим типам, которые вы можете назвать. 

Для легальных идентификаторов нужно помнить всего четыре правила:
+ Идентификаторы должны начинаться с буквы, символа валюты или символа _. Символы валюты включают доллар ($), юань (¥), 
евро (€) и так далее.
+ Идентификаторы могут включать числа, но не начинаться с них.
+ Одиночное подчеркивание _ не допускается в качестве идентификатора.
+ Вы не можете использовать то же имя, что и зарезервированное слово Java. Зарезервированное слово — это специальное 
слово, которое Java отложила в сторону, чтобы вам не разрешалось его использовать.
+ Помните, что язык Java чувствителен к регистру, поэтому вы можете использовать версии ключевых слов, которые 
отличаются только регистром. Пожалуйста, не надо.

Не беспокойтесь — вам не нужно запоминать полный список зарезервированных слов. Экзамен спросит вас только о тех, 
которые обычно используются, например, о class и for. В таблице 1.9 перечислены все зарезервированные слова в Java. 

#### Таблица 1.9 - Зарезервированные слова

abstract | assert | boolean | break | byte | case | catch | char | class | const* | continue | default | do | double | 
else | enum | extends | final | finally | float | for | goto* | if | implements | import | instanceof | int | interface | 
long | native | new | package | private | protected | public | return | short | static | strictfp | super | switch | 
synchronized | this | throw | throws | transient | try | void | volatile | while |


___

&#42; Зарезервированные слова const и goto фактически не используются в Java. Они зарезервированы для того, чтобы люди, 
пришедшие из других языков программирования, не использовали их случайно — и, теоретически, на случай, если Java 
однажды захочет их использовать.

---

Есть и другие имена, которые вы не можете использовать. Например, true, false и null — это буквальные значения, поэтому 
они не могут быть именами переменных. Кроме того, есть контекстные ключевые слова, такие как module в главе 12. 
Приготовьтесь к проверке этих правил. Следующие примеры являются законными:

```
long okidentifier;
float $OK2Identifier;
boolean _alsoOK1d3ntifi3r;
char __SStillOkbutKnotsonice$;
```

Эти примеры незаконны:

```
int 3DPointClass;    // идентификаторы не могут начинаться с цифры
byte hollywood@vine; // @ не является буквой, цифрой, $ или _
String *$coffee;     // * не является буквой, цифрой, $ или _
double public;       // public — зарезервированное слово
short _;             // одно подчеркивание не допускается
```

---

### camelCase и snake_case

Хотя вы можете делать сумасшедшие вещи с именами идентификаторов, пожалуйста, не делайте этого. В Java есть соглашения, 
чтобы код был читабельным и последовательным. Например, в camel case (верблюжьем регистре) первая буква каждого слова 
заглавная. Имена методов и переменных обычно пишутся верблюжьим регистром с первой строчной буквой, например toUpper().
Имена классов и интерфейсов также пишутся верблюжьим регистром, с прописной первой буквой, например ArrayList.

Другой стиль называется snake case (змеиным футляром). Он просто использует подчеркивание (_) для разделения слов. Java 
обычно использует заглавные буквы для констант и значений перечисления, таких как NUMBER_FLAGS. 

Экзамен не всегда будет следовать этим соглашениям, чтобы усложнить вопросы об идентификаторах. 
Напротив, вопросы по другим темам обычно соответствуют стандартным соглашениям. 
Мы рекомендуем вам следовать этим правилам на работе.

---

### Объявление нескольких переменных

Вы также можете объявить и инициализировать несколько переменных в одном операторе. Как вы думаете, сколько переменных 
объявлено и инициализировано в следующем примере?

```
void sandFence() {
   String s1, s2;
   String s3 = "yes", s4 = "no";
}
```

Были объявлены четыре строковые переменные: s1, s2, s3 и s4. Вы можете объявить много переменных в одном объявлении, 
если они все одного типа. Вы также можете инициализировать любое или все эти значения встроенными. В предыдущем примере 
у нас есть две инициализированные переменные: s3 и s4. Две другие переменные остаются объявленными, но еще не 
инициализированными.

Вот где это становится сложно. Обратите внимание на сложные вещи! Экзамен попытается обмануть вас. Опять же, как вы 
думаете, сколько переменных объявлено и инициализировано в следующем коде?

```
void paintFence() {
  int i1, i2, i3 = 0;
}
```

Как и следовало ожидать, были объявлены три переменные: i1, i2 и i3. Однако было инициализировано только одно из этих 
значений: i3. Два других остаются объявленными, но еще не инициализированными. В этом вся хитрость. Каждый фрагмент, 
разделенный запятой, представляет собой небольшое объявление. Инициализация i3 применяется только к i3. Он не 
имеет ничего общего с i1 или i2, несмотря на то, что находится в том же утверждении. Как вы увидите в следующем 
разделе, вы не можете использовать i1 или i2 до тех пор, пока они не будут инициализированы.

Другой способ, которым экзамен может попытаться обмануть вас, — это показать вам код, подобный этой строке:

```
int num, String value; // НЕ КОМПИЛИРУЕТСЯ
```

Этот код не компилируется, потому что он пытается объявить несколько переменных разных типов в одном операторе. Ярлык 
для объявления нескольких переменных в одном операторе допустим, только если они имеют общий тип.

---

Легальный, допустимый и компилируемый — все это синонимы в мире экзаменов по Java. Мы стараемся использовать всю 
терминологию, с которой вы можете столкнуться на экзамене.

---

Чтобы убедиться, что вы понимаете это, посмотрите, сможете ли вы выяснить, какие из следующих утверждений 
являются допустимыми:

```
4: boolean b1, b2;
5: String s1 = "1", s2;
6: double d1, double d2;
7: int i1; int i2;
8: int i3; i4;
```

Строки 4 и 5 являются допустимыми. Каждая из них объявляет две переменные. В строке 4 не инициализируется ни одна 
переменная, а в строке 5 инициализируется только одна. Строка 7 также является допустимой. Хотя int появляется дважды, 
каждое из них находится в отдельном выражении. Операторы в Java разделяются точкой с запятой (;). Так уж получилось, 
что в одной строке два совершенно разных утверждения.

Строка 6 недопустима. Java не позволяет объявлять два разных типа в одном выражении. Подождите минуту! Переменные d1 и 
d2 относятся к одному типу. Они оба типа double. Хотя это правда, это все еще не разрешено. Если вы хотите объявить 
несколько переменных в одном операторе, они должны использовать одно и то же объявление типа и не повторять его.

Строка 8 недопустима. Опять же, у нас есть два совершенно разных утверждения в одной строке. Второе объявление в строке 
8 не является допустимым объявлением, поскольку в нем не указан тип. Когда вы видите на экзамене странно расположенную 
точку с запятой, представьте, что код находится в отдельных строках, и подумайте, компилируется ли код таким образом. 
В этом случае последние две строки кода можно было бы переписать следующим образом:

```
int i1;
int i2;
int i3;
i4;
```

Глядя на последнюю строку отдельно, вы можете легко увидеть, что объявление недействительно. И да, экзамен 
действительно впихивает несколько операторов в одну строку — отчасти для того, чтобы обмануть вас, а отчасти для 
того, чтобы на экране поместилось больше кода. В реальном мире, пожалуйста, ограничьтесь одним объявлением на 
оператор и строку. Ваши товарищи по команде будут благодарны вам за читаемый код.

## Инициализация переменных

Прежде чем вы сможете использовать переменную, ей нужно значение. Для некоторых типов переменных это значение 
устанавливается автоматически, а для других требуется, чтобы его указал программист. В следующих разделах мы 
рассмотрим различия между значениями по умолчанию для локальных переменных, переменных экземпляра и класса.

### Создание локальных переменных

Локальная переменная — это переменная, определенная в конструкторе, методе или блоке инициализатора. Для простоты мы 
сосредоточимся в первую очередь на локальных переменных в методах в этом разделе, хотя правила для остальных те же.

### Окончательные локальные переменные

Ключевое слово final может применяться к локальным переменным и эквивалентно объявлению констант в других языках. 
Рассмотрим этот пример:

```
5: final int y = 10;
6: int x = 20;
7: y = x + 10; // НЕ КОМПИЛИРУЕТСЯ
```

Обе переменные установлены, но y использует ключевое слово final. По этой причине строка 7 вызывает ошибку компилятора, 
поскольку значение нельзя изменить. 

Модификатор final также можно применять к ссылкам на локальные переменные. В следующем примере используется объект 
массива int[], о котором вы узнаете в главе 4.

```
5: final int[] favoriteNumbers = new int[10];
6: favoriteNumbers[0] = 10;
7: favoriteNumbers[1] = 20;
8: favoriteNumbers = null; // НЕ КОМПИЛИРУЕТСЯ
```

Обратите внимание, что мы можем изменить содержимое или данные в массиве. Ошибка компилятора возникает только в 
строке 8, когда мы пытаемся изменить значение ссылки favoriteNumbers.

### Неинициализированные локальные переменные

Локальные переменные не имеют значения по умолчанию и должны быть инициализированы перед использованием. Кроме того, 
компилятор сообщит об ошибке, если вы попытаетесь прочитать неинициализированное значение. Например, следующий код 
генерирует ошибку компилятора:

```
4: public int notValid() {
5:    int y = 10;
6:    int x;
7:    int reply = x + y;  // НЕ КОМПИЛИРУЕТСЯ
8:    return reply;
9: }
```

Переменная y инициализируется значением 10. Напротив, переменная x не инициализируется до того, как она будет 
использована в выражении в строке 7, и компилятор выдаст ошибку. Компилятор достаточно умен, чтобы распознавать 
переменные, которые были инициализированы после их объявления, но до их использования. Вот пример:

```
public int valid() {
  int y = 10;
  int x; // x is declared here
  x = 3; // x is initialized here
  int z; // z is declared here but never initialized or used
  int reply = x + y;
  return reply;
}
```

В этом примере x объявляется, инициализируется и используется в отдельных строках. Кроме того, z объявлен, но никогда 
не используется, поэтому его не требуется инициализировать.

Компилятор также достаточно умен, чтобы распознавать более сложные инициализации. В этом примере есть две ветки кода:

```
public void findAnswer(boolean check) {
   int answer;
   int otherAnswer;
   int onlyOneBranch;
   if (check) {
      onlyOneBranch = 1;
      answer = 1;
   } else {
      answer = 2;
   }
   System.out.println(answer);
   System.out.println(onlyOneBranch); // DOES NOT COMPILE
}
```

Переменная ответа инициализируется в обеих ветвях оператора if, так что компилятор вполне доволен. Он знает, что 
независимо от того, является ли проверка истинной или ложной, значение ответа будет установлено в какое-либо значение 
до того, как оно будет использовано. Переменная otherAnswer не инициализируется, но никогда не используется, и 
компилятор в равной степени доволен. Помните, что компилятор беспокоится только в том случае, если вы пытаетесь 
использовать неинициализированные локальные переменные; это не возражает против тех, которые вы никогда не используете.

Переменная onlyOneBranch инициализируется, только если проверка оказывается истинной. Компилятор знает, что проверка 
может оказаться ложной, что приведет к неинициализированному коду, и выдаст ошибку компилятора. Вы узнаете больше 
об операторе if в главе 3 «Принятие решений (Making Decisions)».

---
На экзамене будьте осторожны с любой локальной переменной, которая объявлена, но не инициализирована в одной строке. 
Это обычное место на экзамене, которое может привести к ответу «Не компилируется». Перед использованием на экзамене 
убедитесь, что он инициализирован.
---

### Передача параметров конструктора и метода (Passing Constructor and Method Parameters)

Переменные, передаваемые конструктору или методу, называются параметрами конструктора или параметрами метода 
соответственно. Эти параметры похожи на локальные переменные, которые были предварительно инициализированы. 
Правила инициализации параметров конструктора и метода одинаковы, поэтому мы сосредоточимся в первую очередь на 
параметрах метода.

В предыдущем примере check является параметром метода. 

```
public void findAnswer(boolean check) {}
    Take a look at the following method checkAnswer() in the same class:
public void checkAnswer() {
  boolean value;
  findAnswer(value); // DOES NOT COMPILE
}
```

Вызов findAnswer() не компилируется, поскольку он пытается использовать неинициализированную переменную. В то время 
как вызывающая сторона метода checkAnswer() должна быть обеспокоена инициализацией переменной, оказавшись внутри 
метода findAnswer(), мы можем предположить, что локальная переменная была инициализирована некоторым значением.

### Определение переменных экземпляра и класса (Defining Instance and Class Variables)

Переменные, не являющиеся локальными переменными, определяются либо как переменные экземпляра, либо как переменные 
класса. Переменная экземпляра, часто называемая полем, представляет собой значение, определенное в конкретном 
экземпляре объекта. Допустим, у нас есть класс Person с переменной экземпляра name типа String. Каждый экземпляр 
класса будет иметь собственное значение name, например Elysia или Sarah. Два экземпляра могут иметь одинаковое 
значение name, но изменение значения для одного не изменяет другого.

С другой стороны, переменная класса — это переменная, определенная на уровне класса и совместно используемая всеми 
экземплярами класса. Он даже может быть общедоступным для классов вне класса и не требует экземпляра для использования.
В нашем предыдущем примере Person переменная общего класса могла использоваться для представления списка людей в 
зоопарке сегодня. Вы можете сказать, что переменная является переменной класса, потому что перед ней стоит ключевое 
слово static. Вы узнаете об этом в главе 5. А пока просто знайте, что переменная является переменной класса, если в её 
объявлении есть ключевое слово static.

Переменные экземпляра и класса не требуют их инициализации. Как только вы объявляете эти переменные, им присваивается 
значение по умолчанию. Компилятор не знает, какое значение использовать, и поэтому хочет самое простое значение, 
которое он может дать типу: null для объекта, 0 для числовых типов, и false для логического значения. Вам не нужно 
знать значение по умолчанию для char, но если вам интересно, это '\u0000' (NUL).

### Определение типа с помощью var (Inferring the Type with var)

У вас есть возможность использовать ключевое слово var вместо типа при объявлении локальных переменных при 
определенных условиях. Чтобы использовать эту функцию, вы просто набираете var вместо примитивного или ссылочного типа.
Вот пример: 

```
public class Zoo {
    public void whatTypeAmI() {
       var name = "Hello";
       var size = 7;
    }
}
```

Формальное название этой функции — вывод типа локальной переменной. Давайте разберем это. Сначала идет локальная 
переменная. Это означает именно то, на что это похоже. Вы можете использовать эту функцию только для локальных 
переменных. Экзамен может попытаться обмануть вас с помощью такого кода: 

```
public class VarKeyword {
    var tricky = "Hello"; // DOES NOT COMPILE
}
```

Подождите минуту! Мы только что узнали разницу между экземпляром и локальными переменными. Переменная «tricky» — это 
переменная экземпляра. Вывод типа локальной переменной работает с локальными переменными, а не с переменными 
экземпляра.

### Вывод типа var (Type Inference of var) 

Теперь, когда вы понимаете, что такое локальная переменная, пора перейти к тому, что означает вывод типа. Хорошая 
новость заключается в том, что это также означает то, на что это похоже. Когда вы вводите var, вы даёте компилятору 
указание определить тип за вас. Компилятор просматривает код в строке объявления и использует его для определения типа. 
Взгляните на этот пример:

```
7: public void reassignment() {
8:    var number = 7;
9:    number = 4;
10:   number = "five"; // DOES NOT COMPILE
11: }
```
В строке 8 компилятор определяет, что нам нужна переменная типа int. В строке 9 у нас нет проблем с присвоением ей 
другого int. В строке 10 у Java есть проблема. Мы попросили его присвоить String переменной int. Это не разрешено.
Это эквивалентно вводу этого:

```
int number = "five";
```

---
Если вы знаете такой язык, как JavaScript, вы можете ожидать, что var будет означать переменную, которая может 
принимать любой тип во время выполнения. В Java var по-прежнему является особым типом, определенным во время компиляции. 
Он не меняет тип во время выполнения.
---

Для простоты при обсуждении var мы будем предполагать, что оператор объявления переменной завершается одной строкой.
Вы можете вставить разрыв строки между именем переменной и её значением инициализации, как в следующем примере:

```
7: public void breakingDeclaration() {
8:    var silly
9:        = 1;
10: }
```

Этот пример корректен и компилируется, но мы считаем, что объявление и инициализация глупости происходят в одной строке.

### Примеры с var

Давайте рассмотрим ещё несколько сценариев, чтобы экзамен не обманул вас по этой теме! Как вы думаете, следующее 
компилируется?

```
3: public void doesThisCompile(boolean check) {
4:    var question;
5:    question = 1;
6:    var answer;
7:    if (check) {
8:        answer = 2;
9:    } else {
10:       answer = 3;
11:   }
12:   System.out.println(answer);
13: }
```

Код не компилируется. Помните, что для определения типа локальной переменной компилятор смотрит только на строку с 
объявлением. Поскольку question и answer не присваиваются значения в строках, где они определены, компилятор не знает, 
что с ними делать. По этой причине строки 4 и 6 не компилируются. Это может показаться вам странным, поскольку обе 
ветви if/else присваивают значение. Увы, он не находится в той же строке, что и объявление, поэтому не считается для 
var. Сравните это поведение с тем, что мы видели недавно, когда обсуждали ветвление и инициализацию локальной 
переменной в нашем методе findAnswer().

Теперь мы знаем, что начальное значение, используемое для определения типа, должно быть частью одного и того же 
оператора. Можете ли вы понять, почему эти два утверждения не компилируются?

```
4: public void twoTypes() {
5:    int a, var b = 3;   // DOES NOT COMPILE
6:    var n = null;       // DOES NOT COMPILE
7: }
```

Строка 5 не будет работать, даже если вы замените var реальным типом. Все типы, объявленные в одной строке, должны 
быть одного типа и иметь одно и то же объявление. Мы не могли написать int a, int v = 3; either.

6-я строка — одна. Компилятору предлагается определить тип null. Это может быть любой ссылочный тип. Единственный 
выбор, который может сделать компилятор, это Object. Однако это почти наверняка не то, что имел в виду автор кода.
Дизайнеры Java так решили было бы лучше не допускать var для null, чем угадывать намерение. 

---
Хотя var не может быть инициализирована null значением без типа, ей можно переназначить null значение 
после её объявления при условии, что базовый тип данных является ссылочным типом.
---

Давайте попробуем другой пример. Вы понимаете, почему это не компилируется? 

```
public int addition(var a, var b) {   // DOES NOT COMPILE
   return a + b;
}
```

В этом примере a и b являются параметрами метода. Это не локальные переменные. Следите за тем, чтобы переменная var 
использовалась с конструкторами, параметрами методов или переменными экземпляра. Использование var в одном из этих 
мест — хороший экзаменационный трюк, чтобы проверить, обращаете ли вы внимание. Помните, что var используется только 
для определения типа локальной переменной!

Есть одно последнее правило, о котором вы должны знать: var не является зарезервированным словом и может 
использоваться в качестве идентификатора. Это считается зарезервированным именем типа. Зарезервированное имя типа 
означает, что его нельзя использовать для определения типа, например класса, интерфейса или перечисления. Как вы 
думаете, это законно?

```
package var;

public class Var {
    public void var() {
      var var = "var";
    }
    
    public void Var() {
      Var var = new Var();
    }
}
```

Хотите верьте, хотите нет, но этот код компилируется. Java чувствителен к регистру, поэтому Var не вносит никаких 
конфликтов в качестве имени класса. Имя локальной переменной var допустимо. Пожалуйста, не пишите код, который 
выглядит так на вашей работе! Но понимание того, почему это работает, поможет вам подготовиться к любым каверзным 
экзаменационным вопросам, которые создатели экзамена могут задать вам.

---
### var в реальном мире (или на парктике)

Ключевое слово var отлично подходит для авторов экзаменов, поскольку упрощает написание сложного кода.
Когда вы работаете над реальным проектом, вы хотите, чтобы код легко читался.

Как только у вас появится код, похожий на следующий, пора подумать об использовании var: 

```
PileOfPapersToFileInFilingCabinet pileOfPapersToFile = new PileOfPapersToFileInFilingCabinet();
```

Вы можете видеть, как сокращение этого было бы улучшением без потери информации: 

```
var pileOfPapersToFile = new PileOfPapersToFileInFilingCabinet();
```

Если вы когда-либо сомневались, уместно ли использовать var, мы рекомендуем «Вывод типа локальной переменной: 
рекомендации по стилю», который доступен по следующему адресу. 
https://openjdk.org/projects/amber/guides/lvti-style-guide
--- 

## Управление областью видимости переменных

Вы узнали, что локальные переменные объявляются внутри блока кода. Сколько вы видите переменных, которые относятся к 
этому методу?

```
public void eat(int piecesOfCheese) {
   int bitesOfCheese = 1;
}
```

Есть две переменные с локальной областью видимости. Переменная bitesOfCheese объявляется внутри метода. Переменная 
pieceOfCheese является параметром метода. Ни одна из переменных не может использоваться вне того места, где она 
определена.

### Ограничение области

Локальные переменные никогда не могут иметь область действия больше, чем метод, в котором они определены. Однако они 
могут иметь меньшую область действия. Рассмотрим этот пример:

```
3: public void eatIfHungry(boolean hungry) {
4:     if (hungry) {
5:          int bitesOfCheese = 1;
6:     }   // bitesOfCheese goes out of scope here
7:     System.out.println(bitesOfCheese);   // DOES NOT COMPILE
8: }
```

Переменная hungry имеет область действия всего метода, в то время как переменная bitesOfCheese имеет меньшую область 
действия. Он доступен для использования только в операторе if, поскольку он объявлен внутри него. Когда вы видите набор 
фигурных скобок ({}) в коде, это означает, что вы ввели новый блок кода. Каждый блок кода имеет свою область видимости. 
Когда есть несколько блоков, вы сопоставляете их изнутри. В нашем случае блок оператора if начинается со строки 4 и 
заканчивается на строке 6. Блок метода начинается со строки 3 и заканчивается на строке 8.

Поскольку bitesOfCheese объявлен в блоке операторов if, область действия ограничена этим блоком. Когда компилятор 
доходит до строки 7, он жалуется, что ничего не знает об этой штуке bitesOfCheese и выдает ошибку.

Помните, что блоки могут содержать другие блоки. Эти меньшие содержащиеся блоки могут ссылаться на переменные, 
определенные в более крупных блоках области действия, но не наоборот. Вот пример:

```
16: public void eatIfHungry(boolean hungry) {
17:     if (hungry) {
18:       int bitesOfCheese = 1;
19:       {
20:           var teenyBit = true;
21:           System.out.println(bitesOfCheese);
22:        }
23:     }
24:     System.out.println(teenyBit); // DOES NOT COMPILE
25: }
```

Переменная, определенная в строке 18, находится в области действия до тех пор, пока блок не заканчивается в строке 23. 
Использование её в меньшем блоке с строк 19 по 22 допустимо. Переменная, определенная в строке 20, выходит за 
пределы области действия в строке 22. Использование её в строке 24 не допускается.

### Область трассировки

Экзамен попытается обмануть вас различными вопросами по объему. Вы, вероятно, увидите вопрос, который кажется сложным 
и не компилируется, потому что одна из переменных находится вне области действия.

Давайте попробуем один. Не волнуйтесь, если вы еще не знакомы с операторами if или циклами while.

Неважно, что делает код, поскольку мы говорим о области видимости. Посмотрите, сможете ли вы выяснить, в какой строке 
каждая из пяти локальных переменных входит в область действия и выходит из неё:

```
11: public void eatMore(boolean hungry, int amountOfFood) {
12:     int roomInBelly = 5;
13:     if (hungry) {
14:        var timeToEat = true;
15:        while (amountOfFood > 0) {
16:           int amountEaten = 2;
17:           roomInBelly = roomInBelly - amountEaten;
18:           amountOfFood = amountOfFood - amountEaten;
19:     }
20:  }
21:  System.out.println(amountOfFood);
22: }
```

Этот метод компилируется. Первым шагом в определении области видимости является определение блоков кода. В данном 
случае есть три блока. Вы можете сказать это, потому что есть три набора фигурных скобок. Начиная с самого внутреннего 
набора, мы можем видеть, где начинается и заканчивается блок цикла while. Повторяйте этот процесс по мере того, как мы 
переходим к блоку операторов if и блоку методов. В таблице 1.10 показаны номера строк, с которых начинается и 
заканчивается каждый блок.

#### Таблица 1.10 - Отслеживание объёма по блокам (Tracking scope by block)
|   Линия    | Первая строка в блоке | Последняя строка в блоке |
|:----------:|:---------------------:|:------------------------:|
|   while    |          15           |            19            |
|     if     |          13           |            20            |
|   Method   |          11           |            22            |


Теперь, когда мы знаем, где находятся блоки, мы можем посмотреть на область действия каждой переменной. hungry и
amountOfFood являются параметрами метода, поэтому они доступны для всего метода. Это означает, что их областью действия 
являются строки с 11 по 22. Переменная roomInBelly входит в область видимости в строке 12, потому что именно там 
она объявлена. Он остается в области видимости для остальной части метода и выходит из области видимости в строке 22.
Переменная timeToEat входит в область видимости в строке 14, где она объявлена. Он выходит за рамки в строке 20, где 
заканчивается блок if. Наконец, переменная amountEaten входит в область видимости в строке 16, где она объявлена. 
Он выходит за рамки в строке 19, где заканчивается блок while.

Вам очень захочется попрактиковаться в этом навыке! Идентификация блоков и области видимости переменных должна быть 
второй натурой экзамена. Хорошая новость заключается в том, что существует множество примеров кода, на которых 
можно попрактиковаться. Вы можете просмотреть любой пример кода по любой теме в этой книге и сопоставить фигурные 
скобки.

### Применение области действия к классам или Применение области видимости к классам (Applying Scope to Classes)

Все это было для локальных переменных. К счастью, правило для переменных экземпляра проще: они доступны, как только они 
определены, и действуют в течение всего времени существования самого объекта. Правило для переменных класса, также 
называемых статическими, еще проще: они попадают в область видимости при объявлении, как и другие типы переменных.
Тем не менее, они остаются в области видимости на протяжении всей жизни программы.

Давайте сделаем ещё один пример, чтобы убедиться, что вы разобрались с этим. Опять же, попробуйте выяснить тип 
четырех переменных и когда они входят в область действия и выходят из неё.

```
1: public class Mouse {
2:    final static int MAX_LENGTH = 5;
3:    int length;
4:    public void grow(int inches) {
5:        if (length < MAX_LENGTH) {
6:           int newSize = length + inches;
7:           length = newSize;
8:        }
9:    }
10: }
```

В этом классе у нас есть одна переменная класса, MAX_LENGTH; одна переменная экземпляра, длина; и две локальные 
переменные, inches и newSize. Переменная MAX_LENGTH является переменной класса, потому что в ее объявлении есть 
ключевое слово static. В этом случае MAX_LENGTH входит в область действия строки 2, где оно объявлено. Он остается в 
области видимости, пока программа не завершится.

Затем length входит в область видимости в строке 3, где она объявлена. Он остается в области до тех пор, пока 
существует этот объект Mouse. inches входит в область видимости, где она объявлена в строке 4. Он выходит за рамки в 
конце метода в строке 9. newSize входит в область видимости, где она объявлена в строке 6. Поскольку он определен 
внутри блока операторов if, он выходит из области видимости, когда этот блок заканчивается на строке 8.

### Область обзора (Reviewing Scope)

Понял все это? Давайте рассмотрим правила, касающиеся сферы применения:
+ Локальные переменные: в области видимости от объявления до конца блока
+ Параметры метода: в объеме на время действия метода
+ Переменные экземпляра: в области действия с момента объявления до тех пор, пока объект не станет пригодным для 
сборки мусора.
+ Переменные класса: в области действия от объявления до завершения программы

Не знаете, что такое сборка мусора? Расслабьтесь: это наш следующий и последний раздел этой главы.

## Уничтожение объектов (Destroying Objects)

Теперь, когда мы поиграли с нашими объектами, пришло время убрать их. К счастью, JVM позаботится об этом за вас. 
Java предоставляет сборщик мусора для автоматического поиска объектов, которые больше не нужны. Помните, что ваш 
код — не единственный процесс, работающий в вашей Java-программе. Код Java существует внутри JVM, которая включает 
в себя многочисленные процессы, независимые от кода вашего приложения. Одним из наиболее важных из них является 
встроенный сборщик мусора.

Все объекты Java хранятся в куче (heap) памяти вашей программы. Куча, также называемая свободным хранилищем, 
представляет собой большой пул неиспользуемой памяти, выделенной вашему Java-приложению. Если ваша программа продолжает 
создавать экземпляры объектов и оставлять их в куче, в конечном итоге у нее закончится память и произойдет сбой.
О, нет! К счастью, сборка мусора решает эту проблему. В следующих разделах мы рассмотрим сборку мусора.

### Понимание сборки мусора (Understanding Garbage Collection)

Сборка мусора относится к процессу автоматического освобождения памяти в куче путем удаления объектов, которые больше 
не доступны в вашей программе. Существует множество различных алгоритмов сборки мусора, но вам не нужно знать ни один 
из них для экзамена.

Как разработчик, наиболее интересной частью сборки мусора является определение того, когда память, принадлежащая 
объекту, может быть освобождена. В Java и других языках право на сборку мусора относится к состоянию объекта, когда 
он больше не доступен в программе и, следовательно, не может быть удален сборщиком мусора.

Означает ли это, что объект, подходящий для сборки мусора, будет немедленно удален сборщиком мусора? Точно нет. 
Когда объект на самом деле отбрасывается, это не находится под вашим контролем, но для экзамена вам нужно будет 
знать в любой момент, какие объекты имеют право на сборку мусора.

Думайте о праве на сборку мусора, как об отправке посылки. Вы можете взять предмет, запечатать его в маркированной 
коробке и положить в почтовый ящик. Это аналогично тому, чтобы сделать элемент пригодным для сборки мусора.
Однако, когда почтальон приходит, чтобы забрать его, это не в вашей власти. Например, это может быть праздничный день 
или суровое погодное явление. Вы даже можете позвонить на почту и попросить их забрать его прямо сейчас, но нет 
никакой гарантии, когда и произойдет ли это на самом деле. Надеюсь, они придут раньше, чем ваш почтовый ящик 
заполнится посылками!

Java включает встроенный метод для поддержки сборки мусора, где вы можете предложить запустить сборку мусора.

```
System.gc();
```

Как и почтовое отделение, Java может игнорировать вас. Этот метод ничего не гарантирует.

### Отслеживание права (Tracing Eligibility)

Как JVM узнает, когда объект подходит для сборки мусора? JVM терпеливо ждет и отслеживает каждый объект, пока не 
определит, что код больше не нуждается в этой памяти. Объект будет оставаться в куче до тех пор, пока он не 
станет недоступным. Объект перестает быть доступным, когда возникает одна из двух ситуаций:
+ Объект больше не имеет ссылок, указывающих на него.
+ Все ссылки на объект вышли за область видимости.

---
#### Объекты против ссылок (Objects vs. References)

Не путайте ссылку с объектом, на который она ссылается; это две разные сущности. Ссылка — это переменная, которая 
имеет имя и может использоваться для доступа к содержимому объекта. Ссылка может быть назначена другой ссылке, 
передана в метод или возвращена из метода. Все ссылки имеют одинаковый размер, независимо от их типа.

Объект находится в куче и не имеет имени. Следовательно, у вас нет другого способа получить доступ к объекту, кроме 
как через ссылку. Объекты бывают разных форм и размеров и потребляют разное количество памяти. Объект не может 
быть назначен другому объекту, и объект не может быть передан методу или возвращен из метода. Это объект, который 
собирает мусор, а не его ссылка.

![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/chapter%201/image%201/figure%20obj-ref.JPG)

---

Понимание разницы между ссылкой и объектом имеет большое значение для понимания сборки мусора, оператора new и 
многих других аспектов языка Java. Посмотрите на этот код и посмотрите, сможете ли вы выяснить, когда каждый объект 
впервые становится пригодным для сборки мусора:

```
1: public class Scope {
2:    public static void main(String[] args) {
3:       String one, two;
4:       one = new String("a");
5:       two = new String("b");
6:       one = two;
7:       String three = one;
8:       one = null;
9:  } }
```

Когда вам задают вопрос о сборе мусора на экзамене, рекомендуем нарисовать, что происходит. У вас в голове есть за 
чем уследить, и легко сделать глупую ошибку, пытаясь удержать все это в памяти. Давайте попробуем вместе сейчас. 
Действительно. Возьмите карандаш и бумагу. Мы подождем.

Получил эту бумагу? Хорошо, давайте начнем. В строке 3 напишите один и два (просто слова — не нужно ни прямоугольников, 
ни стрелок, поскольку в куче еще нет объектов). В строке 4 у нас есть наш первый объект. Нарисуйте прямоугольник со 
строкой «а» в нем и проведите стрелку от слова «один» к этому прямоугольнику. Строка 5 аналогична. На этот раз 
нарисуйте еще одну рамку со строкой «b» и стрелкой от слова «два». На этом этапе ваша работа должна выглядеть так, 
как показано на рис. 1.4.

#### Рис. 1.4 - Ваш рисунок после строки 5
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/chapter%201/image%201/figure%201.4.JPG)

В строке 6 переменная one изменяется и указывает на «b». Либо сотрите, либо зачеркните стрелку от **"единицы"** и нарисуйте 
новую стрелку от **"единицы"** до «b». В строке 7 у нас есть новая переменная, поэтому напишите слово «три» и 
нарисуйте стрелку от «три» до «b». Обратите внимание, что три указывают на то, на что человек указывает прямо сейчас, 
а не на то, на что он указывал в начале. Вот почему вы рисуете картинки. Такое легко забыть. На этом этапе ваша работа 
должна выглядеть так, как показано на рис. 1.5.

Наконец, вычеркните строку между единицей и «b», так как в строке 8 эта переменная устанавливается равной нулю.
Теперь мы пытались выяснить, когда объекты впервые стали подходящими для сборки мусора. В строке 6 мы избавились от 
единственной стрелки, указывающей на «а», что сделало этот объект подходящим для сборки мусора. "b" имеет стрелки, 
указывающие на него, пока он не выйдет за рамки. Это означает, что «b» не выходит из области видимости до конца 
метода в строке 9.

#### Рис. 1.5 - Ваш рисунок после строки 7
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/chapter%201/image%201/figure%201.5.JPG)

---
### Форматирование кода на экзамене (Code Formatting on the Exam)

Не все вопросы будут включать декларации пакетов и импорт. Не беспокойтесь об отсутствующих операторах пакетов или 
импортах, если вас об этом не спросят. Ниже приведены распространенные случаи, когда вам не нужно проверять импорт:

+ Код, начинающийся с имени класса
+ Код, начинающийся с объявления метода
+ Код, который начинается с фрагмента кода, который обычно находится внутри класса или метода
+ Код, в котором номера строк не начинаются с 1

Вы увидите код, у которого нет метода. Когда это происходит, предположим, что весь необходимый вспомогательный код, 
такой как метод main() и определение класса, написан правильно. Вас просто спрашивают, компилируется ли показанная 
вам часть кода, когда она помещается в действительный окружающий код. Наконец, помните, что дополнительные пробелы 
не имеют значения в синтаксисе Java. Экзамен может использовать различное количество пробелов, чтобы обмануть вас.

## Резюме (Summary)

Java начинает выполнение программы с метода main(). Наиболее распространенная сигнатура для этого метода, запускаемого 
из командной строки: public static void main(String[] args). Аргументы передаются после имени класса, как в java 
NameOfClass firstArgument. Аргументы индексируются, начиная с 0. 

Код Java организован в папки, называемые пакетами. Чтобы ссылаться на классы в других пакетах, вы используете оператор 
импорта (import). Подстановочный знак, заканчивающийся оператором импорта, означает, что вы хотите импортировать все 
классы в этом пакете. Он не включает пакеты, которые находятся внутри этого. Пакет java.lang уникален тем, что его не 
нужно импортировать.

Для некоторых элементов класса важен порядок в файле. Оператор package идет первым, если он присутствует. Затем идут 
операторы импорта, если они есть. Затем следует объявление класса. Поля и методы могут находиться в любом порядке 
внутри класса.

Примитивные типы являются основными строительными блоками типов Java. Они собраны в ссылочные типы. Ссылочные типы 
могут иметь методы, которым может быть присвоено null (нулевое) значение. Числовые литералы могут содержать символы 
подчеркивания (_), если они не начинают и не заканчивают литерал и не стоят рядом с десятичной точкой (.). 
Классы-оболочки являются ссылочными типами и существуют по одному для каждого примитива. Текстовые блоки позволяют 
создавать String на нескольких строках, используя " " ". 

Объявление переменной включает указание типа данных и присвоение переменной имени. Переменные, представляющие поля в 
классе, автоматически инициализируются соответствующими значениями 0, null или false во время создания экземпляра 
объекта. Локальные переменные должны быть специально инициализированы, прежде чем их можно будет использовать. 
Идентификаторы могут содержать буквы, цифры, символы валюты или _. Идентификаторы не могут начинаться с цифр.
Объявления локальных переменных могут использовать ключевое слово var вместо фактического типа. При использовании var 
тип устанавливается один раз во время компиляции и не меняется.

Область действия относится к той части кода, где можно получить доступ к переменной. В Java есть три типа переменных, 
в зависимости от области их действия: переменные экземпляра, переменные класса и локальные переменные. Переменные 
экземпляра — это нестатические поля вашего класса. Переменные класса — это статические поля внутри класса. Локальные 
переменные объявляются внутри конструктора, метода или блока инициализатора.

Конструкторы создают объекты Java. Конструктор — это метод, соответствующий имени класса и опускающий возвращаемый тип.
При создании экземпляра объекта сначала инициализируются поля и блоки кода. Затем запускается конструктор. Наконец, 
сборка мусора отвечает за удаление объектов из памяти, когда они больше не могут быть использованы. Объект становится 
пригодным для сборки мусора, когда на него больше нет ссылок или все его ссылки вышли за пределы области видимости.

## Основы экзамена (Exam Essentials)

Уметь писать код, используя метод main(). Метод main() обычно записывается как public static void main(String[] args).
Ссылки на аргументы начинаются с args[0]. Доступ к аргументу, который не был передан, приведет к тому, что код выдаст 
исключение. 

Поймите эффект от использования пакетов и импорта. Пакеты содержат классы Java. Классы можно импортировать по имени 
класса или подстановочному знаку. Подстановочные знаки не смотрят на подкаталоги. В случае конфликта импорт имени 
класса имеет приоритет. Операторы Package и Import необязательны. Если они присутствуют, они оба идут перед объявлением 
класса в указанном порядке.

Уметь распознавать конструктор. Конструктор имеет то же имя, что и класс. Это выглядит как метод без возвращаемого типа.

Уметь определять законные и незаконные декларации и инициализацию. Несколько переменных могут быть объявлены и 
инициализированы в одном операторе, если они имеют общий тип. Локальные переменные требуют явной инициализации; 
другие используют значение по умолчанию для этого типа. Идентификаторы могут содержать буквы, цифры, символы валюты 
или _, хотя они не могут начинаться с цифр. Кроме того, вы не можете определить идентификатор, состоящий из одного 
символа _ подчеркивания. (Числовые литералы могут содержать символы подчеркивания между двумя цифрами, например 1_000, 
но не в других местах, например  _100_.0_.) 

Поймите, как создавать текстовые блоки. Текстовый блок начинается с " " " в первой строке. На следующей строке 
начинается содержимое. Последняя строка заканчивается на " " ". Если " " " находится на отдельной строке, включается 
конечный разрыв строки.

Уметь правильно использовать var. Var используется для локальной переменной. Переменная инициализируется в той же 
строке, где она объявлена, и, хотя она может изменить значение, она не может изменить тип. Переменная не может быть 
инициализирована нулевым значением без типа, а также не может использоваться в объявлениях нескольких переменных.

Уметь определять, где переменные входят в область видимости и выходят из нее. Все переменные попадают в область 
видимости, когда они объявлены. Локальные переменные выходят из области видимости, когда заканчивается блок, в котором 
они объявлены. Переменные экземпляра выходят за пределы области видимости, когда объект подходит для сборки мусора.
Переменные класса остаются в области видимости, пока программа работает. 

Знайте, как определить, когда объект подходит для сборки мусора. Нарисуйте диаграмму, чтобы отслеживать ссылки и 
объекты по мере отслеживания кода. Когда стрелки не указывают на ящик (объект), он подходит для сборки мусора.

## Review Questions


