# Потоки

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Работа с потоками и лямбда-выражениями

+ Используйте объекты Java и примитивные потоки, включая лямбда-выражения, реализующие функциональные интерфейсы, для 
предоставления, фильтрации, сопоставления, потребления и сортировки данных
+ Выполнение декомпозиции, конкатенации и сокращения, а также группировки и секционирования в последовательных и 
параллельных потоках

---

К настоящему времени вы должны понимать синтаксис лямбда-выражения и ссылки на методы. Оба они используются при 
реализации функциональных интерфейсов. Если вам нужно больше практики, возможно, вы захотите вернуться назад и 
просмотреть главу 8 "Лямбды и функциональные интерфейсы" и главу 9 "Коллекции и дженерики". В этой главе мы добавим к 
этому собственно функциональное программирование, сосредоточив внимание на Streams API.

Обратите внимание, что Streams API  в этой главе используется для функционального программирования. Напротив, существуют 
также потоки java.io, о которых мы поговорим в главе 14 «Ввод-вывод». Несмотря на то, что оба используют слово 
«поток(stream)», они не похожи друг на друга.

В этой главе мы представляем Optional. Затем мы вводим конвейер Stream и связываем все это вместе. Возможно, вам 
захочется прочитать эту главу дважды, прежде чем отвечать на контрольные вопросы, чтобы вы действительно поняли суть. 
Функциональное программирование, как правило, требует сложного обучения, но может оказаться очень увлекательным, как 
только вы освоите его.

## Возврат Optional

Предположим, вы посещаете вводный курс Java и получаете 90 и 100 баллов на первых двух экзаменах. Теперь мы спрашиваем 
вас, каков ваш средний показатель. Среднее значение рассчитывается путем сложения баллов и деления на количество баллов, 
что дает (90+100)/2. Это дает 190/2, поэтому вы отвечаете 95. Отлично!

Теперь предположим, что вы посещаете второй урок по Java, и это первый день занятий. Мы спрашиваем вас, какой у вас 
средний балл в этом классе, который только начался. Вы еще не сдавали экзамены, поэтому вам нечего сдавать в среднем. 
Было бы неверно сказать, что ваше среднее значение равно нулю. Это звучит плохо и неправда. Данных просто нет, поэтому 
у вас нет среднего значения.

Как нам выразить этот ответ «мы не знаем» или «неприменимо» на Java? Мы используем тип Optional. Optional создается с 
использованием фабрики. Вы можете либо запросить пустой Optional параметр, либо передать значение для Optional параметра 
для переноса. Думайте о Optional как о поле, в котором может что-то находиться, или же оно может быть пустым. На 
рисунке 10.1 показаны оба варианта.

#### Рис. 10.1 - Optional


### Создание Optional

Вот как запрограммировать наш метод average:

```
10: public static Optional<Double> average(int... scores) { 
11:    if (scores.length == 0) return Optional.empty(); 
12:    int sum = 0; 
13:    for (int score: scores) sum += score; 
14:    return Optional.of((double) sum / scores.length); 
15: }
```

Строка 11 возвращает пустой Optional параметр, если мы не можем вычислить среднее значение. В строках 12 и 13 
суммируются баллы. Существует способ выполнения этих математических вычислений с помощью функционального 
программирования, но мы вернемся к этому позже в этой главе. На самом деле, весь метод можно было бы записать в одну 
строку, но это не научит вас тому, как работает Optional! В строке 14 создается Optional параметр для переноса среднего
значения.

Вызов метода показывает, что находится в наших двух полях:

```
System.out.println(average(90, 100)); // Optional[95.0]
System.out.println(average());        // Optional.empty
```

Вы можете видеть, что один Optional параметр содержит значение, а другой пуст. Обычно мы хотим проверить, есть ли 
значение, и/или получить его из коробки. Вот один из способов сделать это:

```
Optional<Double> opt = average(90, 100);
if (opt.isPresent())
   System.out.println(opt.get());  // 95.0
```

Сначала мы проверяем, содержит ли Optional параметр значение. Затем мы распечатываем его. Что, если мы не выполнили 
проверку, и Optional параметр был пуст?

```
Optional<Double> opt = average();
System.out.println(opt.get()); // NoSuchElementException
```

Мы получим исключение, поскольку внутри Optional значения нет.

```
java.util.NoSuchElementException: No value present
```

При создании Optional обычно требуется использовать empty(), когда значение равно null. Вы можете сделать это с помощью 
оператора if или тернарного оператора. Мы используем тернарный оператор (? :) для упрощения кода, который вы видели в 
главе 2 “Операторы”.

```
Optional o = (value == null) ? Optional.empty() : Optional.of(value);
```

Если value равно null, o присваивается пустое Optional значение. В противном случае мы переносим значение. Поскольку это 
очень распространенный шаблон, Java предоставляет фабричный метод, позволяющий сделать то же самое.

```
Optional o = Optional.ofNullable(value);
```

Это охватывает static методы, которых вам нужно знать о Optional. В таблице 10.1 обобщено большинство методов 
экземпляра на Optional, которые вам необходимо знать для экзамена. Есть несколько других, которые связаны с цепочкой. 
Мы рассмотрим их позже в этой главе.

#### Таблица 10.1 - Общие Optional методы экземпляра

|          Метод           |              Когда Optional пуст               | Когда Optional содержит значение |  
|:------------------------:|:----------------------------------------------:|:--------------------------------:|
|          get()           |             Генерирует исключение              |       Возвращает значение        |
|  ifPresent(Consumer c)   |                Ничего не делает                |  Вызывает Consumer со значением  |
|       isPresent()        |                Возвращает false                |         Возвращает true          |
|     orElse(T other)      |           Возвращает other параметр            |       Возвращает значение        |
|  orElseGet(Supplier s)   |      Возвращает результат вызова Supplier      |       Возвращает значение        |
|      orElseThrow()       |       Выбрасывает NoSuchElementException       |       Возвращает значение        |
| orElseThrow(Supplier s)  | Выдает исключение, созданное вызовом Supplier  |       Возвращает значение        |

Вы уже видели get() и isPresent(). Другие методы позволяют вам писать код, использующий Optional параметр в одной 
строке, без необходимости использования тернарного оператора. Это облегчает чтение кода. Вместо использования оператора 
if, который мы использовали ранее при проверке среднего значения, мы можем указать Consumer, который будет запускаться, 
когда внутри Optional есть значение. Если его нет, метод просто пропускает запуск Consumer.

```
Optional<Double> opt = average(90, 100); 
opt.ifPresent(System.out::println);
```

Использование ifPresent() лучше выражает наше намерение. Мы хотим, чтобы что-то было сделано, если значение 
присутствует. Вы можете думать об этом как об операторе if без else.

### Работа с пустым Optional

Остальные методы позволяют указать, что делать, если значение отсутствует. Есть несколько вариантов. Первые два 
позволяют указать возвращаемое значение напрямую или с помощью Supplier.

```
30: Optional<Double> opt = average(); 
31: System.out.println(opt.orElse(Double.NaN)); 
32: System.out.println(opt.orElseGet(() -> Math.random()));
```

Это напечатает примерно следующее:

```
NaN 
0.49775932295380165
```

В строке 31 показано, что вы можете вернуть определенное значение или переменную. В нашем случае мы печатаем значение 
«not a number». В строке 32 показано использование Supplier для генерации значения во время выполнения для возврата. 
Однако я рад, что наши профессора не дали нам случайное среднее значение!

В качестве альтернативы мы можем заставить код генерировать исключение, если Optional параметр пуст.

```
30: Optional<Double> opt = average(); 
31: System.out.println(opt.orElseThrow());
```

Это напечатает примерно следующее:

```
Exception in thread "main" java.util.NoSuchElementException:
  No value present
  at java.base/java.util.Optional.orElseThrow(Optional.java:382)
```

Без указания Supplier для исключения, Java выдаст исключение NoSuchElementException. В качестве альтернативы мы можем 
заставить код генерировать собственное исключение, если Optional параметр пуст. Помните, что трассировка стека выглядит 
странно, поскольку генерируются лямбда-выражения, а не именованные классы.

```
30: Optional<Double> opt = average();
31: System.out.println(opt.orElseThrow(
32:    () -> new IllegalStateException()));
```

Это напечатает примерно следующее:

```
Exception in thread "main" java.lang.IllegalStateException
  at optionals.Methods.lambda$orElse$1(Methods.java:31)
  at java.base/java.util.Optional.orElseThrow(Optional.java:408)
```

В строке 32 показано использование Supplier для создания исключения, которое должно быть выброшено. Обратите внимание: 
мы не пишем throw new IllegalStateException(). Метод orElseThrow() фактически генерирует исключение при его запуске.

Два метода, использующие Supplier, имеют разные имена. Вы понимаете, почему этот код не компилируется?

```
System.out.println(opt.orElseGet(
   () -> new IllegalStateException())); // НЕ КОМПИЛИРУЕТСЯ
```

Переменная opt является Optional<Double>. Это означает, что Supplier должен вернуть Double. Поскольку этот Supplier 
возвращает исключение, тип не соответствует.

Последний пример с Optional действительно прост. Как вы думаете, что это дает?

```
Optional<Double> opt = average(90, 100);
System.out.println(opt.orElse(Double.NaN));
System.out.println(opt.orElseGet(() -> Math.random()));
System.out.println(opt.orElseThrow());
```

Он печатает 95.0 три раза. Поскольку значение существует, нет необходимости использовать логику «или иначе».

**Является ли optional таким же, как null?**

Альтернативой Optional является возврат значения null. У этого подхода есть несколько недостатков. Во-первых, не 
существует четкого способа выразить, что значение null может быть особым значением. Напротив, возврат Optional 
значения — это четкое заявление в API о том, что значения может не быть.

Еще одним преимуществом Optional является то, что вы можете использовать стиль функционального программирования с 
ifPresent() и другими методами вместо использования оператора if. Наконец, ближе к концу главы вы увидите, что можно 
объединять Optional вызовы.

## Использование потоков

Поток в Java — это последовательность данных. Потоковый конвейер состоит из операций, которые выполняются над потоком 
для получения результата. Во-первых, мы концептуально рассмотрим поток трубопроводов. После этого переходим к коду.

### Понимание потока трубопровода

Подумайте о потоке трубопровода как о сборочной линии на заводе. Предположим, мы запускаем сборочную линию по 
изготовлению вывесок для выставок животных в зоопарке. У нас есть ряд вакансий. Вынимать таблички из коробки — задача 
одного человека. Нарисовать вывеску — это работа второго человека. Нанести название животного на табличку по 
трафарету — задача третьего человека. Задача последнего человека — положить готовый знак в коробку и отнести к 
соответствующей выставке.

Обратите внимание, что второй человек не может ничего сделать, пока первый человек не вытащит из коробки один знак. 
Точно так же третий человек не может ничего сделать, пока не будет нарисован один знак, а последний человек не может 
ничего сделать, пока он не будет нарисован по трафарету.

Конвейер по изготовлению знаков конечен. Как только мы обработаем содержимое нашей коробки со знаками, все будет готово. 
Конечные потоки имеют предел. Другие сборочные линии, например, по производству продуктов питания, работают вечно. 
Конечно, в какой-то момент, когда завод закрывается, они останавливаются, но сделайте вид, что этого не происходит. Или 
представьте, что цикл восхода и захода солнца бесконечен, поскольку он не заканчивается в течение чрезмерно большого 
периода времени.

Еще одна важная особенность сборочной линии заключается в том, что каждый человек прикасается к каждому элементу, чтобы 
выполнить свою операцию, а затем этот фрагмент данных исчезает. Оно не возвращается. В этот момент этим занимается 
следующий человек. Это отличается от списков и очередей, которые вы видели в предыдущей главе. С помощью списка вы 
можете получить доступ к любому элементу в любое время. В очереди вы ограничены в том, к каким элементам вы можете 
получить доступ, но все элементы присутствуют. При использовании потоков данные не генерируются заранее — они создаются 
при необходимости. Это пример ленивой оценки, при которой выполнение откладывается до тех пор, пока это не станет 
необходимым.

По пути на станциях сборочной линии может произойти многое. В функциональном программировании это называется потоковыми 
операциями. Как и на сборочной линии, операции происходят в конвейере. Кто-то должен начинать и заканчивать работу, а 
между ними может быть любое количество станций. Ведь работа одного человека – это не конвейер! Потоковый конвейер 
состоит из трех частей, как показано на рисунке 10.2.

+ Source: Откуда берется поток.
+ Intermediate operations: Преобразует поток в другой. Промежуточных операций может быть столько, сколько захотите. 
Поскольку в потоках используется отложенная оценка, промежуточные операции не выполняются до тех пор, пока не запустится 
терминальная операция.
+ Terminal operation: Выдаёт результат. Поскольку потоки можно использовать только один раз, после завершения 
терминальной операции поток становится недействительным.

#### Рис. 10.2 - Потоковый конвейер


Обратите внимание, что операции нам неизвестны. Глядя на сборочную линию снаружи, вас волнует только то, что входит и 
выходит. То, что происходит между ними, является деталью реализации.

Вам нужно будет хорошо знать различия между промежуточными и терминальными операциями. Убедитесь, что вы можете 
заполнить таблицу 10.2.

#### Таблица 10.2 - Промежуточные операции по сравнению с терминальными

|                     Сценарий                     | Промежуточная операция | Терминальная операция |  
|:------------------------------------------------:|:----------------------:|:---------------------:|
|      Необходимая часть полезного конвейера?      |          Нет           |          Да           |
| Может ли существовать несколько раз в конвейере? |           Да           |          Нет          |
|   Тип возвращаемого значения — это тип потока?   |           Да           |          Нет          |
|          Выполняется при вызове метода?          |          Нет           |          Да           |
|     Трансляция действительна после звонка?       |           Да           |          Нет          |

На заводе обычно есть бригадир, который наблюдает за работой. Java играет ведущую роль при работе с потоковыми 
конвейерами. Это действительно важная роль, особенно когда речь идет о ленивых вычислениях и бесконечных потоках. 
Думайте об объявлении потока как о передаче инструкций руководителю. Как только бригадир узнает, что нужно сделать, он 
расставляет посты и сообщает рабочим, каковы будут их обязанности. Однако рабочие не приступают к работе до тех пор, 
пока бригадир не прикажет им начать. Бригадир ждет, пока не увидит работу терминала, чтобы приступить к работе. Они 
также следят за работой и останавливают линию, как только работа завершена.

Давайте посмотрим на несколько примеров этого. В этих примерах мы не используем код, потому что очень важно понять 
концепцию потокового конвейера, прежде чем начинать писать код. На рисунке 10.3 показан потоковый конвейер с одной 
промежуточной операцией.

#### Рис. 10.3 - Шаги по запуску потокового конвейера


Давайте посмотрим на то, что происходит с точки зрения руководителя. Во-первых, они видят, что источник извлекает 
знаки из коробки. Мастер усаживает работника за стол, чтобы тот распаковал коробку, и говорит ждать сигнала к началу. 
Затем мастер видит промежуточную операцию по раскрашиванию вывески. Они подставляют рабочего с краской и говорят ждать 
сигнала к началу. Наконец, бригадир видит операцию терминала по складыванию знаков в стопку. Они поручают это одному 
работнику и кричат, что все три работника должны начать.

Предположим, что в поле есть два знака. Шаг 1 - первый работник достает один знак из коробки и передает его второму 
работнику. Шаг 2 - второй рабочий красит его и передает третьему рабочему. Шаг 3 - это когда третий рабочий кладет его в
стопку. Шаги 4-6 - это тот же процесс для другого знака. Затем бригадир видит, что никаких вывесок не осталось, и 
закрывает все предприятие.

Бригадир умен и может принимать решения о том, как наилучшим образом выполнить работу, исходя из того, что необходимо. 
В качестве примера давайте рассмотрим потоковый конвейер на рис. 10.4.

#### Рис. 10.4 - Потоковый конвейер с ограничением


Руководитель по-прежнему видит источник получения знаков из коробки и назначает работника делать это по команде. Они 
по-прежнему видят промежуточную операцию по покраске и назначают другого работника с инструкциями подождать, а затем 
покрасить. Затем они видят промежуточный шаг, на котором нам нужны всего два знака. Они поручают рабочему подсчитывать 
проходящие мимо знаки и уведомлять бригадира, когда рабочий увидит два. Наконец, они назначили работника для работы с 
терминалом, который должен был сложить таблички в стопку.

На этот раз предположим, что в поле есть 10 знаков. Мы начнем, как в прошлый раз. Первый сигнал проходит по конвейеру. 
Второй знак также проходит свой путь по трубопроводу. Когда работник, ответственный за подсчет, видит второй знак, он 
сообщает об этом бригадиру. Бригадир позволяет оператору терминала завершить свою задачу, а затем кричит: “Остановите 
линию”. Не имеет значения, что в коробке есть еще восемь знаков. Они нам не нужны, так что раскрашивать их было бы 
ненужной работой. И мы все хотим избежать ненужной работы!

Точно так же бригадир остановил бы линию после первого знака, если бы операция терминала должна была найти первый 
созданный знак.

В следующих разделах мы рассмотрим три части конвейера. Мы также обсуждаем специальные типы потоков для примитивов и 
способы печати потока.

### Создание источников потока

В Java потоки, о которых мы говорили, представлены интерфейсом Stream<T>, определенным в пакете java.util.stream.

### Создание конечных потоков

Для простоты начнём с конечных потоков. Есть несколько способов их создания.

```
11: Stream<String> empty = Stream.empty();          // count = 0
12: Stream<Integer> singleElement = Stream.of(1);   // count = 1
13: Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 3
```

В строке 11 показано, как создать пустой поток. В строке 12 показано, как создать поток с одним элементом. В строке 13 
показано, как создать поток из аргумента varargs.

Java также предоставляет удобный способ преобразования Collection в поток.

```
14: var list = List.of("a", "b", "c");
15: Stream<String> fromList = list.stream();
```

В строке 15 показано, что это простой вызов метода для создания потока из списка. Это полезно, поскольку такие
преобразования являются обычным явлением.

**Создание параллельного потока**

Так же легко создать параллельный поток из списка.

```
24: var list = List.of("a", "b", "c"); 
25: Stream<String> fromListParallel = list.parallelStream();
```

Это замечательная функция, поскольку вы можете писать код, использующий параллелизм, даже не узнав, что такое поток. 
Использование параллельных потоков похоже на создание нескольких таблиц рабочих процессов, которые могут выполнять одну 
и ту же задачу. Рисование было бы намного быстрее, если бы у нас было пять художников, рисующих вывески, а не один. 
Просто имейте в виду, что некоторые задачи нельзя выполнять параллельно, например, размещать знаки в том порядке, в 
котором они были созданы в потоке. Также имейте в виду, что координация работы требует затрат, поэтому для 
небольших потоков может быть быстрее выполнять ее последовательно. Подробную информацию о одновременном выполнении 
задач вы узнаете в главе 13 «Параллелизм».

### Создание бесконечных потоков

Пока это не особо впечатляет. Мы могли бы сделать все это с помощью списков. Однако мы не можем создать 
бесконечный список, это делает потоки более мощными.

```
17: Stream<Double> randoms = Stream.generate(Math::random);
18: Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2);
```

Строка 17 генерирует поток случайных чисел. Сколько случайных чисел? Сколько бы вам ни потребовалось. Если вы вызовете 
randoms.forEach(System.out::println), программа будет печатать случайные числа, пока вы ее не уничтожите. Далее в этой 
главе вы узнаете о таких операциях, как limit(), позволяющих превратить бесконечный поток в конечный поток.

Строка 18 дает вам больше контроля. Метод iterate() принимает начальное значение в качестве первого параметра. Это 
первый элемент, который будет частью потока. Другой параметр - это лямбда-выражение, которому передается предыдущее 
значение и генерируется следующее значение. Как и в примере со случайными числами, он будет продолжать выдавать 
нечетные числа до тех пор, пока они вам понадобятся.

**Печать ссылки на поток**

Если вы попытаетесь вызвать System.out.print(stream), вы получите что-то вроде следующего:

```
java.util.stream.ReferencePipeline$3@4517d9a3
```

Это отличается от Collection, где вы видите содержимое. Для сдачи экзамена это знать не обязательно. Мы упоминаем об 
этом, чтобы вы не были застигнуты врасплох при написании кода для практики.

---

Что, если вам нужны просто нечетные числа меньше 100? Существует перегруженная версия iterate(), которая помогает:

```
19: Stream<Integer> oddNumberUnder100 = Stream.iterate(
20:    1,                // seed
21:    n -> n < 100,     // Predicate, указывающий, когда будет выполнено
22:    n -> n + 2);      // Унарный оператор для получения следующего значения
```

Этот метод принимает три параметра. Обратите внимание, как они разделяются запятыми (,), как и во всех других методах. 
Экзамен может попытаться обмануть вас, используя точки с запятой, поскольку это похоже на цикл for. Как и в случае с 
циклом for, вы должны позаботиться о том, чтобы случайно не создать бесконечный поток.

### Обзор методов создания потоков

Для ознакомления убедитесь, что вы знакомы со всеми методами, приведенными в таблице 10.3. Это способы создания 
источника для потоков с учетом экземпляра коллекции coll.

#### Таблица 10.3 - Создание источника

|                      Метод                      | Конечный или бесконечный? |                                                                                                 Примечания                                                                                                  |  
|:-----------------------------------------------:|:-------------------------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|                 Stream.empty()                  |         Конечный          |                                                                                    Создает stream с нулевыми элементами.                                                                                    |
|               Stream.of(varargs)                |         Конечный          |                                                                                    Создает stream со списком элементов.                                                                                     |
|                  coll.stream()                  |         Конечный          |                                                                                         Создает поток из коллекции.                                                                                         |
|              coll.parallelStream()              |         Конечный          |                                                                    Создает поток из коллекции, где поток может выполняться параллельно.                                                                     |
|           Stream. generate(supplier)            |        Бесконечный        |                                                                      Создает поток, вызывая supplier для каждого элемента по запросу.                                                                       |
|       Stream.iterate(seed, unaryOperator)       |        Бесконечный        |                              Создает поток, используя начальное значение для первого элемента, а затем вызывая унарный оператор для каждого последующего элемента по запросу.                               |
| Stream.iterate(seed, predicate, unaryOperator)  | Конечный или бесконечный  | Создает поток, используя начальное значение для первого элемента, а затем вызывая унарный оператор для каждого последующего элемента по запросу. Останавливается, если Predicate возвращает значение false. |

### Использование общих операций терминала

Вы можете выполнить терминальную операцию без каких-либо промежуточных операций, но не наоборот. Вот почему в первую 
очередь мы говорим о терминальных операциях. Сокращение — это особый тип терминальной операции, при котором все 
содержимое потока объединяется в один примитив или объект. Например, у вас может быть int или Collection.

В таблице 10.4 обобщена информация по этому разделу. Не стесняйтесь использовать его в качестве руководства, чтобы 
запомнить наиболее важные моменты, когда мы будем рассматривать каждый из них индивидуально. Мы объясняем их от простого 
к самому сложному, а не в алфавитном порядке.

#### Таблица 10.4 - Терминальные потоковые операции

|                     Метод                     | Что происходит с бесконечными потоками | Возвращаемое значение | Сокращение |  
|:---------------------------------------------:|:--------------------------------------:|:---------------------:|:----------:|
|                    count()                    |            Не прекращается             |         long          |     Да     |
|               min() <br/> max()               |            Не прекращается             |      Optional<T>      |     Да     |
|          findAny() <br/> findFirst()          |              Прекращается              |      Optional<T>      |    Нет     |
| allMatch() <br/> anyMatch() <br/> noneMatch() |          Иногда прекращается           |        boolean        |    Нет     |
|                   forEach()                   |            Не прекращается             |         void          |    Нет     |
|                   reduce()                    |            Не прекращается             |      Варьируется      |     Да     |
|                   collect()                   |            Не прекращается             |     Варьируется       |     Да     |

### Подсчет

Метод count() определяет количество элементов в конечном потоке. Для бесконечного потока он никогда не заканчивается. 
Почему? Посчитайте от 1 до бесконечности и дайте нам знать, когда закончите. Вернее, не делайте этого, потому что мы бы 
предпочли, чтобы вы готовились к экзамену, чем провели остаток жизни за счетами. Метод count() является сокращением, 
поскольку он просматривает каждый элемент в потоке и возвращает одно значение. Сигнатура метода следующая:

```
public long count()
```

В этом примере показан вызов count() для конечного потока:

```
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
System.out.println(s.count());   // 3
```

### Нахождение минимума и максимума

Методы min() и max() позволяют вам передать собственный компаратор и найти наименьшее или наибольшее значение в конечном
потоке в соответствии с этим порядком сортировки. Как и метод count(), min() и max() зависают в бесконечном потоке, 
поскольку не могут быть уверены, что меньшее или большее значение не появится позже в потоке. Оба метода являются 
сокращениями, поскольку после просмотра всего потока они возвращают одно значение. Сигнатуры метода следующие:

```
public Optional<T> min(Comparator<? super T> comparator)
public Optional<T> max(Comparator<? super T> comparator)
```

В этом примере находится животное с наименьшим количеством букв в имени:

```
Stream<String> s = Stream.of("monkey", "ape", "bonobo");
Optional<String> min = s.min((s1, s2) -> s1.length()-s2.length());
min.ifPresent(System.out::println); // ape
```

Обратите внимание, что код возвращает Optional параметр, а не значение. Это позволяет методу указать, что минимум или 
максимум не был найден. Мы используем Optional метод ifPresent() и ссылку на метод, чтобы распечатать минимум, только 
если он найден. В качестве примера того, где нет минимума, давайте рассмотрим пустой поток:

```
Optional<?> minEmpty = Stream.empty().min((s1, s2) -> 0);
System.out.println(minEmpty.isPresent()); // false
```

Поскольку поток пуст, компаратор никогда не вызывается, и в Optional отсутствует значение.

_Что, если вам нужны оба значения min() и max() для одного и того же потока? На данный момент вы не можете получить и 
то, и другое, по крайней мере, не используя эти методы. Помните, что поток может иметь только одну терминальную 
операцию. После выполнения терминальной операции поток не может быть использован повторно. Как вы увидите позже в этой 
главе, для некоторых числовых потоков существуют встроенные методы обобщения, которые вычислят набор значений для вас._

### Поиск значения

Методы findAny() и findFirst() возвращают элемент потока, если поток не пуст. Если поток пуст, они возвращают пустой 
Optional. Это первый метод, который вы видели, который может завершиться бесконечным потоком. Поскольку Java генерирует 
только тот объем потока, который вам нужен, бесконечный поток должен генерировать только один элемент.

Как следует из названия, метод findAny() может возвращать любой элемент потока. При вызове в потоках, которые вы видели 
до сих пор, он обычно возвращает первый элемент, хотя такое поведение не гарантируется. Как вы увидите в главе 13, метод 
findAny() с большей вероятностью вернет случайный элемент при работе с параллельными потоками.

Эти методы являются терминальными операциями, а не редукцией. Причина в том, что иногда они возвращаются, не обработав 
все элементы. Это означает, что они возвращают значение на основе потока, но не сводят весь поток к одному значению.

Сигнатуры метода следующие:

```
public Optional<T> findAny()
public Optional<T> findFirst()
```

В этом примере находит животное:

```
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
Stream<String> infinite = Stream.generate(() -> "chimp");

s.findAny().ifPresent(System.out::println);        // monkey (usually)
infinite.findAny().ifPresent(System.out::println); // chimp
```

Найти любое совпадение полезнее, чем кажется. Иногда нам просто хочется протестировать результаты и получить 
репрезентативный элемент, но нам не нужно тратить время на обработку, генерируя их все. В конце концов, если мы 
планируем работать только с одним элементом, зачем искать больше?

### Соответствие

Методы allMatch(), anyMatch() и noneMatch() выполняют поиск в потоке и возвращают информацию о том, как поток относится 
к предикату. Они могут завершаться, а могут и не прекращаться для бесконечных потоков. Это зависит от данных. Как и 
методы поиска, они не являются сокращениями, поскольку не обязательно рассматривают все элементы.

Сигнатуры метода следующие:

```
public boolean anyMatch(Predicate <? super T> predicate)
public boolean allMatch(Predicate <? super T> predicate)
public boolean noneMatch(Predicate <? super T> predicate)
```

В этом примере проверяется, начинаются ли имена животных с букв:

```
var list = List.of("monkey", "2", "chimp");
Stream<String> infinite = Stream.generate(() -> "chimp");
Predicate<String> pred = x -> Character.isLetter(x.charAt(0));

System.out.println(list.stream().anyMatch(pred));  // true
System.out.println(list.stream().allMatch(pred));  // false
System.out.println(list.stream().noneMatch(pred)); // false
System.out.println(infinite.anyMatch(pred));       // true
```

Это показывает, что мы можем повторно использовать один и тот же предикат, но каждый раз нам нужен другой поток. 
Метод anyMatch() возвращает значение true, поскольку два из трех элементов совпадают. Метод allMatch() возвращает 
false, поскольку ни один из них не соответствует. Метод noneMatch() также возвращает false, поскольку хотя бы одно 
совпадение. В бесконечном потоке найдено одно совпадение, поэтому вызов завершается. Если бы мы вызвали allMatch(), он
бы работал до тех пор, пока мы не завершим программу.

_Помните, что allMatch(), AnyMatch() и noneMatch() возвращают логическое значение. Напротив, методы поиска возвращают 
Optional, поскольку они возвращают элемент потока._

### Итерация 

Как и в Java Collections Framework, обычно приходится перебирать элементы потока. Как и ожидалось, вызов forEach() для 
бесконечного потока не завершается. Поскольку возвращаемого значения нет, это не сокращение.

Прежде чем использовать его, подумайте, не будет ли лучше другой подход. Разработчики, которые сначала научились писать 
циклы, обычно используют их для всего. Например, цикл с оператором if можно записать с фильтром. О фильтрах вы узнаете 
в разделе промежуточные операции.

Сигнатура метода следующая:

```
public void forEach(Consumer<? super T> action)
```

Обратите внимание, что это единственная терминальная операция, возвращающая тип void. Если вы хотите, чтобы что-то 
произошло, вы должны сделать это в Consumer. Вот один из способов распечатать элементы в потоке (есть и другие способы,
которые мы рассмотрим позже в этой главе):

```
Stream<String> s = Stream.of("Monkey", "Gorilla", "Bonobo");
s.forEach(System.out::print); // MonkeyGorillaBonobo
```

_Помните, что вы можете вызвать forEach() непосредственно в Collection или в Stream. Не запутайтесь на экзамене, 
увидев оба подхода._

Обратите внимание, что вы не можете использовать традиционный цикл for в потоке.

```
Stream<Integer> s = Stream.of(1);
for (Integer i  : s) {} // НЕ КОМПИЛИРУЕТСЯ
```

Хотя forEach() звучит как цикл, на самом деле это оператор терминала для потоков. Потоки нельзя использовать в качестве 
источника в цикле for-each, поскольку они не реализуют интерфейс Iterable.

### Сокращение

Метод reduce() объединяет поток в один объект. Это редукция, а значит, она обрабатывает все элементы. Вот три сигнатуры 
метода:

```
public T reduce(T identity, BinaryOperator<T> accumulator)

public Optional<T> reduce(BinaryOperator<T> accumulator)

public <U> U reduce(U identity,
   BiFunction<U,? super T,U> accumulator,
   BinaryOperator<U> combiner)
```

Давайте возьмем их по одному. Самый распространенный способ сокращения — начать с начального значения и продолжать 
объединять его со следующим значением. Подумайте, как можно объединить массив объектов String в одну строку без 
функционального программирования.

Это может выглядеть примерно так:

```
var array = new String[] { "w", "o", "l", "f" };
var result = "";
for (var s: array) result = result + s;
System.out.println(result); // wolf
```

Идентичность — это начальное значение сокращения, в данном случае пустая строка. Аккумулятор объединяет текущий 
результат с текущим значением в потоке. С помощью лямбда-выражения мы можем сделать то же самое с потоком и сокращением:

```
Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", (s, c) -> s + c);
System.out.println(word); // wolf
```

Обратите внимание, что у нас все еще есть пустая строка в качестве идентификатора. Мы также по-прежнему объединяем 
объекты String для получения следующего значения. Мы можем даже переписать это со ссылкой на метод:

```
Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", String::concat);
System.out.println(word); // wolf
```

Давайте попробуем еще один. Можете ли вы написать сокращение для умножения всех Integer объектов в потоке? Попробуй это. 
Наше решение показано здесь:

```
Stream<Integer> stream = Stream.of(3, 5, 6);
System.out.println(stream.reduce(1, (a, b) -> a * b));  // 90
```

Мы устанавливаем идентификатор на 1 и аккумулятор на умножение. Во многих случаях идентификатор на самом деле не 
обязателен, поэтому Java позволяет нам его опустить. Если вы не указываете идентификатор, возвращается Optional, 
поскольку данных может не быть. Есть три варианта того, что находится в Optional:

+ Если поток пуст, возвращается пустой Optional.
+ Если поток имеет один элемент, он возвращается.
+ Если поток содержит несколько элементов, для их объединения применяется сумматор.

Ниже иллюстрируется каждый из этих сценариев:

```
BinaryOperator<Integer> op = (a, b) -> a * b;
Stream<Integer> empty = Stream.empty();
Stream<Integer> oneElement = Stream.of(3);
Stream<Integer> threeElements = Stream.of(3, 5, 6);

empty.reduce(op).ifPresent(System.out::println);         // no output
oneElement.reduce(op).ifPresent(System.out::println);    // 3
threeElements.reduce(op).ifPresent(System.out::println); // 90
```

Почему существует два похожих метода? Почему бы просто не требовать всегда удостоверение личности? Java могла бы 
сделать это. Однако иногда полезно различать случай, когда поток пуст, а не случай, когда существует значение, которое 
соответствует идентификатору, возвращаемому в результате вычисления. Сигнатура, возвращающая Optional, 
позволяет нам различать эти случаи. Например, мы могли бы вернуть Optional.empty(), когда поток пуст, и Optional.of(3), 
когда есть значение.

Третья сигнатура метода используется, когда мы имеем дело с разными типами. Это позволяет Java создавать промежуточные 
сокращения, а затем объединять их в конце. Давайте посмотрим на пример, который подсчитывает количество символов в 
каждой строке:

```
Stream<String> stream = Stream.of("w", "o", "l", "f!");
int length = stream.reduce(0, (i, s) -> i+s.length(), (a, b) -> a+b);
System.out.println(length); // 5
```

Первый параметр (0) — это значение _инициализатора_. Если бы у нас был пустой поток, это был бы ответ. Второй 
параметр — аккумулятор. В отличие от _аккумуляторов_, которые вы видели ранее, этот работает со смешанными типами данных. 
В этом примере первый аргумент i — Integer, а второй аргумент s — String. Он добавляет длину текущей строки к нашему 
текущему итогу. Третий параметр называется _объединителем_, который объединяет любые промежуточные итоги. В этом случае 
a и b являются Integer.

Операция reduce() с тремя аргументами полезна при работе с параллельными потоками, поскольку она позволяет 
декомпозировать поток и повторно собирать его отдельными потоками. Например, если бы нам нужно было подсчитать длину 
четырех 100-символьных строк, первые два значения и последние два значения можно было бы вычислить независимо. Затем 
промежуточный результат (200 + 200) будет объединен в конечное значение.

### Сбор

Метод collect() — это особый тип сокращения, называемый _изменяемым сокращением_. Это более эффективно, чем обычное 
сокращение, поскольку при накоплении мы используем один и тот же изменяемый объект. К распространенным изменяемым 
объектам относятся StringBuilder и ArrayList. Это действительно полезный метод, поскольку он позволяет нам получать 
данные из потоков в другую форму. Сигнатуры метода следующие:

```
public <R> R collect(Supplier<R> supplier,
   BiConsumer<R, ? super T> accumulator,
   BiConsumer<R, R> combiner)
   
public <R,A> R collect(Collector<? super T, A,R> collector)
```

Начнем с первой сигнатуры, которая используется, когда мы хотим конкретно запрограммировать, как должен работать сбор. 
Наш пример wolf из reduce можно преобразовать для использования метода collect():

```
Stream<String> stream = Stream.of("w", "o", "l", "f");
StringBuilder word = stream.collect(
   StringBuilder::new,
   StringBuilder::append,
   StringBuilder::append);
   
System.out.println(word); // wolf
```

Первый параметр - это supplier, который создает объект, который будет сохранять результаты по мере сбора данных. 
Помните, что Supplier не принимает никаких параметров и возвращает значение. В этом случае он создает новый 
StringBuilder.

Второй параметр - это accumulator, который представляет собой BiConsumer, который принимает два параметра и ничего не 
возвращает. Он отвечает за добавление еще одного элемента к сбору данных. В этом примере он добавляет следующую строку к 
StringBuilder.

Конечным параметром является combiner, который является другим BiConsumer. Он отвечает за сбор двух наборов данных и их 
объединение. Это полезно, когда мы обрабатываем данные параллельно. Формируются две меньшие коллекции, которые затем 
объединяются в одну. Это сработало бы со StringBuilder только в том случае, если бы мы не заботились о порядке букв. В 
этом случае аккумулятор и объединитель имеют схожую логику.

Теперь давайте посмотрим на пример, где логика отличается в аккумуляторе и объединителе:

```
Stream<String> stream = Stream.of("w", "o", "l", "f");

TreeSet<String> set = stream.collect(
   TreeSet::new,
   TreeSet::add,
   TreeSet::addAll);
   
System.out.println(set); // [f, l, o, w]
```

Коллектор, как и прежде, состоит из трех частей. Поставщик создает пустой TreeSet. Накопитель добавляет одну строку из 
потока в TreeSet. Объединитель добавляет все элементы одного TreeSet в другой в случае, если операции выполнялись 
параллельно и их необходимо объединить.

Мы начали с длинной сигнатуры, потому что именно так вы реализуете свой собственный коллектор. Важно знать, как это 
сделать для сдачи экзамена, и понимать, как работают коллекторы. На практике многие обычные коллекторы появляются снова 
и снова. Вместо того чтобы заставлять разработчиков постоянно переопределять одни и те же функции, Java предоставляет 
класс с общими коллекторами, разумно названными Collectors. Такой подход также облегчает чтение кода, поскольку он 
более выразителен. Например, мы могли бы переписать предыдущий пример следующим образом:

```
Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set =
   stream.collect(Collectors.toCollection(TreeSet::new));
System.out.println(set); // [f, l, o, w]
```

Если бы нам не нужно было сортировать набор, мы могли бы сделать код еще короче:

```
Stream<String> stream = Stream.of("w", "o", "l", "f");
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o]
```

Вы можете получить другой результат для этого последнего, поскольку toSet() не дает никаких гарантий относительно того, 
какую реализацию Set вы получите. Скорее всего, это будет HashSet, но вы не должны ожидать или полагаться на это.

_На экзамене предполагается, что вы будете знать об общих предопределенных коллекторах в дополнение к возможности 
написать свой собственный, пройдя проверку поставщика, накопителя и объединителя._

Далее в этой главе мы покажем множество Collectors, которые используются для группировки данных. Это большая тема, 
поэтому лучше освоить, как работают потоки, прежде чем добавлять слишком много Collectors в микс.

### Использование общих промежуточных операций

В отличие от терминальной операции, промежуточная операция создает в качестве результата поток. Промежуточная операция 
также может обрабатывать бесконечный поток, просто возвращая другой бесконечный поток. Поскольку элементы производятся 
только по мере необходимости, это работает нормально. Работнику сборочной линии не нужно беспокоиться о том, сколько еще 
элементов пройдет, и вместо этого он может сосредоточиться на текущем элементе.

### Фильтрация

Метод filter() возвращает поток с элементами, соответствующими заданному выражению. Вот сигнатура метода:

```
public Stream<T> filter(Predicate<? super T> predicate)
```

Эту операцию легко запомнить, она эффективна, поскольку мы можем передать ей любой Predicate. Например, при этом 
сохраняются все элементы, начинающиеся с буквы m:

```
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.filter(x -> x.startsWith("m"))
    .forEach(System.out::print); // monkey
```

### Удаление дубликатов

Метод distinct() возвращает поток с удаленными повторяющимися значениями. Для удаления дубликаты не обязательно должны 
находиться рядом. Как вы можете себе представить, Java вызывает метод equals(), чтобы определить, эквивалентны ли 
объекты. Сигнатура метода следующая:

```
public Stream<T> distinct()
```

Вот пример:

```
Stream<String> s = Stream.of("duck", "duck", "duck", "goose");
s.distinct()
   .forEach(System.out::print); // duckgoose
```

### Ограничение по позиции

Ограничение по положению. Методы limit() и skip() могут уменьшить размер потока, а метод limit() может создать конечный 
поток из бесконечного потока. Сигнатуры метода показаны здесь:

```
public Stream<T> limit(long maxSize)
public Stream<T> skip(long n)
```

Следующий код создает бесконечный поток чисел, считая с 1. Операция skip() возвращает бесконечный поток, начиная с 
чисел, считая с 6, поскольку она пропускает первые пять элементов. Вызов limit() принимает первые два из них. Теперь у
нас есть конечный поток с двумя элементами, который затем можно распечатать с помощью метода forEach():

```
Stream<Integer> s = Stream.iterate(1, n -> n + 1);
s.skip(5)
   .limit(2)
   .forEach(System.out::print); // 67
```

### Mapping 616