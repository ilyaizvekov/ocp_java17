# Потоки

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Работа с потоками и лямбда-выражениями

+ Используйте объекты Java и примитивные потоки, включая лямбда-выражения, реализующие функциональные интерфейсы, для 
предоставления, фильтрации, сопоставления, потребления и сортировки данных
+ Выполнение декомпозиции, конкатенации и сокращения, а также группировки и секционирования в последовательных и 
параллельных потоках

---

К настоящему времени вы должны понимать синтаксис лямбда-выражения и ссылки на методы. Оба они используются при 
реализации функциональных интерфейсов. Если вам нужно больше практики, возможно, вы захотите вернуться назад и 
просмотреть главу 8 "Лямбды и функциональные интерфейсы" и главу 9 "Коллекции и дженерики". В этой главе мы добавим к 
этому собственно функциональное программирование, сосредоточив внимание на Streams API.

Обратите внимание, что Streams API  в этой главе используется для функционального программирования. Напротив, существуют 
также потоки java.io, о которых мы поговорим в главе 14 «Ввод-вывод». Несмотря на то, что оба используют слово 
«поток(stream)», они не похожи друг на друга.

В этой главе мы представляем Optional. Затем мы вводим конвейер Stream и связываем все это вместе. Возможно, вам 
захочется прочитать эту главу дважды, прежде чем отвечать на контрольные вопросы, чтобы вы действительно поняли суть. 
Функциональное программирование, как правило, требует сложного обучения, но может оказаться очень увлекательным, как 
только вы освоите его.

## Возврат Optional

Предположим, вы посещаете вводный курс Java и получаете 90 и 100 баллов на первых двух экзаменах. Теперь мы спрашиваем 
вас, каков ваш средний показатель. Среднее значение рассчитывается путем сложения баллов и деления на количество баллов, 
что дает (90+100)/2. Это дает 190/2, поэтому вы отвечаете 95. Отлично!

Теперь предположим, что вы посещаете второй урок по Java, и это первый день занятий. Мы спрашиваем вас, какой у вас 
средний балл в этом классе, который только начался. Вы еще не сдавали экзамены, поэтому вам нечего сдавать в среднем. 
Было бы неверно сказать, что ваше среднее значение равно нулю. Это звучит плохо и неправда. Данных просто нет, поэтому 
у вас нет среднего значения.

Как нам выразить этот ответ «мы не знаем» или «неприменимо» на Java? Мы используем тип Optional. Optional создается с 
использованием фабрики. Вы можете либо запросить пустой Optional параметр, либо передать значение для Optional параметра 
для переноса. Думайте о Optional как о поле, в котором может что-то находиться, или же оно может быть пустым. На 
рисунке 10.1 показаны оба варианта.

#### Рис. 10.1 - Optional


### Создание Optional

Вот как запрограммировать наш метод average:

```
10: public static Optional<Double> average(int... scores) { 
11:    if (scores.length == 0) return Optional.empty(); 
12:    int sum = 0; 
13:    for (int score: scores) sum += score; 
14:    return Optional.of((double) sum / scores.length); 
15: }
```

Строка 11 возвращает пустой Optional параметр, если мы не можем вычислить среднее значение. В строках 12 и 13 
суммируются баллы. Существует способ выполнения этих математических вычислений с помощью функционального 
программирования, но мы вернемся к этому позже в этой главе. На самом деле, весь метод можно было бы записать в одну 
строку, но это не научит вас тому, как работает Optional! В строке 14 создается Optional параметр для переноса среднего
значения.

Вызов метода показывает, что находится в наших двух полях:

```
System.out.println(average(90, 100)); // Optional[95.0]
System.out.println(average());        // Optional.empty
```

Вы можете видеть, что один Optional параметр содержит значение, а другой пуст. Обычно мы хотим проверить, есть ли 
значение, и/или получить его из коробки. Вот один из способов сделать это:

```
Optional<Double> opt = average(90, 100);
if (opt.isPresent())
   System.out.println(opt.get());  // 95.0
```

Сначала мы проверяем, содержит ли Optional параметр значение. Затем мы распечатываем его. Что, если мы не выполнили 
проверку, и Optional параметр был пуст?

```
Optional<Double> opt = average();
System.out.println(opt.get()); // NoSuchElementException
```

Мы получим исключение, поскольку внутри Optional значения нет.

```
java.util.NoSuchElementException: No value present
```

При создании Optional обычно требуется использовать empty(), когда значение равно null. Вы можете сделать это с помощью 
оператора if или тернарного оператора. Мы используем тернарный оператор (? :) для упрощения кода, который вы видели в 
главе 2 “Операторы”.

```
Optional o = (value == null) ? Optional.empty() : Optional.of(value);
```

Если value равно null, o присваивается пустое Optional значение. В противном случае мы переносим значение. Поскольку это 
очень распространенный шаблон, Java предоставляет фабричный метод, позволяющий сделать то же самое.

```
Optional o = Optional.ofNullable(value);
```

Это охватывает static методы, которых вам нужно знать о Optional. В таблице 10.1 обобщено большинство методов 
экземпляра на Optional, которые вам необходимо знать для экзамена. Есть несколько других, которые связаны с цепочкой. 
Мы рассмотрим их позже в этой главе.

#### Таблица 10.1 - Общие Optional методы экземпляра

|          Метод           |              Когда Optional пуст               | Когда Optional содержит значение |  
|:------------------------:|:----------------------------------------------:|:--------------------------------:|
|          get()           |             Генерирует исключение              |       Возвращает значение        |
|  ifPresent(Consumer c)   |                Ничего не делает                |  Вызывает Consumer со значением  |
|       isPresent()        |                Возвращает false                |         Возвращает true          |
|     orElse(T other)      |           Возвращает other параметр            |       Возвращает значение        |
|  orElseGet(Supplier s)   |      Возвращает результат вызова Supplier      |       Возвращает значение        |
|      orElseThrow()       |       Выбрасывает NoSuchElementException       |       Возвращает значение        |
| orElseThrow(Supplier s)  | Выдает исключение, созданное вызовом Supplier  |       Возвращает значение        |

Вы уже видели get() и isPresent(). Другие методы позволяют вам писать код, использующий Optional параметр в одной 
строке, без необходимости использования тернарного оператора. Это облегчает чтение кода. Вместо использования оператора 
if, который мы использовали ранее при проверке среднего значения, мы можем указать Consumer, который будет запускаться, 
когда внутри Optional есть значение. Если его нет, метод просто пропускает запуск Consumer.

```
Optional<Double> opt = average(90, 100); 
opt.ifPresent(System.out::println);
```

Использование ifPresent() лучше выражает наше намерение. Мы хотим, чтобы что-то было сделано, если значение 
присутствует. Вы можете думать об этом как об операторе if без else.

### Работа с пустым Optional

Остальные методы позволяют указать, что делать, если значение отсутствует. Есть несколько вариантов. Первые два 
позволяют указать возвращаемое значение напрямую или с помощью Supplier.

```
30: Optional<Double> opt = average(); 
31: System.out.println(opt.orElse(Double.NaN)); 
32: System.out.println(opt.orElseGet(() -> Math.random()));
```

Это напечатает примерно следующее:

```
NaN 
0.49775932295380165
```

В строке 31 показано, что вы можете вернуть определенное значение или переменную. В нашем случае мы печатаем значение 
«not a number». В строке 32 показано использование Supplier для генерации значения во время выполнения для возврата. 
Однако я рад, что наши профессора не дали нам случайное среднее значение!

В качестве альтернативы мы можем заставить код генерировать исключение, если Optional параметр пуст.

```
30: Optional<Double> opt = average(); 
31: System.out.println(opt.orElseThrow());
```

Это напечатает примерно следующее:

```
Exception in thread "main" java.util.NoSuchElementException:
  No value present
  at java.base/java.util.Optional.orElseThrow(Optional.java:382)
```

Без указания Supplier для исключения, Java выдаст исключение NoSuchElementException. В качестве альтернативы мы можем 
заставить код генерировать собственное исключение, если Optional параметр пуст. Помните, что трассировка стека выглядит 
странно, поскольку генерируются лямбда-выражения, а не именованные классы.

```
30: Optional<Double> opt = average();
31: System.out.println(opt.orElseThrow(
32:    () -> new IllegalStateException()));
```

Это напечатает примерно следующее:

```
Exception in thread "main" java.lang.IllegalStateException
  at optionals.Methods.lambda$orElse$1(Methods.java:31)
  at java.base/java.util.Optional.orElseThrow(Optional.java:408)
```

В строке 32 показано использование Supplier для создания исключения, которое должно быть выброшено. Обратите внимание: 
мы не пишем throw new IllegalStateException(). Метод orElseThrow() фактически генерирует исключение при его запуске.

Два метода, использующие Supplier, имеют разные имена. Вы понимаете, почему этот код не компилируется?

```
System.out.println(opt.orElseGet(
   () -> new IllegalStateException())); // НЕ КОМПИЛИРУЕТСЯ
```

Переменная opt является Optional<Double>. Это означает, что Supplier должен вернуть Double. Поскольку этот Supplier 
возвращает исключение, тип не соответствует.

Последний пример с Optional действительно прост. Как вы думаете, что это дает?

```
Optional<Double> opt = average(90, 100);
System.out.println(opt.orElse(Double.NaN));
System.out.println(opt.orElseGet(() -> Math.random()));
System.out.println(opt.orElseThrow());
```

Он печатает 95.0 три раза. Поскольку значение существует, нет необходимости использовать логику «или иначе».

**Является ли optional таким же, как null?**

Альтернативой Optional является возврат значения null. У этого подхода есть несколько недостатков. Во-первых, не 
существует четкого способа выразить, что значение null может быть особым значением. Напротив, возврат Optional 
значения — это четкое заявление в API о том, что значения может не быть.

Еще одним преимуществом Optional является то, что вы можете использовать стиль функционального программирования с 
ifPresent() и другими методами вместо использования оператора if. Наконец, ближе к концу главы вы увидите, что можно 
объединять Optional вызовы.

## Использование потоков

Поток в Java — это последовательность данных. Потоковый конвейер состоит из операций, которые выполняются над потоком 
для получения результата. Во-первых, мы концептуально рассмотрим поток трубопроводов. После этого переходим к коду.

### Понимание потока трубопровода

Подумайте о потоке трубопровода как о сборочной линии на заводе. Предположим, мы запускаем сборочную линию по 
изготовлению вывесок для выставок животных в зоопарке. У нас есть ряд вакансий. Вынимать таблички из коробки — задача 
одного человека. Нарисовать вывеску — это работа второго человека. Нанести название животного на табличку по 
трафарету — задача третьего человека. Задача последнего человека — положить готовый знак в коробку и отнести к 
соответствующей выставке.

Обратите внимание, что второй человек не может ничего сделать, пока первый человек не вытащит из коробки один знак. 
Точно так же третий человек не может ничего сделать, пока не будет нарисован один знак, а последний человек не может 
ничего сделать, пока он не будет нарисован по трафарету.

Конвейер по изготовлению знаков конечен. Как только мы обработаем содержимое нашей коробки со знаками, все будет готово. 
Конечные потоки имеют предел. Другие сборочные линии, например, по производству продуктов питания, работают вечно. 
Конечно, в какой-то момент, когда завод закрывается, они останавливаются, но сделайте вид, что этого не происходит. Или 
представьте, что цикл восхода и захода солнца бесконечен, поскольку он не заканчивается в течение чрезмерно большого 
периода времени.

Еще одна важная особенность сборочной линии заключается в том, что каждый человек прикасается к каждому элементу, чтобы 
выполнить свою операцию, а затем этот фрагмент данных исчезает. Оно не возвращается. В этот момент этим занимается 
следующий человек. Это отличается от списков и очередей, которые вы видели в предыдущей главе. С помощью списка вы 
можете получить доступ к любому элементу в любое время. В очереди вы ограничены в том, к каким элементам вы можете 
получить доступ, но все элементы присутствуют. При использовании потоков данные не генерируются заранее — они создаются 
при необходимости. Это пример ленивой оценки, при которой выполнение откладывается до тех пор, пока это не станет 
необходимым.

По пути на станциях сборочной линии может произойти многое. В функциональном программировании это называется потоковыми 
операциями. Как и на сборочной линии, операции происходят в конвейере. Кто-то должен начинать и заканчивать работу, а 
между ними может быть любое количество станций. Ведь работа одного человека – это не конвейер! Потоковый конвейер 
состоит из трех частей, как показано на рисунке 10.2.

+ Source: Откуда берется поток.
+ Intermediate operations: Преобразует поток в другой. Промежуточных операций может быть столько, сколько захотите. 
Поскольку в потоках используется отложенная оценка, промежуточные операции не выполняются до тех пор, пока не запустится 
терминальная операция.
+ Terminal operation: Выдаёт результат. Поскольку потоки можно использовать только один раз, после завершения 
терминальной операции поток становится недействительным.

#### Рис. 10.2 - Потоковый конвейер


Обратите внимание, что операции нам неизвестны. Глядя на сборочную линию снаружи, вас волнует только то, что входит и 
выходит. То, что происходит между ними, является деталью реализации.

Вам нужно будет хорошо знать различия между промежуточными и терминальными операциями. Убедитесь, что вы можете 
заполнить таблицу 10.2.

#### Таблица 10.2 - Промежуточные операции по сравнению с терминальными

|                     Сценарий                     | Промежуточная операция | Терминальная операция |  
|:------------------------------------------------:|:----------------------:|:---------------------:|
|      Необходимая часть полезного конвейера?      |          Нет           |          Да           |
| Может ли существовать несколько раз в конвейере? |           Да           |          Нет          |
|   Тип возвращаемого значения — это тип потока?   |           Да           |          Нет          |
|          Выполняется при вызове метода?          |          Нет           |          Да           |
|     Трансляция действительна после звонка?       |           Да           |          Нет          |

На заводе обычно есть бригадир, который наблюдает за работой. Java играет ведущую роль при работе с потоковыми 
конвейерами. Это действительно важная роль, особенно когда речь идет о ленивых вычислениях и бесконечных потоках. 
Думайте об объявлении потока как о передаче инструкций руководителю. Как только бригадир узнает, что нужно сделать, он 
расставляет посты и сообщает рабочим, каковы будут их обязанности. Однако рабочие не приступают к работе до тех пор, 
пока бригадир не прикажет им начать. Бригадир ждет, пока не увидит работу терминала, чтобы приступить к работе. Они 
также следят за работой и останавливают линию, как только работа завершена.

Давайте посмотрим на несколько примеров этого. В этих примерах мы не используем код, потому что очень важно понять 
концепцию потокового конвейера, прежде чем начинать писать код. На рисунке 10.3 показан потоковый конвейер с одной 
промежуточной операцией.

#### Рис. 10.3 - Шаги по запуску потокового конвейера


Давайте посмотрим на то, что происходит с точки зрения руководителя. Во-первых, они видят, что источник извлекает 
знаки из коробки. Мастер усаживает работника за стол, чтобы тот распаковал коробку, и говорит ждать сигнала к началу. 
Затем мастер видит промежуточную операцию по раскрашиванию вывески. Они подставляют рабочего с краской и говорят ждать 
сигнала к началу. Наконец, бригадир видит операцию терминала по складыванию знаков в стопку. Они поручают это одному 
работнику и кричат, что все три работника должны начать.

Предположим, что в поле есть два знака. Шаг 1 - первый работник достает один знак из коробки и передает его второму 
работнику. Шаг 2 - второй рабочий красит его и передает третьему рабочему. Шаг 3 - это когда третий рабочий кладет его в
стопку. Шаги 4-6 - это тот же процесс для другого знака. Затем бригадир видит, что никаких вывесок не осталось, и 
закрывает все предприятие.

Бригадир умен и может принимать решения о том, как наилучшим образом выполнить работу, исходя из того, что необходимо. 
В качестве примера давайте рассмотрим потоковый конвейер на рис. 10.4.

#### Рис. 10.4 - Потоковый конвейер с ограничением


Руководитель по-прежнему видит источник получения знаков из коробки и назначает работника делать это по команде. Они 
по-прежнему видят промежуточную операцию по покраске и назначают другого работника с инструкциями подождать, а затем 
покрасить. Затем они видят промежуточный шаг, на котором нам нужны всего два знака. Они поручают рабочему подсчитывать 
проходящие мимо знаки и уведомлять бригадира, когда рабочий увидит два. Наконец, они назначили работника для работы с 
терминалом, который должен был сложить таблички в стопку.

На этот раз предположим, что в поле есть 10 знаков. Мы начнем, как в прошлый раз. Первый сигнал проходит по конвейеру. 
Второй знак также проходит свой путь по трубопроводу. Когда работник, ответственный за подсчет, видит второй знак, он 
сообщает об этом бригадиру. Бригадир позволяет оператору терминала завершить свою задачу, а затем кричит: “Остановите 
линию”. Не имеет значения, что в коробке есть еще восемь знаков. Они нам не нужны, так что раскрашивать их было бы 
ненужной работой. И мы все хотим избежать ненужной работы!

Точно так же бригадир остановил бы линию после первого знака, если бы операция терминала должна была найти первый 
созданный знак.

В следующих разделах мы рассмотрим три части конвейера. Мы также обсуждаем специальные типы потоков для примитивов и 
способы печати потока.

### Создание источников потока

В Java потоки, о которых мы говорили, представлены интерфейсом Stream<T>, определенным в пакете java.util.stream.

### Создание конечных потоков
