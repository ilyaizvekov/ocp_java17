# Потоки

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Работа с потоками и лямбда-выражениями

+ Используйте объекты Java и примитивные потоки, включая лямбда-выражения, реализующие функциональные интерфейсы, для 
предоставления, фильтрации, сопоставления, потребления и сортировки данных
+ Выполнение декомпозиции, конкатенации и сокращения, а также группировки и секционирования в последовательных и 
параллельных потоках

---

К настоящему времени вы должны понимать синтаксис лямбда-выражения и ссылки на методы. Оба они используются при 
реализации функциональных интерфейсов. Если вам нужно больше практики, возможно, вы захотите вернуться назад и 
просмотреть главу 8 "Лямбды и функциональные интерфейсы" и главу 9 "Коллекции и дженерики". В этой главе мы добавим к 
этому собственно функциональное программирование, сосредоточив внимание на Streams API.

Обратите внимание, что Streams API  в этой главе используется для функционального программирования. Напротив, существуют 
также потоки java.io, о которых мы поговорим в главе 14 «Ввод-вывод». Несмотря на то, что оба используют слово 
«поток(stream)», они не похожи друг на друга.

В этой главе мы представляем Optional. Затем мы вводим конвейер Stream и связываем все это вместе. Возможно, вам 
захочется прочитать эту главу дважды, прежде чем отвечать на контрольные вопросы, чтобы вы действительно поняли суть. 
Функциональное программирование, как правило, требует сложного обучения, но может оказаться очень увлекательным, как 
только вы освоите его.

## Возврат Optional

Предположим, вы посещаете вводный курс Java и получаете 90 и 100 баллов на первых двух экзаменах. Теперь мы спрашиваем 
вас, каков ваш средний показатель. Среднее значение рассчитывается путем сложения баллов и деления на количество баллов, 
что дает (90+100)/2. Это дает 190/2, поэтому вы отвечаете 95. Отлично!

Теперь предположим, что вы посещаете второй урок по Java, и это первый день занятий. Мы спрашиваем вас, какой у вас 
средний балл в этом классе, который только начался. Вы еще не сдавали экзамены, поэтому вам нечего сдавать в среднем. 
Было бы неверно сказать, что ваше среднее значение равно нулю. Это звучит плохо и неправда. Данных просто нет, поэтому 
у вас нет среднего значения.

Как нам выразить этот ответ «мы не знаем» или «неприменимо» на Java? Мы используем тип Optional. Optional создается с 
использованием фабрики. Вы можете либо запросить пустой Optional параметр, либо передать значение для Optional параметра 
для переноса. Думайте о Optional как о поле, в котором может что-то находиться, или же оно может быть пустым. На 
рисунке 10.1 показаны оба варианта.

#### Рис. 10.1 - Optional


### Создание Optional

Вот как запрограммировать наш метод average:

```
10: public static Optional<Double> average(int... scores) { 
11:    if (scores.length == 0) return Optional.empty(); 
12:    int sum = 0; 
13:    for (int score: scores) sum += score; 
14:    return Optional.of((double) sum / scores.length); 
15: }
```

Строка 11 возвращает пустой Optional параметр, если мы не можем вычислить среднее значение. В строках 12 и 13 
суммируются баллы. Существует способ выполнения этих математических вычислений с помощью функционального 
программирования, но мы вернемся к этому позже в этой главе. На самом деле, весь метод можно было бы записать в одну 
строку, но это не научит вас тому, как работает Optional! В строке 14 создается Optional параметр для переноса среднего
значения.

Вызов метода показывает, что находится в наших двух полях:

```
System.out.println(average(90, 100)); // Optional[95.0]
System.out.println(average());        // Optional.empty
```

Вы можете видеть, что один Optional параметр содержит значение, а другой пуст. Обычно мы хотим проверить, есть ли 
значение, и/или получить его из коробки. Вот один из способов сделать это:

```
Optional<Double> opt = average(90, 100);
if (opt.isPresent())
   System.out.println(opt.get());  // 95.0
```

Сначала мы проверяем, содержит ли Optional параметр значение. Затем мы распечатываем его. Что, если мы не выполнили 
проверку, и Optional параметр был пуст?

```
Optional<Double> opt = average();
System.out.println(opt.get()); // NoSuchElementException
```

Мы получим исключение, поскольку внутри Optional значения нет.

```
java.util.NoSuchElementException: No value present
```

При создании Optional обычно требуется использовать empty(), когда значение равно null. Вы можете сделать это с помощью 
оператора if или тернарного оператора. Мы используем тернарный оператор (? :) для упрощения кода, который вы видели в 
главе 2 “Операторы”.

```
Optional o = (value == null) ? Optional.empty() : Optional.of(value);
```

Если value равно null, o присваивается пустое Optional значение. В противном случае мы переносим значение. Поскольку это 
очень распространенный шаблон, Java предоставляет фабричный метод, позволяющий сделать то же самое.

```
Optional o = Optional.ofNullable(value);
```

Это охватывает static методы, которых вам нужно знать о Optional. В таблице 10.1 обобщено большинство методов 
экземпляра на Optional, которые вам необходимо знать для экзамена. Есть несколько других, которые связаны с цепочкой. 
Мы рассмотрим их позже в этой главе.

#### Таблица 10.1 - Общие Optional методы экземпляра

|          Метод           |              Когда Optional пуст               | Когда Optional содержит значение |  
|:------------------------:|:----------------------------------------------:|:--------------------------------:|
|          get()           |             Генерирует исключение              |       Возвращает значение        |
|  ifPresent(Consumer c)   |                Ничего не делает                |  Вызывает Consumer со значением  |
|       isPresent()        |                Возвращает false                |         Возвращает true          |
|     orElse(T other)      |           Возвращает other параметр            |       Возвращает значение        |
|  orElseGet(Supplier s)   |      Возвращает результат вызова Supplier      |       Возвращает значение        |
|      orElseThrow()       |       Выбрасывает NoSuchElementException       |       Возвращает значение        |
| orElseThrow(Supplier s)  | Выдает исключение, созданное вызовом Supplier  |       Возвращает значение        |
 