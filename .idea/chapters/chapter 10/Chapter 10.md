# Потоки

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Работа с потоками и лямбда-выражениями

+ Используйте объекты Java и примитивные потоки, включая лямбда-выражения, реализующие функциональные интерфейсы, для 
предоставления, фильтрации, сопоставления, потребления и сортировки данных
+ Выполнение декомпозиции, конкатенации и сокращения, а также группировки и секционирования в последовательных и 
параллельных потоках

---

К настоящему времени вы должны понимать синтаксис лямбда-выражения и ссылки на методы. Оба они используются при 
реализации функциональных интерфейсов. Если вам нужно больше практики, возможно, вы захотите вернуться назад и 
просмотреть главу 8 "Лямбды и функциональные интерфейсы" и главу 9 "Коллекции и дженерики". В этой главе мы добавим к 
этому собственно функциональное программирование, сосредоточив внимание на Streams API.

Обратите внимание, что Streams API  в этой главе используется для функционального программирования. Напротив, существуют 
также потоки java.io, о которых мы поговорим в главе 14 «Ввод-вывод». Несмотря на то, что оба используют слово 
«поток(stream)», они не похожи друг на друга.

В этой главе мы представляем Optional. Затем мы вводим конвейер Stream и связываем все это вместе. Возможно, вам 
захочется прочитать эту главу дважды, прежде чем отвечать на контрольные вопросы, чтобы вы действительно поняли суть. 
Функциональное программирование, как правило, требует сложного обучения, но может оказаться очень увлекательным, как 
только вы освоите его.

## Возврат Optional

Предположим, вы посещаете вводный курс Java и получаете 90 и 100 баллов на первых двух экзаменах. Теперь мы спрашиваем 
вас, каков ваш средний показатель. Среднее значение рассчитывается путем сложения баллов и деления на количество баллов, 
что дает (90+100)/2. Это дает 190/2, поэтому вы отвечаете 95. Отлично!

Теперь предположим, что вы посещаете второй урок по Java, и это первый день занятий. Мы спрашиваем вас, какой у вас 
средний балл в этом классе, который только начался. Вы еще не сдавали экзамены, поэтому вам нечего сдавать в среднем. 
Было бы неверно сказать, что ваше среднее значение равно нулю. Это звучит плохо и неправда. Данных просто нет, поэтому 
у вас нет среднего значения.

Как нам выразить этот ответ «мы не знаем» или «неприменимо» на Java? Мы используем тип Optional. Optional создается с 
использованием фабрики. Вы можете либо запросить пустой Optional параметр, либо передать значение для Optional параметра 
для переноса. Думайте о Optional как о поле, в котором может что-то находиться, или же оно может быть пустым. На 
рисунке 10.1 показаны оба варианта.

#### Рис. 10.1 - Optional


### Создание Optional

Вот как запрограммировать наш метод average:

```
10: public static Optional<Double> average(int... scores) { 
11:    if (scores.length == 0) return Optional.empty(); 
12:    int sum = 0; 
13:    for (int score: scores) sum += score; 
14:    return Optional.of((double) sum / scores.length); 
15: }
```

Строка 11 возвращает пустой Optional параметр, если мы не можем вычислить среднее значение. В строках 12 и 13 
суммируются баллы. Существует способ выполнения этих математических вычислений с помощью функционального 
программирования, но мы вернемся к этому позже в этой главе. На самом деле, весь метод можно было бы записать в одну 
строку, но это не научит вас тому, как работает Optional! В строке 14 создается Optional параметр для переноса среднего
значения.

Вызов метода показывает, что находится в наших двух полях:

```
System.out.println(average(90, 100)); // Optional[95.0]
System.out.println(average());        // Optional.empty
```

Вы можете видеть, что один Optional параметр содержит значение, а другой пуст. Обычно мы хотим проверить, есть ли 
значение, и/или получить его из коробки. Вот один из способов сделать это:

```
Optional<Double> opt = average(90, 100);
if (opt.isPresent())
   System.out.println(opt.get());  // 95.0
```

Сначала мы проверяем, содержит ли Optional параметр значение. Затем мы распечатываем его. Что, если мы не выполнили 
проверку, и Optional параметр был пуст?

```
Optional<Double> opt = average();
System.out.println(opt.get()); // NoSuchElementException
```

Мы получим исключение, поскольку внутри Optional значения нет.

```
java.util.NoSuchElementException: No value present
```

При создании Optional обычно требуется использовать empty(), когда значение равно null. Вы можете сделать это с помощью 
оператора if или тернарного оператора. Мы используем тернарный оператор (? :) для упрощения кода, который вы видели в 
главе 2 “Операторы”.

```
Optional o = (value == null) ? Optional.empty() : Optional.of(value);
```

Если value равно null, o присваивается пустое Optional значение. В противном случае мы переносим значение. Поскольку это 
очень распространенный шаблон, Java предоставляет фабричный метод, позволяющий сделать то же самое.

```
Optional o = Optional.ofNullable(value);
```

Это охватывает static методы, которых вам нужно знать о Optional. В таблице 10.1 обобщено большинство методов 
экземпляра на Optional, которые вам необходимо знать для экзамена. Есть несколько других, которые связаны с цепочкой. 
Мы рассмотрим их позже в этой главе.

#### Таблица 10.1 - Общие Optional методы экземпляра

|          Метод           |              Когда Optional пуст               | Когда Optional содержит значение |  
|:------------------------:|:----------------------------------------------:|:--------------------------------:|
|          get()           |             Генерирует исключение              |       Возвращает значение        |
|  ifPresent(Consumer c)   |                Ничего не делает                |  Вызывает Consumer со значением  |
|       isPresent()        |                Возвращает false                |         Возвращает true          |
|     orElse(T other)      |           Возвращает other параметр            |       Возвращает значение        |
|  orElseGet(Supplier s)   |      Возвращает результат вызова Supplier      |       Возвращает значение        |
|      orElseThrow()       |       Выбрасывает NoSuchElementException       |       Возвращает значение        |
| orElseThrow(Supplier s)  | Выдает исключение, созданное вызовом Supplier  |       Возвращает значение        |

Вы уже видели get() и isPresent(). Другие методы позволяют вам писать код, использующий Optional параметр в одной 
строке, без необходимости использования тернарного оператора. Это облегчает чтение кода. Вместо использования оператора 
if, который мы использовали ранее при проверке среднего значения, мы можем указать Consumer, который будет запускаться, 
когда внутри Optional есть значение. Если его нет, метод просто пропускает запуск Consumer.

```
Optional<Double> opt = average(90, 100); 
opt.ifPresent(System.out::println);
```

Использование ifPresent() лучше выражает наше намерение. Мы хотим, чтобы что-то было сделано, если значение 
присутствует. Вы можете думать об этом как об операторе if без else.

### Работа с пустым Optional

Остальные методы позволяют указать, что делать, если значение отсутствует. Есть несколько вариантов. Первые два 
позволяют указать возвращаемое значение напрямую или с помощью Supplier.

```
30: Optional<Double> opt = average(); 
31: System.out.println(opt.orElse(Double.NaN)); 
32: System.out.println(opt.orElseGet(() -> Math.random()));
```

Это напечатает примерно следующее:

```
NaN 
0.49775932295380165
```

В строке 31 показано, что вы можете вернуть определенное значение или переменную. В нашем случае мы печатаем значение 
«not a number». В строке 32 показано использование Supplier для генерации значения во время выполнения для возврата. 
Однако я рад, что наши профессора не дали нам случайное среднее значение!

В качестве альтернативы мы можем заставить код генерировать исключение, если Optional параметр пуст.

```
30: Optional<Double> opt = average(); 
31: System.out.println(opt.orElseThrow());
```

Это напечатает примерно следующее:

```
Exception in thread "main" java.util.NoSuchElementException:
  No value present
  at java.base/java.util.Optional.orElseThrow(Optional.java:382)
```

Без указания Supplier для исключения, Java выдаст исключение NoSuchElementException. В качестве альтернативы мы можем 
заставить код генерировать собственное исключение, если Optional параметр пуст. Помните, что трассировка стека выглядит 
странно, поскольку генерируются лямбда-выражения, а не именованные классы.

```
30: Optional<Double> opt = average();
31: System.out.println(opt.orElseThrow(
32:    () -> new IllegalStateException()));
```

Это напечатает примерно следующее:

```
Exception in thread "main" java.lang.IllegalStateException
  at optionals.Methods.lambda$orElse$1(Methods.java:31)
  at java.base/java.util.Optional.orElseThrow(Optional.java:408)
```

В строке 32 показано использование Supplier для создания исключения, которое должно быть выброшено. Обратите внимание: 
мы не пишем throw new IllegalStateException(). Метод orElseThrow() фактически генерирует исключение при его запуске.

Два метода, использующие Supplier, имеют разные имена. Вы понимаете, почему этот код не компилируется?

```
System.out.println(opt.orElseGet(
   () -> new IllegalStateException())); // НЕ КОМПИЛИРУЕТСЯ
```

Переменная opt является Optional<Double>. Это означает, что Supplier должен вернуть Double. Поскольку этот Supplier 
возвращает исключение, тип не соответствует.

Последний пример с Optional действительно прост. Как вы думаете, что это дает?

```
Optional<Double> opt = average(90, 100);
System.out.println(opt.orElse(Double.NaN));
System.out.println(opt.orElseGet(() -> Math.random()));
System.out.println(opt.orElseThrow());
```

Он печатает 95.0 три раза. Поскольку значение существует, нет необходимости использовать логику «или иначе».

**Является ли optional таким же, как null?**

Альтернативой Optional является возврат значения null. У этого подхода есть несколько недостатков. Во-первых, не 
существует четкого способа выразить, что значение null может быть особым значением. Напротив, возврат Optional 
значения — это четкое заявление в API о том, что значения может не быть.

Еще одним преимуществом Optional является то, что вы можете использовать стиль функционального программирования с 
ifPresent() и другими методами вместо использования оператора if. Наконец, ближе к концу главы вы увидите, что можно 
объединять Optional вызовы.

## Использование потоков

Поток в Java — это последовательность данных. Потоковый конвейер состоит из операций, которые выполняются над потоком 
для получения результата. Во-первых, мы концептуально рассмотрим поток трубопроводов. После этого переходим к коду.

### Понимание потока трубопровода

Подумайте о потоке трубопровода как о сборочной линии на заводе. Предположим, мы запускаем сборочную линию по 
изготовлению вывесок для выставок животных в зоопарке. У нас есть ряд вакансий. Вынимать таблички из коробки — задача 
одного человека. Нарисовать вывеску — это работа второго человека. Нанести название животного на табличку по 
трафарету — задача третьего человека. Задача последнего человека — положить готовый знак в коробку и отнести к 
соответствующей выставке.

Обратите внимание, что второй человек не может ничего сделать, пока первый человек не вытащит из коробки один знак. 
Точно так же третий человек не может ничего сделать, пока не будет нарисован один знак, а последний человек не может 
ничего сделать, пока он не будет нарисован по трафарету.

Конвейер по изготовлению знаков конечен. Как только мы обработаем содержимое нашей коробки со знаками, все будет готово. 
Конечные потоки имеют предел. Другие сборочные линии, например, по производству продуктов питания, работают вечно. 
Конечно, в какой-то момент, когда завод закрывается, они останавливаются, но сделайте вид, что этого не происходит. Или 
представьте, что цикл восхода и захода солнца бесконечен, поскольку он не заканчивается в течение чрезмерно большого 
периода времени.

Еще одна важная особенность сборочной линии заключается в том, что каждый человек прикасается к каждому элементу, чтобы 
выполнить свою операцию, а затем этот фрагмент данных исчезает. Оно не возвращается. В этот момент этим занимается 
следующий человек. Это отличается от списков и очередей, которые вы видели в предыдущей главе. С помощью списка вы 
можете получить доступ к любому элементу в любое время. В очереди вы ограничены в том, к каким элементам вы можете 
получить доступ, но все элементы присутствуют. При использовании потоков данные не генерируются заранее — они создаются 
при необходимости. Это пример ленивой оценки, при которой выполнение откладывается до тех пор, пока это не станет 
необходимым.

По пути на станциях сборочной линии может произойти многое. В функциональном программировании это называется потоковыми 
операциями. Как и на сборочной линии, операции происходят в конвейере. Кто-то должен начинать и заканчивать работу, а 
между ними может быть любое количество станций. Ведь работа одного человека – это не конвейер! Потоковый конвейер 
состоит из трех частей, как показано на рисунке 10.2.

+ Source: Откуда берется поток.
+ Intermediate operations: Преобразует поток в другой. Промежуточных операций может быть столько, сколько захотите. 
Поскольку в потоках используется отложенная оценка, промежуточные операции не выполняются до тех пор, пока не запустится 
терминальная операция.
+ Terminal operation: Выдаёт результат. Поскольку потоки можно использовать только один раз, после завершения 
терминальной операции поток становится недействительным.

#### Рис. 10.2 - Потоковый конвейер


Обратите внимание, что операции нам неизвестны. Глядя на сборочную линию снаружи, вас волнует только то, что входит и 
выходит. То, что происходит между ними, является деталью реализации.

Вам нужно будет хорошо знать различия между промежуточными и терминальными операциями. Убедитесь, что вы можете 
заполнить таблицу 10.2.

#### Таблица 10.2 - Промежуточные операции по сравнению с терминальными

|                     Сценарий                     | Промежуточная операция | Терминальная операция |  
|:------------------------------------------------:|:----------------------:|:---------------------:|
|      Необходимая часть полезного конвейера?      |          Нет           |          Да           |
| Может ли существовать несколько раз в конвейере? |           Да           |          Нет          |
|   Тип возвращаемого значения — это тип потока?   |           Да           |          Нет          |
|          Выполняется при вызове метода?          |          Нет           |          Да           |
|     Трансляция действительна после звонка?       |           Да           |          Нет          |

На заводе обычно есть бригадир, который наблюдает за работой. Java играет ведущую роль при работе с потоковыми 
конвейерами. Это действительно важная роль, особенно когда речь идет о ленивых вычислениях и бесконечных потоках. 
Думайте об объявлении потока как о передаче инструкций руководителю. Как только бригадир узнает, что нужно сделать, он 
расставляет посты и сообщает рабочим, каковы будут их обязанности. Однако рабочие не приступают к работе до тех пор, 
пока бригадир не прикажет им начать. Бригадир ждет, пока не увидит работу терминала, чтобы приступить к работе. Они 
также следят за работой и останавливают линию, как только работа завершена.

Давайте посмотрим на несколько примеров этого. В этих примерах мы не используем код, потому что очень важно понять 
концепцию потокового конвейера, прежде чем начинать писать код. На рисунке 10.3 показан потоковый конвейер с одной 
промежуточной операцией.

#### Рис. 10.3 - Шаги по запуску потокового конвейера


Давайте посмотрим на то, что происходит с точки зрения руководителя. Во-первых, они видят, что источник извлекает 
знаки из коробки. Мастер усаживает работника за стол, чтобы тот распаковал коробку, и говорит ждать сигнала к началу. 
Затем мастер видит промежуточную операцию по раскрашиванию вывески. Они подставляют рабочего с краской и говорят ждать 
сигнала к началу. Наконец, бригадир видит операцию терминала по складыванию знаков в стопку. Они поручают это одному 
работнику и кричат, что все три работника должны начать.

Предположим, что в поле есть два знака. Шаг 1 - первый работник достает один знак из коробки и передает его второму 
работнику. Шаг 2 - второй рабочий красит его и передает третьему рабочему. Шаг 3 - это когда третий рабочий кладет его в
стопку. Шаги 4-6 - это тот же процесс для другого знака. Затем бригадир видит, что никаких вывесок не осталось, и 
закрывает все предприятие.

Бригадир умен и может принимать решения о том, как наилучшим образом выполнить работу, исходя из того, что необходимо. 
В качестве примера давайте рассмотрим потоковый конвейер на рис. 10.4.

#### Рис. 10.4 - Потоковый конвейер с ограничением


Руководитель по-прежнему видит источник получения знаков из коробки и назначает работника делать это по команде. Они 
по-прежнему видят промежуточную операцию по покраске и назначают другого работника с инструкциями подождать, а затем 
покрасить. Затем они видят промежуточный шаг, на котором нам нужны всего два знака. Они поручают рабочему подсчитывать 
проходящие мимо знаки и уведомлять бригадира, когда рабочий увидит два. Наконец, они назначили работника для работы с 
терминалом, который должен был сложить таблички в стопку.

На этот раз предположим, что в поле есть 10 знаков. Мы начнем, как в прошлый раз. Первый сигнал проходит по конвейеру. 
Второй знак также проходит свой путь по трубопроводу. Когда работник, ответственный за подсчет, видит второй знак, он 
сообщает об этом бригадиру. Бригадир позволяет оператору терминала завершить свою задачу, а затем кричит: “Остановите 
линию”. Не имеет значения, что в коробке есть еще восемь знаков. Они нам не нужны, так что раскрашивать их было бы 
ненужной работой. И мы все хотим избежать ненужной работы!

Точно так же бригадир остановил бы линию после первого знака, если бы операция терминала должна была найти первый 
созданный знак.

В следующих разделах мы рассмотрим три части конвейера. Мы также обсуждаем специальные типы потоков для примитивов и 
способы печати потока.

### Создание источников потока

В Java потоки, о которых мы говорили, представлены интерфейсом Stream<T>, определенным в пакете java.util.stream.

### Создание конечных потоков

Для простоты начнём с конечных потоков. Есть несколько способов их создания.

```
11: Stream<String> empty = Stream.empty();          // count = 0
12: Stream<Integer> singleElement = Stream.of(1);   // count = 1
13: Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 3
```

В строке 11 показано, как создать пустой поток. В строке 12 показано, как создать поток с одним элементом. В строке 13 
показано, как создать поток из аргумента varargs.

Java также предоставляет удобный способ преобразования Collection в поток.

```
14: var list = List.of("a", "b", "c");
15: Stream<String> fromList = list.stream();
```

В строке 15 показано, что это простой вызов метода для создания потока из списка. Это полезно, поскольку такие
преобразования являются обычным явлением.

**Создание параллельного потока**

Так же легко создать параллельный поток из списка.

```
24: var list = List.of("a", "b", "c"); 
25: Stream<String> fromListParallel = list.parallelStream();
```

Это замечательная функция, поскольку вы можете писать код, использующий параллелизм, даже не узнав, что такое поток. 
Использование параллельных потоков похоже на создание нескольких таблиц рабочих процессов, которые могут выполнять одну 
и ту же задачу. Рисование было бы намного быстрее, если бы у нас было пять художников, рисующих вывески, а не один. 
Просто имейте в виду, что некоторые задачи нельзя выполнять параллельно, например, размещать знаки в том порядке, в 
котором они были созданы в потоке. Также имейте в виду, что координация работы требует затрат, поэтому для 
небольших потоков может быть быстрее выполнять ее последовательно. Подробную информацию о одновременном выполнении 
задач вы узнаете в главе 13 «Параллелизм».

### Создание бесконечных потоков

Пока это не особо впечатляет. Мы могли бы сделать все это с помощью списков. Однако мы не можем создать 
бесконечный список, это делает потоки более мощными.

```
17: Stream<Double> randoms = Stream.generate(Math::random);
18: Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2);
```

Строка 17 генерирует поток случайных чисел. Сколько случайных чисел? Сколько бы вам ни потребовалось. Если вы вызовете 
randoms.forEach(System.out::println), программа будет печатать случайные числа, пока вы ее не уничтожите. Далее в этой 
главе вы узнаете о таких операциях, как limit(), позволяющих превратить бесконечный поток в конечный поток.

Строка 18 дает вам больше контроля. Метод iterate() принимает начальное значение в качестве первого параметра. Это 
первый элемент, который будет частью потока. Другой параметр - это лямбда-выражение, которому передается предыдущее 
значение и генерируется следующее значение. Как и в примере со случайными числами, он будет продолжать выдавать 
нечетные числа до тех пор, пока они вам понадобятся.

**Печать ссылки на поток**

Если вы попытаетесь вызвать System.out.print(stream), вы получите что-то вроде следующего:

```
java.util.stream.ReferencePipeline$3@4517d9a3
```

Это отличается от Collection, где вы видите содержимое. Для сдачи экзамена это знать не обязательно. Мы упоминаем об 
этом, чтобы вы не были застигнуты врасплох при написании кода для практики.

---

Что, если вам нужны просто нечетные числа меньше 100? Существует перегруженная версия iterate(), которая помогает:

```
19: Stream<Integer> oddNumberUnder100 = Stream.iterate(
20:    1,                // seed
21:    n -> n < 100,     // Predicate, указывающий, когда будет выполнено
22:    n -> n + 2);      // Унарный оператор для получения следующего значения
```

Этот метод принимает три параметра. Обратите внимание, как они разделяются запятыми (,), как и во всех других методах. 
Экзамен может попытаться обмануть вас, используя точки с запятой, поскольку это похоже на цикл for. Как и в случае с 
циклом for, вы должны позаботиться о том, чтобы случайно не создать бесконечный поток.

### Обзор методов создания потоков

Для ознакомления убедитесь, что вы знакомы со всеми методами, приведенными в таблице 10.3. Это способы создания 
источника для потоков с учетом экземпляра коллекции coll.

#### Таблица 10.3 - Создание источника

|                      Метод                      | Конечный или бесконечный? |                                                                                                 Примечания                                                                                                  |  
|:-----------------------------------------------:|:-------------------------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|                 Stream.empty()                  |         Конечный          |                                                                                    Создает stream с нулевыми элементами.                                                                                    |
|               Stream.of(varargs)                |         Конечный          |                                                                                    Создает stream со списком элементов.                                                                                     |
|                  coll.stream()                  |         Конечный          |                                                                                         Создает поток из коллекции.                                                                                         |
|              coll.parallelStream()              |         Конечный          |                                                                    Создает поток из коллекции, где поток может выполняться параллельно.                                                                     |
|           Stream. generate(supplier)            |        Бесконечный        |                                                                      Создает поток, вызывая supplier для каждого элемента по запросу.                                                                       |
|       Stream.iterate(seed, unaryOperator)       |        Бесконечный        |                              Создает поток, используя начальное значение для первого элемента, а затем вызывая унарный оператор для каждого последующего элемента по запросу.                               |
| Stream.iterate(seed, predicate, unaryOperator)  | Конечный или бесконечный  | Создает поток, используя начальное значение для первого элемента, а затем вызывая унарный оператор для каждого последующего элемента по запросу. Останавливается, если Predicate возвращает значение false. |

### Использование общих операций терминала

Вы можете выполнить терминальную операцию без каких-либо промежуточных операций, но не наоборот. Вот почему в первую 
очередь мы говорим о терминальных операциях. Сокращение — это особый тип терминальной операции, при котором все 
содержимое потока объединяется в один примитив или объект. Например, у вас может быть int или Collection.

В таблице 10.4 обобщена информация по этому разделу. Не стесняйтесь использовать его в качестве руководства, чтобы 
запомнить наиболее важные моменты, когда мы будем рассматривать каждый из них индивидуально. Мы объясняем их от простого 
к самому сложному, а не в алфавитном порядке.

#### Таблица 10.4 - Терминальные потоковые операции

|                     Метод                     | Что происходит с бесконечными потоками | Возвращаемое значение | Сокращение |  
|:---------------------------------------------:|:--------------------------------------:|:---------------------:|:----------:|
|                    count()                    |            Не прекращается             |         long          |     Да     |
|               min() <br/> max()               |            Не прекращается             |      Optional<T>      |     Да     |
|          findAny() <br/> findFirst()          |              Прекращается              |      Optional<T>      |    Нет     |
| allMatch() <br/> anyMatch() <br/> noneMatch() |          Иногда прекращается           |        boolean        |    Нет     |
|                   forEach()                   |            Не прекращается             |         void          |    Нет     |
|                   reduce()                    |            Не прекращается             |      Варьируется      |     Да     |
|                   collect()                   |            Не прекращается             |     Варьируется       |     Да     |

### Подсчет

Метод count() определяет количество элементов в конечном потоке. Для бесконечного потока он никогда не заканчивается. 
Почему? Посчитайте от 1 до бесконечности и дайте нам знать, когда закончите. Вернее, не делайте этого, потому что мы бы 
предпочли, чтобы вы готовились к экзамену, чем провели остаток жизни за счетами. Метод count() является сокращением, 
поскольку он просматривает каждый элемент в потоке и возвращает одно значение. Сигнатура метода следующая:

```
public long count()
```

В этом примере показан вызов count() для конечного потока:

```
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
System.out.println(s.count());   // 3
```

### Нахождение минимума и максимума

Методы min() и max() позволяют вам передать собственный компаратор и найти наименьшее или наибольшее значение в конечном
потоке в соответствии с этим порядком сортировки. Как и метод count(), min() и max() зависают в бесконечном потоке, 
поскольку не могут быть уверены, что меньшее или большее значение не появится позже в потоке. Оба метода являются 
сокращениями, поскольку после просмотра всего потока они возвращают одно значение. Сигнатуры метода следующие:

```
public Optional<T> min(Comparator<? super T> comparator)
public Optional<T> max(Comparator<? super T> comparator)
```

В этом примере находится животное с наименьшим количеством букв в имени:

```
Stream<String> s = Stream.of("monkey", "ape", "bonobo");
Optional<String> min = s.min((s1, s2) -> s1.length()-s2.length());
min.ifPresent(System.out::println); // ape
```

Обратите внимание, что код возвращает Optional параметр, а не значение. Это позволяет методу указать, что минимум или 
максимум не был найден. Мы используем Optional метод ifPresent() и ссылку на метод, чтобы распечатать минимум, только 
если он найден. В качестве примера того, где нет минимума, давайте рассмотрим пустой поток:

```
Optional<?> minEmpty = Stream.empty().min((s1, s2) -> 0);
System.out.println(minEmpty.isPresent()); // false
```

Поскольку поток пуст, компаратор никогда не вызывается, и в Optional отсутствует значение.

_Что, если вам нужны оба значения min() и max() для одного и того же потока? На данный момент вы не можете получить и 
то, и другое, по крайней мере, не используя эти методы. Помните, что поток может иметь только одну терминальную 
операцию. После выполнения терминальной операции поток не может быть использован повторно. Как вы увидите позже в этой 
главе, для некоторых числовых потоков существуют встроенные методы обобщения, которые вычислят набор значений для вас._

### Поиск значения

Методы findAny() и findFirst() возвращают элемент потока, если поток не пуст. Если поток пуст, они возвращают пустой 
Optional. Это первый метод, который вы видели, который может завершиться бесконечным потоком. Поскольку Java генерирует 
только тот объем потока, который вам нужен, бесконечный поток должен генерировать только один элемент.

Как следует из названия, метод findAny() может возвращать любой элемент потока. При вызове в потоках, которые вы видели 
до сих пор, он обычно возвращает первый элемент, хотя такое поведение не гарантируется. Как вы увидите в главе 13, метод 
findAny() с большей вероятностью вернет случайный элемент при работе с параллельными потоками.

Эти методы являются терминальными операциями, а не редукцией. Причина в том, что иногда они возвращаются, не обработав 
все элементы. Это означает, что они возвращают значение на основе потока, но не сводят весь поток к одному значению.

Сигнатуры метода следующие:

```
public Optional<T> findAny()
public Optional<T> findFirst()
```

В этом примере находит животное:

```
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
Stream<String> infinite = Stream.generate(() -> "chimp");

s.findAny().ifPresent(System.out::println);        // monkey (usually)
infinite.findAny().ifPresent(System.out::println); // chimp
```

Найти любое совпадение полезнее, чем кажется. Иногда нам просто хочется протестировать результаты и получить 
репрезентативный элемент, но нам не нужно тратить время на обработку, генерируя их все. В конце концов, если мы 
планируем работать только с одним элементом, зачем искать больше?

### Соответствие

Методы allMatch(), anyMatch() и noneMatch() выполняют поиск в потоке и возвращают информацию о том, как поток относится 
к предикату. Они могут завершаться, а могут и не прекращаться для бесконечных потоков. Это зависит от данных. Как и 
методы поиска, они не являются сокращениями, поскольку не обязательно рассматривают все элементы.

Сигнатуры метода следующие:

```
public boolean anyMatch(Predicate <? super T> predicate)
public boolean allMatch(Predicate <? super T> predicate)
public boolean noneMatch(Predicate <? super T> predicate)
```

В этом примере проверяется, начинаются ли имена животных с букв:

```
var list = List.of("monkey", "2", "chimp");
Stream<String> infinite = Stream.generate(() -> "chimp");
Predicate<String> pred = x -> Character.isLetter(x.charAt(0));

System.out.println(list.stream().anyMatch(pred));  // true
System.out.println(list.stream().allMatch(pred));  // false
System.out.println(list.stream().noneMatch(pred)); // false
System.out.println(infinite.anyMatch(pred));       // true
```

Это показывает, что мы можем повторно использовать один и тот же предикат, но каждый раз нам нужен другой поток. 
Метод anyMatch() возвращает значение true, поскольку два из трех элементов совпадают. Метод allMatch() возвращает 
false, поскольку ни один из них не соответствует. Метод noneMatch() также возвращает false, поскольку хотя бы одно 
совпадение. В бесконечном потоке найдено одно совпадение, поэтому вызов завершается. Если бы мы вызвали allMatch(), он
бы работал до тех пор, пока мы не завершим программу.

_Помните, что allMatch(), AnyMatch() и noneMatch() возвращают логическое значение. Напротив, методы поиска возвращают 
Optional, поскольку они возвращают элемент потока._

### Итерация 

Как и в Java Collections Framework, обычно приходится перебирать элементы потока. Как и ожидалось, вызов forEach() для 
бесконечного потока не завершается. Поскольку возвращаемого значения нет, это не сокращение.

Прежде чем использовать его, подумайте, не будет ли лучше другой подход. Разработчики, которые сначала научились писать 
циклы, обычно используют их для всего. Например, цикл с оператором if можно записать с фильтром. О фильтрах вы узнаете 
в разделе промежуточные операции.

Сигнатура метода следующая:

```
public void forEach(Consumer<? super T> action)
```

Обратите внимание, что это единственная терминальная операция, возвращающая тип void. Если вы хотите, чтобы что-то 
произошло, вы должны сделать это в Consumer. Вот один из способов распечатать элементы в потоке (есть и другие способы,
которые мы рассмотрим позже в этой главе):

```
Stream<String> s = Stream.of("Monkey", "Gorilla", "Bonobo");
s.forEach(System.out::print); // MonkeyGorillaBonobo
```

_Помните, что вы можете вызвать forEach() непосредственно в Collection или в Stream. Не запутайтесь на экзамене, 
увидев оба подхода._

Обратите внимание, что вы не можете использовать традиционный цикл for в потоке.

```
Stream<Integer> s = Stream.of(1);
for (Integer i  : s) {} // НЕ КОМПИЛИРУЕТСЯ
```

Хотя forEach() звучит как цикл, на самом деле это оператор терминала для потоков. Потоки нельзя использовать в качестве 
источника в цикле for-each, поскольку они не реализуют интерфейс Iterable.

### Сокращение

Метод reduce() объединяет поток в один объект. Это редукция, а значит, она обрабатывает все элементы. Вот три сигнатуры 
метода:

```
public T reduce(T identity, BinaryOperator<T> accumulator)

public Optional<T> reduce(BinaryOperator<T> accumulator)

public <U> U reduce(U identity,
   BiFunction<U,? super T,U> accumulator,
   BinaryOperator<U> combiner)
```

Давайте возьмем их по одному. Самый распространенный способ сокращения — начать с начального значения и продолжать 
объединять его со следующим значением. Подумайте, как можно объединить массив объектов String в одну строку без 
функционального программирования.

Это может выглядеть примерно так:

```
var array = new String[] { "w", "o", "l", "f" };
var result = "";
for (var s: array) result = result + s;
System.out.println(result); // wolf
```

Идентичность — это начальное значение сокращения, в данном случае пустая строка. Аккумулятор объединяет текущий 
результат с текущим значением в потоке. С помощью лямбда-выражения мы можем сделать то же самое с потоком и сокращением:

```
Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", (s, c) -> s + c);
System.out.println(word); // wolf
```

Обратите внимание, что у нас все еще есть пустая строка в качестве идентификатора. Мы также по-прежнему объединяем 
объекты String для получения следующего значения. Мы можем даже переписать это со ссылкой на метод:

```
Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", String::concat);
System.out.println(word); // wolf
```

Давайте попробуем еще один. Можете ли вы написать сокращение для умножения всех Integer объектов в потоке? Попробуй это. 
Наше решение показано здесь:

```
Stream<Integer> stream = Stream.of(3, 5, 6);
System.out.println(stream.reduce(1, (a, b) -> a * b));  // 90
```

Мы устанавливаем идентификатор на 1 и аккумулятор на умножение. Во многих случаях идентификатор на самом деле не 
обязателен, поэтому Java позволяет нам его опустить. Если вы не указываете идентификатор, возвращается Optional, 
поскольку данных может не быть. Есть три варианта того, что находится в Optional:

+ Если поток пуст, возвращается пустой Optional.
+ Если поток имеет один элемент, он возвращается.
+ Если поток содержит несколько элементов, для их объединения применяется сумматор.

Ниже иллюстрируется каждый из этих сценариев:

```
BinaryOperator<Integer> op = (a, b) -> a * b;
Stream<Integer> empty = Stream.empty();
Stream<Integer> oneElement = Stream.of(3);
Stream<Integer> threeElements = Stream.of(3, 5, 6);

empty.reduce(op).ifPresent(System.out::println);         // no output
oneElement.reduce(op).ifPresent(System.out::println);    // 3
threeElements.reduce(op).ifPresent(System.out::println); // 90
```

Почему существует два похожих метода? Почему бы просто не требовать всегда удостоверение личности? Java могла бы 
сделать это. Однако иногда полезно различать случай, когда поток пуст, а не случай, когда существует значение, которое 
соответствует идентификатору, возвращаемому в результате вычисления. Сигнатура, возвращающая Optional, 
позволяет нам различать эти случаи. Например, мы могли бы вернуть Optional.empty(), когда поток пуст, и Optional.of(3), 
когда есть значение.

Третья сигнатура метода используется, когда мы имеем дело с разными типами. Это позволяет Java создавать промежуточные 
сокращения, а затем объединять их в конце. Давайте посмотрим на пример, который подсчитывает количество символов в 
каждой строке:

```
Stream<String> stream = Stream.of("w", "o", "l", "f!");
int length = stream.reduce(0, (i, s) -> i+s.length(), (a, b) -> a+b);
System.out.println(length); // 5
```

Первый параметр (0) — это значение _инициализатора_. Если бы у нас был пустой поток, это был бы ответ. Второй 
параметр — аккумулятор. В отличие от _аккумуляторов_, которые вы видели ранее, этот работает со смешанными типами данных. 
В этом примере первый аргумент i — Integer, а второй аргумент s — String. Он добавляет длину текущей строки к нашему 
текущему итогу. Третий параметр называется _объединителем_, который объединяет любые промежуточные итоги. В этом случае 
a и b являются Integer.

Операция reduce() с тремя аргументами полезна при работе с параллельными потоками, поскольку она позволяет 
декомпозировать поток и повторно собирать его отдельными потоками. Например, если бы нам нужно было подсчитать длину 
четырех 100-символьных строк, первые два значения и последние два значения можно было бы вычислить независимо. Затем 
промежуточный результат (200 + 200) будет объединен в конечное значение.

### Сбор

Метод collect() — это особый тип сокращения, называемый _изменяемым сокращением_. Это более эффективно, чем обычное 
сокращение, поскольку при накоплении мы используем один и тот же изменяемый объект. К распространенным изменяемым 
объектам относятся StringBuilder и ArrayList. Это действительно полезный метод, поскольку он позволяет нам получать 
данные из потоков в другую форму. Сигнатуры метода следующие:

```
public <R> R collect(Supplier<R> supplier,
   BiConsumer<R, ? super T> accumulator,
   BiConsumer<R, R> combiner)
   
public <R,A> R collect(Collector<? super T, A,R> collector)
```

Начнем с первой сигнатуры, которая используется, когда мы хотим конкретно запрограммировать, как должен работать сбор. 
Наш пример wolf из reduce можно преобразовать для использования метода collect():

```
Stream<String> stream = Stream.of("w", "o", "l", "f");
StringBuilder word = stream.collect(
   StringBuilder::new,
   StringBuilder::append,
   StringBuilder::append);
   
System.out.println(word); // wolf
```

Первый параметр - это supplier, который создает объект, который будет сохранять результаты по мере сбора данных. 
Помните, что Supplier не принимает никаких параметров и возвращает значение. В этом случае он создает новый 
StringBuilder.

Второй параметр - это accumulator, который представляет собой BiConsumer, который принимает два параметра и ничего не 
возвращает. Он отвечает за добавление еще одного элемента к сбору данных. В этом примере он добавляет следующую строку к 
StringBuilder.

Конечным параметром является combiner, который является другим BiConsumer. Он отвечает за сбор двух наборов данных и их 
объединение. Это полезно, когда мы обрабатываем данные параллельно. Формируются две меньшие коллекции, которые затем 
объединяются в одну. Это сработало бы со StringBuilder только в том случае, если бы мы не заботились о порядке букв. В 
этом случае аккумулятор и объединитель имеют схожую логику.

Теперь давайте посмотрим на пример, где логика отличается в аккумуляторе и объединителе:

```
Stream<String> stream = Stream.of("w", "o", "l", "f");

TreeSet<String> set = stream.collect(
   TreeSet::new,
   TreeSet::add,
   TreeSet::addAll);
   
System.out.println(set); // [f, l, o, w]
```

Коллектор, как и прежде, состоит из трех частей. Поставщик создает пустой TreeSet. Накопитель добавляет одну строку из 
потока в TreeSet. Объединитель добавляет все элементы одного TreeSet в другой в случае, если операции выполнялись 
параллельно и их необходимо объединить.

Мы начали с длинной сигнатуры, потому что именно так вы реализуете свой собственный коллектор. Важно знать, как это 
сделать для сдачи экзамена, и понимать, как работают коллекторы. На практике многие обычные коллекторы появляются снова 
и снова. Вместо того чтобы заставлять разработчиков постоянно переопределять одни и те же функции, Java предоставляет 
класс с общими коллекторами, разумно названными Collectors. Такой подход также облегчает чтение кода, поскольку он 
более выразителен. Например, мы могли бы переписать предыдущий пример следующим образом:

```
Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set =
   stream.collect(Collectors.toCollection(TreeSet::new));
System.out.println(set); // [f, l, o, w]
```

Если бы нам не нужно было сортировать набор, мы могли бы сделать код еще короче:

```
Stream<String> stream = Stream.of("w", "o", "l", "f");
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o]
```

Вы можете получить другой результат для этого последнего, поскольку toSet() не дает никаких гарантий относительно того, 
какую реализацию Set вы получите. Скорее всего, это будет HashSet, но вы не должны ожидать или полагаться на это.

_На экзамене предполагается, что вы будете знать об общих предопределенных коллекторах в дополнение к возможности 
написать свой собственный, пройдя проверку поставщика, накопителя и объединителя._

Далее в этой главе мы покажем множество Collectors, которые используются для группировки данных. Это большая тема, 
поэтому лучше освоить, как работают потоки, прежде чем добавлять слишком много Collectors в микс.

### Использование общих промежуточных операций

В отличие от терминальной операции, промежуточная операция создает в качестве результата поток. Промежуточная операция 
также может обрабатывать бесконечный поток, просто возвращая другой бесконечный поток. Поскольку элементы производятся 
только по мере необходимости, это работает нормально. Работнику сборочной линии не нужно беспокоиться о том, сколько еще 
элементов пройдет, и вместо этого он может сосредоточиться на текущем элементе.

### Фильтрация

Метод filter() возвращает поток с элементами, соответствующими заданному выражению. Вот сигнатура метода:

```
public Stream<T> filter(Predicate<? super T> predicate)
```

Эту операцию легко запомнить, она эффективна, поскольку мы можем передать ей любой Predicate. Например, при этом 
сохраняются все элементы, начинающиеся с буквы m:

```
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.filter(x -> x.startsWith("m"))
    .forEach(System.out::print); // monkey
```

### Удаление дубликатов

Метод distinct() возвращает поток с удаленными повторяющимися значениями. Для удаления дубликаты не обязательно должны 
находиться рядом. Как вы можете себе представить, Java вызывает метод equals(), чтобы определить, эквивалентны ли 
объекты. Сигнатура метода следующая:

```
public Stream<T> distinct()
```

Вот пример:

```
Stream<String> s = Stream.of("duck", "duck", "duck", "goose");
s.distinct()
   .forEach(System.out::print); // duckgoose
```

### Ограничение по позиции

Ограничение по положению. Методы limit() и skip() могут уменьшить размер потока, а метод limit() может создать конечный 
поток из бесконечного потока. Сигнатуры метода показаны здесь:

```
public Stream<T> limit(long maxSize)
public Stream<T> skip(long n)
```

Следующий код создает бесконечный поток чисел, считая с 1. Операция skip() возвращает бесконечный поток, начиная с 
чисел, считая с 6, поскольку она пропускает первые пять элементов. Вызов limit() принимает первые два из них. Теперь у
нас есть конечный поток с двумя элементами, который затем можно распечатать с помощью метода forEach():

```
Stream<Integer> s = Stream.iterate(1, n -> n + 1);
s.skip(5)
   .limit(2)
   .forEach(System.out::print); // 67
```

### Cопоставление

Метод map() создает взаимно однозначное сопоставление элементов в потоке с элементами следующего шага в потоке. 
Сигнатура метода выглядит следующим образом:

```
public <R> Stream<R> map(Function<? super T, ? extends R> mapper)
```

Этот выглядит более сложным, чем другие, которые вы видели. Он использует лямбда-выражение, чтобы определить тип, 
передаваемый этой функции, и возвращаемый. Возвращаемый тип - это возвращаемый поток.

_Метод map() в потоках предназначен для преобразования данных. Не путайте его с интерфейсом Map, который сопоставляет 
ключи со значениями._

Например, этот код преобразует список объектов String в список объектов Integer, представляющих их длину:

```
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.map(String::length)
   .forEach(System.out::print); // 676
```

Помните, что String::length — это сокращение от лямбда x -> x.length(), что ясно показывает, что это функция, 
преобразующая String в Integer.

### Используя flatMap

Метод flatMap() принимает каждый элемент в потоке и объединяет все элементы, которые он содержит, в один поток. Это 
полезно, если вы хотите удалить пустые элементы из потока или объединить поток списков. Мы показываем вам сигнатуру 
метода для обеспечения согласованности с другими методами, чтобы вы не думали, что мы что-то скрываем. Вы вряд ли 
сможете прочитать это:

```
public <R> Stream<R> flatMap(
   Function<? super T, ? extends Stream<? extends R>> mapper)
```

Эта бессмыслица в основном говорит о том, что она возвращает поток того типа, который функция содержит на более низком 
уровне. Не беспокойтесь о подписи. Это головная боль.

То, что вы должны понять, - это пример. Это переводит всех животных на один уровень и удаляет пустой список.

```
List<String> zero = List.of(); 
var one = List.of("Bonobo"); 
var two = List.of("Mama Gorilla", "Baby Gorilla"); 
Stream<List<String>> animals = Stream.of(zero, one, two);

animals.flatMap(m -> m.stream())
  .forEach(System.out::println);
```

Вот результат:

```
Bonobo
Mama Gorilla
Baby Gorilla
```

Как вы можете видеть, он полностью удалил пустой список и изменил все элементы каждого списка так, чтобы они находились 
на верхнем уровне потока.

---

**Объединение потоков**

Хотя функция flatMap() хороша для общего случая, существует более удобный способ объединения двух потоков:

```
var one = Stream.of("Bonobo");
var two = Stream.of("Mama Gorilla", "Baby Gorilla");

Stream.concat(one, two)
   .forEach(System.out::println);
```

В результате будут созданы те же три строки, что и в предыдущем примере. Два потока объединяются и вызывается 
терминальная операция forEach().

--- 

### Сортировка

Метод sorted() возвращает поток с отсортированными элементами. Как и при сортировке массивов, Java использует 
естественный порядок, если мы не укажем компаратор. Сигнатуры метода следующие:

```
public Stream<T> sorted()
public Stream<T> sorted(Comparator<? super T> comparator)
```

При вызове первой подписи используется порядок сортировки по умолчанию.

```
Stream<String> s = Stream.of("brown-", "bear-");
s.sorted()
   .forEach(System.out::print); // bear-brown
```

При желании мы можем использовать реализацию Comparator через метод или лямбда-выражение. В этом примере мы используем 
метод:

```
Stream<String> s = Stream.of("brown bear-", "grizzly-");
s.sorted(Comparator.reverseOrder())
    .forEach(System.out::print); // grizzly-brown bear
```

Здесь мы передаем Comparator, чтобы указать, что мы хотим сортировать в порядке, обратном естественному. Готовы к 
сложному? Вы понимаете, почему это не компилируется?

```
Stream<String> s = Stream.of("brown bear-", "grizzly-");
s.sorted(Comparator::reverseOrder);  // НЕ КОМПИЛИРУЕТСЯ
```

Взгляните еще раз на вторую сигнатуру метода sorted(). Ему требуется Comparator — функциональный интерфейс, который 
принимает два параметра и возвращает целое число. Однако Comparator::reverseOrder этого не делает. Поскольку метод 
reverseOrder() не принимает аргументов и возвращает значение, ссылка на метод эквивалентна 
() -> Comparator.reverseOrder(), который на самом деле является Supplier<Comparator>. Это несовместимо с sorted(). Мы 
упомянули об этом, чтобы напомнить вам, что вам действительно необходимо хорошо знать ссылки на методы.

### Пытаюсь посмотреть

Метод peek() — наша последняя промежуточная операция. Это полезно для отладки, поскольку позволяет выполнять операцию с 
потоком без изменения потока. Сигнатура метода следующая:

```
public Stream<T> peek(Consumer<? super T> action)
```

Вы могли заметить, что промежуточная операция peek() принимает тот же аргумент, что и терминальная операция forEach(). 
Думайте о peek() как о промежуточной версии forEach(), которая возвращает вам исходный поток.

Чаще всего peek() используется для вывода содержимого потока по мере его прохождения. Предположим, мы допустили опечатку 
и посчитали медведей, начинающихся с буквы g вместо b. Мы озадачены, почему счетчик равен 1, а не 2. Мы можем добавить 
метод peek(), чтобы выяснить, почему.

```
var stream = Stream.of("black bear", "brown bear", "grizzly");
long count = stream.filter(s -> s.startsWith("g"))
   .peek(System.out::println).count();              // grizzly
System.out.println(count);                          // 1
```

В главе 9 вы видели, что peek() просматривает только первый элемент при работе с очередью. В потоке функция peek() 
просматривает каждый элемент, проходящий через эту часть конвейера потока. Это похоже на то, как если бы работник делал 
заметки о том, как проходит конкретный этап процесса.

---

**Сценарий реального мира**
 
#### Опасность: изменение состояния с помощью peek()

Помните, что функция peek() предназначена для выполнения операции без изменения результата. Вот простой потоковый 
конвейер, который не использует peek():

```
var numbers = new ArrayList<>();
var letters = new ArrayList<>();
numbers.add(1);
letters.add('a');

Stream<List<?>> stream = Stream.of(numbers, letters);
stream.map(List::size).forEach(System.out::print); // 11
```

Теперь мы добавляем вызов peek() и отмечаем, что Java не мешает нам писать плохой код просмотра:

```
Stream<List<?>> bad = Stream.of(numbers, letters);
bad.peek(x -> x.remove(0))
   .map(List::size)
   .forEach(System.out::print); // 00
```

Этот пример плох, потому что peek() изменяет структуру данных, используемую в потоке, из-за чего результат конвейера 
потока будет отличаться от результата, который был бы в случае отсутствия просмотра.

---

### Собираем конвейер

Потоки позволяют вам использовать цепочки и выражать то, чего вы хотите достичь, а не то, как это сделать. Допустим, мы 
хотели получить первые два имени наших друзей в алфавитном порядке длиной в четыре символа. Без потоков нам пришлось бы 
написать что-то вроде следующего:

```
var list = List.of("Toby", "Anna", "Leroy", "Alex");
List<String> filtered = new ArrayList<>();
for (String name: list)
   if (name.length() == 4) filtered.add(name);
Collections.sort(filtered);
var iter = filtered.iterator();
if (iter.hasNext()) System.out.println(iter.next());
if (iter.hasNext()) System.out.println(iter.next());
```

Это работает. Чтобы понять, что происходит, нужно немного прочитать и подумать. Проблема, которую мы пытаемся решить, 
теряется в реализации. Он также очень сосредоточен на том, как, а не на том, что. Для потоков эквивалентный код выглядит 
следующим образом:

```
var list = List.of("Toby", "Anna", "Leroy", "Alex");
list.stream().filter(n -> n.length() == 4).sorted()
   .limit(2).forEach(System.out::println);
```

Прежде чем сказать, что читать сложнее, давайте отформатируем его.

```
var list = List.of("Toby", "Anna", "Leroy", "Alex");
list.stream()
   .filter(n -> n.length() == 4)
   .sorted()
   .limit(2)
   .forEach(System.out::println);
```

Разница в том, что мы выражаем то, что происходит. Нас интересуют объекты String длиной 4. Затем мы хотим их 
отсортировать. Тогда нам нужны первые два. Затем мы хотим их распечатать. Это лучше соответствует проблеме, которую мы 
пытаемся решить, и проще.

Как только вы начнете использовать потоки в своем коде, вы можете обнаружить, что используете их во многих местах. 
Иметь более короткий, краткий и понятный код — это определенно хорошо!

В этом примере вы видите все три части конвейера. На рисунке 10.5 показано, как каждая промежуточная операция в 
конвейере переходит в следующую.

#### Рис. 10.5 - Потоковый конвейер с несколькими промежуточными операциями


Помните, что руководитель сборочной линии выясняет, как наилучшим образом реализовать потоковый конвейер. Они расставили 
все столы с инструкциями подождать, прежде чем начинать. Они говорят работнику limit() сообщить им, когда пройдут два 
элемента. Они сообщают работнику sorted(), что они должны просто собрать все элементы по мере их поступления и 
отсортировать их все сразу. После сортировки они должны начать передавать их работнику limit() по одному за раз. Поток 
данных выглядит следующим образом:

1. Метод stream() отправляет Toby в filter(). Метод filter() видит, что длина хорошая, и отправляет Toby в sorted(). 
Метод sorted() пока не может выполнить сортировку, потому что ему нужны все данные, поэтому он содержит Toby.
2. Метод stream() отправляет Anna в filter(). Метод filter() видит, что длина хорошая, и отправляет Anna в sorted(). 
Метод sorted() пока не может выполнить сортировку, потому что ему нужны все данные, поэтому он содержит Anna.
3. Метод stream() отправляет Leroy в filter(). Метод filter() видит, что длина не совпадает, и выводит Leroy из 
обработки на конвейере сборки.
4. Метод stream() отправляет Alex в filter(). Метод filter() видит, что длина хорошая, и отправляет Alex в sorted(). 
Метод sorted() пока не может выполнить сортировку, потому что ему нужны все данные, поэтому он содержит Alex. 
Оказывается, sorted() действительно содержит все необходимые данные, но он еще не знает об этом.
5. Администратор сообщает sorted(), что пришло время выполнить сортировку, и сортировка выполняется.
6. Метод sorted() отправляет Alex в limit(). Метод limit() запоминает, что он видел один элемент, и отправляет Alex в 
forEach(), выводя Alex.
7. Метод sorted() отправляет Anna в limit(). Метод limit() запоминает, что он видел два элемента, и отправляет Anna в 
forEach(), выводя Anna.
8. Метод limit() теперь увидел все необходимые элементы и сообщает об этом администратору. Администратор останавливает 
линию, и в конвейере больше не происходит обработки.

Имеет смысл? Давайте попробуем привести еще несколько примеров, чтобы убедиться, что вы хорошо это понимаете. Как вы 
думаете, что делает следующее?

```
Stream.generate(() -> "Elsa")
   .filter(n -> n.length() == 4)
   .sorted()
   .limit(2)
   .forEach(System.out::println);
```

Он зависает до тех пор, пока вы не завершите работу программы, или он выдает исключение после исчерпания памяти. 
Администратор проинструктировал sorted() подождать, пока не будет представлено все, что нужно отсортировать. Этого 
никогда не происходит, потому что существует бесконечный поток. Как насчет этого примера?

```
Stream.generate(() -> "Elsa")
   .filter(n -> n.length() == 4)   
   .limit(2)   
   .sorted()   
   .forEach(System.out::println);
```

На этом фото Elsa напечатана дважды. Фильтр пропускает элементы, а функция limit() останавливает предыдущие операции 
после двух элементов. Теперь sorted() может выполнять сортировку, потому что у нас есть конечный список. Наконец, как вы 
думаете, что это дает?

```
Stream.generate(() -> "Olaf Lazisson")
   .filter(n -> n.length() == 4)
   .limit(2)   
   .sorted()   
   .forEach(System.out::println);
```

Этот тоже зависает до тех пор, пока мы не завершим работу программы. Фильтр ничего не пропускает, поэтому функция 
limit() никогда не видит два элемента. Это означает, что мы должны продолжать ждать и надеяться, что они появятся.

```
30: long count =  Stream.of("goldfish", "finch") 
31:    .filter(s -> s.length()> 5) 
32:    .collect(Collectors.toList()) 
33:    .stream() 
34:    .count(); 
35: System.out.println(count);   // 1
```

Линии 30–32 — это один конвейер, а линии 33 и 34 — другой. Для первого конвейера строка 30 является исходной, а строка 
32 — конечной операцией. Для второго конвейера строка 33 является исходной, а строка 34 — конечной операцией. Вот это 
сложный способ вывода числа 1!

_На экзамене в качестве вариантов ответа вы можете увидеть длинные или сложные конвейеры. Если это произойдет, 
сосредоточьтесь на различиях между ответами. Это будут ваши подсказки к правильному ответу. Этот подход также сэкономит 
ваше время, поскольку вам не придется изучать весь конвейер по каждому варианту._

Когда вы видите связанные конвейеры, обратите внимание, где находятся исходные и терминальные операции. Это поможет вам 
следить за происходящим. Вы даже можете переписать код в своей голове, чтобы между ними была переменная, чтобы он не был 
таким длинным и сложным. Наш предыдущий пример можно записать следующим образом:

```
List<String> helper =  Stream.of("goldfish", "finch")
   .filter(s -> s.length()> 5)
   .collect(Collectors.toList());
long count = helper.stream()
   .count();
System.out.println(count);
```

Какой стиль вы используете, зависит от вас. Однако перед сдачей экзамена вам необходимо уметь читать оба стиля.

## Работа с примитивными потоками

До сих пор все созданные нами потоки использовали интерфейс Stream с универсальным типом, например Stream<String>, 
Stream<Integer> и т. д. Для числовых значений мы использовали классы-оболочки. Мы сделали это с Collections API в 
главе 9, поэтому это должно выглядеть естественно.

На самом деле Java помимо Stream включает и другие классы потоков, которые можно использовать для работы с выбранными 
примитивами: int, double и long. Давайте разберемся, зачем это нужно. Предположим, мы хотим вычислить сумму чисел в 
конечном потоке:

```
Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.reduce(0, (s, n) -> s + n));  // 6
```

Неплохо. Написать сокращение не составило труда. Мы запустили аккумулятор с нуля. Затем мы добавили каждое число к этой 
промежуточной сумме по мере того, как оно появлялось в потоке. Есть еще один способ сделать это, показанный здесь:

```
Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.mapToInt(x -> x).sum());  // 6
```

На этот раз мы преобразовали наш Stream<Integer> в IntStream и попросили IntStream вычислить для нас сумму. IntStream 
имеет многие из тех же промежуточных и терминальных методов, что и Stream, но включает в себя специализированные методы 
для работы с числовыми данными. Примитивные потоки умеют автоматически выполнять некоторые общие операции.

Пока что это кажется приятным удобством, но не очень важным. Теперь подумайте, как бы вы вычислили среднее значение. 
Вам нужно разделить сумму на количество элементов. Проблема в том, что потоки допускают только один проход. Java 
признает, что вычисление среднего значения является обычным делом, и предоставляет метод вычисления среднего значения 
для классов потоков для примитивов.

```
IntStream intStream = IntStream.of(1, 2, 3); 
OptionalDouble avg = intStream.average(); 
System.out.println(avg.getAsDouble());  // 2.0
```

Вычислить среднее значение не только возможно, но и легко это сделать. Очевидно, что примитивные потоки важны. Мы 
рассмотрим создание и использование таких потоков, включая дополнительные возможности и функциональные интерфейсы.

### Создание примитивных потоков

Вот три типа примитивных потоков:

+ IntStream: Используется для примитивных типов int, short, byte и char
+ LongStream: Используется для примитивного типа long
+ DoubleStream: Используется для примитивных типов double и float

Почему у каждого примитивного типа нет своего собственного примитивного потока? Эти три являются наиболее 
распространенными, поэтому разработчики API выбрали их.

_Когда вы видите на экзамене поток слов, обратите внимание на регистр. С большой буквы или в коде Stream — это имя 
класса, содержащего тип Object. Если использовать строчную букву s, поток — это концепция, которая может быть Stream, 
DoubleStream, IntStream или LongStream._

В таблице 10.5 показаны некоторые методы, уникальные для примитивных потоков. Обратите внимание, что мы не включаем в 
таблицу такие методы, как empty(), которые вы уже знаете из интерфейса Stream.

#### Таблица 10.5 - Общие примитивные потоковые методы

|                    Метод                     |               Примитивный поток               |                                                            Описание                                                             |  
|:--------------------------------------------:|:---------------------------------------------:|:-------------------------------------------------------------------------------------------------------------------------------:|
|           OptionalDouble average()           | IntStream <br/> LongStream <br/> DoubleStream |                                                Среднее арифметическое элементов                                                 |
|              Stream<T> boxed()               | IntStream <br/> LongStream <br/> DoubleStream |                              Stream<T>, где T — класс-оболочка, связанная с примитивным значением.                              |
|              OptionalInt max()               |                   IntStream                   |                                                   Максимальный элемент потока                                                   |
|              OptionalLong max()              |                  LongStream                   |                                                                                                                                 |
|             OptionalDouble max()             |                 DoubleStream                  |                                                                                                                                 |
|              OptionalInt min()               |                   IntStream                   |                                                   Минимальный элемент потока                                                    |
|              OptionalLong min()              |                  LongStream                   |                                                                                                                                 |
|             OptionalDouble min()             |                 DoubleStream                  |                                                                                                                                 |
|        IntStream range(int a, int b)         |                   IntStream                   |                              Возвращает примитивный поток от a (включительно) до b (исключительно)                              |
|       LongStream range(long a, long b)       |                  LongStream                   |                                                                                                                                 |
|     IntStream rangeClosed(int a, int b)      |                   IntStream                   |                              Возвращает примитивный поток от a (включительно) до b (включительно).                              |
|    LongStream rangeClosed(long a, long b)    |                  LongStream                   |                                                                                                                                 |
|                  int sum()                   |                   IntStream                   |                                               Возвращает сумму элементов в потоке                                               |
|                  long sum()                  |                  LongStream                   |                                                                                                                                 |
|                 double sum()                 |                 DoubleStream                  |                                                                                                                                 |
|   IntSummaryStatistics summaryStatistics()   |                   IntStream                   | Возвращает объект, содержащий многочисленные статистические данные потока, такие как среднее, минимальное, максимальное и т.д.  |
|  LongSummaryStatistics summaryStatistics()   |                  LongStream                   |                                                                                                                                 |
| DoubleSummaryStatistics summaryStatistics()  |                 DoubleStream                  |                                                                                                                                 |


Некоторые методы создания примитивного потока эквивалентны тому, как мы создавали источник обычного потока. Вы можете 
создать пустой поток следующим образом:

```
DoubleStream empty = DoubleStream.empty();
```

Другой способ — использовать фабричный метод of() для одного значения или использовать перегрузку varargs.

```
DoubleStream oneValue = DoubleStream.of(3.14);
oneValue.forEach(System.out::println);

DoubleStream varargs = DoubleStream.of(1.0, 1.1, 1.2);
varargs.forEach(System.out::println);
```

Этот код выводит следующее:

```
3.14
1.0
1.1
1.2
```

Вы также можете использовать два метода для создания бесконечных потоков, как мы это делали с Stream.

```
var random = DoubleStream.generate(Math::random); 
var fractions = DoubleStream.iterate(.5, d -> d / 2); 
random.limit(3).forEach(System.out::println); 
fractions.limit(3).forEach(System.out::println);
```

Поскольку потоки бесконечны, мы добавили промежуточную операцию ограничения, чтобы выходные данные не выводили значения 
вечно. Первый поток вызывает static метод Math, чтобы получить случайное double значение. Поскольку числа случайны, ваш 
результат, очевидно, будет другим. Второй поток продолжает создавать меньшие числа, каждый раз деля предыдущее значение 
на два. Результат выполнения этого кода был следующим:

```
0.07890654781186413
0.28564363465842346
0.6311403511266134
0.5
0.25
0.125
```

Вам не обязательно знать это для экзамена, но класс Random предоставляет метод для прямого получения примитивных потоков 
случайных чисел. Интересный факт! Например, ints() генерирует бесконечный поток примитивов IntStream.

Это работает одинаково для каждого типа примитивного потока. Когда имеешь дело с int или long примитивами, обычно 
приходится считать. Предположим, нам нужен поток с числами от 1 до 5. Мы могли бы написать это, используя то, что мы 
объяснили до сих пор:

```
IntStream count = IntStream.iterate(1, n -> n+1).limit(5);
count.forEach(System.out::print); // 12345
```

Этот код распечатывает цифры 1–5. Однако для того, чтобы сделать что-то настолько простое, требуется много кода. 
Java предоставляет метод, который может генерировать диапазон чисел.

```
IntStream range = IntStream.range(1, 6); 
range.forEach(System.out::print); // 12345
```

Это лучше. Если нам нужны были номера 1–5, почему мы пропустили 1–6? Первый параметр метода range() является 
инклюзивным, что означает, что он включает число. Второй параметр метода range() является исключительным, что означает, 
что он останавливается прямо перед этим числом. Однако все еще могло быть яснее. Нам нужны цифры от 1 до 5 включительно. 
К счастью, есть еще один метод, rangeClosed(), который включает оба параметра.

```
IntStream rangeClosed = IntStream.rangeClosed(1, 5);
rangeClosed.forEach(System.out::print); // 12345
```

Даже лучше. На этот раз мы заявили, что нам нужен закрытый диапазон или инклюзивный диапазон. Этот метод лучше 
соответствует тому, как мы выражаем диапазон чисел простым английским языком.

### Сопоставление потоков

Другой способ создания примитивного потока — сопоставление с потоком другого типа. В таблице 10.6 показано, что 
существует метод сопоставления между любыми типами потоков.

#### Таблица 10.6 - Методы сопоставления между типами потоков

| Класс исходного потока | Для создания Stream | Для создания DoubleStream | Для создания IntStream | Для создания LongStream |  
|:----------------------:|:-------------------:|:-------------------------:|:----------------------:|:-----------------------:|
|       Stream<T>        |        map()        |       mapToDouble()       |       mapToInt()       |       mapToLong()       |
|      DoubleStream      |     mapToObj()      |           map()           |       mapToInt()       |       mapToLong()       |
|       IntStream        |     mapToObj()      |       mapToDouble()       |         map()          |       mapToLong()       |
|      LongStream        |     mapToObj()      |      mapToDouble()        |       mapToInt()       |          map()          |

Очевидно, что для того, чтобы это работало, они должны быть совместимыми типами. Java требует, чтобы функция 
сопоставления была предоставлена в качестве параметра, например:

```
Stream<String> objStream = Stream.of("penguin", "fish");
IntStream intStream = objStream.mapToInt(s -> s.length());
```

Эта функция принимает объект, который в данном случае является строкой. Функция возвращает int. Сопоставление функций 
здесь интуитивно понятно. Они принимают исходный тип и возвращают целевой тип. В этом примере фактический тип 
функции — ToIntFunction. В таблице 10.7 показаны названия функций сопоставления. Как видите, они делают то, что вы 
ожидаете.

Вам необходимо запомнить таблицу 10.6 и таблицу 10.7. Это не так сложно, как может показаться. В названиях есть 
закономерности, если запомнить несколько правил. В Таблице 10.6 сопоставление с тем же типом, с которого вы начали, 
называется просто map(). При возврате потока объектов используется метод mapToObj(). Кроме того, это имя примитивного 
типа в имени метода карты.

Что касается таблицы 10.7, вы можете начать с размышления о типах источника и цели. Если целевым типом является объект, 
вы удаляете слово "To" из имени. Если сопоставление происходит с тем же типом, с которого вы начали, вы используете 
унарный оператор вместо функции для примитивных потоков.

**Использование FlatMap()**

Мы можем использовать этот подход и для примитивных потоков. Он работает так же, как и в обычном потоке, за исключением 
того, что имя метода отличается. Вот пример:

```
var integerList = new ArrayList<Integer>();
IntStream ints = integerList.stream()
   .flatMapToInt(x -> IntStream.of(x));
DoubleStream doubles = integerList.stream()
   .flatMapToDouble(x -> DoubleStream.of(x));
LongStream longs = integerList.stream()
   .flatMapToLong(x -> LongStream.of(x));
```

#### Таблица 10.7 - Параметры функции при сопоставлении между типами потоков

| Класс исходного потока | Для создания Stream | Для создания DoubleStream | Для создания IntStream | Для создания LongStream |  
|:----------------------:|:-------------------:|:-------------------------:|:----------------------:|:-----------------------:|
|       Stream<T>        |    Function<T,R>    |   ToDouble Function<T>    |   ToInt Function<T>    |   ToLong Function<T>    |
|      DoubleStream      | Double Function<R>  |   DoubleUnary Operator    |  DoubleToInt Function  |  DoubleToLong Function  |
|       IntStream        |   IntFunction<R>    |   IntToDouble Function    |   IntUnary Operator    |   IntToLong Function    |
|      LongStream        |  Long Function<R>   |  LongToDouble Function    |  LongToInt Function    |   LongUnary Operator    |


Кроме того, вы можете создать поток из примитивного потока. Эти методы показывают два способа достижения этой цели:

```
private static Stream<Integer> mapping(IntStream stream) {    
   return stream.mapToObj(x -> x);
}

private static Stream<Integer> boxing(IntStream stream) {
  return stream.boxed();
}
```

Первый использует метод mapToObj(), который мы видели ранее. Второе более лаконично. Для него не требуется функция 
сопоставления, поскольку все, что он делает, — это автоматически упаковывает каждый примитив в соответствующий 
объект-оболочку. Метод boxed() существует для всех трех типов примитивных потоков.

### Использование Optional с примитивными потоками

Ранее в этой главе мы написали метод для вычисления среднего значения int[] и пообещали, что позже мы предложим лучший 
способ. Теперь, когда вы знаете о примитивных потоках, вы можете вычислить среднее значение в одной строке.

```
var stream = IntStream.rangeClosed(1,10);
OptionalDouble optional = stream.average();
```

Тип возвращаемого значения не является Optional, к которому вы привыкли. Это новый тип под названием OptionalDouble. 
Почему у нас есть отдельный тип, спросите вы? Почему бы просто не использовать Optional<Double>? Разница в том, что
OptionalDouble предназначен для примитива, а Optional<Double> — для класса-оболочки Double. Работа с примитивным 
необязательным классом похожа на работу с самим Optional классом.

```
optional.ifPresent(System.out::println);                  // 5.5 
System.out.println(optional.getAsDouble());               // 5.5 
System.out.println(optional.orElseGet(() -> Double.NaN)); // 5.5
```

Единственное заметное отличие состоит в том, что мы вызвали getAsDouble(), а не get(). Это дает понять, что мы работаем 
с примитивом. Кроме того, orElseGet() принимает DoubleSupplier вместо поставщика.

Как и в случае с примитивными потоками, для примитивов существует три класса, специфичных для каждого типа. В таблице 
10.8 показаны незначительные различия между этими тремя. Вероятно, вы не удивитесь, узнав, что вам придется выучить и 
эту таблицу. Это действительно легко запомнить, поскольку единственным изменением является примитивное имя. Как вы 
помните из раздела «Терминальные операции», ряд потоковых методов возвращают необязательный параметр, например min() или 
findAny(). Каждый из них возвращает соответствующий необязательный тип. Реализации примитивного потока также добавляют 
два новых метода, которые вам необходимо знать. Метод sum() не возвращает необязательное значение. Если вы попытаетесь 
сложить пустой поток, вы просто получите ноль. Метод average() всегда возвращает OptionalDouble, поскольку среднее 
значение потенциально может иметь дробные данные для любого типа.

#### Таблица 10.8 - Optional типы для примитивов

|                                          | OptionalDouble |   OptionalInt   |  OptionalLong   |  
|:----------------------------------------:|:--------------:|:---------------:|:---------------:|
|          Становимся примитивным          | getAsDouble()  |   getAsInt()    |   getAsLong()   |
|        orElseGet() тип параметра         | DoubleSupplier |   IntSupplier   |  LongSupplier   |
| Тип возвращаемого значения max() и min() | OptionalDouble |   OptionalInt   |  OptionalLong   |
|     Тип возвращаемого значения sum()     |     double     |       int       |      long       |
|   Тип возвращаемого значения average()   | OptionalDouble | OptionalDouble  | OptionalDouble  |

Давайте попробуем пример, чтобы убедиться, что вы это понимаете:

```
5: LongStream longs = LongStream.of(5, 10); 
6: long sum = longs.sum(); 
7: System.out.println(sum);     // 15 
8: DoubleStream doubles = DoubleStream.generate(() -> Math.PI); 
9: OptionalDouble min = doubles.min(); // runs infinitely
```

Строка 5 создает поток long примитивов с двумя элементами. Строка 6 показывает, что мы не используем необязательный 
параметр для вычисления суммы. Строка 8 создает бесконечный поток double примитивов. Строка 9 напоминает вам, что вопрос 
о коде, который выполняется бесконечно, может возникнуть и с примитивными потоками.

### Обобщение статистических данных

Вы узнали достаточно, чтобы получить максимальное значение из потока примитивов типа int. Если поток пуст, мы хотим 
сгенерировать исключение.

```
private static int max(IntStream ints) {
   OptionalInt optional = ints.max();
   return optional.orElseThrow(RuntimeException::new);
}
```

Это должно быть уже старая шляпа. Мы получили OptionalInt, потому что у нас есть IntStream. Если необязательный параметр 
содержит значение, мы возвращаем его. В противном случае мы создадим новое исключение RuntimeException.

Теперь мы хотим изменить метод, чтобы он принимал IntStream и возвращал диапазон. Диапазон представляет собой 
минимальное значение, вычтенное из максимального значения. Ой-ой. И min(), и max() являются терминальными операциями, а 
это означает, что они используют поток при запуске. Мы не можем выполнить две терминальные операции над одним и тем же 
потоком. К счастью, это распространенная проблема, и примитивные потоки решают ее за нас с помощью сводной статистики. 
Статистика — это просто громкое слово, обозначающее число, рассчитанное на основе данных.

```
private static int range(IntStream ints) {
   IntSummaryStatistics stats = ints.summaryStatistics();
   if (stats.getCount() == 0) throw new RuntimeException();
   return stats.getMax()-stats.getMin();
}
```

Здесь мы попросили Java выполнить множество вычислений относительно потока. Сводная статистика включает в себя 
следующее:

+ getCount(): Возвращает значение long, представляющее количество значений.
+ getAverage(): Возвращает значение double, представляющее среднее значение. Если поток пуст, возвращает 0.
+ getSum(): Возвращает сумму как double для DoubleSummaryStream и long для IntSummaryStream и LongSummaryStream.
+ getMin(): Возвращает наименьшее число (минимум) в формате double, int или long, в зависимости от типа потока. Если 
поток пуст, возвращает наибольшее числовое значение в зависимости от типа.
+ getMax(): Возвращает наибольшее число (максимум) в формате double, int или long в зависимости от типа потока. Если 
поток пуст, возвращает наименьшее числовое значение в зависимости от типа.

## Работа с расширенными концепциями потокового конвейера

Поздравляем, у вас осталось всего несколько тем! В этом последнем разделе о потоках мы узнаем о взаимосвязи между 
потоками и базовыми данными, объединении в цепочки Optional и группировке сборщиков. После этого вы должны стать 
профессионалом в области стримов!

### Связывание потоков с базовыми данными

Как вы думаете, что это дает?

```
25: var cats = new ArrayList<String>(); 
26: cats.add("Annie"); 
27: cats.add("Ripley"); 
28: var stream = cats.stream(); 
29: cats.add("KC"); 
30: System.out.println(stream.count());
```

Правильный ответ — 3. Строки 25–27 создают List с двумя элементами. Строка 28 запрашивает создание потока из этого List. 
Помните, что потоки оцениваются лениво. Это означает, что поток не создается в строке 28. Создается объект, который 
знает, где искать данные, когда они потребуются. В строке 29 List получает новый элемент. В строке 30 работает потоковый 
конвейер. Сначала он смотрит на источник и видит три элемента.

### Цепочка опций

К настоящему моменту вы знакомы с преимуществами объединения операций в потоковом конвейере. Некоторые промежуточные 
операции для потоков доступны как Optional.

Предположим, вам дан Optional<Integer> и вас просят распечатать значение, но только если оно представляет собой 
трехзначное число. Без функционального программирования вы могли бы написать следующее:

```
private static void threeDigit(Optional<Integer> optional) {
   if (optional.isPresent()) {  // outer if
      var num = optional.get();
      var string = "" + num;
      if (string.length() == 3) // inner if
         System.out.println(string);
   }
}
```

Это работает, но содержит вложенные операторы if. Это дополнительная сложность. Давайте попробуем это еще раз с помощью 
функционального программирования:

```
private static void threeDigit(Optional<Integer> optional) {
   optional.map(n -> "" + n)            // part 1
      .filter(s -> s.length() == 3)     // part 2
      .ifPresent(System.out::println);  // part 3
}
```

Это гораздо короче и выразительнее. При использовании лямбда-выражений на экзамене принято выделять одно утверждение и 
идентифицировать его части с помощью комментария. Мы сделали это здесь, чтобы показать, что происходит при подходах 
функционального и нефункционального программирования.

Предположим, что нам дан пустой Optional. Первый подход возвращает false для внешнего оператора if. Второй подход видит 
пустой Optional и пропускает его как через map(), так и через filter(). Тогда ifPresent() увидит пустой Optional и не 
вызовет параметр Consumer.

В следующем случае нам дан Optional.of(4). Первый подход возвращает false для внутреннего оператора if. Второй подход 
сопоставляет число 4 с «4». Затем filter() возвращает пустой Optional, поскольку фильтр не соответствует, а ifPresent() 
не вызывает параметр Consumer.

Последний случай — это когда нам дается Optional.of(123). Первый подход возвращает true для обоих операторов if. Второй 
подход сопоставляет число 123 со значением «123». Затем filter() возвращает тот же Optional, а ifPresent() теперь 
вызывает параметр Consumer.

Теперь предположим, что мы хотим получить Optional<Integer>, представляющий длину строки, содержащейся в другом 
Optional. Достаточно легко:

```
Optional<Integer> result = optional.map(String::length);
```

Что, если бы у нас был вспомогательный метод, который выполнял бы за нас логику вычисления чего-то, возвращающего 
Optional<Integer>? Использование карты не работает:

```
Optional<Integer> result = optional
   .map(ChainingOptionals::calculator); // НЕ КОМПИЛИРУЕТСЯ
```

Проблема в том, что калькулятор возвращает Optional<Integer>. Метод map() добавляет еще один Optional, предоставляя нам
Optional<Optional<Integer>>. Ну, это нехорошо. Решение состоит в том, чтобы вместо этого вызвать flatMap():

```
Optional<Integer> result = optional
   .flatMap(ChainingOptionals::calculator);
```

Это работает, потому что flatMap удаляет ненужный слой. Другими словами, это сглаживает результат. Объединение вызовов 
flatMap() полезно, когда вы хотите преобразовать один Optional тип в другой.

---

**Сценарий реального мира**

**Проверенные исключения и функциональные интерфейсы**

Возможно, вы уже заметили, что большинство функциональных интерфейсов не объявляют проверенные исключения. Обычно это 
нормально. Однако это проблема при работе с методами, объявляющими проверенные исключения. Предположим, у нас есть класс 
с методом, который выдает проверенное исключение:

```
import java.io.*; 
import java.util.*;
public class ExceptionCaseStudy {
   private static List<String> create() throws IOException {
      throw new IOException();
   }
}
```

Теперь мы используем его в потоке:

```
public void good() throws IOException {
   ExceptionCaseStudy.create().stream().count();
}
```

Здесь нет ничего нового. Метод create() генерирует проверенное исключение. Вызывающий метод обрабатывает или объявляет 
его. А что насчет этого?

```
public void bad() throws IOException {
   Supplier<List<String>> s = ExceptionCaseStudy::create; // НЕ КОМПИЛИРУЕТСЯ
}
```

Фактическая ошибка компилятора выглядит следующим образом:

```
unhandled exception type IOException
```

Что теперь сказать? Проблема в том, что лямбда, к которой расширяется эта ссылка на метод, не объявляет исключение. 
Интерфейс Supplier не допускает проверенных исключений. Есть два подхода, чтобы обойти эту проблему. Один из них — 
перехватить исключение и превратить его в непроверяемое исключение.

```
public void ugly() {
   Supplier<List<String>> s = () -> {
      try {
         return ExceptionCaseStudy.create();
      } catch (IOException e) {
         throw new RuntimeException(e);
      }
   };
}
```

Это работает. Но код отвратительный. Одним из преимуществ функционального программирования является то, что код должен 
быть легко читаемым и кратким. Другая альтернатива — создать метод-оболочку с помощью try/catch.

```
private static List<String> createSafe() {
   try {
      return ExceptionCaseStudy.create();
   } catch (IOException e) {
      throw new RuntimeException(e);
   } }
```

Теперь мы можем без проблем использовать безопасную упаковку у нашего Supplier.

```
public void wrapped() {
   Supplier<List<String>> s2 = ExceptionCaseStudy::createSafe;
}
```

---

### Используя Spliterator

Предположим, вы покупаете пакет с едой, чтобы двое детей могли покормить животных в контактном зоопарке. Чтобы избежать 
споров, приготовьте дополнительную пустую сумку. Вы берете примерно половину еды из основной сумки и кладете ее в сумку, 
которую принесли из дома. Оригинальный пакет с другой половиной еды все еще существует.

Spliterator обеспечивает этот уровень контроля над обработкой. Все начинается с Collection или stream — это ваш мешок с 
едой. Вы вызываете метод trySplit(), чтобы достать из сумки немного еды. Остальная часть еды остается в исходном объекте 
Spliterator.

Характеристики Spliterator зависят от базового источника данных. Источником данных Collection является базовый 
Spliterator. Напротив, при использовании источника данных Stream Spliterator может быть параллельным или даже 
бесконечным. Сам поток выполняется лениво, а не при создании Spliterator.

Реализация собственного Spliterator может оказаться сложной, и ее удобно не рассматривать на экзамене. Вам необходимо 
знать, как работать с некоторыми распространенными методами, объявленными в этом интерфейсе. Упрощенные методы, которые 
вам необходимо знать, приведены в таблице 10.9.

#### TABLE 10.9 Spliterator methods