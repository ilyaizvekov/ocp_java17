# Исключения и локализация

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Обработка исключений

+ Обрабатывать исключения с помощью try/catch/finally, try-with-resources и блоков с несколькими перехватами, включая 
пользовательские исключения

#### Реализация локализации

+ Реализуйте локализацию с использованием языковых стандартов, пакетов ресурсов, анализа и форматирования сообщений, 
дат, времени и чисел, включая денежные и процентные значения.

---

Эта глава посвящена созданию приложений, адаптирующихся к изменениям. Что произойдет, если пользователь введет неверные 
данные на веб-странице? Что, если наше соединение с базой данных оборвется во время распродажи? Наконец, как нам 
создавать приложения, поддерживающие несколько языков или географических регионов?

В этой главе мы обсуждаем эти проблемы и их решения с использованием исключений, форматирования и локализации. Один из 
способов убедиться, что ваши приложения реагируют на изменения, — это обеспечить поддержку на раннем этапе. Например, 
поддержка локализации не означает, что вам действительно нужно сразу же поддерживать определенные языки. Это просто 
означает, что ваше приложение будет легче адаптировать в будущем. Мы надеемся, что к концу этой главы мы создали 
структуру для разработки приложений, которые лучше адаптируются к изменениям.

## Понимание исключений

Программа может выйти из строя практически по любой причине. Вот лишь некоторые возможности:

+ Код пытается подключиться к веб-сайту, но подключение к Интернету не работает.
+ Вы допустили ошибку в кодировании и попытались получить доступ к недопустимому индексу в массиве.
+ Один метод вызывает другой со значением, которое этот метод не поддерживает.

Как видите, некоторые из них являются ошибками кодирования. Другие полностью вне вашего контроля. Ваша программа не 
сможет помочь, если пропадет подключение к Интернету. Единственное, что он может сделать, это разобраться с ситуацией.

### Роль исключений

Исключением является способ Java сказать: “Я сдаюсь. Я не знаю, что мне сейчас делать. Вы справляетесь с этим”. Когда 
вы пишете метод, вы можете либо справиться с исключением, либо сделать его проблемой вызывающего кода.

В качестве примера представьте себе Java как ребенка, который посещает зоопарк. Счастливый путь - это когда ничего не 
идет не так. Ребенок продолжает смотреть на животных до тех пор, пока программа не закончится красиво. Ничего не пошло 
не так, и не было никаких исключений, с которыми нужно было иметь дело.

Младшая сестра этого ребенка не прошла счастливый путь. В волнении она спотыкается и падает. К счастью, это неплохое 
падение. Маленькая девочка встает и продолжает смотреть на других животных. Она сама справилась с этой проблемой. К 
сожалению, позже в тот же день она снова падает и начинает плакать. На этот раз она, плача, заявила, что ей нужна 
помощь. История заканчивается хорошо. Ее папа потирает ее колено и обнимает. Затем они снова начинают наблюдать за 
другими животными и наслаждаются остатком дня.

Это два подхода, которые Java использует при работе с исключениями. Метод может обрабатывать исключительную ситуацию 
сам или возложить ответственность за это на вызывающую сторону.

---

**Сценарий реального мира**

Return Codes vs. Exceptions

Исключения используются, когда «что-то идет не так». Однако слово «неправильно» является субъективным. Следующий код 
возвращает -1 вместо того, чтобы генерировать исключение, если совпадение не найдено:

```
public int indexOf(String[] names, String name) {
   for (int i = 0; i < names.length; i++) {
      if (names[i].equals(name)) { return i; }
   }
   return -1;
}
```

Хотя коды возврата являются общими для определенных задач, таких как поиск, их, как правило, следует избегать. В конце 
концов, Java предоставила фреймворк исключений, так что вы должны его использовать!

---

### Понимание типов исключений

Исключением является событие, которое изменяет ход программы. В Java есть класс Throwable для всех объектов, 
представляющих эти события. Не у всех из них в названии класса есть слово «исключение», что может сбивать с толку. На 
рисунке 11.1 показаны ключевые подклассы Throwable.

#### Рис. 11.1 - Категории исключений



### Проверяемые исключения

Проверяемое исключение - это исключение, которое должно быть объявлено или обработано кодом приложения, в котором оно 
генерируется. В Java все проверяемые исключения наследуют Exception, но не RuntimeException. проверяемые исключения, как 
правило, более ожидаемы — например, попытка прочитать несуществующий файл.

_Проверяемые исключения также включают любой класс, который наследует Throwable, но не Error или RuntimeException, 
например класс, который непосредственно расширяет Throwable. Для экзамена вам просто нужно знать о проверяемых 
исключениях, которые расширяют Exception._

проверяемые исключения? Что мы проверяем? В Java есть правило, называемое правилом handle или declare. Правило handle 
или declare означает, что все проверяемые исключения, которые могут быть выброшены внутри метода, либо заключены в 
совместимые блоки try и catch, либо объявлены в сигнатуре метода.

Поскольку проверяемые исключения, как правило, ожидаемы, Java применяет правило, согласно которому программист должен 
сделать что-то, чтобы показать, что об исключении думали. Возможно, это было обработано в методе. Или, может быть, метод 
объявляет, что он не может обработать исключение, и это должен сделать кто-то другой.

Давайте взглянем на пример. Следующий метод fall() объявляет, что он может вызвать исключение IOException, которое 
является проверяемым исключением:

```
void fall(int distance) throws IOException {
  if (distance > 10) {
     throw new IOException();
  }
}
```

Обратите внимание, что вы используете здесь два разных ключевых слова. Ключевое слово throw сообщает Java, что вы хотите 
выдать исключение, а ключевое слово throws просто объявляет, что метод может выдать исключение. А может и нет.

Теперь, когда вы знаете, как объявить исключение, как с ним справиться? Следующая альтернативная версия метода fall() 
обрабатывает это исключение:

```
void fall(int distance) {
   try {
     if (distance > 10) {
        throw new IOException();
     }
   } catch (Exception e) {
      e.printStackTrace();
   }
}
```

Обратите внимание, что оператор catch использует Exception, а не IOException. Поскольку IOException является подклассом 
Exception, блоку catch разрешено его перехватывать. Более подробно блоки try и catch мы рассмотрим далее в этой главе.

### Непроверяемые исключения

Непроверяемое исключение - это любое исключение, которое не нужно объявлять или обрабатывать кодом приложения, в котором 
оно генерируется. Непроверяемые исключения часто называют исключениями времени выполнения, хотя в Java непроверяемые 
исключения включают любой класс, который наследует RuntimeException или Error.

_Допустимо обрабатывать или объявлять непроверяемое исключение. Тем не менее, лучше задокументировать непроверяемые 
исключения, о которых должны знать вызывающие, в комментарии Javadoc, а не объявлять непроверяемое исключение._

Исключение во время выполнения определяется как класс RuntimeException и его подклассы. Исключения во время выполнения, 
как правило, бывают неожиданными, но не обязательно фатальными. Например, доступ к недопустимому индексу массива 
является неожиданным. Несмотря на то, что они наследуют класс Exception, они не являются проверяемыми исключениями.

Непроверяемое исключение может возникнуть практически в любой строке кода, поскольку его не требуется обрабатывать или 
объявлять. Например, исключение NullPointerException может быть вызвано в теле следующего метода, если входная ссылка 
равна null:

```
void fall(String input) {
   System.out.println(input.toLowerCase());
}
```

Мы работаем с объектами в Java так часто, что исключение NullPointerException может возникнуть практически в любом 
месте. Если бы вам приходилось объявлять непроверяемые исключения везде, в каждом отдельном методе был бы такой 
беспорядок! Код скомпилируется, если вы объявите непроверяемое исключение. Однако это излишне.

### Error и Throwable

Error означает, что что-то пошло настолько ужасно неправильно, что ваша программа не должна пытаться восстановиться 
после этого. Например, дисковод “исчез” или программе не хватило памяти. Это ненормальные состояния, с которыми вы вряд 
ли столкнетесь и от которых не сможете оправиться.

Для экзамена единственное, что вам нужно знать о Throwable, это то, что это родительский класс всех исключений, включая 
класс Error. Хотя вы можете обрабатывать исключения Throwable и Error, не рекомендуется делать это в коде вашего 
приложения. Когда мы ссылаемся на исключения в этой главе, мы обычно имеем в виду любой класс, который наследует 
Throwable, хотя мы почти всегда работаем с классом Exception или его подклассами.

### Обзор типов исключений

Обязательно внимательно изучите все, что приведено в таблице 11.1. Перед экзаменом помните, что Throwable - это либо 
исключение, либо ошибка. Вы не должны перехватывать Throwable непосредственно в своем коде.

#### Таблица 11.1 - Типы исключений и ошибок

|           Тип            |                   Как распознать                    | Все в порядке, чтобы программа поймала? | Требуется ли программа для обработки или объявления? |  
|:------------------------:|:---------------------------------------------------:|:---------------------------------------:|:----------------------------------------------------:|
| Непроверяемые исключения |            Подкласс из RuntimeException             |                   Да                    |                         Нет                          |
| Проверяемые исключения   | Подкласс Exception, но не подкласс RuntimeException |                   Да                    |                          Да                          |
|          Error           |                  Подкласс из Error                  |                   Нет                   |                         Нет                          |

### Выбрасывание исключения

Любой Java-код может генерировать исключение; это включает в себя код, который вы пишете. Некоторые исключения 
предусмотрены в Java. Вы можете столкнуться с исключением, которое было составлено для экзамена. Это прекрасно. Вопрос 
сделает очевидным, что это исключение, поскольку имя класса заканчивается на Exception. Например, MyMadeUpException явно 
является исключением.

На экзамене вы увидите два типа кода, которые приводят к исключению. Первый - это неправильный код. Вот пример:

```
String[] animals = new String[0]; 
System.out.println(animals[0]);  // ArrayIndexOutOfBoundsException
```

Этот код генерирует исключение ArrayIndexOutOfBoundsException, поскольку в массиве нет элементов. Это означает, что 
вопросы об исключениях могут быть скрыты за вопросами, которые кажутся о чем-то другом.

_На экзамене в некоторых вопросах есть выбор не компилировать и выбрасывать исключение. Обратите особое внимание на код, 
который вызывает метод по нулевой ссылке или ссылается на недопустимый массив или индекс списка. Если вы заметили это, 
то знаете, что правильный ответ — код генерирует исключение во время выполнения._

Второй способ создания исключения в коде — это явный запрос Java на его создание. Java позволяет вам писать такие 
операторы:

```
throw new Exception(); 
throw new Exception("Ow! I fell."); 
throw new RuntimeException(); 
throw new RuntimeException("Ow! I fell.");
```

Ключевое слово throw сообщает Java, что вы хотите, чтобы какая-то другая часть кода обрабатывала исключение. Это то же 
самое, что молодая девушка, оплакивающая своего папу. Кто-то другой должен выяснить, что делать с этим исключением.

---

**throw vs. throws**

Всякий раз, когда вы видите throws на экзамене, убедитесь, что используется правильный. Ключевое слово throw 
используется как оператор внутри блока кода для создания нового исключения или повторного создания существующего 
исключения, в то время как ключевое слово throws используется только в конце объявления метода, чтобы указать, какие 
исключения он поддерживает.

---

При создании исключения вы обычно можете передать параметр String вместе с сообщением или можете не передавать 
параметры и использовать значения по умолчанию. Мы говорим «обычно», потому что это условность. Кто-то объявил 
конструктор, принимающий String. Кто-то также может создать класс исключений, у которого нет конструктора, принимающего 
сообщение.

Кроме того, вы должны знать, что исключение - это объект. Это означает, что вы можете сохранить его в ссылке на объект, 
и это законно:

```
var e = new RuntimeException();
throw e;
```

Код создает исключение в одной строке, а затем генерирует в следующей. Исключение может исходить откуда угодно, даже 
передаваться в метод. Пока это допустимое исключение, оно может быть выброшено.

Экзамен также может попытаться обмануть вас. Вы понимаете, почему этот код не компилируется?

```
throw RuntimeException();   // НЕ КОМПИЛИРУЕТСЯ
```

Если ваш ответ заключается в том, что отсутствует ключевое слово, вы абсолютно правы. Исключение никогда не создается с 
помощью ключевого слова new.

Давайте взглянем на еще одно место, где экзамен может попытаться вас обмануть. Вы понимаете, почему следующее не 
компилируется?

```
3: try { 
4:    throw new RuntimeException(); 
5:    throw new ArrayIndexOutOfBoundsException();  // НЕ КОМПИЛИРУЕТСЯ
6: } catch (Exception e) {}
```

Поскольку строка 4 генерирует исключение, строка 5 никогда не может быть достигнута во время выполнения. Компилятор 
распознает это и сообщает о недостижимой ошибке кода.

### Вызов методов, генерирующие исключения

Когда вы вызываете метод, который генерирует исключение, правила те же, что и внутри метода. Вы понимаете, почему 
следующее не компилируется?

```
class NoMoreCarrotsException extends Exception {}

public class Bunny {
   public static void main(String[] args) {
      eatCarrot();  // НЕ КОМПИЛИРУЕТСЯ
   }
   private static void eatCarrot() throws NoMoreCarrotsException {}
}
```

Проблема в том, что NoMoreCarrotsException является проверяемым исключением. Проверяемые исключения должны быть 
обработаны или объявлены. Код скомпилируется, если вы измените метод main() на любой из следующих:

```
public static void main(String[] args) throws NoMoreCarrotsException {      
   eatCarrot();   
}

public static void main(String[] args) {
   try {
      eatCarrot();
   } catch (NoMoreCarrotsException e) {
      System.out.print("sad rabbit");      
   }
}
```

Возможно, вы заметили, что eatCarrot() не генерирует исключение; он просто заявил, что может. Этого достаточно, 
чтобы компилятор потребовал от вызывающей стороны обработать или объявить исключение.

Компилятор все еще ищет недоступный код. Объявление неиспользуемого исключения не считается недоступным кодом. Это 
дает методу возможность изменить реализацию, чтобы генерировать это исключение в будущем. Вы видите здесь проблему?

```
public void bad() {
   try {
      eatCarrot();
   } catch (NoMoreCarrotsException e) {  // НЕ КОМПИЛИРУЕТСЯ
      System.out.print("sad rabbit");
   }
}

private void eatCarrot() {}
```

Java знает, что eatCarrot() не может генерировать проверяемое исключение, а это означает, что блок catch в bad() не 
может быть достигнут.

_Когда вы видите проверяемое исключение, объявленное внутри блока catch на экзамене, убедитесь, что код в связанном блоке 
try способен выбросить это исключение или его подкласс. В противном случае код недоступен и не компилируется. Помните, 
что это правило не распространяется на непроверяемые исключения или исключения, объявленные в сигнатуре метода._

### Переопределение методов с исключениями

Когда мы представили переопределяющие методы в главе 6 «Проектирование классов», мы включили правило, связанное с 
исключениями. Переопределенный метод не может объявлять какие-либо новые или более широких проверяемых исключений, 
чем метод, который он наследует. Например, этот код не разрешен:

```
class CanNotHopException extends Exception {}

class Hopper {
   public void hop() {}
}

class Bunny extends Hopper {
   public void hop() throws CanNotHopException {}  // НЕ КОМПИЛИРУЕТСЯ
}
```

Java знает, что функции hop() не разрешено генерировать какие-либо проверяемые исключения, потому что метод hop() в 
суперклассе Hopper их не объявляет. Представьте, что произошло бы, если бы версии метода для подклассов могли добавлять 
проверяемые исключения — вы могли бы написать код, который вызывает метод Hopper's hop() и не обрабатывает 
никаких исключений. Тогда, если бы вместо него использовался Bunny, код не знал бы, как обрабатывать или объявлять 
CanNotHopException.

Переопределенному методу в подклассе разрешается объявлять меньше исключений, чем суперклассу или интерфейсу. Это 
допустимо, потому что абоненты уже обрабатывают их.

```
class Hopper {    
public void hop() throws CanNotHopException {}
}
class Bunny extends Hopper {    
public void hop() {}  // Это прекрасно
}
```

Переопределенный метод, не объявляющий одно из исключений, генерируемых родительским методом, аналогичен методу, 
объявляющему, что он генерирует исключение, которое на самом деле никогда не генерируется. Это совершенно законно. 
Аналогично, классу разрешается объявлять подкласс типа exception. Идея та же самая. Суперкласс или интерфейс уже 
позаботился о более широком типе.

### Печать исключения

Существует три способа распечатать исключение. Вы можете позволить Java распечатать его, распечатать только сообщение 
или указать, откуда берется трассировка стека. В этом примере показаны все три подхода:

```
5:  public static void main(String[] args) { 
6:     try { 
7:        hop(); 
8:     } catch (Exception e) { 
9:        System.out.println(e + "\n"); 
10:       System.out.println(e.getMessage()+ "\n"); 
11:       e.printStackTrace(); 
12:    }
13: }
14: private static void hop() { 
15:    throw new RuntimeException("cannot hop"); 
16: }
```

Этот код печатает следующее:

```
java.lang.RuntimeException: cannot hop

cannot hop

java.lang.RuntimeException: cannot hop
   at Handling.hop(Handling.java:15)
   at Handling.main(Handling.java:7)
```

В первой строке показано, что Java выводит по умолчанию: тип исключения и сообщение. Вторая строка показывает только 
сообщение. Остальное показывает трассировку стека. Трассировка стека обычно оказывается наиболее полезной, поскольку она 
показывает иерархию вызовов методов, которые были выполнены для достижения строки, вызвавшей исключение.

## Распознавание классов исключений

Для экзамена вам необходимо распознать три группы классов исключений: RuntimeException, проверяемое Exception и Error. 
Мы рассмотрим типичные примеры каждого типа. На экзамене вам нужно будет узнать, какой это тип исключения и создано ли 
оно виртуальной машиной Java (JVM) или программистом. За некоторыми исключениями вам также необходимо знать, какие из 
них наследуются друг от друга.

### Классы RuntimeException

RuntimeException и его подклассы — это непроверяемые исключения, которые не нужно обрабатывать или объявлять. Они могут 
быть созданы программистом или JVM. Распространенные классы непроверяемых исключений перечислены в таблице 11.2.

#### Таблица 11.2 - Непроверяемые исключения

|    Непроверяемое исключение    |                                                                             Описание                                                                              |  
|:------------------------------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|      ArithmeticException       |                                                       Выбрасывается, когда код пытается разделить на ноль.                                                        |
| ArrayIndexOutOfBoundsException |                                          Выбрасывается, когда код использует недопустимый индекс для доступа к массиву.                                           |
|       ClassCastException       |                                     Выбрасывается при попытке привести объект к классу, экземпляром которого он не является.                                      |
|      NullPointerException      |                                                Генерируется, когда есть null-ссылка, для которой требуется объект.                                                |
|    IllegalArgumentException    |                             Выбрасывается программистом, чтобы указать, что методу был передан незаконный или неподходящий аргумент.                              |
|     NumberFormatException      | Подкласс IllegalArgumentException. Выбрасывается, когда предпринимается попытка преобразовать строку в числовой тип, но строка не имеет соответствующего формата. |


### ArithmeticException

Попытка разделить целое число на ноль дает неопределенный результат. Когда это произойдет, JVM 
выдаст ArithmeticException:

```
int answer = 11 / 0;
```

Запуск этого кода приводит к следующему выводу:

```
Exception in thread "main" java.lang.ArithmeticException: / by zero
```

В Java не используется слово «разделить». Однако это нормально, потому что мы знаем, что / — это оператор деления и что 
Java пытается сообщить вам, что произошло деление на ноль.

Поток «main» сообщает вам, что код был вызван прямо или косвенно из программы с методом main. На экзамене это все, 
что вы увидите. Далее следует имя исключения, а затем дополнительная информация (если таковая имеется), связанная с 
исключением.

### ArrayIndexOutOfBoundsException

Теперь вы уже знаете, что индексы массива начинаются с 0 и увеличиваются на 1, что меньше длины массива — что означает, 
что этот код вызовет исключение ArrayIndexOutOfBoundsException:

```
int[] countsOfMoose = new int[3];
System.out.println(countsOfMoose[-1]);
```

Это проблема, потому что не существует такого понятия, как отрицательный индекс массива. Выполнение этого кода приводит 
к следующему результату:

```
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException:
Index -1 out of bounds for length 3
```

### ClassCastException

Java пытается защитить вас от невозможных приведений. Этот код не компилируется, поскольку Integer не является 
подклассом String:

```
String type = "moose"; 
Integer number = (Integer) type;  // НЕ КОМПИЛИРУЕТСЯ
```

Более сложный код препятствует попыткам Java защитить вас. Если приведение завершается неудачно во время выполнения, 
Java выдаст исключение ClassCastException:

```
String type = "moose"; 
Object obj = type; 
Integer number = (Integer) obj; // ClassCastException
```

Компилятор видит приведение Object к Integer. Это может быть хорошо. Компилятор не осознает, что в этом объекте есть 
строка. Когда код запускается, он дает следующий результат:

```
Exception in thread "main" java.lang.ClassCastException: 
java.base/java.lang.String
cannot be cast to java.lang.base/java.lang.Integer
```

Java сообщает вам оба типа, которые были вовлечены в проблему, делая очевидным, что не так.

### NullPointerException

Переменные экземпляра и методы должны вызываться по ненулевой ссылке. Если ссылка равна null, JVM выдаст исключение 
NullPointerException.

```
1: public class Frog { 
2:    public void hop(String name, Integer jump) { 
3:       System.out.print(name.toLowerCase() + " " + jump.intValue()); 
4:    }
5:    
6:    public static void main(String[] args) { 
7:       new Frog().hop(null, 1); 
8:    } }
```

Выполнение этого кода приводит к следующему результату:

```
Exception in thread "main" java.lang.NullPointerException: Cannot invoke
"String.toLowerCase()" because "<parameter1>" is null
```

Если вы новичок в Java 17, вы должны были заметить что-то особенное в выводе. JVM теперь сообщает вам ссылку на объект, 
вызвавшую исключение NullPointerException! Эта новая функция называется Helpful NullPointerExceptions.

В качестве другого примера предположим, что мы изменили строку 7:

```
7:       new Frog().hop("Kermit", null);
```

Затем вывод во время выполнения изменяется следующим образом:

```
Exception in thread "main" java.lang.NullPointerException: Cannot invoke
"java.lang.Integer.intValue()" because "<parameter2>" is null
```

_По умолчанию исключение NullPointerException для локальной переменной или параметра метода печатается с номером, 
указывающим порядок его появления в методе, например <local2> или <parameter4>. Если вы похожи на нас и хотите, чтобы 
отображалось фактическое имя переменной, скомпилируйте код с флагом -g:vars, который добавляет отладочную информацию. В 
предыдущих примерах <parameter1> и <parameter2> заменяются именем и переходом соответственно._

Поскольку это новая функция в Java, возможно, вы увидите ее в вопросе на экзамене.

---

**Включение/выключение Helpful NullPointerExceptions**

Когда в Java 14 были добавлены полезные исключения NullPointerException, эта функция была отключена по умолчанию, и ее 
нужно было включать с помощью аргумента командной строки ShowCodeDetailsInExceptionMessages для JVM:

```
java -XX:+ShowCodeDetailsInExceptionMessages Frog
```

В Java 15 и более поздних версиях поведение по умолчанию было изменено, и теперь оно включено по умолчанию, хотя его все 
еще можно отключить с помощью аргумента командной строки.

```
java -XX:-ShowCodeDetailsInExceptionMessages Frog
```

---

### IllegalArgumentException

IllegalArgumentException — это способ защитить вашу программу. Вы хотите сообщить вызывающему абоненту, что что-то не 
так, — желательно очевидным образом, чтобы вызывающий абонент не мог его игнорировать, чтобы программист исправил 
проблему. Видеть, что код заканчивается исключением, — отличное напоминание о том, что что-то не так. Рассмотрим этот 
пример при вызове setNumberEggs(-2):

```
public void setNumberEggs(int numberEggs) {
   if (numberEggs < 0)
      throw new IllegalArgumentException("# eggs must not be negative");
   this.numberEggs = numberEggs;
}
```

Программа выдает исключение, когда ее не устраивают значения параметров. Вывод выглядит следующим образом:

```
Exception in thread "main"
java.lang.IllegalArgumentException: # eggs must not be negative
```

Очевидно, что эту проблему необходимо решить, если программист хочет, чтобы программа делала что-нибудь полезное.

### NumberFormatException

Java предоставляет методы для преобразования строк в числа. Когда им передается недопустимое значение, они вызывают 
исключение NumberFormatException. Идея аналогична IllegalArgumentException. Поскольку это распространенная проблема, 
Java выделяет ей отдельный класс. Фактически NumberFormatException является подклассом IllegalArgumentException. Вот 
пример попытки преобразовать что-то нечисловое в int:

```
Integer.parseInt("abc");
```

Вывод выглядит следующим образом:

```
Exception in thread "main"
java.lang.NumberFormatException: For input string: "abc"
```

Для сдачи экзамена вам необходимо знать, что NumberFormatException является подклассом IllegalArgumentException. 
Подробнее о том, почему это важно, мы поговорим позже в этой главе.

### Классы проверяемых исключений

Проверяемые исключения имеют Exception в своей иерархии, но не RuntimeException. Они должны быть обработаны или 
объявлены. Распространенные проверяемые исключения перечислены в таблице 11.3.

Для экзамена вам нужно знать, что все это проверяемые исключения, которые должны быть обработаны или объявлены. Вам 
также нужно знать, что FileNotFoundException и NotSerializableException являются подклассами IOException. Вы видите эти 
три класса в главе 14, “Ввод-вывод”, и SQLException в главе 15, “JDBC”.

#### Таблица 11.3 - Проверяемые исключения

|  Проверяемое исключение  |                                                     Описание                                                     |  
|:------------------------:|:----------------------------------------------------------------------------------------------------------------:|
|  FileNotFoundException   |       Подкласс IOException. Генерируется программно, когда код пытается сослаться на несуществующий файл.        |
|       IOException        |                 Выбрасывается программно при возникновении проблем с чтением или записью файла.                  |
| NotSerializableException | Подкласс IOException. Вызывается программно при попытке сериализации или десериализации несериализуемого класса. |
|      ParseException      |                         Указывает на проблему с синтаксическим анализом входных данных.                          |
|      SQLException        |                             Выдается при ошибке, связанной с доступом к базе данных.                             |


### Классы ошибок

Ошибки — это непроверяемые исключения, расширяющие класс Error. Они создаются JVM и не должны обрабатываться или 
объявляться. Ошибки редки, но вы можете увидеть ошибки, перечисленные в таблице 11.4.

#### Таблица 11.4 - Ошибки 

|           Ошибка            |                                                                    Описание                                                                    |  
|:---------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------:|
| ExceptionInInitializerError |                              Вызывается, когда статический инициализатор выдает исключение и не обрабатывает его.                              |
|     StackOverflowError      | Вызывается, когда метод вызывает себя слишком много раз (так называемая бесконечная рекурсия, поскольку метод обычно вызывает себя без конца). |
|    NoClassDefFoundError     |                   Вызывается, когда класс, который использует код, доступен во время компиляции, но не во время выполнения.                    |

Для экзамена вам просто нужно знать, что эти ошибки не проверены и код часто не может восстановиться после них.

## Обработка исключений

Что вы делаете, когда встречаете исключение? Как вы обрабатываете исключение или восстанавливаетесь после него? В этом 
разделе мы покажем различные операторы Java, поддерживающие обработку исключений.

### Использование операторов try и catch

Теперь, когда вы знаете, что такое исключения, давайте посмотрим, как с ними обращаться. Java использует оператор try, 
чтобы отделить логику, которая может вызвать исключение, от логики, обрабатывающей это исключение. На рисунке 11.2 
показан синтаксис оператора try.

#### Рис. 11.2 - Синтаксис оператора try


Код в блоке try выполняется нормально. Если какой-либо из операторов генерирует исключение, которое может быть 
перехвачено типом исключения, указанным в блоке catch, блок try прекращает работу и выполнение переходит к оператору 
catch. Если ни один из операторов в блоке try не генерирует исключение, которое можно перехватить, предложение catch не 
запускается.

Вы, наверное, заметили, что слова «блок» и «предложение» используются как взаимозаменяемые. Экзамен тоже делает то же 
самое, так что привыкайте к этому. Оба верны. Блок правильный, потому что присутствуют фигурные скобки. Предложение 
правильное, поскольку оно является частью оператора try.

Здесь нет множества синтаксических правил. Фигурные скобки необходимы для блоков try и catch. В нашем примере маленькая 
девочка встает сама, когда впервые падает. Вот как это выглядит:

```
3:  void explore() { 
4:     try { 
5:        fall(); 
6:        System.out.println("never get here"); 
7:     } catch (RuntimeException e) { 
8:        getUp(); 
9:     }
10:    seeAnimals(); 
11: }
12: void fall() {  throw new RuntimeException(); }
```

Во-первых, строка 5 вызывает метод fall(). Строка 12 выдает исключение. Это означает, что Java переходит прямо к блоку 
catch, пропуская строку 6. Девушка встает на строку 8. Теперь оператор try завершен, и выполнение продолжается нормально 
со строки 10.

Теперь давайте посмотрим на некоторые неверные операторы try, с помощью которых экзамен может попытаться вас обмануть. 
Вы видите, что с этим не так?

```
try  // НЕ КОМПИЛИРУЕТСЯ    
   fall();
catch (Exception e)    
   System.out.println("get up");
```

Проблема в том, что фигурные скобки {} отсутствуют. Операторы try подобны методам: фигурные скобки необходимы, даже 
если внутри блоков кода есть только один оператор, а операторы if и циклы являются специальными и позволяют опускать 
фигурные скобки.

Как насчет этого?

```
try {  // НЕ КОМПИЛИРУЕТСЯ    
   fall();
}
```

Этот код не компилируется, потому что после блока try ничего нет. Помните, что смысл оператора try заключается в том, 
чтобы что-то произошло, если возникнет исключение. Без другого предложения оператор try будет одиноким. Как вы вскоре 
увидите, существует особый тип оператора try, который включает в себя неявный блок finally, хотя синтаксис сильно 
отличается от этого примера.

### Цепочка блоков catch

Для подготовки к экзамену вам могут быть предоставлены классы исключений, и вам необходимо понять, как они 
функционируют. Вот как с ними бороться. Во-первых, вы должны быть в состоянии распознать, является ли исключение 
проверяемым или непроверяемым. Во-вторых, вам нужно определить, является ли какое-либо из исключений подклассами других.

```
class AnimalsOutForAWalk extends RuntimeException {}

class ExhibitClosed extends RuntimeException {}

class ExhibitClosedForLunch extends ExhibitClosed {}
```

В этом примере есть три пользовательских исключения. Все они являются непроверяемыми исключениями, поскольку они прямо 
или косвенно расширяют RuntimeException. Теперь мы объединяем оба типа исключений в цепочку с двумя блоками catch и 
обрабатываем их, распечатывая соответствующее сообщение:

```
public void visitPorcupine() {
   try {
      seeAnimal();
   } catch (AnimalsOutForAWalk e) {  // первый блок catch
      System.out.print("try back later");
   } catch (ExhibitClosed e) {       // второй блок catch
      System.out.print("not today");
   }
}
```

При запуске этого кода возможны три варианта. Если seeAnimal() не генерирует исключение, ничего не распечатывается. 
Если животное вышло на прогулку, выполняется только первый блок отлова. Если выставка закрыта, запускается только 
второй блок catch. Невозможно, чтобы оба блока catch выполнялись, когда они соединены таким образом.

Существует правило для порядка следования блоков catch. Java просматривает их в том порядке, в котором они появляются. 
Если выполнение одного из блоков catch невозможно, возникает ошибка компилятора о недоступности кода. Например, это 
происходит, когда блок catch суперкласса появляется перед блоком catch подкласса. Помните, мы предупреждали вас 
о необходимости обращать внимание на любые исключения из подкласса.

В примере с дикобразом порядок блоков catch может быть изменен на противоположный, поскольку исключения не наследуются 
друг от друга. И да, мы видели, как дикобраза выводили на прогулку на поводке.

В следующем примере показаны типы исключений, которые наследуются друг от друга:

```
public void visitMonkeys() {
   try {
      seeAnimal();
   } catch (ExhibitClosedForLunch e) {  // Исключение подкласса
      System.out.print("try back later");
   } catch (ExhibitClosed e) {          // Исключение суперкласса
      System.out.print("not today");
   }
}
```

Если выдается более конкретное исключение ExhibitClosedForLunch, запускается первый блок catch. Если нет, Java 
проверяет, выброшено ли исключение ExhibitClosed суперкласса, и перехватывает его. На этот раз порядок блоков catch 
имеет значение. Обратное не работает.

```
public void visitMonkeys() {
   try {
      seeAnimal();
   } catch (ExhibitClosed e) {
      System.out.print("not today");
   } catch (ExhibitClosedForLunch e) {  // НЕ КОМПИЛИРУЕТСЯ
      System.out.print("try back later");
   } 
}
```

Если выдается более конкретное исключение ExhibitClosedForLunch, блок catch для ExhibitClosed запускается, а это 
означает, что второй блок catch не может быть запущен. Java правильно сообщает вам, что существует недостижимый блок 
catch.

Давайте попробуем это еще раз. Вы понимаете, почему этот код не компилируется?

```
public void visitSnakes() {    
   try {   
   } catch (IllegalArgumentException e) {   
   } catch (NumberFormatException e) {  // НЕ КОМПИЛИРУЕТСЯ   
   }
}
```

Помните, ранее мы говорили, что вам нужно знать, что NumberFormatException является подклассом IllegalArgumentException? 
Этот пример является причиной. Поскольку NumberFormatException является подклассом, оно всегда будет перехватываться 
первым блоком catch, что делает код второго блока catch недоступным, который не компилируется. Аналогично, для сдачи 
экзамена вам необходимо знать, что FileNotFoundException является подклассом IOException и не может использоваться 
аналогичным образом.

Чтобы просмотреть несколько блоков catch, помните, что будет запущен не более одного блока catch, и это будет первый 
блок catch, который сможет обработать исключение. Кроме того, помните, что исключение, определенное оператором catch, 
находится в области действия только этого блока catch. Например, следующий код вызывает ошибку компилятора, поскольку 
он пытается использовать объект исключения вне блока, для которого он был определен:

```
public void visitManatees() {
   try {
   } catch (NumberFormatException e1) {
      System.out.println(e1);
   } catch (IllegalArgumentException e2) {
      System.out.println(e1);  // НЕ КОМПИЛИРУЕТСЯ
   }
}
```

### Применение блока multi-catch

Часто мы хотим, чтобы результат выброшенного исключения был одинаковым, независимо от того, какое конкретное исключение 
было выброшено. Например, взгляните на этот метод:

```
public static void main(String args[]) {    
   try {      
      System.out.println(Integer.parseInt(args[1]));   
   } catch (ArrayIndexOutOfBoundsException e) {      
      System.out.println("Missing or invalid input");
   } catch (NumberFormatException e) {      
      System.out.println("Missing or invalid input");   
   }
}
```

Обратите внимание, что у нас есть один и тот же оператор println() для двух разных блоков catch. Мы можем справиться с 
этим более изящно, используя блок multi-catch. Блок multi-catch позволяет перехватывать несколько типов исключений 
одним и тем же блоком catch. Давайте перепишем предыдущий пример, используя блок multi-catch:

```
public static void main(String[] args) {
   try {
      System.out.println(Integer.parseInt(args[1]));
   } catch (ArrayIndexOutOfBoundsException | NumberFormatException e) {
      System.out.println("Missing or invalid input");
   }
}
```

Это намного лучше. Здесь нет дублирующегося кода, вся общая логика собрана в одном месте, и логика находится именно там, 
где вы ожидаете ее найти. При желании вы все равно можете иметь второй блок catch для исключений на случай, если вы 
захотите по-другому обрабатывать другие типы исключений.

На рисунке 11.3 показан синтаксис multi-catch. Это похоже на обычное предложение catch, за исключением того, что 
указаны два или более типов исключений, разделенных вертикальной чертой. Конвейер (|) также используется в качестве 
оператора «или», что позволяет легко запомнить, что вы можете использовать любой из типов исключений. Обратите 
внимание, что в предложении catch есть только одно имя переменной. Java говорит, что переменная с именем e может иметь 
тип Exception1 или Exception2.

#### Рис. 11.3 - Синтаксис блока multi-catch


Экзамен может попытаться обмануть вас неверным синтаксисом. Помните, что исключения могут быть перечислены в любом 
порядке в предложении catch. Однако имя переменной должно появляться только один раз и в конце. Вы понимаете, почему 
они действительны или недействительны?

```
catch(Exception1 e | Exception2 e | Exception3 e) // НЕ КОМПИЛИРУЕТСЯ

catch(Exception1 e1 | Exception2 e2 | Exception3 e3) // НЕ КОМПИЛИРУЕТСЯ

catch(Exception1 | Exception2 | Exception3 e)
```

Первая строка неверна, поскольку имя переменной встречается три раза. Просто потому, что это одно и то же имя 
переменной, это не значит, что все в порядке. Вторая строка неверна, поскольку имя переменной снова встречается три 
раза. Использование разных имен переменных не делает ситуацию лучше. Третья строка компилируется. Он показывает 
правильный синтаксис для указания трех исключений.

Java предполагает использование множественного перехвата для несвязанных между собой исключений и не позволяет вам 
указывать избыточные типы в множественном перехвате. Вы видите, что здесь не так?

```
try {
   throw new IOException();
} catch (FileNotFoundException | IOException p) {} // НЕ КОМПИЛИРУЕТСЯ
```

Указание связанных исключений в multi-catch является излишним, и компилятор выдает такое сообщение:

```
The exception FileNotFoundException is already caught by the alternative
IOException
```

Поскольку FileNotFoundException является подклассом IOException, этот код не будет компилироваться. Блок multi-catch 
подчиняется правилам, аналогичным объединению блоков catch в цепочку, которые вы видели в предыдущем разделе. 
Например, оба вызывают ошибки компилятора, когда обнаруживают недостижимый код или перехватывают повторяющиеся и
сключения. Единственное различие между блоками multi-catch и блоками catch в цепочку состоит в том, что порядок не 
имеет значения для блока multi-catch внутри одного выражения catch.

Возвращаясь к примеру, правильный код — просто удалить ссылку на посторонний подкласс, как показано здесь:

```
try {
   throw new IOException();
} catch (IOException e) {}
```

### Добавление блока finally

Оператор try также позволяет запускать код в конце с предложением finally, независимо от того, создано ли исключение.  
На рис. 11.4 показан синтаксис оператора try с этой дополнительной функциональностью.

В коде есть два пути: catch и finally. Если генерируется исключение, блок finally запускается после блока catch. 
Если исключение не генерируется, блок finally запускается после завершения блока try.

Давайте вернемся к нашему примеру с молодой девушкой, на этот раз с finally:

```
12: void explore() { 
13:    try { 
14:       seeAnimals(); 
15:       fall();
16:    } catch (Exception e) { 
17:       getHugFromDaddy(); 
18:    } finally { 
19:       seeMoreAnimals();
20:    }
21:    goHome(); 
22: }
```

#### Рис. 11.4 - Синтаксис оператора try с finally


Девушка падает на строку 15. Если она встает сама, код переходит к блоку «finally» и выполняет строку 19. Затем 
оператор try завершается, и код переходит к строке 21. Если девочка не встает сама по себе она выдает исключение. 
Запускается блок catch, и она получает объятия в строке 17. Благодаря этим объятиям она готова увидеть больше животных в 
строке 19. Затем оператор try завершается, и код переходит к строке 21. В любом случае окончание будет таким: 
одинаковый. Блок «finally» выполняется, и выполнение продолжается после оператора try.

Экзамен попытается обмануть вас, указав пропущенные предложения или предложения в неправильном порядке. Вы понимаете, 
почему следующее компилируется или не компилируется?

```
25: try {  // DНЕ КОМПИЛИРУЕТСЯ
26:    fall(); 
27: } finally { 
28:    System.out.println("all better"); 
29: } catch (Exception e) { 
30:    System.out.println("get up"); 
31: }
32:
33: try {  // НЕ КОМПИЛИРУЕТСЯ
34:    fall(); 
35: }
36:
37: try { 
38:    fall(); 
39: } finally { 
40:    System.out.println("all better"); 
41: }
```

Первый пример (строки 25–31) не компилируется, поскольку блоки catch и finally расположены в неправильном порядке. 
Второй пример (строки 33–35) не компилируется, поскольку должен быть блок catch или finally. Третий пример 
(строки 37–41) вполне подходит. Блок catch не требуется, если присутствует finally.

Большинство примеров, с которыми вы столкнетесь на экзамене, в конечном итоге будут выглядеть надуманными. Например, вам 
будут заданы такие вопросы, как то, что выводит этот код:

```
public static void main(String[] unused) {
   StringBuilder sb = new StringBuilder();
   try {
      sb.append("t");
   } catch (Exception e) {
      sb.append("c");
   } finally {
      sb.append("f");
   }
   sb.append("a");
   System.out.print(sb.toString());
}
```

Ответ - tfa. Выполняется блок try. Поскольку исключение не генерируется, Java переходит прямо к блоку finally. Затем 
выполняется код после инструкции try. Мы знаем, что это глупый пример, но вы можете ожидать увидеть подобные примеры на 
экзамене.

Есть еще одно дополнительное правило, которое вы должны знать для блоков finally. Если введена инструкция try с блоком 
finally, то блок finally всегда будет выполняться, независимо от того, завершится ли код успешно. Взгляните на 
следующий метод goHome(). Предполагая, что в строке 14 может быть выдано исключение, а может и не быть, каковы 
возможные значения, которые может вывести этот метод? Кроме того, каким будет возвращаемое значение в каждом 
конкретном случае?

```
12: int goHome() { 
13:    try { 
14:       // Необязательно создавать исключение здесь
15:       System.out.print("1"); 
16:       return -1; 
17:    } catch (Exception e) { 
18:       System.out.print("2"); 
19:       return -2;
20:    } finally { 
21:       System.out.print("3"); 
22:       return -3; 
23:    }
24: }
```

Если в строке 14 не будет выдано исключение, то будет выполнена строка 15 с выводом 1. Однако перед возвратом метода 
выполняется блок finally, выводящий значение 3. Если генерируется исключение, то строки 15 и 16 будут пропущены, а 
строки 17-19 будут выполнены, выводя 2, за которыми следует 3 из блока finally. Хотя первое напечатанное значение 
может отличаться, метод всегда печатает 3 последним, поскольку оно находится в блоке finally.

Каково возвращаемое значение метода goHome()? В этом случае это всегда -3. Поскольку блок finally выполняется незадолго 
до завершения метода, он прерывает оператор return как внутри блоков try, так и catch.

Для экзамена вам нужно помнить, что блок finally всегда будет выполнен. Тем не менее, это может завершиться неудачно. 
Взгляните на следующий фрагмент кода. Что произошло бы, если бы информация была null в строке 32?

```
31: } finally { 
32:    info.printDetails(); 
33:    System.out.print("Exiting"); 
34:    return "zoo"; 
35: }
```

Если бы info было равно null, то был бы выполнен блок finally, но он остановился бы на строке 32 и выдал исключение 
NullPointerException. Строки 33 и 34 не были бы выполнены. В этом примере вы видите, что, хотя блок finally всегда 
будет выполняться, он может не завершиться.

---

**System.exit()**

Существует одно исключение из правила “блок finally всегда будет выполнен”: Java определяет метод, который вы вызываете 
как System.exit(). Он принимает целочисленный параметр, представляющий возвращаемый код состояния.

```
try {       
   System.exit(0);    
} finally {       
   System.out.print("Never going to get here");  // Не напечатано    
}
```

System.exit() сообщает Java: “Остановитесь. Завершите программу прямо сейчас. Не проходите мимо, идите. Не собирайте 
200 долларов”. Когда System.exit() вызывается в блоке try или catch, блок finally не запускается.

---

## Автоматизация управления ресурсами

Зачастую ваше приложение работает с файлами, базами данных и различными объектами подключения. Обычно эти внешние 
источники данных называются ресурсами. Во многих случаях вы открываете соединение с ресурсом, будь то по сети или внутри 
файловой системы. Затем вы читаете/записываете нужные данные. Наконец, вы закрываете ресурс, чтобы указать, что вы 
закончили с ним.

Что произойдет, если вы не закроете ресурс, когда закончите с ним? Короче говоря, может случиться много плохого. Если 
вы подключаетесь к базе данных, вы можете использовать все доступные соединения, а это означает, что никто не сможет 
связаться с базой данных, пока вы не освободите свои соединения. Хотя вы часто слышите об утечках памяти, приводящих к 
сбою программ, утечка ресурсов не менее опасна и возникает, когда программе не удается освободить свои соединения с 
ресурсом, в результате чего ресурс становится недоступным. Это может означать, что ваша программа больше не сможет 
взаимодействовать с базой данных или, что еще хуже, все программы не смогут связаться с базой данных!

На экзамене ресурсом обычно является файл или база данных, которым требуется какой-то поток или соединение для чтения 
или записи данных. В главах 14 и 15 вы создадите множество ресурсов, которые нужно будет закрыть, когда вы закончите с 
ними.

### Представляем Try-with-Resources

Давайте посмотрим на метод, который открывает файл, считывает данные и закрывает его:

```
4:  public void readFile(String file) { 
5:     FileInputStream is = null; 
6:     try { 
7:        is = new FileInputStream("myfile.txt"); 
8:        // Read file data 
9:     } catch (IOException e) { 
10:       e.printStackTrace(); 
11:    } finally { 
12:       if(is != null) { 
13:          try { 
14:             is.close(); 
15:          } catch (IOException e2) { 
16:             e2.printStackTrace(); 
17:          }
18:       }
19:    }
20: }
```

Ого, это долгий метод! Почему у нас есть два блока try и catch? Итак, строки 7 и 14 включают проверенные вызовы 
IOException, и они должны быть перехвачены методом или повторно созданы методом. Половина строк кода в этом методе 
просто закрывает ресурс. И чем больше у вас ресурсов, тем длиннее становится такой код. Например, у вас может быть 
несколько ресурсов, которые необходимо закрыть в определенном порядке. Вы также не хотите, чтобы исключение, вызванное 
закрытием одного ресурса, предотвращало закрытие другого ресурса.

Чтобы решить эту проблему, Java включает оператор try-with-resources, который автоматически закрывает все ресурсы, 
открытые в предложении try. Эта функция также известна как автоматическое управление ресурсами, поскольку Java 
автоматически заботится о закрытии.

Давайте посмотрим на наш тот же пример, используя оператор try-with-resources:

```
4:  public void readFile(String file) {
5:     try (FileInputStream is = new FileInputStream("myfile.txt")) {
6:        // Read file data 
7:     } catch (IOException e) { 
8:        e.printStackTrace(); 
9:     }
10: }
```

Функционально они похожи, но в нашей новой версии строк в два раза меньше. Однако что еще более важно, используя 
оператор try-with-resources, мы гарантируем, что как только соединение выйдет за пределы области видимости, Java 
попытается закрыть его тем же методом.

