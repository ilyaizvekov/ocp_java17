# Исключения и локализация

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Обработка исключений

+ Обрабатывать исключения с помощью try/catch/finally, try-with-resources и блоков с несколькими перехватами, включая 
пользовательские исключения

#### Реализация локализации

+ Реализуйте локализацию с использованием языковых стандартов, пакетов ресурсов, анализа и форматирования сообщений, 
дат, времени и чисел, включая денежные и процентные значения.

---

Эта глава посвящена созданию приложений, адаптирующихся к изменениям. Что произойдет, если пользователь введет неверные 
данные на веб-странице? Что, если наше соединение с базой данных оборвется во время распродажи? Наконец, как нам 
создавать приложения, поддерживающие несколько языков или географических регионов?

В этой главе мы обсуждаем эти проблемы и их решения с использованием исключений, форматирования и локализации. Один из 
способов убедиться, что ваши приложения реагируют на изменения, — это обеспечить поддержку на раннем этапе. Например, 
поддержка локализации не означает, что вам действительно нужно сразу же поддерживать определенные языки. Это просто 
означает, что ваше приложение будет легче адаптировать в будущем. Мы надеемся, что к концу этой главы мы создали 
структуру для разработки приложений, которые лучше адаптируются к изменениям.

## Понимание исключений

Программа может выйти из строя практически по любой причине. Вот лишь некоторые возможности:

+ Код пытается подключиться к веб-сайту, но подключение к Интернету не работает.
+ Вы допустили ошибку в кодировании и попытались получить доступ к недопустимому индексу в массиве.
+ Один метод вызывает другой со значением, которое этот метод не поддерживает.

Как видите, некоторые из них являются ошибками кодирования. Другие полностью вне вашего контроля. Ваша программа не 
сможет помочь, если пропадет подключение к Интернету. Единственное, что он может сделать, это разобраться с ситуацией.

### Роль исключений

Исключением является способ Java сказать: “Я сдаюсь. Я не знаю, что мне сейчас делать. Вы справляетесь с этим”. Когда 
вы пишете метод, вы можете либо справиться с исключением, либо сделать его проблемой вызывающего кода.

В качестве примера представьте себе Java как ребенка, который посещает зоопарк. Счастливый путь - это когда ничего не 
идет не так. Ребенок продолжает смотреть на животных до тех пор, пока программа не закончится красиво. Ничего не пошло 
не так, и не было никаких исключений, с которыми нужно было иметь дело.

Младшая сестра этого ребенка не прошла счастливый путь. В волнении она спотыкается и падает. К счастью, это неплохое 
падение. Маленькая девочка встает и продолжает смотреть на других животных. Она сама справилась с этой проблемой. К 
сожалению, позже в тот же день она снова падает и начинает плакать. На этот раз она, плача, заявила, что ей нужна 
помощь. История заканчивается хорошо. Ее папа потирает ее колено и обнимает. Затем они снова начинают наблюдать за 
другими животными и наслаждаются остатком дня.

Это два подхода, которые Java использует при работе с исключениями. Метод может обрабатывать исключительную ситуацию 
сам или возложить ответственность за это на вызывающую сторону.

---

**Сценарий реального мира**

Return Codes vs. Exceptions

Исключения используются, когда «что-то идет не так». Однако слово «неправильно» является субъективным. Следующий код 
возвращает -1 вместо того, чтобы генерировать исключение, если совпадение не найдено:

```
public int indexOf(String[] names, String name) {
   for (int i = 0; i < names.length; i++) {
      if (names[i].equals(name)) { return i; }
   }
   return -1;
}
```

Хотя коды возврата являются общими для определенных задач, таких как поиск, их, как правило, следует избегать. В конце 
концов, Java предоставила фреймворк исключений, так что вы должны его использовать!

---

### Понимание типов исключений

Исключением является событие, которое изменяет ход программы. В Java есть класс Throwable для всех объектов, 
представляющих эти события. Не у всех из них в названии класса есть слово «исключение», что может сбивать с толку. На 
рисунке 11.1 показаны ключевые подклассы Throwable.

#### Рис. 11.1 - Категории исключений



### Проверяемые исключения

Проверяемое исключение - это исключение, которое должно быть объявлено или обработано кодом приложения, в котором оно 
генерируется. В Java все проверяемые исключения наследуют Exception, но не RuntimeException. проверяемые исключения, как 
правило, более ожидаемы — например, попытка прочитать несуществующий файл.

_Проверяемые исключения также включают любой класс, который наследует Throwable, но не Error или RuntimeException, 
например класс, который непосредственно расширяет Throwable. Для экзамена вам просто нужно знать о проверяемых 
исключениях, которые расширяют Exception._

проверяемые исключения? Что мы проверяем? В Java есть правило, называемое правилом handle или declare. Правило handle 
или declare означает, что все проверяемые исключения, которые могут быть выброшены внутри метода, либо заключены в 
совместимые блоки try и catch, либо объявлены в сигнатуре метода.

Поскольку проверяемые исключения, как правило, ожидаемы, Java применяет правило, согласно которому программист должен 
сделать что-то, чтобы показать, что об исключении думали. Возможно, это было обработано в методе. Или, может быть, метод 
объявляет, что он не может обработать исключение, и это должен сделать кто-то другой.

Давайте взглянем на пример. Следующий метод fall() объявляет, что он может вызвать исключение IOException, которое 
является проверяемым исключением:

```
void fall(int distance) throws IOException {
  if (distance > 10) {
     throw new IOException();
  }
}
```

Обратите внимание, что вы используете здесь два разных ключевых слова. Ключевое слово throw сообщает Java, что вы хотите 
выдать исключение, а ключевое слово throws просто объявляет, что метод может выдать исключение. А может и нет.

Теперь, когда вы знаете, как объявить исключение, как с ним справиться? Следующая альтернативная версия метода fall() 
обрабатывает это исключение:

```
void fall(int distance) {
   try {
     if (distance > 10) {
        throw new IOException();
     }
   } catch (Exception e) {
      e.printStackTrace();
   }
}
```

Обратите внимание, что оператор catch использует Exception, а не IOException. Поскольку IOException является подклассом 
Exception, блоку catch разрешено его перехватывать. Более подробно блоки try и catch мы рассмотрим далее в этой главе.

### Непроверяемые исключения

Непроверяемое исключение - это любое исключение, которое не нужно объявлять или обрабатывать кодом приложения, в котором 
оно генерируется. Непроверяемые исключения часто называют исключениями времени выполнения, хотя в Java непроверяемые 
исключения включают любой класс, который наследует RuntimeException или Error.

_Допустимо обрабатывать или объявлять непроверяемое исключение. Тем не менее, лучше задокументировать непроверяемые 
исключения, о которых должны знать вызывающие, в комментарии Javadoc, а не объявлять непроверяемое исключение._

Исключение во время выполнения определяется как класс RuntimeException и его подклассы. Исключения во время выполнения, 
как правило, бывают неожиданными, но не обязательно фатальными. Например, доступ к недопустимому индексу массива 
является неожиданным. Несмотря на то, что они наследуют класс Exception, они не являются проверяемыми исключениями.

Непроверяемое исключение может возникнуть практически в любой строке кода, поскольку его не требуется обрабатывать или 
объявлять. Например, исключение NullPointerException может быть вызвано в теле следующего метода, если входная ссылка 
равна null:

```
void fall(String input) {
   System.out.println(input.toLowerCase());
}
```

Мы работаем с объектами в Java так часто, что исключение NullPointerException может возникнуть практически в любом 
месте. Если бы вам приходилось объявлять непроверяемые исключения везде, в каждом отдельном методе был бы такой 
беспорядок! Код скомпилируется, если вы объявите непроверяемое исключение. Однако это излишне.

### Error и Throwable

Error означает, что что-то пошло настолько ужасно неправильно, что ваша программа не должна пытаться восстановиться 
после этого. Например, дисковод “исчез” или программе не хватило памяти. Это ненормальные состояния, с которыми вы вряд 
ли столкнетесь и от которых не сможете оправиться.

Для экзамена единственное, что вам нужно знать о Throwable, это то, что это родительский класс всех исключений, включая 
класс Error. Хотя вы можете обрабатывать исключения Throwable и Error, не рекомендуется делать это в коде вашего 
приложения. Когда мы ссылаемся на исключения в этой главе, мы обычно имеем в виду любой класс, который наследует 
Throwable, хотя мы почти всегда работаем с классом Exception или его подклассами.

### Обзор типов исключений

Обязательно внимательно изучите все, что приведено в таблице 11.1. Перед экзаменом помните, что Throwable - это либо 
исключение, либо ошибка. Вы не должны перехватывать Throwable непосредственно в своем коде.

#### Таблица 11.1 - Типы исключений и ошибок

|           Тип            |                   Как распознать                    | Все в порядке, чтобы программа поймала? | Требуется ли программа для обработки или объявления? |  
|:------------------------:|:---------------------------------------------------:|:---------------------------------------:|:----------------------------------------------------:|
| Непроверяемые исключения |            Подкласс из RuntimeException             |                   Да                    |                         Нет                          |
| Проверяемые исключения   | Подкласс Exception, но не подкласс RuntimeException |                   Да                    |                          Да                          |
|          Error           |                  Подкласс из Error                  |                   Нет                   |                         Нет                          |

### Выбрасывание исключения

Любой Java-код может генерировать исключение; это включает в себя код, который вы пишете. Некоторые исключения 
предусмотрены в Java. Вы можете столкнуться с исключением, которое было составлено для экзамена. Это прекрасно. Вопрос 
сделает очевидным, что это исключение, поскольку имя класса заканчивается на Exception. Например, MyMadeUpException явно 
является исключением.

На экзамене вы увидите два типа кода, которые приводят к исключению. Первый - это неправильный код. Вот пример:

```
String[] animals = new String[0]; 
System.out.println(animals[0]);  // ArrayIndexOutOfBoundsException
```

Этот код генерирует исключение ArrayIndexOutOfBoundsException, поскольку в массиве нет элементов. Это означает, что 
вопросы об исключениях могут быть скрыты за вопросами, которые кажутся о чем-то другом.

_На экзамене в некоторых вопросах есть выбор не компилировать и выбрасывать исключение. Обратите особое внимание на код, 
который вызывает метод по нулевой ссылке или ссылается на недопустимый массив или индекс списка. Если вы заметили это, 
то знаете, что правильный ответ — код генерирует исключение во время выполнения._

Второй способ создания исключения в коде — это явный запрос Java на его создание. Java позволяет вам писать такие 
операторы:

```
throw new Exception(); 
throw new Exception("Ow! I fell."); 
throw new RuntimeException(); 
throw new RuntimeException("Ow! I fell.");
```

Ключевое слово throw сообщает Java, что вы хотите, чтобы какая-то другая часть кода обрабатывала исключение. Это то же 
самое, что молодая девушка, оплакивающая своего папу. Кто-то другой должен выяснить, что делать с этим исключением.

---

**throw vs. throws**

Всякий раз, когда вы видите throws на экзамене, убедитесь, что используется правильный. Ключевое слово throw 
используется как оператор внутри блока кода для создания нового исключения или повторного создания существующего 
исключения, в то время как ключевое слово throws используется только в конце объявления метода, чтобы указать, какие 
исключения он поддерживает.

---

При создании исключения вы обычно можете передать параметр String вместе с сообщением или можете не передавать 
параметры и использовать значения по умолчанию. Мы говорим «обычно», потому что это условность. Кто-то объявил 
конструктор, принимающий String. Кто-то также может создать класс исключений, у которого нет конструктора, принимающего 
сообщение.

Кроме того, вы должны знать, что исключение - это объект. Это означает, что вы можете сохранить его в ссылке на объект, 
и это законно:

```
var e = new RuntimeException();
throw e;
```

Код создает исключение в одной строке, а затем генерирует в следующей. Исключение может исходить откуда угодно, даже 
передаваться в метод. Пока это допустимое исключение, оно может быть выброшено.

Экзамен также может попытаться обмануть вас. Вы понимаете, почему этот код не компилируется?

```
throw RuntimeException();   // НЕ КОМПИЛИРУЕТСЯ
```

Если ваш ответ заключается в том, что отсутствует ключевое слово, вы абсолютно правы. Исключение никогда не создается с 
помощью ключевого слова new.

Давайте взглянем на еще одно место, где экзамен может попытаться вас обмануть. Вы понимаете, почему следующее не 
компилируется?

```
3: try { 
4:    throw new RuntimeException(); 
5:    throw new ArrayIndexOutOfBoundsException();  // НЕ КОМПИЛИРУЕТСЯ
6: } catch (Exception e) {}
```

Поскольку строка 4 генерирует исключение, строка 5 никогда не может быть достигнута во время выполнения. Компилятор 
распознает это и сообщает о недостижимой ошибке кода.

### Вызов методов, генерирующие исключения

Когда вы вызываете метод, который генерирует исключение, правила те же, что и внутри метода. Вы понимаете, почему 
следующее не компилируется?

```
class NoMoreCarrotsException extends Exception {}

public class Bunny {
   public static void main(String[] args) {
      eatCarrot();  // НЕ КОМПИЛИРУЕТСЯ
   }
   private static void eatCarrot() throws NoMoreCarrotsException {}
}
```

Проблема в том, что NoMoreCarrotsException является проверяемым исключением. Проверяемые исключения должны быть 
обработаны или объявлены. Код скомпилируется, если вы измените метод main() на любой из следующих:

```
public static void main(String[] args) throws NoMoreCarrotsException {      
   eatCarrot();   
}

public static void main(String[] args) {
   try {
      eatCarrot();
   } catch (NoMoreCarrotsException e) {
      System.out.print("sad rabbit");      
   }
}
```

Возможно, вы заметили, что eatCarrot() не генерирует исключение; он просто заявил, что может. Этого достаточно, 
чтобы компилятор потребовал от вызывающей стороны обработать или объявить исключение.

Компилятор все еще ищет недоступный код. Объявление неиспользуемого исключения не считается недоступным кодом. Это 
дает методу возможность изменить реализацию, чтобы генерировать это исключение в будущем. Вы видите здесь проблему?

```
public void bad() {
   try {
      eatCarrot();
   } catch (NoMoreCarrotsException e) {  // НЕ КОМПИЛИРУЕТСЯ
      System.out.print("sad rabbit");
   }
}

private void eatCarrot() {}
```

Java знает, что eatCarrot() не может генерировать проверяемое исключение, а это означает, что блок catch в bad() не 
может быть достигнут.

_Когда вы видите проверяемое исключение, объявленное внутри блока catch на экзамене, убедитесь, что код в связанном блоке 
try способен выбросить это исключение или его подкласс. В противном случае код недоступен и не компилируется. Помните, 
что это правило не распространяется на непроверяемые исключения или исключения, объявленные в сигнатуре метода._

### Переопределение методов с исключениями

Когда мы представили переопределяющие методы в главе 6 «Проектирование классов», мы включили правило, связанное с 
исключениями. Переопределенный метод не может объявлять какие-либо новые или более широких проверяемых исключений, 
чем метод, который он наследует. Например, этот код не разрешен:

```
class CanNotHopException extends Exception {}

class Hopper {
   public void hop() {}
}

class Bunny extends Hopper {
   public void hop() throws CanNotHopException {}  // НЕ КОМПИЛИРУЕТСЯ
}
```

Java знает, что функции hop() не разрешено генерировать какие-либо проверяемые исключения, потому что метод hop() в 
суперклассе Hopper их не объявляет. Представьте, что произошло бы, если бы версии метода для подклассов могли добавлять 
проверяемые исключения — вы могли бы написать код, который вызывает метод Hopper's hop() и не обрабатывает 
никаких исключений. Тогда, если бы вместо него использовался Bunny, код не знал бы, как обрабатывать или объявлять 
CanNotHopException.

Переопределенному методу в подклассе разрешается объявлять меньше исключений, чем суперклассу или интерфейсу. Это 
допустимо, потому что абоненты уже обрабатывают их.

```
class Hopper {    
public void hop() throws CanNotHopException {}
}
class Bunny extends Hopper {    
public void hop() {}  // Это прекрасно
}
```

Переопределенный метод, не объявляющий одно из исключений, генерируемых родительским методом, аналогичен методу, 
объявляющему, что он генерирует исключение, которое на самом деле никогда не генерируется. Это совершенно законно. 
Аналогично, классу разрешается объявлять подкласс типа exception. Идея та же самая. Суперкласс или интерфейс уже 
позаботился о более широком типе.

### Печать исключения

Существует три способа распечатать исключение. Вы можете позволить Java распечатать его, распечатать только сообщение 
или указать, откуда берется трассировка стека. В этом примере показаны все три подхода:

```
5:  public static void main(String[] args) { 
6:     try { 
7:        hop(); 
8:     } catch (Exception e) { 
9:        System.out.println(e + "\n"); 
10:       System.out.println(e.getMessage()+ "\n"); 
11:       e.printStackTrace(); 
12:    }
13: }
14: private static void hop() { 
15:    throw new RuntimeException("cannot hop"); 
16: }
```

Этот код печатает следующее:

```
java.lang.RuntimeException: cannot hop

cannot hop

java.lang.RuntimeException: cannot hop
   at Handling.hop(Handling.java:15)
   at Handling.main(Handling.java:7)
```

В первой строке показано, что Java выводит по умолчанию: тип исключения и сообщение. Вторая строка показывает только 
сообщение. Остальное показывает трассировку стека. Трассировка стека обычно оказывается наиболее полезной, поскольку она 
показывает иерархию вызовов методов, которые были выполнены для достижения строки, вызвавшей исключение.

## Распознавание классов исключений

Для экзамена вам необходимо распознать три группы классов исключений: RuntimeException, проверяемое Exception и Error. 
Мы рассмотрим типичные примеры каждого типа. На экзамене вам нужно будет узнать, какой это тип исключения и создано ли 
оно виртуальной машиной Java (JVM) или программистом. За некоторыми исключениями вам также необходимо знать, какие из 
них наследуются друг от друга.

### Классы RuntimeException

RuntimeException и его подклассы — это непроверяемые исключения, которые не нужно обрабатывать или объявлять. Они могут 
быть созданы программистом или JVM. Распространенные классы непроверяемых исключений перечислены в таблице 11.2.

#### Таблица 11.2 - Непроверяемые исключения

|    Непроверяемое исключение    |                                                                             Описание                                                                              |  
|:------------------------------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|      ArithmeticException       |                                                       Выбрасывается, когда код пытается разделить на ноль.                                                        |
| ArrayIndexOutOfBoundsException |                                          Выбрасывается, когда код использует недопустимый индекс для доступа к массиву.                                           |
|       ClassCastException       |                                     Выбрасывается при попытке привести объект к классу, экземпляром которого он не является.                                      |
|      NullPointerException      |                                                Генерируется, когда есть null-ссылка, для которой требуется объект.                                                |
|    IllegalArgumentException    |                             Выбрасывается программистом, чтобы указать, что методу был передан незаконный или неподходящий аргумент.                              |
|     NumberFormatException      | Подкласс IllegalArgumentException. Выбрасывается, когда предпринимается попытка преобразовать строку в числовой тип, но строка не имеет соответствующего формата. |


### ArithmeticException

Попытка разделить целое число на ноль дает неопределенный результат. Когда это произойдет, JVM 
выдаст ArithmeticException:

```
int answer = 11 / 0;
```

Запуск этого кода приводит к следующему выводу:

```
Exception in thread "main" java.lang.ArithmeticException: / by zero
```

В Java не используется слово «разделить». Однако это нормально, потому что мы знаем, что / — это оператор деления и что 
Java пытается сообщить вам, что произошло деление на ноль.

Поток «main» сообщает вам, что код был вызван прямо или косвенно из программы с методом main. На экзамене это все, 
что вы увидите. Далее следует имя исключения, а затем дополнительная информация (если таковая имеется), связанная с 
исключением.

### ArrayIndexOutOfBoundsException

Теперь вы уже знаете, что индексы массива начинаются с 0 и увеличиваются на 1, что меньше длины массива — что означает, 
что этот код вызовет исключение ArrayIndexOutOfBoundsException:

```
int[] countsOfMoose = new int[3];
System.out.println(countsOfMoose[-1]);
```

Это проблема, потому что не существует такого понятия, как отрицательный индекс массива. Выполнение этого кода приводит 
к следующему результату:

```
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException:
Index -1 out of bounds for length 3
```

### ClassCastException

Java пытается защитить вас от невозможных приведений. Этот код не компилируется, поскольку Integer не является 
подклассом String:

```
String type = "moose"; 
Integer number = (Integer) type;  // НЕ КОМПИЛИРУЕТСЯ
```

Более сложный код препятствует попыткам Java защитить вас. Если приведение завершается неудачно во время выполнения, 
Java выдаст исключение ClassCastException:

```
String type = "moose"; 
Object obj = type; 
Integer number = (Integer) obj; // ClassCastException
```

Компилятор видит приведение Object к Integer. Это может быть хорошо. Компилятор не осознает, что в этом объекте есть 
строка. Когда код запускается, он дает следующий результат:

```
Exception in thread "main" java.lang.ClassCastException: 
java.base/java.lang.String
cannot be cast to java.lang.base/java.lang.Integer
```

Java сообщает вам оба типа, которые были вовлечены в проблему, делая очевидным, что не так.

### NullPointerException

Переменные экземпляра и методы должны вызываться по ненулевой ссылке. Если ссылка равна null, JVM выдаст исключение 
NullPointerException.

```
1: public class Frog { 
2:    public void hop(String name, Integer jump) { 
3:       System.out.print(name.toLowerCase() + " " + jump.intValue()); 
4:    }
5:    
6:    public static void main(String[] args) { 
7:       new Frog().hop(null, 1); 
8:    } }
```

Выполнение этого кода приводит к следующему результату:

```
Exception in thread "main" java.lang.NullPointerException: Cannot invoke
"String.toLowerCase()" because "<parameter1>" is null
```

Если вы новичок в Java 17, вы должны были заметить что-то особенное в выводе. JVM теперь сообщает вам ссылку на объект, 
вызвавшую исключение NullPointerException! Эта новая функция называется Helpful NullPointerExceptions.

В качестве другого примера предположим, что мы изменили строку 7:

```
7:       new Frog().hop("Kermit", null);
```

Затем вывод во время выполнения изменяется следующим образом:

```
Exception in thread "main" java.lang.NullPointerException: Cannot invoke
"java.lang.Integer.intValue()" because "<parameter2>" is null
```

_По умолчанию исключение NullPointerException для локальной переменной или параметра метода печатается с номером, 
указывающим порядок его появления в методе, например <local2> или <parameter4>. Если вы похожи на нас и хотите, чтобы 
отображалось фактическое имя переменной, скомпилируйте код с флагом -g:vars, который добавляет отладочную информацию. В 
предыдущих примерах <parameter1> и <parameter2> заменяются именем и переходом соответственно._

Поскольку это новая функция в Java, возможно, вы увидите ее в вопросе на экзамене.

---

**Включение/выключение Helpful NullPointerExceptions**

Когда в Java 14 были добавлены полезные исключения NullPointerException, эта функция была отключена по умолчанию, и ее 
нужно было включать с помощью аргумента командной строки ShowCodeDetailsInExceptionMessages для JVM:

```
java -XX:+ShowCodeDetailsInExceptionMessages Frog
```

В Java 15 и более поздних версиях поведение по умолчанию было изменено, и теперь оно включено по умолчанию, хотя его все 
еще можно отключить с помощью аргумента командной строки.

```
java -XX:-ShowCodeDetailsInExceptionMessages Frog
```

---

### IllegalArgumentException

IllegalArgumentException — это способ защитить вашу программу. Вы хотите сообщить вызывающему абоненту, что что-то не 
так, — желательно очевидным образом, чтобы вызывающий абонент не мог его игнорировать, чтобы программист исправил 
проблему. Видеть, что код заканчивается исключением, — отличное напоминание о том, что что-то не так. Рассмотрим этот 
пример при вызове setNumberEggs(-2):

```
public void setNumberEggs(int numberEggs) {
   if (numberEggs < 0)
      throw new IllegalArgumentException("# eggs must not be negative");
   this.numberEggs = numberEggs;
}
```

Программа выдает исключение, когда ее не устраивают значения параметров. Вывод выглядит следующим образом:

```
Exception in thread "main"
java.lang.IllegalArgumentException: # eggs must not be negative
```

Очевидно, что эту проблему необходимо решить, если программист хочет, чтобы программа делала что-нибудь полезное.

### NumberFormatException

Java предоставляет методы для преобразования строк в числа. Когда им передается недопустимое значение, они вызывают 
исключение NumberFormatException. Идея аналогична IllegalArgumentException. Поскольку это распространенная проблема, 
Java выделяет ей отдельный класс. Фактически NumberFormatException является подклассом IllegalArgumentException. Вот 
пример попытки преобразовать что-то нечисловое в int:

```
Integer.parseInt("abc");
```

Вывод выглядит следующим образом:

```
Exception in thread "main"
java.lang.NumberFormatException: For input string: "abc"
```

Для сдачи экзамена вам необходимо знать, что NumberFormatException является подклассом IllegalArgumentException. 
Подробнее о том, почему это важно, мы поговорим позже в этой главе.

### Классы проверяемых исключений

Проверяемые исключения имеют Exception в своей иерархии, но не RuntimeException. Они должны быть обработаны или 
объявлены. Распространенные проверяемые исключения перечислены в таблице 11.3.

Для экзамена вам нужно знать, что все это проверяемые исключения, которые должны быть обработаны или объявлены. Вам 
также нужно знать, что FileNotFoundException и NotSerializableException являются подклассами IOException. Вы видите эти 
три класса в главе 14, “Ввод-вывод”, и SQLException в главе 15, “JDBC”.

#### Таблица 11.3 - Проверяемые исключения

|  Проверяемое исключение  |                                                     Описание                                                     |  
|:------------------------:|:----------------------------------------------------------------------------------------------------------------:|
|  FileNotFoundException   |       Подкласс IOException. Генерируется программно, когда код пытается сослаться на несуществующий файл.        |
|       IOException        |                 Выбрасывается программно при возникновении проблем с чтением или записью файла.                  |
| NotSerializableException | Подкласс IOException. Вызывается программно при попытке сериализации или десериализации несериализуемого класса. |
|      ParseException      |                         Указывает на проблему с синтаксическим анализом входных данных.                          |
|      SQLException        |                             Выдается при ошибке, связанной с доступом к базе данных.                             |


### Классы ошибок

Ошибки — это непроверяемые исключения, расширяющие класс Error. Они создаются JVM и не должны обрабатываться или 
объявляться. Ошибки редки, но вы можете увидеть ошибки, перечисленные в таблице 11.4.

#### Таблица 11.4 - Ошибки 

|           Ошибка            |                                                                    Описание                                                                    |  
|:---------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------:|
| ExceptionInInitializerError |                              Вызывается, когда статический инициализатор выдает исключение и не обрабатывает его.                              |
|     StackOverflowError      | Вызывается, когда метод вызывает себя слишком много раз (так называемая бесконечная рекурсия, поскольку метод обычно вызывает себя без конца). |
|    NoClassDefFoundError     |                   Вызывается, когда класс, который использует код, доступен во время компиляции, но не во время выполнения.                    |

Для экзамена вам просто нужно знать, что эти ошибки не проверены и код часто не может восстановиться после них.

## Обработка исключений

Что вы делаете, когда встречаете исключение? Как вы обрабатываете исключение или восстанавливаетесь после него? В этом 
разделе мы покажем различные операторы Java, поддерживающие обработку исключений.

### Использование операторов try и catch

Теперь, когда вы знаете, что такое исключения, давайте посмотрим, как с ними обращаться. Java использует оператор try, 
чтобы отделить логику, которая может вызвать исключение, от логики, обрабатывающей это исключение. На рисунке 11.2 
показан синтаксис оператора try.

#### Рис. 11.2 - Синтаксис оператора try


Код в блоке try выполняется нормально. Если какой-либо из операторов генерирует исключение, которое может быть 
перехвачено типом исключения, указанным в блоке catch, блок try прекращает работу и выполнение переходит к оператору 
catch. Если ни один из операторов в блоке try не генерирует исключение, которое можно перехватить, предложение catch не 
запускается.

Вы, наверное, заметили, что слова «блок» и «предложение» используются как взаимозаменяемые. Экзамен тоже делает то же 
самое, так что привыкайте к этому. Оба верны. Блок правильный, потому что присутствуют фигурные скобки. Предложение 
правильное, поскольку оно является частью оператора try.

Здесь нет множества синтаксических правил. Фигурные скобки необходимы для блоков try и catch. В нашем примере маленькая 
девочка встает сама, когда впервые падает. Вот как это выглядит:

```
3:  void explore() { 
4:     try { 
5:        fall(); 
6:        System.out.println("never get here"); 
7:     } catch (RuntimeException e) { 
8:        getUp(); 
9:     }
10:    seeAnimals(); 
11: }
12: void fall() {  throw new RuntimeException(); }
```

Во-первых, строка 5 вызывает метод fall(). Строка 12 выдает исключение. Это означает, что Java переходит прямо к блоку 
catch, пропуская строку 6. Девушка встает на строку 8. Теперь оператор try завершен, и выполнение продолжается нормально 
со строки 10.

Теперь давайте посмотрим на некоторые неверные операторы try, с помощью которых экзамен может попытаться вас обмануть. 
Вы видите, что с этим не так?

```
try  // НЕ КОМПИЛИРУЕТСЯ    
   fall();
catch (Exception e)    
   System.out.println("get up");
```

Проблема в том, что фигурные скобки {} отсутствуют. Операторы try подобны методам: фигурные скобки необходимы, даже 
если внутри блоков кода есть только один оператор, а операторы if и циклы являются специальными и позволяют опускать 
фигурные скобки.

Как насчет этого?

```
try {  // НЕ КОМПИЛИРУЕТСЯ    
   fall();
}
```

Этот код не компилируется, потому что после блока try ничего нет. Помните, что смысл оператора try заключается в том, 
чтобы что-то произошло, если возникнет исключение. Без другого предложения оператор try будет одиноким. Как вы вскоре 
увидите, существует особый тип оператора try, который включает в себя неявный блок finally, хотя синтаксис сильно 
отличается от этого примера.

### Цепочка блоков catch

Для подготовки к экзамену вам могут быть предоставлены классы исключений, и вам необходимо понять, как они 
функционируют. Вот как с ними бороться. Во-первых, вы должны быть в состоянии распознать, является ли исключение 
проверяемым или непроверяемым. Во-вторых, вам нужно определить, является ли какое-либо из исключений подклассами других.

```
class AnimalsOutForAWalk extends RuntimeException {}

class ExhibitClosed extends RuntimeException {}

class ExhibitClosedForLunch extends ExhibitClosed {}
```

В этом примере есть три пользовательских исключения. Все они являются непроверяемыми исключениями, поскольку они прямо 
или косвенно расширяют RuntimeException. Теперь мы объединяем оба типа исключений в цепочку с двумя блоками catch и 
обрабатываем их, распечатывая соответствующее сообщение:

```
public void visitPorcupine() {
   try {
      seeAnimal();
   } catch (AnimalsOutForAWalk e) {  // первый блок catch
      System.out.print("try back later");
   } catch (ExhibitClosed e) {       // второй блок catch
      System.out.print("not today");
   }
}
```

При запуске этого кода возможны три варианта. Если seeAnimal() не генерирует исключение, ничего не распечатывается. 
Если животное вышло на прогулку, выполняется только первый блок отлова. Если выставка закрыта, запускается только 
второй блок catch. Невозможно, чтобы оба блока catch выполнялись, когда они соединены таким образом.

Существует правило для порядка следования блоков catch. Java просматривает их в том порядке, в котором они появляются. 
Если выполнение одного из блоков catch невозможно, возникает ошибка компилятора о недоступности кода. Например, это 
происходит, когда блок catch суперкласса появляется перед блоком catch подкласса. Помните, мы предупреждали вас 
о необходимости обращать внимание на любые исключения из подкласса.

В примере с дикобразом порядок блоков catch может быть изменен на противоположный, поскольку исключения не наследуются 
друг от друга. И да, мы видели, как дикобраза выводили на прогулку на поводке.

В следующем примере показаны типы исключений, которые наследуются друг от друга:

```
public void visitMonkeys() {
   try {
      seeAnimal();
   } catch (ExhibitClosedForLunch e) {  // Исключение подкласса
      System.out.print("try back later");
   } catch (ExhibitClosed e) {          // Исключение суперкласса
      System.out.print("not today");
   }
}
```

Если выдается более конкретное исключение ExhibitClosedForLunch, запускается первый блок catch. Если нет, Java 
проверяет, выброшено ли исключение ExhibitClosed суперкласса, и перехватывает его. На этот раз порядок блоков catch 
имеет значение. Обратное не работает.

```
public void visitMonkeys() {
   try {
      seeAnimal();
   } catch (ExhibitClosed e) {
      System.out.print("not today");
   } catch (ExhibitClosedForLunch e) {  // НЕ КОМПИЛИРУЕТСЯ
      System.out.print("try back later");
   } 
}
```

Если выдается более конкретное исключение ExhibitClosedForLunch, блок catch для ExhibitClosed запускается, а это 
означает, что второй блок catch не может быть запущен. Java правильно сообщает вам, что существует недостижимый блок 
catch.

Давайте попробуем это еще раз. Вы понимаете, почему этот код не компилируется?

```
public void visitSnakes() {    
   try {   
   } catch (IllegalArgumentException e) {   
   } catch (NumberFormatException e) {  // НЕ КОМПИЛИРУЕТСЯ   
   }
}
```

Помните, ранее мы говорили, что вам нужно знать, что NumberFormatException является подклассом IllegalArgumentException? 
Этот пример является причиной. Поскольку NumberFormatException является подклассом, оно всегда будет перехватываться 
первым блоком catch, что делает код второго блока catch недоступным, который не компилируется. Аналогично, для сдачи 
экзамена вам необходимо знать, что FileNotFoundException является подклассом IOException и не может использоваться 
аналогичным образом.

Чтобы просмотреть несколько блоков catch, помните, что будет запущен не более одного блока catch, и это будет первый 
блок catch, который сможет обработать исключение. Кроме того, помните, что исключение, определенное оператором catch, 
находится в области действия только этого блока catch. Например, следующий код вызывает ошибку компилятора, поскольку 
он пытается использовать объект исключения вне блока, для которого он был определен:

```
public void visitManatees() {
   try {
   } catch (NumberFormatException e1) {
      System.out.println(e1);
   } catch (IllegalArgumentException e2) {
      System.out.println(e1);  // НЕ КОМПИЛИРУЕТСЯ
   }
}
```

### Применение блока multi-catch

Часто мы хотим, чтобы результат выброшенного исключения был одинаковым, независимо от того, какое конкретное исключение 
было выброшено. Например, взгляните на этот метод:

```
public static void main(String args[]) {    
   try {      
      System.out.println(Integer.parseInt(args[1]));   
   } catch (ArrayIndexOutOfBoundsException e) {      
      System.out.println("Missing or invalid input");
   } catch (NumberFormatException e) {      
      System.out.println("Missing or invalid input");   
   }
}
```

Обратите внимание, что у нас есть один и тот же оператор println() для двух разных блоков catch. Мы можем справиться с 
этим более изящно, используя блок multi-catch. Блок multi-catch позволяет перехватывать несколько типов исключений 
одним и тем же блоком catch. Давайте перепишем предыдущий пример, используя блок multi-catch:

```
public static void main(String[] args) {
   try {
      System.out.println(Integer.parseInt(args[1]));
   } catch (ArrayIndexOutOfBoundsException | NumberFormatException e) {
      System.out.println("Missing or invalid input");
   }
}
```

Это намного лучше. Здесь нет дублирующегося кода, вся общая логика собрана в одном месте, и логика находится именно там, 
где вы ожидаете ее найти. При желании вы все равно можете иметь второй блок catch для исключений на случай, если вы 
захотите по-другому обрабатывать другие типы исключений.

На рисунке 11.3 показан синтаксис multi-catch. Это похоже на обычное предложение catch, за исключением того, что 
указаны два или более типов исключений, разделенных вертикальной чертой. Конвейер (|) также используется в качестве 
оператора «или», что позволяет легко запомнить, что вы можете использовать любой из типов исключений. Обратите 
внимание, что в предложении catch есть только одно имя переменной. Java говорит, что переменная с именем e может иметь 
тип Exception1 или Exception2.

#### Рис. 11.3 - Синтаксис блока multi-catch


Экзамен может попытаться обмануть вас неверным синтаксисом. Помните, что исключения могут быть перечислены в любом 
порядке в предложении catch. Однако имя переменной должно появляться только один раз и в конце. Вы понимаете, почему 
они действительны или недействительны?

```
catch(Exception1 e | Exception2 e | Exception3 e) // НЕ КОМПИЛИРУЕТСЯ

catch(Exception1 e1 | Exception2 e2 | Exception3 e3) // НЕ КОМПИЛИРУЕТСЯ

catch(Exception1 | Exception2 | Exception3 e)
```

Первая строка неверна, поскольку имя переменной встречается три раза. Просто потому, что это одно и то же имя 
переменной, это не значит, что все в порядке. Вторая строка неверна, поскольку имя переменной снова встречается три 
раза. Использование разных имен переменных не делает ситуацию лучше. Третья строка компилируется. Он показывает 
правильный синтаксис для указания трех исключений.

Java предполагает использование множественного перехвата для несвязанных между собой исключений и не позволяет вам 
указывать избыточные типы в множественном перехвате. Вы видите, что здесь не так?

```
try {
   throw new IOException();
} catch (FileNotFoundException | IOException p) {} // НЕ КОМПИЛИРУЕТСЯ
```

Указание связанных исключений в multi-catch является излишним, и компилятор выдает такое сообщение:

```
The exception FileNotFoundException is already caught by the alternative
IOException
```

Поскольку FileNotFoundException является подклассом IOException, этот код не будет компилироваться. Блок multi-catch 
подчиняется правилам, аналогичным объединению блоков catch в цепочку, которые вы видели в предыдущем разделе. 
Например, оба вызывают ошибки компилятора, когда обнаруживают недостижимый код или перехватывают повторяющиеся и
сключения. Единственное различие между блоками multi-catch и блоками catch в цепочку состоит в том, что порядок не 
имеет значения для блока multi-catch внутри одного выражения catch.

Возвращаясь к примеру, правильный код — просто удалить ссылку на посторонний подкласс, как показано здесь:

```
try {
   throw new IOException();
} catch (IOException e) {}
```

### Добавление блока finally

Оператор try также позволяет запускать код в конце с предложением finally, независимо от того, создано ли исключение.  
На рис. 11.4 показан синтаксис оператора try с этой дополнительной функциональностью.

В коде есть два пути: catch и finally. Если генерируется исключение, блок finally запускается после блока catch. 
Если исключение не генерируется, блок finally запускается после завершения блока try.

Давайте вернемся к нашему примеру с молодой девушкой, на этот раз с finally:

```
12: void explore() { 
13:    try { 
14:       seeAnimals(); 
15:       fall();
16:    } catch (Exception e) { 
17:       getHugFromDaddy(); 
18:    } finally { 
19:       seeMoreAnimals();
20:    }
21:    goHome(); 
22: }
```

#### Рис. 11.4 - Синтаксис оператора try с finally


Девушка падает на строку 15. Если она встает сама, код переходит к блоку «finally» и выполняет строку 19. Затем 
оператор try завершается, и код переходит к строке 21. Если девочка не встает сама по себе она выдает исключение. 
Запускается блок catch, и она получает объятия в строке 17. Благодаря этим объятиям она готова увидеть больше животных в 
строке 19. Затем оператор try завершается, и код переходит к строке 21. В любом случае окончание будет таким: 
одинаковый. Блок «finally» выполняется, и выполнение продолжается после оператора try.

Экзамен попытается обмануть вас, указав пропущенные предложения или предложения в неправильном порядке. Вы понимаете, 
почему следующее компилируется или не компилируется?

```
25: try {  // DНЕ КОМПИЛИРУЕТСЯ
26:    fall(); 
27: } finally { 
28:    System.out.println("all better"); 
29: } catch (Exception e) { 
30:    System.out.println("get up"); 
31: }
32:
33: try {  // НЕ КОМПИЛИРУЕТСЯ
34:    fall(); 
35: }
36:
37: try { 
38:    fall(); 
39: } finally { 
40:    System.out.println("all better"); 
41: }
```

Первый пример (строки 25–31) не компилируется, поскольку блоки catch и finally расположены в неправильном порядке. 
Второй пример (строки 33–35) не компилируется, поскольку должен быть блок catch или finally. Третий пример 
(строки 37–41) вполне подходит. Блок catch не требуется, если присутствует finally.

Большинство примеров, с которыми вы столкнетесь на экзамене, в конечном итоге будут выглядеть надуманными. Например, вам 
будут заданы такие вопросы, как то, что выводит этот код:

```
public static void main(String[] unused) {
   StringBuilder sb = new StringBuilder();
   try {
      sb.append("t");
   } catch (Exception e) {
      sb.append("c");
   } finally {
      sb.append("f");
   }
   sb.append("a");
   System.out.print(sb.toString());
}
```

Ответ - tfa. Выполняется блок try. Поскольку исключение не генерируется, Java переходит прямо к блоку finally. Затем 
выполняется код после инструкции try. Мы знаем, что это глупый пример, но вы можете ожидать увидеть подобные примеры на 
экзамене.

Есть еще одно дополнительное правило, которое вы должны знать для блоков finally. Если введена инструкция try с блоком 
finally, то блок finally всегда будет выполняться, независимо от того, завершится ли код успешно. Взгляните на 
следующий метод goHome(). Предполагая, что в строке 14 может быть выдано исключение, а может и не быть, каковы 
возможные значения, которые может вывести этот метод? Кроме того, каким будет возвращаемое значение в каждом 
конкретном случае?

```
12: int goHome() { 
13:    try { 
14:       // Необязательно создавать исключение здесь
15:       System.out.print("1"); 
16:       return -1; 
17:    } catch (Exception e) { 
18:       System.out.print("2"); 
19:       return -2;
20:    } finally { 
21:       System.out.print("3"); 
22:       return -3; 
23:    }
24: }
```

Если в строке 14 не будет выдано исключение, то будет выполнена строка 15 с выводом 1. Однако перед возвратом метода 
выполняется блок finally, выводящий значение 3. Если генерируется исключение, то строки 15 и 16 будут пропущены, а 
строки 17-19 будут выполнены, выводя 2, за которыми следует 3 из блока finally. Хотя первое напечатанное значение 
может отличаться, метод всегда печатает 3 последним, поскольку оно находится в блоке finally.

Каково возвращаемое значение метода goHome()? В этом случае это всегда -3. Поскольку блок finally выполняется незадолго 
до завершения метода, он прерывает оператор return как внутри блоков try, так и catch.

Для экзамена вам нужно помнить, что блок finally всегда будет выполнен. Тем не менее, это может завершиться неудачно. 
Взгляните на следующий фрагмент кода. Что произошло бы, если бы информация была null в строке 32?

```
31: } finally { 
32:    info.printDetails(); 
33:    System.out.print("Exiting"); 
34:    return "zoo"; 
35: }
```

Если бы info было равно null, то был бы выполнен блок finally, но он остановился бы на строке 32 и выдал исключение 
NullPointerException. Строки 33 и 34 не были бы выполнены. В этом примере вы видите, что, хотя блок finally всегда 
будет выполняться, он может не завершиться.

---

**System.exit()**

Существует одно исключение из правила “блок finally всегда будет выполнен”: Java определяет метод, который вы вызываете 
как System.exit(). Он принимает целочисленный параметр, представляющий возвращаемый код состояния.

```
try {       
   System.exit(0);    
} finally {       
   System.out.print("Never going to get here");  // Не напечатано    
}
```

System.exit() сообщает Java: “Остановитесь. Завершите программу прямо сейчас. Не проходите мимо, идите. Не собирайте 
200 долларов”. Когда System.exit() вызывается в блоке try или catch, блок finally не запускается.

---

## Автоматизация управления ресурсами

Зачастую ваше приложение работает с файлами, базами данных и различными объектами подключения. Обычно эти внешние 
источники данных называются ресурсами. Во многих случаях вы открываете соединение с ресурсом, будь то по сети или внутри 
файловой системы. Затем вы читаете/записываете нужные данные. Наконец, вы закрываете ресурс, чтобы указать, что вы 
закончили с ним.

Что произойдет, если вы не закроете ресурс, когда закончите с ним? Короче говоря, может случиться много плохого. Если 
вы подключаетесь к базе данных, вы можете использовать все доступные соединения, а это означает, что никто не сможет 
связаться с базой данных, пока вы не освободите свои соединения. Хотя вы часто слышите об утечках памяти, приводящих к 
сбою программ, утечка ресурсов не менее опасна и возникает, когда программе не удается освободить свои соединения с 
ресурсом, в результате чего ресурс становится недоступным. Это может означать, что ваша программа больше не сможет 
взаимодействовать с базой данных или, что еще хуже, все программы не смогут связаться с базой данных!

На экзамене ресурсом обычно является файл или база данных, которым требуется какой-то поток или соединение для чтения 
или записи данных. В главах 14 и 15 вы создадите множество ресурсов, которые нужно будет закрыть, когда вы закончите с 
ними.

### Представляем Try-with-Resources

Давайте посмотрим на метод, который открывает файл, считывает данные и закрывает его:

```
4:  public void readFile(String file) { 
5:     FileInputStream is = null; 
6:     try { 
7:        is = new FileInputStream("myfile.txt"); 
8:        // Read file data 
9:     } catch (IOException e) { 
10:       e.printStackTrace(); 
11:    } finally { 
12:       if(is != null) { 
13:          try { 
14:             is.close(); 
15:          } catch (IOException e2) { 
16:             e2.printStackTrace(); 
17:          }
18:       }
19:    }
20: }
```

Ого, это долгий метод! Почему у нас есть два блока try и catch? Итак, строки 7 и 14 включают проверенные вызовы 
IOException, и они должны быть перехвачены методом или повторно созданы методом. Половина строк кода в этом методе 
просто закрывает ресурс. И чем больше у вас ресурсов, тем длиннее становится такой код. Например, у вас может быть 
несколько ресурсов, которые необходимо закрыть в определенном порядке. Вы также не хотите, чтобы исключение, вызванное 
закрытием одного ресурса, предотвращало закрытие другого ресурса.

Чтобы решить эту проблему, Java включает оператор try-with-resources, который автоматически закрывает все ресурсы, 
открытые в предложении try. Эта функция также известна как автоматическое управление ресурсами, поскольку Java 
автоматически заботится о закрытии.

Давайте посмотрим на наш тот же пример, используя оператор try-with-resources:

```
4:  public void readFile(String file) {
5:     try (FileInputStream is = new FileInputStream("myfile.txt")) {
6:        // Read file data 
7:     } catch (IOException e) { 
8:        e.printStackTrace(); 
9:     }
10: }
```

Функционально они похожи, но в нашей новой версии строк в два раза меньше. Однако что еще более важно, используя 
оператор try-with-resources, мы гарантируем, что как только соединение выйдет за пределы области видимости, Java 
попытается закрыть его тем же методом.

Компилятор «за кулисами» заменяет блок try-with-resources блоком try и finally. Мы называем этот «скрытый» блок 
«finally» неявным блоком «finally», поскольку он создается и используется компилятором автоматически. Вы по-прежнему 
можете создать определяемый программистом блок finally при использовании оператора try-with-resources; просто имейте в 
виду, что неявный будет вызван первым.

_В отличие от сборки мусора, ресурсы не закрываются автоматически, когда выходят за пределы области действия. Поэтому 
рекомендуется закрывать ресурсы в том же блоке кода, который их открывает. При использовании оператора 
try-withre-sources для открытия всех ресурсов это происходит автоматически._

### Основы работы с ресурсами

На рис. 11.5 показано, как выглядит оператор try-with-resources. Обратите внимание, что в предложении try можно открыть 
один или несколько ресурсов. Когда открыто несколько ресурсов, они закрываются в порядке, обратном тому, в котором они 
были созданы. Также обратите внимание, что для перечисления этих ресурсов используются круглые скобки, а для разделения 
объявлений используются точки с запятой. Это работает так же, как объявление нескольких индексов в цикле for.

#### Рис. 11.5 - Синтаксис базового оператора try-with-resources


Что случилось с блоком catch на рисунке 11.5? Что ж, оказывается, что блок catch не является обязательным для оператора 
try-with-resources. Например, мы можем переписать предыдущий пример readFile() так, чтобы метод объявлял исключение и 
сделал его еще короче:

```
4: public void readFile(String file) throws IOException {
5:    try (FileInputStream is = new FileInputStream("myfile.txt")) {
6:       // Чтение данных файла
7:    }
8: }
```

Ранее в этой главе вы узнали, что оператор try должен иметь один или несколько блоков catch или блок finally. Оператор 
try-with-resources отличается от оператора try тем, что ни один из них не требуется, хотя разработчик может добавить 
оба. Для сдачи экзамена вам необходимо знать, что неявный блок finally запускается раньше всех блоков, закодированных 
программистом.

### Построение операторов Try-with-Resources

В операторе try-with-resources можно использовать только классы, реализующие интерфейс AutoCloseable. Например, 
следующее не компилируется, поскольку String не реализует интерфейс AutoCloseable:

```
try (String reptile = "lizard") {}
```

Наследование AutoCloseable требует реализации совместимого метода close().

```
interface AutoCloseable {
   public void close() throws Exception;
}
```

Судя по вашим исследованиям переопределения методов, это означает, что реализованная версия close() может выбрать 
исключение или подкласс или вообще не создавать никаких исключений.

В оставшейся части этого раздела мы используем следующий пользовательский класс ресурсов, который просто печатает 
сообщение при вызове метода close():

```
public class MyFileClass implements AutoCloseable {
   private final int num;
   public MyFileClass(int num) { this.num = num; }
   @Override public void close() {
      System.out.println("Closing: " + num);
   } }
```

_В главе 14 вы встретите ресурсы, реализующие Closeable, а не AutoCloseable. Поскольку Closeable расширяет 
AutoCloseable, они оба поддерживаются в операторах try-with-resources. Единственная разница между ними заключается в 
том, что метод close() класса Closeable объявляет IOException, а метод close() класса AutoCloseable объявляет Exception._

### Объявление ресурсов

Хотя try-with-resources поддерживает объявление нескольких переменных, каждая переменная должна быть объявлена в 
отдельном операторе. Например, следующее не компилируется:

```
try (MyFileClass is = new MyFileClass(1),  // НЕ КОМПИЛИРУЕТСЯ    
   os = new MyFileClass(2)) {
}

try (MyFileClass ab = new MyFileClass(1),  // НЕ КОМПИЛИРУЕТСЯ
   MyFileClass cd = new MyFileClass(2)) {
}
```

Первый пример не компилируется, поскольку в нем отсутствует тип данных и используется запятая (,) вместо точки с 
запятой (;). Второй пример не компилируется, поскольку в нем также используется запятая (,) вместо точки с запятой (;). 
Каждый ресурс должен включать тип данных и быть разделен точкой с запятой (;).

Вы можете объявить ресурс, используя var в качестве типа данных в инструкции try-with-resources, поскольку ресурсы 
являются локальными переменными.

```
try (var f = new BufferedInputStream(new FileInputStream("it.txt"))) {
   // Файл процесса
}
```

Объявление ресурсов — распространенная ситуация, когда использование var весьма полезно, поскольку сокращает и без того 
длинную строку кода.

### Объем Try-with-Resources

Ресурсы, созданные в предложении try, находятся в области видимости только внутри блока try. Это еще один способ 
запомнить, что неявный метод finally выполняется перед любыми блоками catch/finally, которые вы кодируете 
самостоятельно. Неявное закрытие уже выполнено, и ресурс больше не доступен. Вы понимаете, почему строки 6 и 8 в этом 
примере не компилируются?

```
3: try (Scanner s = new Scanner(System.in)) { 
4:    s.nextLine(); 
5: } catch(Exception e) { 
6:    s.nextInt(); // НЕ КОМПИЛИРУЕТСЯ
7: } finally { 
8:    s.nextInt(); // НЕ КОМПИЛИРУЕТСЯ
9: }
```

Проблема в том, что Scanner вышел за пределы области действия в конце предложения try. Строки 6 и 8 не имеют к нему 
доступа. Это хорошая особенность. Вы не можете случайно использовать объект, который был закрыт. В традиционном 
операторе try переменная должна быть объявлена перед оператором try, чтобы к ней могли получить доступ оба блока try и 
finally, что имеет неприятный побочный эффект, заключающийся в том, что переменная попадает в область видимости для 
остальной части метода, просто приглашая вас позвонить случайно.

### Следующий порядок операций

При работе с операторами try-with-resources важно знать, что ресурсы закрываются в порядке, обратном тому, в котором 
они создаются. Сможете ли вы, используя наш собственный MyFileClass, выяснить, что печатает этот метод?

```
public static void main(String... xyz) {
   try (MyFileClass bookReader = new MyFileClass(1);
         MyFileClass movieReader = new MyFileClass(2)) {
      System.out.println("Try Block");
      throw new RuntimeException();
   } catch (Exception e) {
      System.out.println("Catch Block");
   } finally {
      System.out.println("Finally Block");
   }
}
```

Вывод следующий:

```
Try Block
Closing: 2
Closing: 1
Catch Block
Finally Block
```

Перед экзаменом убедитесь, что вы понимаете, почему метод печатает операторы в таком порядке. Помните, что ресурсы 
закрываются в порядке, обратном тому, в котором они были объявлены, и неявный метод «final» выполняется раньше, чем 
«final», определенный программистом.

### Применение Effectively Final

Хотя ресурсы часто создаются в инструкции try-with-resources, их можно объявить заранее, при условии, что они помечены 
как final или effectively final. В синтаксисе вместо объявления ресурса используется имя ресурса, разделенное точкой с 
запятой (;). Давайте попробуем другой пример:

```
11: public static void main(String... xyz) { 
12:    final var bookReader = new MyFileClass(4); 
13:    MyFileClass movieReader = new MyFileClass(5); 
14:    try (bookReader; 
15:          var tvReader = new MyFileClass(6); 
16:          movieReader) { 
17:       System.out.println("Try Block"); 
18:    } finally { 
19:       System.out.println("Finally Block"); 
20:    }
21: }
```

Давайте рассмотрим эту строку по одной. В строке 12 объявляется final переменная bookReader, а в строке 13 объявляется 
effectively final переменная movieReader. Оба этих ресурса можно использовать в операторе try-with-resources. Мы знаем, 
что movieReader является фактически окончательным, поскольку это локальная переменная, которой значение присваивается 
только один раз. Помните, что проверка эффективности метода final заключается в том, что если мы вставим ключевое слово 
final при объявлении переменной, код все равно компилируется.

В строках 14 и 16 используется новый синтаксис для объявления ресурсов в инструкции try-with-resources, используя 
только имя переменной и разделяя ресурсы точкой с запятой (;). В строке 15 используется обычный синтаксис объявления 
нового ресурса в предложении try.

При выполнении код печатает следующее:

```
Try Block 
Closing: 5 
Closing: 6 
Closing: 4 
Finally Block
```

Если на экзамене вы встретите вопрос, в котором используется оператор try-with-resources с переменной, не объявленной в 
предложении try, убедитесь, что он действительно является окончательным. Например, следующее не компилируется:

``` 
31: var writer = Files.newBufferedWriter(path); 
32: try (writer) {  // НЕ КОМПИЛИРУЕТСЯ
33:    writer.append("Welcome to the zoo!"); 
34: }
35: writer = null;
```

Переменная writer переназначается в строке 35, в результате чего компилятор не считает ее окончательной. Поскольку это 
фактически не конечная переменная, ее нельзя использовать в инструкции try-withresources в строке 32.

Другое место, где экзамен может попытаться обмануть вас, — это доступ к ресурсу после его закрытия. Учтите следующее:

```
41: var writer = Files.newBufferedWriter(path); 
42: writer.append("This write is permitted but a really bad idea!"); 
43: try (writer) { 
44:    writer.append("Welcome to the zoo!"); 
45: }
46: writer.append("This write will fail!");  // IOException
```

Этот код компилируется, но выдает исключение в строке 46 при закрытом потоке сообщений. Хотя запись в ресурс возможна до 
оператора try-with-resources, но не после него.

### Понимание подавленных исключений

Мы завершаем обсуждение исключений, пожалуй, самой запутанной темой: подавленными исключениями (suppressed exceptions).
Что произойдет, если метод close() выдаст исключение? Давайте попробуем наглядный пример:

```
public class TurkeyCage implements AutoCloseable {
   public void close() {
      System.out.println("Close gate");
   }
   public static void main(String[] args) {
      try (var t = new TurkeyCage()) {
         System.out.println("Put turkeys in");
      }
   }
}
```

Если TurkeyCage не закроется, все индюки могут сбежать. Очевидно, что нам необходимо справиться с такой ситуацией. Мы 
уже знаем, что ресурсы закрываются до запуска любых запрограммированных блоков catch. Это означает, что мы можем 
перехватить исключение, выданное функцией close(), если захотим. В качестве альтернативы мы можем позволить вызывающему 
объекту справиться с этим.

Давайте расширим наш пример новой реализацией JammedTurkeyCage, показанной здесь:

```
1:  public class JammedTurkeyCage implements AutoCloseable { 
2:     public void close() throws IllegalStateException { 
3:        throw new IllegalStateException("Cage door does not close"); 
4:     }
5:     public static void main(String[] args) { 
6:        try (JammedTurkeyCage t = new JammedTurkeyCage()) { 
7:           System.out.println("Put turkeys in"); 
8:        } catch (IllegalStateException e) { 
9:           System.out.println("Caught: " + e.getMessage()); 
10:       }
11:    }
12: }
```

Метод close() автоматически вызывается методом try-with-resources. Он генерирует исключение, которое перехватывается 
нашим блоком catch и печатает следующее:

```
Caught: Cage door does not close
```

Это кажется достаточно разумным. Что произойдет, если блок try также выдаст исключение? Когда выдается несколько 
исключений, все, кроме первого, называются подавленными исключениями. Идея состоит в том, что Java рассматривает первое 
исключение как основное и обрабатывает все возникающие исключения при автоматическом закрытии.

Как вы думаете, что выведет следующая реализация нашего метода main()?

```
5:     public static void main(String[] args) { 
6:        try (JammedTurkeyCage t = new JammedTurkeyCage()) { 
7:           throw new IllegalStateException("Turkeys ran off"); 
8:        } catch (IllegalStateException e) { 
9:           System.out.println("Caught: " + e.getMessage()); 
10:          for (Throwable t: e.getSuppressed()) 
11:             System.out.println("Suppressed: "+t.getMessage()); 
12:       }
13:    }
```

Строка 7 выдает основное исключение. На этом этапе предложение try заканчивается, и Java автоматически вызывает метод 
close(). В строке 3 JammedTurkeyCage выдается исключение IllegalStateException, которое добавляется как подавленное 
исключение. Затем строка 8 перехватывает основное исключение. В строке 9 выводится сообщение об основном исключении. 
Строки 10 и 11 перебирают все подавленные исключения и выводят их. Программа печатает следующее:

```
Caught: Turkeys ran off 
Suppressed: Cage door does not close
```

Имейте в виду, что блок catch ищет совпадения с основным исключением. Как вы думаете, что напечатает этот код?

```
5:     public static void main(String[] args) { 
6:        try (JammedTurkeyCage t = new JammedTurkeyCage()) { 
7:           throw new RuntimeException("Turkeys ran off"); 
8:        } catch (IllegalStateException e) { 
9:           System.out.println("caught: " + e.getMessage()); 
10:       }
11:    }
```

Строка 7 снова выдает основное исключение. Java вызывает метод close() и добавляет подавленное исключение. Строка 8 
будет перехватывать исключение IllegalStateException. Однако у нас нет ни одного из них. Основное исключение — 
RuntimeException. Поскольку это не соответствует предложению catch, вызывающему объекту выдается исключение. В 
конечном итоге метод main() выведет что-то вроде следующего:

```
Exception in thread "main" java.lang.RuntimeException: Turkeys ran off
   at JammedTurkeyCage.main(JammedTurkeyCage.java:7)
   Suppressed: java.lang.IllegalStateException:
         Cage door does not close
      at JammedTurkeyCage.close(JammedTurkeyCage.java:3)
      at JammedTurkeyCage.main(JammedTurkeyCage.java:8)
```

Java запоминает подавленные исключения, которые сопровождают основное исключение, даже если мы не обрабатываем их 
в коде.

_Если исключение генерируется более чем двумя ресурсами, первое из них становится основным исключением, а остальные 
группируются как подавленные исключения. А поскольку ресурсы закрываются в порядке, обратном их объявлению, основное 
исключение будет относиться к последнему объявленному ресурсу, который выдает исключение._

Имейте в виду, что подавленные исключения применяются только к исключениям, созданным в предложении try. В следующем 
примере не создается подавленное исключение:

```
5:     public static void main(String[] args) { 
6:        try (JammedTurkeyCage t = new JammedTurkeyCage()) { 
7:           throw new IllegalStateException("Turkeys ran off"); 
8:        } finally { 
9:           throw new RuntimeException("and we couldn't find them"); 
10:       }
11:    }
```

Строка 7 выдает исключение. Затем Java пытается закрыть ресурс и добавляет к нему подавленное исключение. Теперь у нас 
проблема. После всего этого запускается блок finally. Поскольку строка 9 также генерирует исключение, предыдущее 
исключение из строки 7 теряется, а код печатает следующее:

```
Exception in thread "main" java.lang.RuntimeException:
   and we couldn't find them
   at JammedTurkeyCage.main(JammedTurkeyCage.java:9)
```

Это всегда было и остается плохой практикой программирования. Мы не хотим терять исключения! Хотя это выходит за рамки 
экзамена, причина этого связана с обратной совместимостью. Такое поведение существовало до того, как было добавлено 
автоматическое управление ресурсами.

## Форматирование значений

Теперь мы немного переключим тему и поговорим о том, как форматировать данные для пользователей. В этом разделе мы 
будем работать с числами, датами и временем. Это особенно важно в следующем разделе, когда мы расширим настройку на 
разные языки и локализаций. Возможно, вы захотите просмотреть главу 4 «Основные API», если вам нужно освежить знания о 
создании различных объектов даты и времени.

### Форматирование чисел

В главе 4 вы увидели, как управлять выводом числа с помощью метода String.format(). Это полезно для простых вещей, но 
иногда вам нужен более детальный контроль. При этом мы представляем интерфейс NumberFormat, который имеет два часто 
используемых метода:

```
public final String format(double number)
public final String format(long number)
```

Поскольку NumberFormat — это интерфейс, для его использования нам нужен конкретный класс DecimalFormat. Он включает в 
себя конструктор, который принимает строку шаблона:

```
public DecimalFormat(String pattern)
```

Паттерны могут быть довольно сложными. Но, к счастью, для сдачи экзамена вам нужно знать только о двух символах 
форматирования, показанных в таблице 11.5.

#### Таблица 11.5 - Символы DecimalFormat 

|        Символ        |                           Значение                           | Примеры  |  
|:--------------------:|:------------------------------------------------------------:|----------|
|          #           |     Опустите позицию, если для нее не существует цифры.      | $2.2     |
|          0           | Поставьте 0 в положение, если для него не существует цифры.  | $002.20  |

Эти примеры должны помочь пролить свет на то, как работают эти символы:

```
12: double d = 1234.567; 
13: NumberFormat f1 = new DecimalFormat("###,###,###.0"); 
14: System.out.println(f1.format(d));  // 1,234.6 
15:
16: NumberFormat f2 = new DecimalFormat("000,000,000.00000"); 
17: System.out.println(f2.format(d));  // 000,001,234.56700 
18:
19: NumberFormat f3 = new DecimalFormat("Your Balance $#,###,###.##"); 
20: System.out.println(f3.format(d));  // Your Balance $1,234.57
```

В строке 14 отображаются цифры числа, округляемые до ближайшей десятой после запятой. Дополнительные позиции слева 
опущены, поскольку мы использовали #. В строке 17 добавляются начальные и конечные нули, чтобы получить желаемую длину 
вывода. В строке 20 показано добавление префикса неформатирующего символа вместе с округлением, поскольку печатается 
меньше цифр, чем доступно. Обратите внимание, что запятые автоматически удаляются, если они используются между 
символами #.

Как вы видите в разделе локализации, существует второй конкретный класс, наследующий NumberFormat, который вам 
понадобится знать для экзамена.

### Форматирование даты и времени

Классы даты и времени поддерживают множество методов получения из них данных.

```
LocalDate date = LocalDate.of(2022, Month.OCTOBER, 20);
System.out.println(date.getDayOfWeek());  // THURSDAY
System.out.println(date.getMonth());      // OCTOBER
System.out.println(date.getYear());       // 2022
System.out.println(date.getDayOfYear());  // 293
```

Java предоставляет класс DateTimeFormatter для отображения стандартных форматов.

```
LocalDate date = LocalDate.of(2022, Month.OCTOBER, 20);
LocalTime time = LocalTime.of(11, 12, 34);
LocalDateTime dt = LocalDateTime.of(date, time);

System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
System.out.println(time.format(DateTimeFormatter.ISO_LOCAL_TIME));
System.out.println(dt.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
```

Фрагмент кода печатает следующее:

```
2022-10-20
11:12:34
2022-10-20T11:12:34
```

DateTimeFormatter выдаст исключение, если обнаружит несовместимый тип. Например, каждое из следующих действий создаст 
исключение во время выполнения, поскольку оно пытается отформатировать дату со значением времени, и наоборот:

```
date.format(DateTimeFormatter.ISO_LOCAL_TIME);  // RuntimeException
time.format(DateTimeFormatter.ISO_LOCAL_DATE);  // RuntimeException
```

### Настройка формата даты/времени

Если вы не хотите использовать один из предопределенных форматов, DateTimeFormatter поддерживает собственный формат 
с использованием String формата даты.

```
var f = DateTimeFormatter.ofPattern("MMMM dd, yyyy 'at' hh:mm"); 
System.out.println(dt.format(f));  // October 20, 2022 at 11:12
```

Давайте немного разберемся с этим. Java присваивает каждой букве или символу определенную часть даты/времени. 
Например, M используется для обозначения месяца, а y — для года. И случай имеет значение! Использование m вместо M 
означает, что возвращается минута часа, а не месяц года.

А как насчет количества символов? Число часто определяет формат части даты/времени. Использование M само по себе выводит 
минимальное количество символов для месяца, например 1 для января, в то время как использование MM всегда выводит две 
цифры, например 01. Кроме того, при использовании MMM выводится трехбуквенная аббревиатура, например Jul для обозначения 
июля, в то время как MMMM выводит полное название месяца.


_Возможно, хотя и маловероятно, встретить на экзамене вопросы, в которых используется SimpleDateFormat, а не более 
полезный DateTimeFormatter. Если вы действительно увидите это на экзамене, используемом со старым java.util. Объект 
даты, просто знайте, что пользовательские форматы, которые, вероятно, появятся на экзамене, будут совместимы с обоими._

### Изучение стандартных символов даты и времени

Для подготовки к экзамену вы должны быть достаточно знакомы с различными символами, чтобы вы могли посмотреть на строку 
даты / времени и иметь хорошее представление о том, каким будет результат. В таблице 11.6 приведены символы, с которыми 
вы должны быть знакомы для сдачи экзамена.

#### Таблица 11.6 - Распространенные символы даты и времени

| Символ |         Значение         |          Примеры           |  
|:------:|:------------------------:|:--------------------------:|
|   y    |           Год            |          22, 2022          |
|   M    |          Месяц           |    1, 01, Jan, January     |
|   d    |           День           |           5, 05            |
|   h    |           Часы           |           9, 09            |
|   m    |          Минуты          |             45             |
|   S    |         Секунды          |             52             |
|   a    |        a.m./p.m.         |           AM, PM           |
|   z    | Название часового пояса  | Eastern Standard Time, EST |
|   Z    | Смещение часового пояса  |           -0400            |

Давайте попробуем привести несколько примеров. Как вы думаете, что означают следующие печати?

```
var dt = LocalDateTime.of(2022, Month.OCTOBER, 20, 6, 15, 30);

var formatter1 = DateTimeFormatter.ofPattern("MM/dd/yyyy hh:mm:ss");
System.out.println(dt.format(formatter1));  // 10/20/2022 06:15:30

var formatter2 = DateTimeFormatter.ofPattern("MM_yyyy_-_dd");
System.out.println(dt.format(formatter2));  // 10_2022_-_20

var formatter3 = DateTimeFormatter.ofPattern("h:mm z");
System.out.println(dt.format(formatter3));  // DateTimeException
```

В первом примере выводится дата с указанием месяца перед днем, за которым следует время. Второй пример печатает дату в 
странном формате с дополнительными символами, которые просто отображаются как часть выходных данных.

Третий пример генерирует исключение во время выполнения, поскольку в базовом LocalDateTime не указан часовой пояс. 
Если бы вместо этого использовалось ZonedDateTime, код завершился бы успешно и вывел бы что-то вроде 06:15 EDT, в 
зависимости от часового пояса.

Как вы видели в предыдущем примере, вам нужно убедиться, что строка формата совместима с базовым типом даты/времени. 
В таблице 11.7 показано, какие символы вы можете использовать с каждым из объектов даты/времени.

Убедитесь, что вы знаете, какие символы совместимы с какими типами даты/времени. Например, попытка отформатировать 
месяц для LocalTime или час для LocalDate приведет к исключению времени выполнения.

#### Таблица 11.7 - Поддерживаемые символы даты/времени

| Символ | LocalDate | LocalTime | LocalDateTime | ZonedDateTime |  
|:------:|:---------:|:---------:|:-------------:|:-------------:|
|   y    |     √     |           |       √       |       √       |
|   M    |     √     |           |       √       |       √       |
|   d    |     √     |           |       √       |       √       |
|   h    |           |     √     |       √       |       √       |
|   m    |           |     √     |       √       |       √       |
|   S    |           |     √     |       √       |       √       |
|   a    |           |     √     |       √       |       √       |
|   z    |           |           |               |       √       |
|   Z    |           |           |               |       √       |


### Выбор метода format()

Классы даты/времени содержат метод format(), который принимает форматтер, а классы форматтера содержат метод format(), 
который принимает значение даты/времени. В результате приемлемо любое из следующих условий:

```
var dateTime = LocalDateTime.of(2022, Month.OCTOBER, 20, 6, 15, 30);
var formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy hh:mm:ss");

System.out.println(dateTime.format(formatter));  // 10/20/2022 06:15:30
System.out.println(formatter.format(dateTime));  // 10/20/2022 06:15:30
```

Эти операторы печатают одно и то же значение во время выполнения. Какой синтаксис вы используете, зависит от вас.

### Добавление пользовательских текстовых значений

Что делать, если вы хотите, чтобы ваш формат включал некоторые пользовательские текстовые значения? Если вы просто 
введете их как часть строки формата, форматтер будет интерпретировать каждый символ как символ даты/времени. В лучшем 
случае он будет отображать странные данные на основе введенных вами дополнительных символов. В худшем случае будет 
выдано исключение, поскольку символы содержат недопустимые символы. Ни то, ни другое нежелательно!

Один из способов решения этой проблемы — разбить форматтер на несколько более мелких форматтеров, а затем объединить 
результаты.

```
var dt = LocalDateTime.of(2022, Month.OCTOBER, 20, 6, 15, 30);
var f1 = DateTimeFormatter.ofPattern("MMMM dd, yyyy ");
var f2 = DateTimeFormatter.ofPattern(" hh:mm");
System.out.println(dt.format(f1) + "at" + dt.format(f2));
```

Выводит October 20, 2022 at 06:15 во время выполнения.

Хотя это работает, это может стать затруднительным, если смешано много текстовых значений и символов даты. К счастью, 
Java предлагает гораздо более простое решение. Вы можете экранировать текст, заключив его в пару одинарных кавычек ('). 
Экранирование текста указывает средству форматирования игнорировать значения внутри одинарных кавычек и просто вставлять 
их как часть конечного значения.

```
var f = DateTimeFormatter.ofPattern("MMMM dd, yyyy 'at' hh:mm");
System.out.println(dt.format(f));  // October 20, 2022 at 06:15
```

Но что, если вам нужно также отобразить в выводе одинарную кавычку? Добро пожаловать в удовольствие от побега персонажей! 
Java поддерживает это, помещая две одинарные кавычки рядом друг с другом.

Мы завершаем обсуждение форматирования даты некоторыми примерами форматов и их вывода, основанными на текстовых 
значениях, показанных здесь:

```
var g1 = DateTimeFormatter.ofPattern("MMMM dd', Party''s at' hh:mm");
System.out.println(dt.format(g1));  // October 20, Party's at 06:15

var g2 = DateTimeFormatter.ofPattern("'System format, hh:mm: 'hh:mm"); 
System.out.println(dt.format(g2));  // System format, hh:mm: 06:15

var g3 = DateTimeFormatter.ofPattern("'NEW! 'yyyy', yay!'");
System.out.println(dt.format(g3));  // NEW! 2022, yay!
```

Если вы не экранируете текстовые значения одинарными кавычками, во время выполнения будет выдано исключение, если текст 
нельзя интерпретировать как символ даты/времени.

```
DateTimeFormatter.ofPattern("The time is hh:mm");  // Выброшено исключение
```

Эта строка выдает исключение, поскольку T — неизвестный символ. На экзамене вам также может быть представлена неполная 
escape-последовательность.

```
DateTimeFormatter.ofPattern("'Time is: hh:mm: ");  // Выброшено исключение
```

Неспособность завершить escape-последовательность вызовет исключение во время выполнения.

## Поддержка интернационализации и локализации

Многим приложениям необходимо работать в разных странах и на разных языках. Например, рассмотрим предложение: 
«1 апреля 22 года в зоопарке будет проведено специальное мероприятие, посвященное поведению животных». Когда 
мероприятие? В Соединенных Штатах это 1 апреля. Однако британский читатель интерпретировал бы это как 4 января. 
Британский читатель также может задаться вопросом, почему мы не написали «поведение». Если мы создаем веб-сайт или 
программу, которая будет использоваться в нескольких странах, мы хотим использовать правильный язык и форматирование.

Интернационализация — это процесс разработки вашей программы таким образом, чтобы ее можно было адаптировать. Это 
предполагает размещение строк в файле свойств и обеспечение использования правильных средств форматирования данных. 
Локализация означает поддержку нескольких локалей или географических регионов. Вы можете думать о локали как о 
сочетании языка и страны. Локализация включает в себя перевод строк на разные языки. Он также включает вывод дат и 
чисел в формате, соответствующем данной локали.

_Изначально вашей программе не нужно поддерживать несколько языковых стандартов. Главное - обеспечить надежность вашего 
приложения в будущем, используя эти методы. Таким образом, когда ваш продукт станет успешным, вы сможете добавить 
поддержку новых языков или регионов, не переписывая все заново._

В этом разделе мы рассмотрим, как определить языковой стандарт и использовать его для форматирования дат, чисел и строк.

### Выбор языка

В то время как Oracle определяет языковой стандарт как “определенный географический, политический или культурный 
регион”, на экзамене вы увидите только языки и страны. Oracle, конечно же, не собирается углубляться в политические 
регионы, которые не являются странами. Это слишком спорно для экзамена!

Класс Locale находится в пакете java.util. Первая полезная локализация, которую нужно найти, - это текущая локализация 
пользователя. Попробуйте запустить следующий код на своем компьютере:

```
Locale locale = Locale.getDefault();
System.out.println(locale);
```

Когда мы его запускаем, он печатает en_US. У вас может быть по-другому. Этот вывод по умолчанию сообщает нам, что наши 
компьютеры используют английский язык и находятся в Соединенных Штатах.

Обратите внимание на формат. Сначала идет строчный код языка. Язык всегда нужен. Затем следует подчеркивание, за которым 
следует код страны в верхнем регистре. Страна не является обязательной. На рисунке 11.6 показаны два формата объектов 
Locale, которые вы должны запомнить.

#### Рис. 11.6 - Форматы Locale


На практике убедитесь, что вы понимаете, почему каждый из этих идентификаторов Locale недействителен:

```
US     // Cannot have country without language
enUS   // Missing underscore
US_en  // The country and language are reversed
EN     // Language must be lowercase
```

Исправленные версии — en и en_US.

_Вам не нужно запоминать коды языка или страны. Экзамен позволит вам узнать обо всем, что используется. Вам необходимо 
распознавать действительные и недействительные форматы. Обратите внимание на верхний/строчный регистр и подчеркивание. 
Например, если вы видите локаль, выраженную как es_CO, вы должны знать, что язык — es, а страна — CO, даже если вы не 
знали, что они представляют испанский язык и Колумбию соответственно._

Как разработчику, вам часто приходится писать код, который выбирает языковой стандарт, отличный от стандартного по 
умолчанию. Есть три распространенных способа сделать это. Первый - использовать встроенные константы в классе 
Locale, доступные для некоторых распространенных языков.

```
System.out.println(Locale.GERMAN);   // de 
System.out.println(Locale.GERMANY);  // de_DE
```

В первом примере выбран немецкий язык, на котором говорят во многих странах, включая Австрию (de_AT) и Лихтенштейн 
(de_LI). Во втором примере выбирается как немецкий язык, так и Германия в качестве страны. Хотя эти примеры могут 
выглядеть похожими, они не являются одинаковыми. Только один из них содержит код страны.

Второй способ выбора Locale - использовать конструкторы для создания нового объекта. Вы можете передать только язык 
или и язык, и страну:

```
System.out.println(new Locale("fr"));        // fr 
System.out.println(new Locale("hi", "IN"));  // hi_IN
```

Первый - это французский язык, а второй - хинди в Индии. Опять же, вам не нужно запоминать коды. Существует еще один 
конструктор, который позволяет вам быть еще более конкретным в отношении языкового стандарта. К счастью, на экзамене не 
указано значение варианта.

Java позволит вам создать Locale с недопустимым языком или страной, например xx_XX. Однако это не будет соответствовать 
Locale, который вы хотите использовать, и ваша программа не будет вести себя должным образом.

Есть третий способ создать более гибкий языковой стандарт. Шаблон проектирования builder позволяет вам задать все 
свойства, которые вас интересуют, а затем в конце создать языковой стандарт. Это означает, что вы можете указывать 
свойства в любом порядке. Следующие два значения языкового стандарта представляют en_US:

```
Locale l1 = new Locale.Builder() 
   .setLanguage("en")
   .setRegion("US")
   .build();
  
Locale l2 = new Locale.Builder()
   .setRegion("US")
   .setLanguage("en")
   .build();
```

При тестировании программы вам может потребоваться использовать языковой стандарт, отличный от используемого по 
умолчанию на вашем компьютере.

```
System.out.println(Locale.getDefault());  // en_US
Locale locale = new Locale("fr");
Locale.setDefault(locale);
System.out.println(Locale.getDefault());  // fr
```

Попробуйте и не волнуйтесь — языковой стандарт меняется только для этой одной Java-программы. Это не изменяет никаких 
настроек на вашем компьютере. Это даже не изменяет будущие выполнения той же программы.

_Экзамен может использовать функцию setDefault(), поскольку она не может делать предположений о том, где вы находитесь. 
На практике мы редко пишем код для изменения языкового стандарта пользователя по умолчанию._

### Локализующие номера

Вас может удивить, что форматирование или анализ денежных и числовых значений могут меняться в зависимости от вашего 
региона. Например, в США перед значением ставится знак доллара вместе с десятичной точкой для значений менее одного 
доллара, например $2.15. Однако в Германии к значению добавляется символ евро вместе с запятой для значений 
менее одного евро, например 2,15 €.

К счастью, пакет java.text включает в себя классы, которые помогут сэкономить положение. В следующих разделах описано, 
как форматировать числа, валюту и даты в зависимости от языкового стандарта.

Первый шаг к форматированию или анализу данных один и тот же: получить экземпляр NumberFormat. В таблице 11.8 показаны 
доступные фабричные методы.

Если у вас есть экземпляр NumberFormat, вы можете вызвать format(), чтобы превратить число в строку, или использовать 
parse(), чтобы превратить строку в число.

_Классы формата не являются потокобезопасными. Не храните их в переменных экземпляра или статических переменных. 
Подробнее о потокобезопасности вы узнаете в главе 13 «Параллелизм»._

#### Таблица 11.8 - Factory methods to get a NumberFormat

|                       Описание                       |                                        Использование по умолчанию Locale и указанного Locale                                         |  
|:----------------------------------------------------:|:------------------------------------------------------------------------------------------------------------------------------------:|
|           Форматировщик общего назначения            |                               NumberFormat.getInstance() <br/> NumberFormat.getInstance(Locale locale)                               |
|               Такой же как getInstance               |                         NumberFormat.getNumberInstance() <br/> NumberFormat.getNumberInstance(Locale locale)                         |
|           Для форматирования денежных сумм           |                       NumberFormat.getCurrencyInstance() <br/> NumberFormat.getCurrencyInstance(Locale locale)                       |
|             Для форматирования процентов             |                        NumberFormat.getPercentInstance() <br/> NumberFormat.getPercentInstance(Locale locale)                        |
|   Округляет десятичные значения перед отображением   |                        NumberFormat.getIntegerInstance() <br/> NumberFormat.getIntegerInstance(Locale locale)                        |
| Возвращает средство форматирования компактных чисел  | NumberFormat.getCompactNumberInstance() <br/> NumberFormat.getCompactNumberInstance( Locale locale, NumberFormat.Style formatStyle)  |

### Форматирование чисел

Когда мы форматируем данные, мы преобразуем их из структурированного объекта или примитивного значения в строку. Метод 
NumberFormat.format() форматирует заданное число на основе языкового стандарта, связанного с объектом NumberFormat.

Вернемся на минутку в наш зоопарк. Что касается маркетинговой литературы, мы хотим указать среднемесячное количество 
посетителей зоопарка Сан-Диего. Ниже показано, как распечатать одно и то же число в трех разных локализациях:

```
int attendeesPerYear = 3_200_000; 
int attendeesPerMonth = attendeesPerYear / 12;

var us = NumberFormat.getInstance(Locale.US); 
System.out.println(us.format(attendeesPerMonth));  // 266,666

var gr = NumberFormat.getInstance(Locale.GERMANY); 
System.out.println(gr.format(attendeesPerMonth));  // 266.666

var ca = NumberFormat.getInstance(Locale.CANADA_FRENCH); 
System.out.println(ca.format(attendeesPerMonth));  // 266 666
```

Это показывает, как наши гости из США, Германии и Франко-Канады могут видеть одну и ту же информацию в том цифровом 
формате, который они привыкли использовать. На практике мы бы просто вызвали NumberFormat.getInstance() и полагались бы 
на языковой стандарт пользователя по умолчанию для форматирования выходных данных.

Форматирование валюты работает таким же образом.

```
double price = 48;
var myLocale = NumberFormat.getCurrencyInstance();
System.out.println(myLocale.format(price));
```

При запуске с языковым стандартом en_US по умолчанию для Соединенных Штатов этот код выводит $48.00. С другой стороны, 
при запуске с языковым стандартом en_GB по умолчанию для Великобритании он выдает £48.00.

_В реальном мире для денег используйте int или BigDecimal, а не double. Выполнять математические вычисления с помощью 
double опасно, поскольку значения хранятся как числа с плавающей запятой. Ваш начальник не оценит, если вы потеряете 
копейки или доли копеек во время транзакций!_

Наконец, на экзамене могут быть примеры, показывающие проценты форматирования:

```
double successRate = 0.802;
var us = NumberFormat.getPercentInstance(Locale.US);
System.out.println(us.format(successRate));  // 80%

var gr = NumberFormat.getPercentInstance(Locale.GERMANY);
System.out.println(gr.format(successRate));  // 80 %
```

Мы знаем, что разница невелика, но вы должны, по крайней мере, знать, что возможность выводить процентные значения 
зависит от региона проведения экзамена!

### Анализ чисел

Когда мы анализируем данные, мы преобразуем их из строки в структурированный объект или примитивное значение. Метод 
NumberFormat.parse() выполняет эту задачу и учитывает языковой стандарт.

Например, если языковой стандарт - английский/Соединенные Штаты (en_US) и число содержит запятые, запятые 
рассматриваются как символы форматирования. Если языковой стандарт относится к стране или языку, которые используют 
запятые в качестве десятичного разделителя, запятая обрабатывается как десятичная точка.

_Метод parse(), встречающийся в различных типах, объявляет проверяемое исключение ParseException, которое должно быть 
обработано или объявлено в методе, в котором оно вызывается._

Давайте посмотрим на пример. Следующий код анализирует цену билета со скидкой для разных языков. Метод parse() выдает 
проверенное исключение ParseException, поэтому обязательно обработайте или объявите его в своем собственном коде.

```
String s = "40.45";

var en = NumberFormat.getInstance(Locale.US); 
System.out.println(en.parse(s));  // 40.45

var fr = NumberFormat.getInstance(Locale.FRANCE); 
System.out.println(fr.parse(s));  // 40
```

В США точка (.) является частью числа, и число анализируется так, как и следовало ожидать. Во Франции не используется 
десятичная точка для разделения чисел. Java анализирует его как символ форматирования и перестает обращать внимание на 
остальную часть числа. Урок заключается в том, чтобы убедиться, что вы выполняете анализ с использованием правильной 
локализации!

Метод parse() также используется для анализа валюты. Например, мы можем прочитать ежемесячный доход зоопарка от 
продажи билетов:

```
String income = "$92,807.99";
var cf = NumberFormat.getCurrencyInstance();
double value = (Double) cf.parse(income);
System.out.println(value);  // 92807.99
```

Строка валюты "$92,807.99" содержит знак доллара и запятую. Метод parse удаляет символы и преобразует значение в число. 
Возвращаемое значение parse — это объект Number. Number является родительским классом для всех классов-оболочек 
java.lang, поэтому возвращаемое значение можно привести к соответствующему типу данных. Number преобразуется в Double, 
а затем автоматически распаковывается в double.

### Форматирование с помощью CompactNumberFormat

Второй класс, наследующий NumberFormat, который вам нужно знать для экзамена, — это CompactNumberFormat. Это новинка 
экзамена по Java 17, поэтому вы, скорее всего, увидите по нему вопрос!

CompactNumberFormat похож на DecimalFormat, но предназначен для использования в местах, где пространство для печати 
может быть ограничено. Он самоуверен в том смысле, что он выбирает формат для вас, и в зависимости от локализации этот 
вывод может меняться в зависимости от вашего местоположения.

Рассмотрим следующий пример кода, который пять раз применяет CompactNumberFormat к двум языковым стандартам, используя 
статический импорт для Style (перечисление со значением SHORT или LONG):

```
var formatters = Stream.of(
   NumberFormat.getCompactNumberInstance(),
   NumberFormat.getCompactNumberInstance(Locale.getDefault(), Style.SHORT),
   NumberFormat.getCompactNumberInstance(Locale.getDefault(), Style.LONG),
   NumberFormat.getCompactNumberInstance(Locale.GERMAN, Style.SHORT),
   NumberFormat.getCompactNumberInstance(Locale.GERMAN, Style.LONG),
   NumberFormat.getNumberInstance());
   
formatters.map(s -> s.format(7_123_456)).forEach(System.out::println);
```

Этот код печатает следующее при запуске в локали en_US (разрывы строк добавлены для удобства чтения):

```
7M
7M
7 million

7 Mio. 
7 Millionen

7,123,456
```

Обратите внимание, что первые две строки одинаковы. Если вы не укажете стиль, по умолчанию используется SHORT. Далее 
обратите внимание, что значения, кроме последнего (который не использует компактный форматировщик чисел), усекаются. 
Есть причина, по которой его называют компактным форматером чисел! Также обратите внимание, что в краткой форме для 
больших значений используются общие метки, например K для тысячи. И последнее, но не менее важное: вывод может 
отличаться для вас при запуске, поскольку он был запущен в локали en_US.

Используя те же средства форматирования, давайте попробуем еще один пример:

```
formatters.map(s -> s.format(314_900_000)).forEach(System.out::println);
```

Это печатает следующее при запуске в локализации en_US:

```
315M
315M
315 million

315 Mio. 
315 Millionen

314,900,000
```

Обратите внимание, что третья цифра автоматически округляется в большую сторону для записей, использующих 
CompactNumberFormat. Ниже приведены правила для CompactNumberFormat:

+ Сначала он определяет самый высокий диапазон чисел, например тысячи (K), миллион (M), миллиард (B) или триллион (T).
+ Затем он возвращается к первым трем цифрам этого диапазона, округляя последнюю цифру по мере необходимости.
+ Наконец, он печатает идентификатор. Если используется SHORT, возвращается символ. Если используется LONG, 
возвращается пробел, за которым следует слово.

Перед экзаменом убедитесь, что вы понимаете разницу между форматами SHORT и LONG и распространенными символами, 
такими как M, обозначающими миллион.

### Локализация дат

Как и числа, форматы дат могут варьироваться в зависимости от региона. В таблице 11.9 показаны методы, используемые 
для извлечения экземпляра DateTimeFormatter с использованием языкового стандарта по умолчанию.

#### Таблица 11.9 - Фабричные методы для получения DateTimeFormatter

|              Описание              |                                                               Использование по умолчанию Locale                                                               |  
|:----------------------------------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|       Для форматирования дат       |                                                   DateTimeFormatter.ofLocalizedDate(FormatStyle dateStyle)                                                    |
|     Для форматирования времени     |                                                   DateTimeFormatter.ofLocalizedTime(FormatStyle timeStyle)                                                    |
| Для форматирования даты и времени  | DateTimeFormatter.ofLocalizedDateTime (FormatStyle dateStyle, FormatStyle timeStyle) <br/> DateTimeFormatter.ofLocalizedDateTime (FormatStyle dateTimeStyle)  |

Каждый метод в таблице принимает параметр FormatStyle (или два) с возможными значениями SHORT, MEDIUM, LONG и FULL. 
Для сдачи экзамена вам не обязательно знать формат каждого из этих стилей.

Что делать, если вам нужен форматировщик для определенного языка? Достаточно просто — просто добавьте withLocale(locale) 
к вызову метода.

Давайте соберем все это вместе. Взгляните на следующий фрагмент кода, который основан на статическом импорте значения 
java.time.format.FormatStyle.SHORT:

```
public static void print(DateTimeFormatter dtf,       
      LocalDateTime dateTime, Locale locale) {   
   System.out.println(dtf.format(dateTime) + " --- "      
      + dtf.withLocale(locale).format(dateTime));
}
public static void main(String[] args) {
   Locale.setDefault(new Locale("en", "US"));
   var italy = new Locale("it", "IT");
   var dt = LocalDateTime.of(2022, Month.OCTOBER, 20, 15, 12, 34);
   
   // 10/20/22 --- 20/10/22
   print(DateTimeFormatter.ofLocalizedDate(SHORT),dt,italy);
   
    // 3:12 PM ---  15:12
   print(DateTimeFormatter.ofLocalizedTime(SHORT),dt,italy);
   
   // 10/20/22, 3:12 PM --- 20/10/22, 15:12
   print(DateTimeFormatter.ofLocalizedDateTime(SHORT,SHORT),dt,italy);
}
```

Сначала мы устанавливаем en_US в качестве языкового стандарта по умолчанию, а it_IT - в качестве запрашиваемого 
языкового стандарта. Затем мы выводим каждое значение, используя две локали. Как вы можете видеть, применение 
языкового стандарта оказывает большое влияние на встроенные форматировщики даты и времени.

### Указание категории языкового стандарта

Когда вы вызываете Locale.setDefault() с языковым стандартом, внутренне выбираются несколько параметров отображения и 
форматирования. Если вам требуется более детальный контроль над языковым стандартом по умолчанию, Java разделяет базовые 
параметры форматирования на отдельные категории с помощью перечисления Locale.Category.

Перечисление Locale.Category — это вложенный элемент в Locale, который поддерживает различные локализации для 
отображения и форматирования данных. Для сдачи экзамена вы должны быть знакомы с двумя перечислимыми значениями в 
таблице 11.10.

#### Таблица 11.10 - Значения Locale.Category

| Значение |                               Описание                               |  
|:--------:|:--------------------------------------------------------------------:|
| DISPLAY  | Категория, используемая для отображения данных о языковом стандарте. |
| FORMAT   |   Категория, используемая для форматирования дат, чисел или валют.   | 

Когда вы вызываете Locale.setDefault() с языковым стандартом, DISPLAY и FORMAT устанавливаются вместе. Давайте 
посмотрим на пример:

```
10: public static void printCurrency(Locale locale, double money) { 
11:    System.out.println( 
12:       NumberFormat.getCurrencyInstance().format(money) 
13:       + ", " + locale.getDisplayLanguage()); 
14: }
15: public static void main(String[] args) { 
16:    var spain = new Locale("es", "ES"); 
17:    var money = 1.23;
18:
19:    // Print with default locale 
20:    Locale.setDefault(new Locale("en", "US")); 
21:    printCurrency(spain, money);  // $1.23, Spanish 
22:
23:    // Print with selected locale display 
24:    Locale.setDefault(Category.DISPLAY, spain); 
25:    printCurrency(spain, money);  // $1.23, español 
26:
27:    // Print with selected locale format 
28:    Locale.setDefault(Category.FORMAT, spain); 
29:    printCurrency(spain, money);  // 1,23 €, español 
30: }
```

Код печатает одни и те же данные три раза. Сначала он печатает переменные языка spain и money, используя локаль en_US. 
Затем он печатает его, используя категорию DISPLAY es_ES, а категория FORMAT остается en_US. Наконец, он печатает 
данные, используя обе категории, для которых установлено значение es_ES.

Для подготовки к экзамену вам не нужно запоминать различные параметры отображения и форматирования для каждой категории. 
Вам просто нужно знать, что вы можете устанавливать части локального независимо. Вы также должны знать, что вызов 
Locale.setDefault(us) после предыдущего фрагмента кода изменит обе категории locale на en_US.

## Загрузка свойств с помощью пакетов ресурсов

До сих пор мы хранили все текстовые строки, отображаемые нашим пользователям, как часть программы внутри классов, 
которые их используют. Локализация требует их переноса в другое место.

Пакет ресурсов содержит объекты, специфичные для локализации, которые будут использоваться программой. Это похоже на 
карту с ключами и значениями. Пакет ресурсов обычно хранится в файле свойств. Файл свойств — это текстовый файл 
определенного формата с парами ключ/значение.

Наша зоопрограмма прошла успешно. Сейчас мы получаем запросы на его использование еще в трех зоопарках! У нас уже есть 
поддержка зоопарков в США. Теперь нам нужно добавить зоопарк Ла-Пальмира во Франции, зоопарк Большого Ванкувера в 
англоязычной Канаде и зоопарк Гранби во франкоязычной Канаде.

Мы сразу понимаем, что нам придется интернационализировать нашу программу. Пакеты ресурсов будут весьма полезны. 
Они позволят нам легко перевести наше приложение на несколько языков или даже поддерживать несколько языков 
одновременно. Позже будет легко добавить больше регионов, если зоопарки в еще большем количестве стран 
заинтересуются. Мы подумали о том, какие локали нам нужно поддерживать, и придумали четыре:

```
Locale us            = new Locale("en", "US"); 
Locale france        = new Locale("fr", "FR"); 
Locale englishCanada = new Locale("en", "CA"); 
Locale frenchCanada  = new Locale("fr", "CA");
```

В следующих разделах мы создадим пакет ресурсов, используя файлы свойств. Концептуально он похож на Map<String,String>, 
где каждая строка представляет отдельный ключ/значение. Ключ и значение разделяются знаком равенства (=) или двоеточием 
(:). Для простоты в этой главе мы используем знак равенства. Мы также рассмотрим, как Java определяет, какой пакет 
ресурсов использовать.

### Создание пакета ресурсов

Мы собираемся обновить наше приложение для поддержки четырех перечисленных ранее локалей. К счастью, Java не требует от 
нас создания четырех разных пакетов ресурсов. Если у нас нет пакета ресурсов для конкретной страны, Java будет 
использовать пакет для конкретного языка. Это немного сложнее, но давайте начнем с простого примера.

На данный момент нам нужны файлы свойств на английском и французском языках для нашего пакета ресурсов Zoo. Сначала 
создайте два файла свойств.

```
Zoo_en.properties 
hello=Hello
open=The zoo is open

Zoo_fr.properties
hello=Bonjour
open=Le zoo est ouvert
```

Имена файлов соответствуют имени нашего пакета ресурсов Zoo. Затем за ними следует подчеркивание (_), целевой языковой 
стандарт и расширение файла .properties. Мы можем написать нашу самую первую программу, которая использует пакет 
ресурсов для печати этой информации.

```
10: public static void printWelcomeMessage(Locale locale) { 
11:    var rb = ResourceBundle.getBundle("Zoo", locale); 
12:    System.out.println(rb.getString("hello") 
13:       + ", " + rb.getString("open")); 
14: }
15: public static void main(String[] args) { 
16:    var us = new Locale("en", "US"); 
17:    var france = new Locale("fr", "FR"); 
18:    printWelcomeMessage(us);     // Hello, The zoo is open 
19:    printWelcomeMessage(france); // Bonjour, Le zoo est ouvert 
20: }
```

Строки 16 и 17 создают две локализации, которые мы хотим протестировать, но фактическую работу выполняет метод в 
строках 10–14. Строка 11 вызывает фабричный метод ResourceBundle, чтобы получить правильный пакет ресурсов. Строки 12 и 
13 извлекают нужную строку из пакета ресурсов и печатают результаты.

Поскольку пакет ресурсов содержит пары ключ/значение, вы можете даже просмотреть их, чтобы получить список всех пар. 
Класс ResourceBundle предоставляет метод keySet() для получения набора всех ключей.

```
var us = new Locale("en", "US");
ResourceBundle rb = ResourceBundle.getBundle("Zoo", us);
rb.keySet().stream()
   .map(k -> k + ": " + rb.getString(k))
   .forEach(System.out::println);
```

В этом примере проходят все ключи. Он сопоставляет каждый ключ со строкой как с ключом, так и со значением, прежде чем 
все печатать.

```
hello: Hello
open: The zoo is open
```

---

_Сценарий реального мира_

**Загрузка файлов пакета ресурсов во время выполнения**

Для сдачи экзамена вам не нужно знать, где хранятся файлы свойств пакетов ресурсов. Если экзамен предоставляет файл 
свойств, можно с уверенностью предположить, что он существует и загружается во время выполнения.

Однако в ваших собственных приложениях пакеты ресурсов могут храниться в разных местах. Хотя их можно хранить внутри 
JAR-файла, который их использует, делать это не рекомендуется. Этот подход заставляет вас пересобирать JAR-файл 
приложения каждый раз при изменении текста. Одним из преимуществ использования пакетов ресурсов является отделение кода 
приложения от текстовых данных, специфичных для локали.

Другой подход — поместить все файлы свойств в отдельный JAR-файл или папку свойств и загрузить их в путь к классам во 
время выполнения. Таким образом, новый язык можно добавить без изменения JAR-файла приложения.

---

### Выбор пакета ресурсов

Существует два способа получения пакета ресурсов, с которыми вам следует ознакомиться к экзамену.

```
ResourceBundle.getBundle("name");
ResourceBundle.getBundle("name", locale);
```

Первый использует языковой стандарт по умолчанию. Вероятно, вы будете использовать его в программах, которые пишете. 
Либо экзамен скажет вам, что считать языковым стандартом по умолчанию, либо используется второй подход.

Java обрабатывает логику выбора наилучшего доступного пакета ресурсов для данного ключа. Он пытается найти наиболее 
конкретное значение. В таблице 11.11 показано, что происходит в Java при запросе пакета ресурсов Zoo с локализацией 
new Locale("fr", "FR"), когда локалью по умолчанию является английский (США).

#### Таблица 11.11 - Выбор пакета ресурсов для французского/французского языка с языковым стандартом по умолчанию: английский/США

| Шаг |                          Ищет файл                           |                          Причина                           |  
|-----|:------------------------------------------------------------:|:----------------------------------------------------------:|
| 1   |                     Zoo_fr_FR.properties                     |                      Requested locale                      |
| 2   |                      Zoo_fr.properties                       |     Язык, который мы запрашивали, без указания страны      |  
| 3   |                     Zoo_en_US.properties                     |                     Язык по умолчанию                      |
| 4   |                      Zoo_en.properties                       |            Язык локали по умолчанию без страны             |
| 5   |                        Zoo.properties                        |         Никакой локали вообще — пакет по умолчанию         |
| 6   | Если все еще не найден, выбросьте  MissingResourceException  | Нет доступных языковых стандартов или пакетов по умолчанию |

Чтобы запомнить порядок таблицы 11.11, изучите следующие шаги:

1. Найдите пакет ресурсов для запрошенной локали, а затем пакет для локали по умолчанию.
2. Для каждой локали проверьте язык/страну, а затем только язык.
3. Используйте пакет ресурсов по умолчанию, если соответствующий языковой стандарт не найден.

_Как мы упоминали ранее, Java поддерживает пакеты ресурсов как из классов, так и из свойств Java. Когда Java ищет 
соответствующий пакет ресурсов, он сначала проверяет наличие файла пакета ресурсов с соответствующим именем класса. 
Для экзамена вам просто нужно уметь работать с файлами свойств._

Давайте проверим, понимаете ли вы таблицу 11.11. Какое максимальное количество файлов необходимо будет рассмотреть Java, 
чтобы найти подходящий пакет ресурсов с помощью следующего кода?

```
Locale.setDefault(new Locale("hi"));
ResourceBundle rb = ResourceBundle.getBundle("Zoo", new Locale("en"));
```

Ответ: три. Они перечислены здесь:

```
1. Zoo_en.properties 
2. Zoo_hi.properties 
3. Zoo.properties
```

Запрошенная локаль — en, поэтому начнем с нее. Поскольку локаль en не содержит страны, мы переходим к локали по 
умолчанию, hi. Опять же, страны нет, поэтому мы заканчиваем пакетом по умолчанию.

### Выбор значений пакета ресурсов

Получил все это? Хорошо, потому что есть некий поворот. Шаги, которые мы обсуждали до сих пор, предназначены для поиска 
соответствующего пакета ресурсов, который можно использовать в качестве основы. Java не требуется для получения всех 
ключей из одного и того же пакета ресурсов. Он может получить их от любого родителя соответствующего пакета ресурсов. 
Родительский пакет ресурсов в иерархии просто удаляет компоненты имени, пока не достигнет вершины. В таблице 11.12 
показано, как это сделать.

#### Таблица 11.12 - Выбор свойств пакета ресурсов

|  Значение  |                              Описание                              |  
|:----------:|:------------------------------------------------------------------:|
| Zoo_fr_FR  | Zoo_fr_FR.properties <br/> Zoo_fr.properties <br/> Zoo.properties  |


После выбора пакета ресурсов будут использоваться только свойства одной иерархии. Сравните это поведение с 
таблицей 11.11, в которой используется пакет ресурсов en_US по умолчанию, если другие пакеты ресурсов недоступны.

Что это значит? Предположим, что запрошенная локаль — fr_FR, а значение по умолчанию — en_US. JVM будет предоставлять 
данные из en_US только в том случае, если нет соответствующего пакета ресурсов fr_FR или fr. Если он обнаружит пакет 
ресурсов fr_FR или fr, то будут использоваться только эти пакеты вместе с пакетом по умолчанию.

Давайте соберем все это вместе и распечатаем информацию о наших зоопарках. На этот раз у нас есть несколько 
файлов свойств.

```
Zoo.properties 
name=Vancouver Zoo

Zoo_en.properties 
hello=Hello 
open=is open

Zoo_en_US.properties 
name=The Zoo

Zoo_en_CA.properties 
visitors=Canada visitors
```

Предположим, что у нас есть посетитель из Квебека (где по умолчанию используется французский язык Канады), который 
попросил программу предоставить информацию на английском языке. Как вы думаете, что это дает?

```
11: Locale.setDefault(new Locale("en", "US")); 
12: Locale locale = new Locale("en", "CA"); 
13: ResourceBundle rb = ResourceBundle.getBundle("Zoo", locale); 
14: System.out.print(rb.getString("hello")); 
15: System.out.print(". "); 
16: System.out.print(rb.getString("name")); 
17: System.out.print(" "); 
18: System.out.print(rb.getString("open")); 
19: System.out.print(" "); 
20: System.out.print(rb.getString("visitors"));
```

Программа печатает следующее: 

```
Hello. Vancouver Zoo is open Canada visitors
```

Языковой стандарт по умолчанию — en_US, а запрошенный языковой стандарт — en_CA. Сначала Java просматривает доступные 
пакеты ресурсов, чтобы найти совпадение. Он сразу находит его с помощью Zoo_en_CA.properties. Это означает, что локаль 
по умолчанию en_US не имеет значения.

Строка 14 не находит совпадения с ключом hello в Zoo_en_CA.properties, поэтому она поднимается по иерархии до 
Zoo_en.properties. Строка 16 не находит совпадения имени ни в одном из первых двух файлов свойств, поэтому ей 
приходится идти до самого верха иерархии до Zoo.properties. Строка 18 работает так же, как и строка 14, но использует 
Zoo_en.properties. Наконец, строка 20 выполняет эту задачу проще и находит соответствующий ключ в Zoo_en_CA.properties.

В этом примере использовались только три файла свойств: Zoo_en_CA.properties, Zoo_en.properties и Zoo.properties. 
Даже если свойство не было найдено в en_CA или пакетах ресурсов en, программа предпочитала использовать Zoo.properties 
(пакет ресурсов по умолчанию), а не Zoo_en_US.properties (локаль по умолчанию).

Что делать, если свойство не найдено ни в одном пакете ресурсов? Затем выдается исключение. Например, попытка 
вызвать rb.getString("close") в предыдущей программе приводит к возникновению исключения MissingResourceException во 
время выполнения.

### Форматирование сообщений

Часто мы просто хотим вывести текстовые данные из пакета ресурсов, но иногда вам нужно отформатировать эти данные с 
помощью параметров. В реальных программах переменные обычно заменяются в середине строки пакета ресурсов. По соглашению 
используется число внутри фигурных скобок, например {0}, {1} и т. д. Число указывает порядок, в котором будут 
передаваться параметры. Хотя пакеты ресурсов не поддерживают это напрямую, класс MessageFormat поддерживает.

Например, предположим, что у нас определено это свойство:

```
helloByName=Hello, {0} and {1}
```

В Java мы можем нормально прочитать значение. После этого мы можем запустить его через класс MessageFormat для 
подстановки параметров. Второй параметр format() — это переменная переменная, позволяющая указать любое количество 
входных значений.

Предположим, у нас есть пакет ресурсов rb:

```
String format = rb.getString("helloByName");
System.out.print(MessageFormat.format(format, "Tammy", "Henry"));
```

Это напечатает следующее:

```
Hello, Tammy and Henry
```

### Использование класса Properties

При работе с классом ResourceBundle вы также можете столкнуться с классом Properties. Он функционирует аналогично 
классу HashMap, о котором вы узнали в главе 9 «Коллекции и дженерики», за исключением того, что он использует значения 
String для ключей и значений. Давайте создадим его и установим некоторые значения.

```
import java.util.Properties; 
public class ZooOptions {
   public static void main(String[] args) {
      var props = new Properties();
      props.setProperty("name", "Our zoo");
      props.setProperty("open", "10am");
   }
}
```

Класс Properties обычно используется для обработки значений, которые могут не существовать.

```
System.out.println(props.getProperty("camel"));         // null
System.out.println(props.getProperty("camel", "Bob"));  // Bob
```

Если бы был передан ключ, который действительно существовал, оба оператора напечатали бы его. Обычно это называется 
предоставлением значения по умолчанию или резервного значения для отсутствующего ключа.

Класс Properties также включает метод get(), но только getProperty() позволяет использовать значение по умолчанию. 
Например, следующий вызов недопустим, поскольку get() принимает только один параметр:

```
props.get("open");                               // 10am

props.get("open", "The zoo will be open soon");  // НЕ КОМПИЛИРУЕТСЯ
```

## Резюме 


В этой главе рассмотрен широкий спектр тем, связанных с созданием приложений, хорошо реагирующих на изменения. Мы 
начали наше обсуждение с обработки исключений. Исключения можно разделить на две категории: проверяемые и непроверяемые. 
В Java проверяемые исключения наследуют Exception, но не RuntimeException, и их необходимо обрабатывать или объявлять. 
Непроверяемые исключения наследуют RuntimeException или Error и их не нужно обрабатывать или объявлять. Обнаружение 
ошибки считается плохой практикой.

Вы можете создать свои собственные проверяемые или непроверяемые исключения, расширив Exception или RuntimeException 
соответственно. Вы также можете определить пользовательские конструкторы и сообщения для ваших исключений, которые 
будут отображаться в трассировках стека.

Автоматическое управление ресурсами можно включить с помощью инструкции try-with-resources, чтобы убедиться, что ресурсы 
закрыты должным образом. Ресурсы закрываются по завершении блока try в порядке, обратном порядку, в котором они 
объявлены. Подавленное исключение возникает, когда генерируется более одного исключения, часто как часть операции 
finally block или try-with-resources close().

Java включает в себя ряд встроенных классов для форматирования чисел и дат. Мы рассмотрели, как создавать 
пользовательские форматтеры для каждого из них. Вы должны быть в состоянии прочитать эти пользовательские форматы, 
когда столкнетесь с ними на экзамене.

Локализация предполагает создание программ, которые адаптируются к изменениям. Вы можете создать класс Locale с 
обязательным кодом языка в нижнем регистре и необязательным кодом страны в верхнем регистре. Например, en и en_US - это 
языки для английского и американского английского соответственно. Вам нужно знать, как форматировать значения числа и 
даты/времени в зависимости от языка, включая новый класс Compact NumberFormat.

ResourceBundle позволяет указывать пары ключ/значение в файле свойств. Java просматривает пакеты ресурсов-кандидатов от 
наиболее специфичных до наиболее общих, чтобы найти соответствие. Если для запрошенного языкового стандарта не найдено 
совпадений, Java переключается на языковой стандарт по умолчанию, а затем, наконец, на пакет ресурсов по умолчанию. 
Как только соответствующий пакет ресурсов найден, Java просматривает только иерархию этого пакета ресурсов для выбора 
значений.

Применяя принципы, о которых вы узнали из этой главы, к своим собственным проектам, вы можете создавать приложения, 
которые работают дольше, со встроенной поддержкой любых непредвиденных событий, которые могут возникнуть.

## Основы экзамена

**Разбирайтесь в различных типах исключений.**  Все исключения являются подклассами java.lang.Throwable. Подклассы 
java.lang.Error никогда не должны перехватываться. В коде приложения следует обрабатывать только подклассы 
java.lang.Exception.

**Различайте проверяемые и непроверяемые исключения.** Непроверяемые исключения не требуют перехвата или обработки и 
являются подклассами java.lang.RuntimeException или java.lang.Error. Все остальные подклассы java.lang.Exception 
являются проверяемыми исключениями и должны быть обработаны или объявлены.

**Поймите последовательность выполнения инструкции try.**  Оператор try должен иметь блок catch или блок finally. 
Несколько блоков catch могут быть объединены в цепочку при условии, что ни один тип исключения суперкласса не 
появляется в более раннем блоке catch, чем его подкласс. Выражение multi-catch может использоваться для обработки 
нескольких исключений в одном блоке catch при условии, что одно исключение не является подклассом другого. 
Блок finally выполняется последним независимо от того, создано ли исключение.

**Уметь следовать порядку инструкции try-with-resources.**  Оператор try-with-resources — это особый тип блока try, в 
котором один или несколько ресурсов объявляются и автоматически закрываются в порядке, обратном их объявлению. Его 
можно использовать с блоком catch или finally или без него, при этом неявный блок finally всегда выполняется первым.

**Уметь писать методы, объявляющие исключения.** Поймите разницу между ключевыми словами throw и throws и как объявлять 
методы с исключениями. Знайте, как правильно переопределить метод, объявляющий исключения.

**Определите допустимые строки языкового стандарта.** Знайте, что код языка написан строчными буквами и является 
обязательным, в то время как код страны написан прописными буквами и необязателен. Иметь возможность выбирать языковой 
стандарт, используя встроенную константу, конструктор или класс builder.

**Форматируйте даты, числа и сообщения.**  Уметь форматировать даты, числа и сообщения в различные строковые форматы и 
знать, как язык влияет на эти форматы. Узнайте, чем отличаются различные средства форматирования чисел (денежные, 
процентные, компактные). Уметь писать собственный форматировщик дат или чисел, используя символы, в том числе уметь 
экранировать литеральные значения.

**Определите, какой пакет ресурсов Java будет использовать для поиска ключа.**  Иметь возможность создавать пакеты 
ресурсов для набора локализаций, используя файлы свойств. Знайте порядок поиска, который Java использует для выбора 
пакета ресурсов, и как учитываются языковой стандарт по умолчанию и пакет ресурсов по умолчанию. Как только пакет 
ресурсов найден, распознайте иерархию, используемую для выбора значений.


