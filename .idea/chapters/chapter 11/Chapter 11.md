# Исключения и локализация

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Обработка исключений

+ Обрабатывать исключения с помощью try/catch/finally, try-with-resources и блоков с несколькими перехватами, включая 
пользовательские исключения

#### Реализация локализации

+ Реализуйте локализацию с использованием языковых стандартов, пакетов ресурсов, анализа и форматирования сообщений, 
дат, времени и чисел, включая денежные и процентные значения.

---

Эта глава посвящена созданию приложений, адаптирующихся к изменениям. Что произойдет, если пользователь введет неверные 
данные на веб-странице? Что, если наше соединение с базой данных оборвется во время распродажи? Наконец, как нам 
создавать приложения, поддерживающие несколько языков или географических регионов?

В этой главе мы обсуждаем эти проблемы и их решения с использованием исключений, форматирования и локализации. Один из 
способов убедиться, что ваши приложения реагируют на изменения, — это обеспечить поддержку на раннем этапе. Например, 
поддержка локализации не означает, что вам действительно нужно сразу же поддерживать определенные языки. Это просто 
означает, что ваше приложение будет легче адаптировать в будущем. Мы надеемся, что к концу этой главы мы создали 
структуру для разработки приложений, которые лучше адаптируются к изменениям.

## Понимание исключений

Программа может выйти из строя практически по любой причине. Вот лишь некоторые возможности:

+ Код пытается подключиться к веб-сайту, но подключение к Интернету не работает.
+ Вы допустили ошибку в кодировании и попытались получить доступ к недопустимому индексу в массиве.
+ Один метод вызывает другой со значением, которое этот метод не поддерживает.

Как видите, некоторые из них являются ошибками кодирования. Другие полностью вне вашего контроля. Ваша программа не 
сможет помочь, если пропадет подключение к Интернету. Единственное, что он может сделать, это разобраться с ситуацией.

### Роль исключений

Исключением является способ Java сказать: “Я сдаюсь. Я не знаю, что мне сейчас делать. Вы справляетесь с этим”. Когда 
вы пишете метод, вы можете либо справиться с исключением, либо сделать его проблемой вызывающего кода.

В качестве примера представьте себе Java как ребенка, который посещает зоопарк. Счастливый путь - это когда ничего не 
идет не так. Ребенок продолжает смотреть на животных до тех пор, пока программа не закончится красиво. Ничего не пошло 
не так, и не было никаких исключений, с которыми нужно было иметь дело.

Младшая сестра этого ребенка не прошла счастливый путь. В волнении она спотыкается и падает. К счастью, это неплохое 
падение. Маленькая девочка встает и продолжает смотреть на других животных. Она сама справилась с этой проблемой. К 
сожалению, позже в тот же день она снова падает и начинает плакать. На этот раз она, плача, заявила, что ей нужна 
помощь. История заканчивается хорошо. Ее папа потирает ее колено и обнимает. Затем они снова начинают наблюдать за 
другими животными и наслаждаются остатком дня.

Это два подхода, которые Java использует при работе с исключениями. Метод может обрабатывать исключительную ситуацию 
сам или возложить ответственность за это на вызывающую сторону.

---

**Сценарий реального мира**

Return Codes vs. Exceptions

Исключения используются, когда «что-то идет не так». Однако слово «неправильно» является субъективным. Следующий код 
возвращает -1 вместо того, чтобы генерировать исключение, если совпадение не найдено:

```
public int indexOf(String[] names, String name) {
   for (int i = 0; i < names.length; i++) {
      if (names[i].equals(name)) { return i; }
   }
   return -1;
}
```

Хотя коды возврата являются общими для определенных задач, таких как поиск, их, как правило, следует избегать. В конце 
концов, Java предоставила фреймворк исключений, так что вы должны его использовать!

---

### Понимание типов исключений

Исключением является событие, которое изменяет ход программы. В Java есть класс Throwable для всех объектов, 
представляющих эти события. Не у всех из них в названии класса есть слово «исключение», что может сбивать с толку. На 
рисунке 11.1 показаны ключевые подклассы Throwable.

#### Рис. 11.1 - Категории исключений



### Проверяемые исключения

Проверяемое исключение - это исключение, которое должно быть объявлено или обработано кодом приложения, в котором оно 
генерируется. В Java все проверяемые исключения наследуют Exception, но не RuntimeException. проверяемые исключения, как 
правило, более ожидаемы — например, попытка прочитать несуществующий файл.

_Проверяемые исключения также включают любой класс, который наследует Throwable, но не Error или RuntimeException, 
например класс, который непосредственно расширяет Throwable. Для экзамена вам просто нужно знать о проверяемых 
исключениях, которые расширяют Exception._

проверяемые исключения? Что мы проверяем? В Java есть правило, называемое правилом handle или declare. Правило handle 
или declare означает, что все проверяемые исключения, которые могут быть выброшены внутри метода, либо заключены в 
совместимые блоки try и catch, либо объявлены в сигнатуре метода.

Поскольку проверяемые исключения, как правило, ожидаемы, Java применяет правило, согласно которому программист должен 
сделать что-то, чтобы показать, что об исключении думали. Возможно, это было обработано в методе. Или, может быть, метод 
объявляет, что он не может обработать исключение, и это должен сделать кто-то другой.

Давайте взглянем на пример. Следующий метод fall() объявляет, что он может вызвать исключение IOException, которое 
является проверяемым исключением:

```
void fall(int distance) throws IOException {
  if (distance > 10) {
     throw new IOException();
  }
}
```

Обратите внимание, что вы используете здесь два разных ключевых слова. Ключевое слово throw сообщает Java, что вы хотите 
выдать исключение, а ключевое слово throws просто объявляет, что метод может выдать исключение. А может и нет.

Теперь, когда вы знаете, как объявить исключение, как с ним справиться? Следующая альтернативная версия метода fall() 
обрабатывает это исключение:

```
void fall(int distance) {
   try {
     if (distance > 10) {
        throw new IOException();
     }
   } catch (Exception e) {
      e.printStackTrace();
   }
}
```

Обратите внимание, что оператор catch использует Exception, а не IOException. Поскольку IOException является подклассом 
Exception, блоку catch разрешено его перехватывать. Более подробно блоки try и catch мы рассмотрим далее в этой главе.

### Непроверяемые исключения

Непроверяемое исключение - это любое исключение, которое не нужно объявлять или обрабатывать кодом приложения, в котором 
оно генерируется. Непроверяемые исключения часто называют исключениями времени выполнения, хотя в Java непроверяемые 
исключения включают любой класс, который наследует RuntimeException или Error.

_Допустимо обрабатывать или объявлять непроверяемое исключение. Тем не менее, лучше задокументировать непроверяемые 
исключения, о которых должны знать вызывающие, в комментарии Javadoc, а не объявлять непроверяемое исключение._

Исключение во время выполнения определяется как класс RuntimeException и его подклассы. Исключения во время выполнения, 
как правило, бывают неожиданными, но не обязательно фатальными. Например, доступ к недопустимому индексу массива 
является неожиданным. Несмотря на то, что они наследуют класс Exception, они не являются проверяемыми исключениями.

Непроверяемое исключение может возникнуть практически в любой строке кода, поскольку его не требуется обрабатывать или 
объявлять. Например, исключение NullPointerException может быть вызвано в теле следующего метода, если входная ссылка 
равна null:

```
void fall(String input) {
   System.out.println(input.toLowerCase());
}
```

Мы работаем с объектами в Java так часто, что исключение NullPointerException может возникнуть практически в любом 
месте. Если бы вам приходилось объявлять непроверяемые исключения везде, в каждом отдельном методе был бы такой 
беспорядок! Код скомпилируется, если вы объявите непроверяемое исключение. Однако это излишне.

### Error и Throwable

Error означает, что что-то пошло настолько ужасно неправильно, что ваша программа не должна пытаться восстановиться 
после этого. Например, дисковод “исчез” или программе не хватило памяти. Это ненормальные состояния, с которыми вы вряд 
ли столкнетесь и от которых не сможете оправиться.

Для экзамена единственное, что вам нужно знать о Throwable, это то, что это родительский класс всех исключений, включая 
класс Error. Хотя вы можете обрабатывать исключения Throwable и Error, не рекомендуется делать это в коде вашего 
приложения. Когда мы ссылаемся на исключения в этой главе, мы обычно имеем в виду любой класс, который наследует 
Throwable, хотя мы почти всегда работаем с классом Exception или его подклассами.

### Обзор типов исключений

Обязательно внимательно изучите все, что приведено в таблице 11.1. Перед экзаменом помните, что Throwable - это либо 
исключение, либо ошибка. Вы не должны перехватывать Throwable непосредственно в своем коде.

#### Таблица 11.1 - Типы исключений и ошибок

|           Тип            |                   Как распознать                    | Все в порядке, чтобы программа поймала? | Требуется ли программа для обработки или объявления? |  
|:------------------------:|:---------------------------------------------------:|:---------------------------------------:|:----------------------------------------------------:|
| Непроверяемые исключения |            Подкласс из RuntimeException             |                   Да                    |                         Нет                          |
| Проверяемые исключения   | Подкласс Exception, но не подкласс RuntimeException |                   Да                    |                          Да                          |
|          Error           |                  Подкласс из Error                  |                   Нет                   |                         Нет                          |

### Выбрасывание исключения

Любой Java-код может генерировать исключение; это включает в себя код, который вы пишете. Некоторые исключения 
предусмотрены в Java. Вы можете столкнуться с исключением, которое было составлено для экзамена. Это прекрасно. Вопрос 
сделает очевидным, что это исключение, поскольку имя класса заканчивается на Exception. Например, MyMadeUpException явно 
является исключением.

На экзамене вы увидите два типа кода, которые приводят к исключению. Первый - это неправильный код. Вот пример:

```
String[] animals = new String[0]; 
System.out.println(animals[0]);  // ArrayIndexOutOfBoundsException
```

Этот код генерирует исключение ArrayIndexOutOfBoundsException, поскольку в массиве нет элементов. Это означает, что 
вопросы об исключениях могут быть скрыты за вопросами, которые кажутся о чем-то другом.

_На экзамене в некоторых вопросах есть выбор не компилировать и выбрасывать исключение. Обратите особое внимание на код, 
который вызывает метод по нулевой ссылке или ссылается на недопустимый массив или индекс списка. Если вы заметили это, 
то знаете, что правильный ответ — код генерирует исключение во время выполнения._

Второй способ создания исключения в коде — это явный запрос Java на его создание. Java позволяет вам писать такие 
операторы:

```
throw new Exception(); 
throw new Exception("Ow! I fell."); 
throw new RuntimeException(); 
throw new RuntimeException("Ow! I fell.");
```

Ключевое слово throw сообщает Java, что вы хотите, чтобы какая-то другая часть кода обрабатывала исключение. Это то же 
самое, что молодая девушка, оплакивающая своего папу. Кто-то другой должен выяснить, что делать с этим исключением.

---

**throw vs. throws**

Всякий раз, когда вы видите throws на экзамене, убедитесь, что используется правильный. Ключевое слово throw 
используется как оператор внутри блока кода для создания нового исключения или повторного создания существующего 
исключения, в то время как ключевое слово throws используется только в конце объявления метода, чтобы указать, какие 
исключения он поддерживает.

---

При создании исключения вы обычно можете передать параметр String вместе с сообщением или можете не передавать 
параметры и использовать значения по умолчанию. Мы говорим «обычно», потому что это условность. Кто-то объявил 
конструктор, принимающий String. Кто-то также может создать класс исключений, у которого нет конструктора, принимающего 
сообщение.

Кроме того, вы должны знать, что исключение - это объект. Это означает, что вы можете сохранить его в ссылке на объект, 
и это законно:

```
var e = new RuntimeException();
throw e;
```

Код создает исключение в одной строке, а затем генерирует в следующей. Исключение может исходить откуда угодно, даже 
передаваться в метод. Пока это допустимое исключение, оно может быть выброшено.

Экзамен также может попытаться обмануть вас. Вы понимаете, почему этот код не компилируется?

```
throw RuntimeException();   // НЕ КОМПИЛИРУЕТСЯ
```

Если ваш ответ заключается в том, что отсутствует ключевое слово, вы абсолютно правы. Исключение никогда не создается с 
помощью ключевого слова new.

Давайте взглянем на еще одно место, где экзамен может попытаться вас обмануть. Вы понимаете, почему следующее не 
компилируется?

```
3: try { 
4:    throw new RuntimeException(); 
5:    throw new ArrayIndexOutOfBoundsException();  // НЕ КОМПИЛИРУЕТСЯ
6: } catch (Exception e) {}
```

Поскольку строка 4 генерирует исключение, строка 5 никогда не может быть достигнута во время выполнения. Компилятор 
распознает это и сообщает о недостижимой ошибке кода.

### Вызов методов, генерирующие исключения

Когда вы вызываете метод, который генерирует исключение, правила те же, что и внутри метода. Вы понимаете, почему 
следующее не компилируется?

```
class NoMoreCarrotsException extends Exception {}

public class Bunny {
   public static void main(String[] args) {
      eatCarrot();  // НЕ КОМПИЛИРУЕТСЯ
   }
   private static void eatCarrot() throws NoMoreCarrotsException {}
}
```

Проблема в том, что NoMoreCarrotsException является проверяемым исключением. Проверяемые исключения должны быть 
обработаны или объявлены. Код скомпилируется, если вы измените метод main() на любой из следующих:

```
public static void main(String[] args) throws NoMoreCarrotsException {      
   eatCarrot();   
}

public static void main(String[] args) {
   try {
      eatCarrot();
   } catch (NoMoreCarrotsException e) {
      System.out.print("sad rabbit");      
   }
}
```

Возможно, вы заметили, что eatCarrot() не генерирует исключение; он просто заявил, что может. Этого достаточно, 
чтобы компилятор потребовал от вызывающей стороны обработать или объявить исключение.

Компилятор все еще ищет недоступный код. Объявление неиспользуемого исключения не считается недоступным кодом. Это 
дает методу возможность изменить реализацию, чтобы генерировать это исключение в будущем. Вы видите здесь проблему?

```
public void bad() {
   try {
      eatCarrot();
   } catch (NoMoreCarrotsException e) {  // НЕ КОМПИЛИРУЕТСЯ
      System.out.print("sad rabbit");
   }
}

private void eatCarrot() {}
```

Java знает, что eatCarrot() не может генерировать проверяемое исключение, а это означает, что блок catch в bad() не 
может быть достигнут.

_Когда вы видите проверяемое исключение, объявленное внутри блока catch на экзамене, убедитесь, что код в связанном блоке 
try способен выбросить это исключение или его подкласс. В противном случае код недоступен и не компилируется. Помните, 
что это правило не распространяется на непроверяемые исключения или исключения, объявленные в сигнатуре метода._

### Переопределение методов с исключениями

Когда мы представили переопределяющие методы в главе 6 «Проектирование классов», мы включили правило, связанное с 
исключениями. Переопределенный метод не может объявлять какие-либо новые или более широких проверяемых исключений, 
чем метод, который он наследует. Например, этот код не разрешен:

```
class CanNotHopException extends Exception {}

class Hopper {
   public void hop() {}
}

class Bunny extends Hopper {
   public void hop() throws CanNotHopException {}  // НЕ КОМПИЛИРУЕТСЯ
}
```

Java знает, что функции hop() не разрешено генерировать какие-либо проверяемые исключения, потому что метод hop() в 
суперклассе Hopper их не объявляет. Представьте, что произошло бы, если бы версии метода для подклассов могли добавлять 
проверяемые исключения — вы могли бы написать код, который вызывает метод Hopper's hop() и не обрабатывает 
никаких исключений. Тогда, если бы вместо него использовался Bunny, код не знал бы, как обрабатывать или объявлять 
CanNotHopException.

Переопределенному методу в подклассе разрешается объявлять меньше исключений, чем суперклассу или интерфейсу. Это 
допустимо, потому что абоненты уже обрабатывают их.

```
class Hopper {    
public void hop() throws CanNotHopException {}
}
class Bunny extends Hopper {    
public void hop() {}  // Это прекрасно
}
```

Переопределенный метод, не объявляющий одно из исключений, генерируемых родительским методом, аналогичен методу, 
объявляющему, что он генерирует исключение, которое на самом деле никогда не генерируется. Это совершенно законно. 
Аналогично, классу разрешается объявлять подкласс типа exception. Идея та же самая. Суперкласс или интерфейс уже 
позаботился о более широком типе.

### Printing an Exception
 