# Модули

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Упаковка и развертывание кода Java и использование системы модулей платформы Java

+ Определите модули и их зависимости, выставьте содержимое модулей, в том числе для отражения. Определите услуги, 
производителей и потребителей
+ Компилируйте код Java, создавайте модульные и немодульные jar-файлы, образы среды выполнения и реализуйте миграцию с 
использованием безымянных и автоматических модулей

---

Пакеты можно группировать в модули. В этой главе мы объясняем назначение модулей и способы создания собственных. Мы 
также покажем, как их запускать и как обнаруживать существующие модули. Далее мы рассмотрим стратегии миграции 
приложения на использование модулей, запуск частично модульного приложения и работу с зависимостями. Затем мы переходим 
к обсуждению сервисов и локаторов сервисов. Наконец, мы покажем, как создать образ времени выполнения.

Мы разместили код из этой главы в Интернете. Поскольку создание структуры каталогов может оказаться утомительным, это 
сэкономит вам некоторое время. Кроме того, команды должны быть абсолютно правильными, поэтому мы включили их в Интернет, 
чтобы вы могли скопировать и вставить их и сравнить с тем, что вы набрали. Оба доступны в нашем репозитории GitHub, 
ссылка на который находится на 

```
www.selikoff.net/ocp-17/
```

## Знакомство с модулями

При написании кода для экзамена вы обычно видите небольшие классы. В конце концов, экзаменационные вопросы должны 
умещаться на одном экране! Когда вы работаете над реальными программами, они намного больше. Реальный проект будет 
состоять из сотен или тысяч классов, сгруппированных в пакеты. Эти пакеты сгруппированы в файлы архива Java (JAR). 
JAR — это ZIP-файл с дополнительной информацией, имеющий расширение .jar.

Помимо кода, написанного вашей командой, большинство приложений также используют код, написанный другими. Открытый 
исходный код — это программное обеспечение с поставляемым кодом, которое часто можно использовать бесплатно. Java имеет 
активное сообщество программного обеспечения с открытым исходным кодом (OSS), и эти библиотеки также поставляются в 
виде файлов JAR. Например, есть библиотеки для чтения файлов, подключения к базе данных и многое другое.

Некоторые проекты с открытым исходным кодом даже зависят от функциональности других проектов с открытым исходным кодом. 
Например, Spring — это широко используемая среда, а JUnit — широко используемая библиотека тестирования. Чтобы 
использовать любой из них, вам необходимо убедиться, что у вас есть совместимые версии всех соответствующих JAR-файлов, 
доступных во время выполнения. Эту сложную цепочку зависимостей и минимальных версий сообщество часто называет JAR-адом. 
Ад — отличный способ описать неправильную версию загружаемого класса или даже исключение ClassNotFoundException во 
время выполнения.

Система модулей платформы Java (JPMS) группирует код на более высоком уровне. Основная цель модуля — предоставить 
группы связанных пакетов, которые предлагают разработчикам определенный набор функций. Это похоже на файл JAR, за 
исключением того, что разработчик выбирает, какие пакеты доступны вне модуля. Давайте разберемся, что такое модули и 
какие задачи они призваны решать.

Система модулей платформы Java включает в себя следующее:

+ Формат для JAR-файлов модуля
+ Разбиение JDK на модули
+ Дополнительные параметры командной строки для инструментов Java


### Изучение модуля

В главе 1 «Строительные блоки» у нас было небольшое приложение Zoo. У него был только один класс, и он распечатывал 
только одну вещь. А теперь представьте, что у нас есть целый штат программистов и мы автоматизируем работу зоопарка. 
Многие вещи необходимо закодировать, в том числе взаимодействие с животными, посетителями, общедоступным веб-сайтом и 
информационно-просветительской деятельностью.

Модуль — это группа из одного или нескольких пакетов плюс специальный файл под названием Module-info.java. Содержимое 
этого файла является объявлением модуля. На рисунке 12.1 перечислены лишь некоторые из модулей, которые могут 
понадобиться зоопарку. В нашем примере мы решили сосредоточиться на взаимодействии животных. Полный зоопарк легко мог 
бы состоять из дюжины модулей. Обратите внимание, что на рисунке 12.1 между многими модулями есть стрелки. Они 
представляют собой зависимости, когда один модуль использует код другого. Персоналу необходимо кормить животных, чтобы 
сохранить свою работу. Строка от zoo.staff до zoo.animal.feeding показывает, что первое зависит от второго.

#### Рис. 12.1 - Проектирование модульной системы


Теперь давайте углубимся в один из этих модулей. На рис. 12.2 показано, что находится внутри модуля zoo.animal.talks. 
Есть три пакета по два класса в каждом. (Это небольшой зоопарк.) Еще есть странный файл под названием module-info.java. 
Этот файл должен находиться внутри всех модулей. Мы объясним это более подробно далее в этой главе.

#### Рис. 12.2 - Заглядываем внутрь модуля


### Преимущества модулей

Модули выглядят как еще один уровень того, что вам нужно знать для программирования. Хотя использование модулей не 
является обязательным, важно понимать проблемы, для решения которых они предназначены:

+ **Улучшенный контроль доступа:** В дополнение к уровням контроля доступа, описанным в главе 5 “Методы”, у вас могут 
быть пакеты, доступные только для других пакетов в модуле.
+ **Более четкое управление зависимостями:** Поскольку модули определяют, на что они полагаются, Java может жаловаться 
на отсутствие JAR при запуске программы, а не при первом обращении к ней во время выполнения.
+ **Пользовательские сборки Java:** Вы можете создать среду выполнения Java, содержащую только те части JDK, которые 
нужны вашей программе, а не полный пакет объемом более 150 МБ.
+ **Улучшенная безопасность:** поскольку вы можете исключить части JDK из своей пользовательской сборки, вам не нужно 
беспокоиться об уязвимостях, обнаруженных в части, которую вы не используете.
+ **Улучшенная производительность:** Еще одним преимуществом меньшего размера Java-пакета является увеличение времени 
запуска и снижение требований к памяти.
+ **Уникальное применение пакетов:** Поскольку модули определяют открытые пакеты, Java может гарантировать, что каждый 
пакет поступает только из одного модуля, и избежать путаницы в отношении того, что запускается.


## Создание и запуск модульной программы

В этом разделе мы создаем, компонуем и запускаем модуль zoo.animal.feeding. Мы выбрали этот модуль для начала, потому 
что от него зависят все остальные модули. Фигура на рис. 12.3 показана конструкция этого модуля. В дополнение к 
module-info.java файл, в нем есть один пакет с одним классом внутри.

#### Рис. 12.3 - Содержание zoo.animal.feeding



В следующих разделах мы создадим, скомпилируем, запустим и упакуем модуль zoo.animal.feeding.

### Создание файлов

Сначала у нас есть очень простой класс, который печатает одну строку в методе main(). Мы знаем, что это не такая уж 
большая реализация. Все программисты, которых мы наняли, могут заполнить его бизнес-логикой. В этой книге мы 
сосредоточимся на том, что вам нужно знать для экзамена. Итак, давайте создадим простой класс.

```
package zoo.animal.feeding;

public class Task {    
   public static void main(String... args) {      
      System.out.println("All fed!");   
   }
}
```

Далее идет файл module-info.java. Это самый простой вариант:

```
module zoo.animal.feeding { 
}
```

Есть несколько ключевых отличий между объявлением модуля и обычным объявлением класса Java:

+ Файл module-info.java должен находиться в корневом каталоге вашего модуля. Обычные классы Java должны быть в пакетах.
+ В объявлении модуля должно использоваться ключевое слово module вместо class, interface или enum.
+ Имя модуля соответствует правилам именования имен пакетов. В своем названии часто присутствуют точки (.). В именах 
обычных классов и пакетов не допускается использование дефисов (-). Имена модулей подчиняются тому же правилу.

Это множество правил для простейшего файла. Когда мы позже в этой главе доработаем этот файл, будет еще много правил.

Следующий шаг — убедиться, что файлы находятся в правильной структуре каталогов. На рисунке 12.4 показана ожидаемая 
структура каталогов.

#### Рис. 12.4 - Структура каталогов модуля zoo.animal.feeding


В частности, feeding-это каталог модуля, и module-info.java файл находится непосредственно под ним. Как и в случае с 
обычным JAR-файлом, у нас также есть пакет zoo.animal.feeding с одной подпапкой для каждой части имени. Класс Task 
находится в соответствующей подпапке для своего пакета.

Также обратите внимание, что мы создали каталог mods на том же уровне, что и модуль. Мы используем его для хранения 
артефактов модуля чуть позже в этой главе. Этот каталог может называться как угодно, но mods — это обычное имя. Если вы 
следуете примеру онлайн-кода, обратите внимание, что каталог mods не включен, поскольку он пуст.

### Компилируем наш первый модуль

Прежде чем мы сможем запустить модульный код, нам нужно его скомпилировать. За исключением параметра module-path, этот 
код должен выглядеть знакомым по главе 1:

```
javac --module-path mods
   -d feeding
   feeding/zoo/animal/feeding/*.java feeding/module-info.java
```

_Когда вы вводите команды в командной строке, все они должны быть набраны в одной строке. Мы используем переносы строк 
в книге, чтобы облегчить чтение и изучение команд. Если вы хотите использовать несколько строк в командной строке, 
подход зависит от операционной системы. Linux использует обратную косую черту (\), чтобы избежать разрыва строки._

Для проверки опция -d указывает каталог для размещения файлов классов. Конец команды представляет собой список 
файлов .java для компиляции. Вы можете перечислить файлы по отдельности или использовать подстановочный знак для всех 
файлов .java в подкаталоге.

Новая часть - это module-path. Этот параметр указывает местоположение любых файлов пользовательского модуля. В этом 
примере module-path мог быть опущен, поскольку нет зависимостей. Вы можете думать о module-path как о замене параметра 
classpath, когда работаете над модульной программой.

---

**А как насчет classpath?**

Опция classpath имеет три возможные формы: -cp, --class-path и -classpath. Вы все еще можете использовать эти параметры. 
Фактически, это обычно происходит при написании немодульных программ.

---

Как и в случае с classpath, в команде можно использовать сокращение. Синтаксис --module-path и -p эквивалентны. 
Это означает, что мы могли бы написать множество других команд вместо предыдущей команды. Следующие четыре команды 
показывают опцию -p:

```
javac -p mods -d feeding
   feeding/zoo/animal/feeding/*.java feeding/*.java

javac -p mods -d feeding
   feeding/zoo/animal/feeding/*.java feeding/module-info.java
   
javac -p mods -d feeding
   feeding/zoo/animal/feeding/Task.java feeding/module-info.java

javac -p mods -d feeding
   feeding/zoo/animal/feeding/Task.java feeding/*.java
```

Хотя вы можете использовать любой вариант, который вам больше нравится, убедитесь, что вы можете распознать все 
действительные формы для экзамена. В Таблице 12.1 перечислены параметры, которые необходимо хорошо знать при компиляции 
модулей. Есть еще много параметров, которые вы можете передать команде javac, но это те, которые вы можете использовать 
для тестирования.

#### Таблица 12.1 - Параметры, которые необходимо знать для использования модулей с javac

|      Использовать для      | Сокращение |     Полная форма      |  
|:--------------------------:|------------|:---------------------:|
| Каталог для файлов классов | -d  <dir>  |          n/a          |
|       Путь к модулю        | -p <path>  | --module-path <path>  |


---

_Сценарий реального мира_

**Создание модулей**

Даже без модулей редко можно вручную запускать команды javac и java в реальном проекте. Они очень быстро становятся 
длинными и сложными. Большинство разработчиков используют такие инструменты сборки, как Maven или Gradle. Эти 
инструменты сборки предлагают каталоги для размещения файлов классов, например target/classes.

Вероятно, единственный раз, когда вам нужно знать синтаксис этих команд, — это сдача экзамена. В любом случае, сами 
по себе концепции полезны.

Обязательно запомните синтаксис команд модуля. По нему вас проверят на экзамене. Мы даем вам множество практических 
вопросов по синтаксису, чтобы закрепить его.

---

### Запуск нашего первого модуля

Прежде чем упаковать наш модуль, мы должны убедиться, что он работает, запустив его. Для этого нам нужно изучить полный 
синтаксис. Предположим, существует модуль с именем book.module. Внутри этого модуля находится пакет com.sybex, в 
котором есть класс OCP с методом main(). На рисунке 12.5 показан синтаксис запуска модуля. Обратите особое внимание на 
часть book.module/com.sybex.OCP. Важно помнить, что вы указываете имя модуля, за которым следует косая черта (/), за 
которой следует полное имя класса.

#### Рис. 12.5 - Запуск модуля с использованием Java


Теперь, когда мы ознакомились с синтаксисом, мы можем написать команду для запуска класса Task в пакете 
zoo.animal.feeding. В следующем примере имя пакета и имя модуля совпадают. Обычно имя модуля совпадает либо с полным 
именем пакета, либо с его началом.

```
java --module-path feeding
   --module zoo.animal.feeding/zoo.animal.feeding.Task 
```

Поскольку вы уже видели, что --module-path использует короткую форму -p, держим пари, что вы не удивитесь, узнав, что 
существует и короткая форма --module. Краткий вариант -m. Это означает, что следующая команда эквивалентна:

```
java -p feeding
   -m zoo.animal.feeding/zoo.animal.feeding.Task
```

В этих примерах мы использовали feeding в качестве пути к модулю, потому что именно здесь мы скомпилировали код. Это 
изменится, как только мы упакуем модуль и запустим его.

#### Таблица 12.2 - Параметры, которые вам необходимо знать для использования модулей с java

| Использовать для | Сокращение |     Полная форма      |  
|:----------------:|------------|:---------------------:|
|   Имя модуля     | -m <name>  |    --module <name>    |
|  Путь к модулю   | -p <path>  | --module-path <path>  |


### Упаковка нашего первого модуля

От модуля мало проку, если мы можем запустить его только в той папке, в которой он был создан. Наш следующий шаг - 
упаковать его. Обязательно создайте каталог mods перед запуском этой команды:

```
jar -cvf mods/zoo.animal.feeding.jar -C feeding/ .
```

Здесь нет ничего специфичного для модуля. Мы упаковываем все в каталог feeding и сохраняем это в JAR-файле с именем 
zoo.animal.feeding.jar в папке mods. Это представляет, как модуль JAR будет выглядеть для другого кода, который захочет 
его использовать.

Теперь давайте снова запустим программу, но на этот раз используя каталог mods вместо свободных классов:

```
java -p mods
   -m zoo.animal.feeding/zoo.animal.feeding.Task
```

Вы могли заметить, что эта команда выглядит идентично приведенной в предыдущем разделе, за исключением каталога. 
В предыдущем примере это было feeding. В данном случае это путь к модулю mods. Поскольку используется путь к модулю, 
запускается модуль JAR.

## Обновление нашего примера для нескольких модулей

Теперь, когда наш модуль zoo.animal.feeding готов, мы можем начать думать о других модулях. Как вы можете видеть на 
рисунке 12.6, все три других модуля в нашей системе зависят от модуля zoo.animal.feeding.

#### Рис. 12.6 - Модули в зависимости от zoo.animal.feeding


### Обновление модуля Feeding

Поскольку код вызова других модулей будет находиться в пакете zoo.animal.feeding, нам необходимо объявить это намерение 
в объявлении модуля.

Директива exports используется для указания того, что модуль предназначен для использования этих пакетов кодом Java вне 
модуля. Как и следовало ожидать, без директивы exports модуль можно запустить только из командной строки. В следующем 
примере мы экспортируем один пакет:

```
module zoo.animal.feeding {
   exports zoo.animal.feeding;
}
```

Перекомпиляция и переупаковка модуля обновит module-info.class внутри нашего файла zoo.animal.feeding.jar. Это те же 
команды javac и jar, которые вы запускали ранее:

```
javac -p mods
   -d feeding
   feeding/zoo/animal/feeding/*.java feeding/module-info.java

jar -cvf mods/zoo.animal.feeding.jar -C feeding/ .
```

### Создание модуля Care

Далее давайте создадим модуль zoo.animal.care. На этот раз у нас будет два пакета. Пакет zoo.animal.care.medical будет 
содержать классы и методы, предназначенные для использования другими модулями. Пакет zoo.animal.care.details будет 
использоваться только этим модулем. Он не будет экспортирован из модуля. Думайте об этом как о конфиденциальности в 
сфере здравоохранения для животных.

На рисунке 12.7 показано содержимое этого модуля. Помните, что все модули должны иметь файл mod-info.java.

#### Рис. 12.7 - Содержание zoo.animal.care


Помимо файла mod-info.java, модуль содержит два основных пакета и класса:

```
// HippoBirthday.java 
package zoo.animal.care.details; 
import zoo.animal.feeding.*; 
public class HippoBirthday {    
   private Task task;
}

// Diet.java 
package zoo.animal.care.medical; 
public class Diet { }
```

На этот раз файл module-info.java определяет три вещи:

```
1: module zoo.animal.care { 
2:    exports zoo.animal.care.medical; 
3:    requires zoo.animal.feeding; 
4: }
```

В строке 1 указывается имя модуля. В строке 2 указан пакет, который мы экспортируем, чтобы его могли использовать другие 
модули. Пока что это похоже на модуль zoo.animal.feeding.

В строке 3 мы видим новую директиву. Оператор require указывает, что необходим модуль. Модуль zoo.animal.care зависит от
модуля zoo.animal.feeding.

Далее нам нужно разобраться со структурой каталогов. Мы создадим два пакета. Первый — zoo.animal.care.details — содержит 
один класс с именем HippoBirthday. Второй — zoo.animal.care.medical, который содержит один класс с именем Diet. 
Попробуйте нарисовать структуру каталогов на бумаге или создать ее на своем компьютере. Если вы пытаетесь запустить эти 
примеры без использования онлайн-кода, просто создайте классы без переменных и методов для всего, кроме файлов 
module-info.java.

Возможно, вы заметили, что пакеты начинаются с того же префикса, что и имя модуля. Это сделано намеренно. Вы можете 
думать об этом так, как будто имя модуля “утверждает” соответствующий пакет и все подпакеты.

Для ознакомления теперь мы скомпилируем и упакуем модуль:

```
javac -p mods
   -d care
   care/zoo/animal/care/details/*.java
   care/zoo/animal/care/medical/*.java
   care/module-info.java
```

Мы компилируем оба пакета и module-info.java файл. В реальном мире вы будете использовать инструмент сборки, а не делать 
это вручную. Для экзамена вы просто перечисляете все пакеты и / или файлы, которые вы хотите скомпилировать.

Теперь, когда мы скомпилировали код, пришло время создать модуль JAR:

```
jar -cvf mods/zoo.animal.care.jar -C care/ .
```

### Создание модуля Talks

До сих пор мы использовали только один оператор exports и requires в модуле. Теперь вы узнаете, как работать с экспортом 
нескольких пакетов или как использовать несколько модулей. На рисунке 12.8 обратите внимание, что модуль 
zoo.animal.talks зависит от двух модулей: zoo.animal.feeding и zoo.animal.care. Это означает, что в инструкции requires 
должно быть два утверждения module-info.java файл.

#### Рис. 12.8 - Dependencies for zoo.animal.talks


На рисунке 12.9 показано содержимое этого модуля. Мы собираемся экспортировать все три пакета в этом модуле.


#### Рис. 12.9 - Содержимое zoo.animal.talks


Сначала давайте посмотрим на module-info.java файл для zoo.animal.talks:

```
1: module zoo.animal.talks { 
2:    exports zoo.animal.talks.content; 
3:    exports zoo.animal.talks.media; 
4:    exports zoo.animal.talks.schedule; 
5:
6:    requires zoo.animal.feeding; 
7:    requires zoo.animal.care; 
8: }
```

В строке 1 указано название модуля. Строки 2-4 позволяют другим модулям ссылаться на все три пакета. В строках 6 и 7 
указаны два модуля, от которых зависит этот модуль.

Тогда у нас есть шесть классов, как показано здесь:

```
// ElephantScript.java
package zoo.animal.talks.content;
public class ElephantScript { }

// SeaLionScript.java
package zoo.animal.talks.content;
public class SeaLionScript { }

// Announcement.java
package zoo.animal.talks.media;
public class Announcement {
   public static void main(String[] args) {
      System.out.println("We will be having talks");
   }
}

// Signage.java
package zoo.animal.talks.media;
public class Signage { }

// Weekday.java
package zoo.animal.talks.schedule;
public class Weekday { }

// Weekend.java
package zoo.animal.talks.schedule;
public class Weekend {}
```

Если вы все еще работаете на своем компьютере, создайте эти классы в пакетах. Ниже приведены команды для компиляции и 
сборки модуля:

```
javac -p mods
   -d talks
   talks/zoo/animal/talks/content/*.java talks/zoo/animal/talks/media/*.java
   talks/zoo/animal/talks/schedule/*.java talks/module-info.java
   
jar -cvf mods/zoo.animal.talks.jar -C talks/ .
```

### Создание модуля Staff

Наш последний модуль zoo.staff. На рисунке 12.10 показано, что внутри находится только одна упаковка. Мы не будем 
раскрывать этот пакет за пределами модуля.

#### Рис. 12.10 - Содержание zoo.staff


Основываясь на рисунке 12.11, знаете ли вы, что должно содержаться в module-info?

#### Рис. 12.11 - Зависимости для zoo.staff


На рисунке 12.11 есть три стрелки, указывающие от zoo.staff к другим модулям. Они представляют собой три необходимых 
модуля. Поскольку никакие пакеты не должны быть доступны из zoo.staff, операторы экспорта отсутствуют. Это дает нам:

```
module zoo.staff {
   requires zoo.animal.feeding;
   requires zoo.animal.care;
   requires zoo.animal.talks;
}
```

В этом модуле у нас есть один класс в файле Jobs.java:

```
package zoo.staff;
public class Jobs { }
```

Для тех из вас, кто следит за вашим компьютером, создайте класс в пакете. Ниже приведены команды для компиляции и 
сборки модуля:

```
javac -p mods
   -d staff
   staff/zoo/staff/*.java staff/module-info.java
   
jar -cvf mods/zoo.staff.jar -C staff/ .
```

## Подробное описание декларации модуля

Теперь, когда мы успешно создали модули, мы можем узнать больше об объявлении модуля. В этих разделах мы рассмотрим
exports, requires, и opens. В следующем разделе, посвященном сервисам, мы рассмотрим их provides и uses. Сейчас самое 
подходящее время упомянуть, что эти директивы могут отображаться в объявлении модуля в любом порядке.

### Exporting a Package