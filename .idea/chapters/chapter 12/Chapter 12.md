# Модули

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Упаковка и развертывание кода Java и использование системы модулей платформы Java

+ Определите модули и их зависимости, выставьте содержимое модулей, в том числе для отражения. Определите услуги, 
производителей и потребителей
+ Компилируйте код Java, создавайте модульные и немодульные jar-файлы, образы среды выполнения и реализуйте миграцию с 
использованием безымянных и автоматических модулей

---

Пакеты можно группировать в модули. В этой главе мы объясняем назначение модулей и способы создания собственных. Мы 
также покажем, как их запускать и как обнаруживать существующие модули. Далее мы рассмотрим стратегии миграции 
приложения на использование модулей, запуск частично модульного приложения и работу с зависимостями. Затем мы переходим 
к обсуждению сервисов и локаторов сервисов. Наконец, мы покажем, как создать образ времени выполнения.

Мы разместили код из этой главы в Интернете. Поскольку создание структуры каталогов может оказаться утомительным, это 
сэкономит вам некоторое время. Кроме того, команды должны быть абсолютно правильными, поэтому мы включили их в Интернет, 
чтобы вы могли скопировать и вставить их и сравнить с тем, что вы набрали. Оба доступны в нашем репозитории GitHub, 
ссылка на который находится на 

```
www.selikoff.net/ocp-17/
```

## Знакомство с модулями

При написании кода для экзамена вы обычно видите небольшие классы. В конце концов, экзаменационные вопросы должны 
умещаться на одном экране! Когда вы работаете над реальными программами, они намного больше. Реальный проект будет 
состоять из сотен или тысяч классов, сгруппированных в пакеты. Эти пакеты сгруппированы в файлы архива Java (JAR). 
JAR — это ZIP-файл с дополнительной информацией, имеющий расширение .jar.

Помимо кода, написанного вашей командой, большинство приложений также используют код, написанный другими. Открытый 
исходный код — это программное обеспечение с поставляемым кодом, которое часто можно использовать бесплатно. Java имеет 
активное сообщество программного обеспечения с открытым исходным кодом (OSS), и эти библиотеки также поставляются в 
виде файлов JAR. Например, есть библиотеки для чтения файлов, подключения к базе данных и многое другое.

Некоторые проекты с открытым исходным кодом даже зависят от функциональности других проектов с открытым исходным кодом. 
Например, Spring — это широко используемая среда, а JUnit — широко используемая библиотека тестирования. Чтобы 
использовать любой из них, вам необходимо убедиться, что у вас есть совместимые версии всех соответствующих JAR-файлов, 
доступных во время выполнения. Эту сложную цепочку зависимостей и минимальных версий сообщество часто называет JAR-адом. 
Ад — отличный способ описать неправильную версию загружаемого класса или даже исключение ClassNotFoundException во 
время выполнения.

Система модулей платформы Java (JPMS) группирует код на более высоком уровне. Основная цель модуля — предоставить 
группы связанных пакетов, которые предлагают разработчикам определенный набор функций. Это похоже на файл JAR, за 
исключением того, что разработчик выбирает, какие пакеты доступны вне модуля. Давайте разберемся, что такое модули и 
какие задачи они призваны решать.

Система модулей платформы Java включает в себя следующее:

+ Формат для JAR-файлов модуля
+ Разбиение JDK на модули
+ Дополнительные параметры командной строки для инструментов Java


### Изучение модуля

В главе 1 «Строительные блоки» у нас было небольшое приложение Zoo. У него был только один класс, и он распечатывал 
только одну вещь. А теперь представьте, что у нас есть целый штат программистов и мы автоматизируем работу зоопарка. 
Многие вещи необходимо закодировать, в том числе взаимодействие с животными, посетителями, общедоступным веб-сайтом и 
информационно-просветительской деятельностью.

Модуль — это группа из одного или нескольких пакетов плюс специальный файл под названием Module-info.java. Содержимое 
этого файла является объявлением модуля. На рисунке 12.1 перечислены лишь некоторые из модулей, которые могут 
понадобиться зоопарку. В нашем примере мы решили сосредоточиться на взаимодействии животных. Полный зоопарк легко мог 
бы состоять из дюжины модулей. Обратите внимание, что на рисунке 12.1 между многими модулями есть стрелки. Они 
представляют собой зависимости, когда один модуль использует код другого. Персоналу необходимо кормить животных, чтобы 
сохранить свою работу. Строка от zoo.staff до zoo.animal.feeding показывает, что первое зависит от второго.

#### Рис. 12.1 - Проектирование модульной системы


Теперь давайте углубимся в один из этих модулей. На рис. 12.2 показано, что находится внутри модуля zoo.animal.talks. 
Есть три пакета по два класса в каждом. (Это небольшой зоопарк.) Еще есть странный файл под названием module-info.java. 
Этот файл должен находиться внутри всех модулей. Мы объясним это более подробно далее в этой главе.

#### Рис. 12.2 - Заглядываем внутрь модуля


### Преимущества модулей

Модули выглядят как еще один уровень того, что вам нужно знать для программирования. Хотя использование модулей не 
является обязательным, важно понимать проблемы, для решения которых они предназначены:

+ **Улучшенный контроль доступа:** В дополнение к уровням контроля доступа, описанным в главе 5 “Методы”, у вас могут 
быть пакеты, доступные только для других пакетов в модуле.
+ **Более четкое управление зависимостями:** Поскольку модули определяют, на что они полагаются, Java может жаловаться 
на отсутствие JAR при запуске программы, а не при первом обращении к ней во время выполнения.
+ **Пользовательские сборки Java:** Вы можете создать среду выполнения Java, содержащую только те части JDK, которые 
нужны вашей программе, а не полный пакет объемом более 150 МБ.
+ **Улучшенная безопасность:** поскольку вы можете исключить части JDK из своей пользовательской сборки, вам не нужно 
беспокоиться об уязвимостях, обнаруженных в части, которую вы не используете.
+ **Улучшенная производительность:** Еще одним преимуществом меньшего размера Java-пакета является увеличение времени 
запуска и снижение требований к памяти.
+ **Уникальное применение пакетов:** Поскольку модули определяют открытые пакеты, Java может гарантировать, что каждый 
пакет поступает только из одного модуля, и избежать путаницы в отношении того, что запускается.


## Создание и запуск модульной программы

В этом разделе мы создаем, компонуем и запускаем модуль zoo.animal.feeding. Мы выбрали этот модуль для начала, потому 
что от него зависят все остальные модули. Фигура на рис. 12.3 показана конструкция этого модуля. В дополнение к 
module-info.java файл, в нем есть один пакет с одним классом внутри.

#### Рис. 12.3 - Содержание zoo.animal.feeding



В следующих разделах мы создадим, скомпилируем, запустим и упакуем модуль zoo.animal.feeding.

### Создание файлов

Сначала у нас есть очень простой класс, который печатает одну строку в методе main(). Мы знаем, что это не такая уж 
большая реализация. Все программисты, которых мы наняли, могут заполнить его бизнес-логикой. В этой книге мы 
сосредоточимся на том, что вам нужно знать для экзамена. Итак, давайте создадим простой класс.

```
package zoo.animal.feeding;

public class Task {    
   public static void main(String... args) {      
      System.out.println("All fed!");   
   }
}
```

Далее идет файл module-info.java. Это самый простой вариант:

```
module zoo.animal.feeding { 
}
```

Есть несколько ключевых отличий между объявлением модуля и обычным объявлением класса Java:

+ Файл module-info.java должен находиться в корневом каталоге вашего модуля. Обычные классы Java должны быть в пакетах.
+ В объявлении модуля должно использоваться ключевое слово module вместо class, interface или enum.
+ Имя модуля соответствует правилам именования имен пакетов. В своем названии часто присутствуют точки (.). В именах 
обычных классов и пакетов не допускается использование дефисов (-). Имена модулей подчиняются тому же правилу.

Это множество правил для простейшего файла. Когда мы позже в этой главе доработаем этот файл, будет еще много правил.

Следующий шаг — убедиться, что файлы находятся в правильной структуре каталогов. На рисунке 12.4 показана ожидаемая 
структура каталогов.

#### Рис. 12.4 - Структура каталогов модуля zoo.animal.feeding


В частности, feeding-это каталог модуля, и module-info.java файл находится непосредственно под ним. Как и в случае с 
обычным JAR-файлом, у нас также есть пакет zoo.animal.feeding с одной подпапкой для каждой части имени. Класс Task 
находится в соответствующей подпапке для своего пакета.

Также обратите внимание, что мы создали каталог mods на том же уровне, что и модуль. Мы используем его для хранения 
артефактов модуля чуть позже в этой главе. Этот каталог может называться как угодно, но mods — это обычное имя. Если вы 
следуете примеру онлайн-кода, обратите внимание, что каталог mods не включен, поскольку он пуст.

### Компилируем наш первый модуль

Прежде чем мы сможем запустить модульный код, нам нужно его скомпилировать. За исключением параметра module-path, этот 
код должен выглядеть знакомым по главе 1:

```
javac --module-path mods
   -d feeding
   feeding/zoo/animal/feeding/*.java feeding/module-info.java
```

_Когда вы вводите команды в командной строке, все они должны быть набраны в одной строке. Мы используем переносы строк 
в книге, чтобы облегчить чтение и изучение команд. Если вы хотите использовать несколько строк в командной строке, 
подход зависит от операционной системы. Linux использует обратную косую черту (\), чтобы избежать разрыва строки._

Для проверки опция -d указывает каталог для размещения файлов классов. Конец команды представляет собой список 
файлов .java для компиляции. Вы можете перечислить файлы по отдельности или использовать подстановочный знак для всех 
файлов .java в подкаталоге.

Новая часть - это module-path. Этот параметр указывает местоположение любых файлов пользовательского модуля. В этом 
примере module-path мог быть опущен, поскольку нет зависимостей. Вы можете думать о module-path как о замене параметра 
classpath, когда работаете над модульной программой.

---

**А как насчет classpath?**

Опция classpath имеет три возможные формы: -cp, --class-path и -classpath. Вы все еще можете использовать эти параметры. 
Фактически, это обычно происходит при написании немодульных программ.

---

Как и в случае с classpath, в команде можно использовать сокращение. Синтаксис --module-path и -p эквивалентны. 
Это означает, что мы могли бы написать множество других команд вместо предыдущей команды. Следующие четыре команды 
показывают опцию -p:

```
javac -p mods -d feeding
   feeding/zoo/animal/feeding/*.java feeding/*.java

javac -p mods -d feeding
   feeding/zoo/animal/feeding/*.java feeding/module-info.java
   
javac -p mods -d feeding
   feeding/zoo/animal/feeding/Task.java feeding/module-info.java

javac -p mods -d feeding
   feeding/zoo/animal/feeding/Task.java feeding/*.java
```

Хотя вы можете использовать любой вариант, который вам больше нравится, убедитесь, что вы можете распознать все 
действительные формы для экзамена. В Таблице 12.1 перечислены параметры, которые необходимо хорошо знать при компиляции 
модулей. Есть еще много параметров, которые вы можете передать команде javac, но это те, которые вы можете использовать 
для тестирования.

#### Таблица 12.1 - Параметры, которые необходимо знать для использования модулей с javac

|      Использовать для      | Сокращение |     Полная форма      |  
|:--------------------------:|------------|:---------------------:|
| Каталог для файлов классов | -d  <dir>  |          n/a          |
|       Путь к модулю        | -p <path>  | --module-path <path>  |


---

_Сценарий реального мира_

**Создание модулей**

Даже без модулей редко можно вручную запускать команды javac и java в реальном проекте. Они очень быстро становятся 
длинными и сложными. Большинство разработчиков используют такие инструменты сборки, как Maven или Gradle. Эти 
инструменты сборки предлагают каталоги для размещения файлов классов, например target/classes.

Вероятно, единственный раз, когда вам нужно знать синтаксис этих команд, — это сдача экзамена. В любом случае, сами 
по себе концепции полезны.

Обязательно запомните синтаксис команд модуля. По нему вас проверят на экзамене. Мы даем вам множество практических 
вопросов по синтаксису, чтобы закрепить его.

---

### Запуск нашего первого модуля

Прежде чем упаковать наш модуль, мы должны убедиться, что он работает, запустив его. Для этого нам нужно изучить полный 
синтаксис. Предположим, существует модуль с именем book.module. Внутри этого модуля находится пакет com.sybex, в 
котором есть класс OCP с методом main(). На рисунке 12.5 показан синтаксис запуска модуля. Обратите особое внимание на 
часть book.module/com.sybex.OCP. Важно помнить, что вы указываете имя модуля, за которым следует косая черта (/), за 
которой следует полное имя класса.

#### Рис. 12.5 - Запуск модуля с использованием Java


Теперь, когда мы ознакомились с синтаксисом, мы можем написать команду для запуска класса Task в пакете 
zoo.animal.feeding. В следующем примере имя пакета и имя модуля совпадают. Обычно имя модуля совпадает либо с полным 
именем пакета, либо с его началом.

```
java --module-path feeding
   --module zoo.animal.feeding/zoo.animal.feeding.Task 
```

Поскольку вы уже видели, что --module-path использует короткую форму -p, держим пари, что вы не удивитесь, узнав, что 
существует и короткая форма --module. Краткий вариант -m. Это означает, что следующая команда эквивалентна:

```
java -p feeding
   -m zoo.animal.feeding/zoo.animal.feeding.Task
```

В этих примерах мы использовали feeding в качестве пути к модулю, потому что именно здесь мы скомпилировали код. Это 
изменится, как только мы упакуем модуль и запустим его.

#### Таблица 12.2 - Параметры, которые вам необходимо знать для использования модулей с java

| Использовать для | Сокращение |     Полная форма      |  
|:----------------:|------------|:---------------------:|
|   Имя модуля     | -m <name>  |    --module <name>    |
|  Путь к модулю   | -p <path>  | --module-path <path>  |


### Упаковка нашего первого модуля

От модуля мало проку, если мы можем запустить его только в той папке, в которой он был создан. Наш следующий шаг - 
упаковать его. Обязательно создайте каталог mods перед запуском этой команды:

```
jar -cvf mods/zoo.animal.feeding.jar -C feeding/ .
```

Здесь нет ничего специфичного для модуля. Мы упаковываем все в каталог feeding и сохраняем это в JAR-файле с именем 
zoo.animal.feeding.jar в папке mods. Это представляет, как модуль JAR будет выглядеть для другого кода, который захочет 
его использовать.

Теперь давайте снова запустим программу, но на этот раз используя каталог mods вместо свободных классов:

```
java -p mods
   -m zoo.animal.feeding/zoo.animal.feeding.Task
```

Вы могли заметить, что эта команда выглядит идентично приведенной в предыдущем разделе, за исключением каталога. 
В предыдущем примере это было feeding. В данном случае это путь к модулю mods. Поскольку используется путь к модулю, 
запускается модуль JAR.

## Обновление нашего примера для нескольких модулей

Теперь, когда наш модуль zoo.animal.feeding готов, мы можем начать думать о других модулях. Как вы можете видеть на 
рисунке 12.6, все три других модуля в нашей системе зависят от модуля zoo.animal.feeding.

#### Рис. 12.6 - Модули в зависимости от zoo.animal.feeding


### Обновление модуля Feeding

Поскольку код вызова других модулей будет находиться в пакете zoo.animal.feeding, нам необходимо объявить это намерение 
в объявлении модуля.

Директива exports используется для указания того, что модуль предназначен для использования этих пакетов кодом Java вне 
модуля. Как и следовало ожидать, без директивы exports модуль можно запустить только из командной строки. В следующем 
примере мы экспортируем один пакет:

```
module zoo.animal.feeding {
   exports zoo.animal.feeding;
}
```

Перекомпиляция и переупаковка модуля обновит module-info.class внутри нашего файла zoo.animal.feeding.jar. Это те же 
команды javac и jar, которые вы запускали ранее:

```
javac -p mods
   -d feeding
   feeding/zoo/animal/feeding/*.java feeding/module-info.java

jar -cvf mods/zoo.animal.feeding.jar -C feeding/ .
```

### Создание модуля Care

Далее давайте создадим модуль zoo.animal.care. На этот раз у нас будет два пакета. Пакет zoo.animal.care.medical будет 
содержать классы и методы, предназначенные для использования другими модулями. Пакет zoo.animal.care.details будет 
использоваться только этим модулем. Он не будет экспортирован из модуля. Думайте об этом как о конфиденциальности в 
сфере здравоохранения для животных.

На рисунке 12.7 показано содержимое этого модуля. Помните, что все модули должны иметь файл mod-info.java.

#### Рис. 12.7 - Содержание zoo.animal.care


Помимо файла mod-info.java, модуль содержит два основных пакета и класса:

```
// HippoBirthday.java 
package zoo.animal.care.details; 
import zoo.animal.feeding.*; 
public class HippoBirthday {    
   private Task task;
}

// Diet.java 
package zoo.animal.care.medical; 
public class Diet { }
```

На этот раз файл module-info.java определяет три вещи:

```
1: module zoo.animal.care { 
2:    exports zoo.animal.care.medical; 
3:    requires zoo.animal.feeding; 
4: }
```

В строке 1 указывается имя модуля. В строке 2 указан пакет, который мы экспортируем, чтобы его могли использовать другие 
модули. Пока что это похоже на модуль zoo.animal.feeding.

В строке 3 мы видим новую директиву. Оператор require указывает, что необходим модуль. Модуль zoo.animal.care зависит от
модуля zoo.animal.feeding.

Далее нам нужно разобраться со структурой каталогов. Мы создадим два пакета. Первый — zoo.animal.care.details — содержит 
один класс с именем HippoBirthday. Второй — zoo.animal.care.medical, который содержит один класс с именем Diet. 
Попробуйте нарисовать структуру каталогов на бумаге или создать ее на своем компьютере. Если вы пытаетесь запустить эти 
примеры без использования онлайн-кода, просто создайте классы без переменных и методов для всего, кроме файлов 
module-info.java.

Возможно, вы заметили, что пакеты начинаются с того же префикса, что и имя модуля. Это сделано намеренно. Вы можете 
думать об этом так, как будто имя модуля “утверждает” соответствующий пакет и все подпакеты.

Для ознакомления теперь мы скомпилируем и упакуем модуль:

```
javac -p mods
   -d care
   care/zoo/animal/care/details/*.java
   care/zoo/animal/care/medical/*.java
   care/module-info.java
```

Мы компилируем оба пакета и module-info.java файл. В реальном мире вы будете использовать инструмент сборки, а не делать 
это вручную. Для экзамена вы просто перечисляете все пакеты и / или файлы, которые вы хотите скомпилировать.

Теперь, когда мы скомпилировали код, пришло время создать модуль JAR:

```
jar -cvf mods/zoo.animal.care.jar -C care/ .
```

### Создание модуля Talks

До сих пор мы использовали только один оператор exports и requires в модуле. Теперь вы узнаете, как работать с экспортом 
нескольких пакетов или как использовать несколько модулей. На рисунке 12.8 обратите внимание, что модуль 
zoo.animal.talks зависит от двух модулей: zoo.animal.feeding и zoo.animal.care. Это означает, что в инструкции requires 
должно быть два утверждения module-info.java файл.

#### Рис. 12.8 - Dependencies for zoo.animal.talks


На рисунке 12.9 показано содержимое этого модуля. Мы собираемся экспортировать все три пакета в этом модуле.


#### Рис. 12.9 - Содержимое zoo.animal.talks


Сначала давайте посмотрим на module-info.java файл для zoo.animal.talks:

```
1: module zoo.animal.talks { 
2:    exports zoo.animal.talks.content; 
3:    exports zoo.animal.talks.media; 
4:    exports zoo.animal.talks.schedule; 
5:
6:    requires zoo.animal.feeding; 
7:    requires zoo.animal.care; 
8: }
```

В строке 1 указано название модуля. Строки 2-4 позволяют другим модулям ссылаться на все три пакета. В строках 6 и 7 
указаны два модуля, от которых зависит этот модуль.

Тогда у нас есть шесть классов, как показано здесь:

```
// ElephantScript.java
package zoo.animal.talks.content;
public class ElephantScript { }

// SeaLionScript.java
package zoo.animal.talks.content;
public class SeaLionScript { }

// Announcement.java
package zoo.animal.talks.media;
public class Announcement {
   public static void main(String[] args) {
      System.out.println("We will be having talks");
   }
}

// Signage.java
package zoo.animal.talks.media;
public class Signage { }

// Weekday.java
package zoo.animal.talks.schedule;
public class Weekday { }

// Weekend.java
package zoo.animal.talks.schedule;
public class Weekend {}
```

Если вы все еще работаете на своем компьютере, создайте эти классы в пакетах. Ниже приведены команды для компиляции и 
сборки модуля:

```
javac -p mods
   -d talks
   talks/zoo/animal/talks/content/*.java talks/zoo/animal/talks/media/*.java
   talks/zoo/animal/talks/schedule/*.java talks/module-info.java
   
jar -cvf mods/zoo.animal.talks.jar -C talks/ .
```

### Создание модуля Staff

Наш последний модуль zoo.staff. На рисунке 12.10 показано, что внутри находится только одна упаковка. Мы не будем 
раскрывать этот пакет за пределами модуля.

#### Рис. 12.10 - Содержание zoo.staff


Основываясь на рисунке 12.11, знаете ли вы, что должно содержаться в module-info?

#### Рис. 12.11 - Зависимости для zoo.staff


На рисунке 12.11 есть три стрелки, указывающие от zoo.staff к другим модулям. Они представляют собой три необходимых 
модуля. Поскольку никакие пакеты не должны быть доступны из zoo.staff, операторы экспорта отсутствуют. Это дает нам:

```
module zoo.staff {
   requires zoo.animal.feeding;
   requires zoo.animal.care;
   requires zoo.animal.talks;
}
```

В этом модуле у нас есть один класс в файле Jobs.java:

```
package zoo.staff;
public class Jobs { }
```

Для тех из вас, кто следит за вашим компьютером, создайте класс в пакете. Ниже приведены команды для компиляции и 
сборки модуля:

```
javac -p mods
   -d staff
   staff/zoo/staff/*.java staff/module-info.java
   
jar -cvf mods/zoo.staff.jar -C staff/ .
```

## Подробное описание декларации модуля

Теперь, когда мы успешно создали модули, мы можем узнать больше об объявлении модуля. В этих разделах мы рассмотрим
exports, requires, и opens. В следующем разделе, посвященном сервисам, мы рассмотрим их provides и uses. Сейчас самое 
подходящее время упомянуть, что эти директивы могут отображаться в объявлении модуля в любом порядке.

### Экспорт пакета

Мы уже видели, как exports packageName экспортирует пакет в другие модули. Также возможно экспортировать пакет в 
определенный модуль. Предположим, зоопарк решает, что доступ к переговорам должен быть только у сотрудников. Мы могли 
бы обновить объявление модуля следующим образом:

```
module zoo.animal.talks {
   exports zoo.animal.talks.content to zoo.staff;
   exports zoo.animal.talks.media;
   exports zoo.animal.talks.schedule;
   
   requires zoo.animal.feeding;
   requires zoo.animal.care;
}
```

В модуле zoo.staff ничего не изменилось. Однако никаким другим модулям не будет разрешен доступ к этому пакету.

Возможно, вы заметили, что ни один из других наших модулей не требует использования zoo.animal.talks в первую очередь. 
Однако мы не знаем, какие другие модули будут существовать в будущем. При проектировании модулей важно учитывать их 
будущее использование. Поскольку мы хотим, чтобы доступ был только к одному модулю, мы разрешаем доступ только к этому 
модулю.

---

**Экспортируемые типы**

Мы говорили об экспорте посылки. Но что именно это значит? Экспортируются все общедоступные классы, интерфейсы, 
перечисления и записи. Кроме того, видны все общедоступные и защищенные поля и методы в этих файлах.

Поля и методы, которые являются private, невидимы, поскольку они недоступны вне класса. Аналогично, поля и методы 
пакета не видны, поскольку они недоступны вне пакета.

---

Директива по exports, по сути, предоставляет нам больше уровней контроля доступа. В таблице 12.3 перечислены параметры 
полного контроля доступа.

#### Таблица 12.3 - Контроль доступа с помощью модулей

|  Уровень  |                Внутри кода модуля                |                          Внешний модуль                           |  
|:---------:|:------------------------------------------------:|:-----------------------------------------------------------------:|
|  private  |        Доступно только в пределах класса         |                            Нет доступа                            |
|   Пакет   |             Доступно только в пакете             |                            Нет доступа                            |
| protected | Доступно только внутри пакета или для подклассов | Доступен подклассам только в том случае, если пакет экспортирован |
|  public   |              Доступно всем классам               |      Доступно только в том случае, если пакет экспортирован       |


### Транзитивное требование модуля

Как вы видели ранее в этой главе, requires moduleName, что текущий модуль зависит от moduleName. Также существует 
requires transitive moduleName, что означает, что любой модуль, которому требуется этот модуль, также будет зависеть от 
moduleName.

Ну, это был глоток. Давайте посмотрим на пример. На рисунке 12.12 показаны модули пунктирными линиями для избыточных 
связей и сплошными линиями для связей, указанных в module-info. Это показывает, как бы выглядели отношения модулей, 
если бы мы использовали только транзитивные зависимости.

#### Рис. 12.12 - Версия наших модулей с транзитивной зависимостью


Например, zoo.animal.talks зависит от zoo.animal.care, который зависит от zoo.animal.feeding. Это означает, что стрелка 
между zoo.animal.talks и zoo.animal.feeding больше не отображается на рисунке 12.12.

Теперь давайте посмотрим на четыре объявления модуля. Первый модуль остается без изменений. Мы экспортируем один пакет 
во все пакеты, использующие этот модуль.

```
module zoo.animal.feeding {
   exports zoo.animal.feeding;
}
```

Модуль zoo.animal.care — это первая возможность улучшить ситуацию. Вместо того, чтобы заставлять все оставшиеся модули 
явно указывать zoo.animal.feeding, в коде requires transitive.

```
module zoo.animal.care {
   exports zoo.animal.care.medical;
   requires transitive zoo.animal.feeding;
}
```

В модуле zoo.animal.talks мы вносим аналогичное изменение и не заставляем другие модули указывать zoo.animal.care. 
Нам также больше не нужно указывать zoo.animal.feeding, поэтому эта строка закомментирована.

```
module zoo.animal.talks {
   exports zoo.animal.talks.content to zoo.staff;
   exports zoo.animal.talks.media;
   exports zoo.animal.talks.schedule;
   // no longer needed requires zoo.animal.feeding;
   // no longer needed requires zoo.animal.care;
   requires transitive zoo.animal.care;
}
```

Наконец, в модуле zoo.staff мы можем избавиться от двух операторов requires.

```
module zoo.staff {
   // no longer needed requires zoo.animal.feeding;
   // no longer needed requires zoo.animal.care;
   requires zoo.animal.talks;
}
```

Чем больше у вас модулей, тем больше преимуществ требуется от requires transitive. Это также более удобно для 
вызывающего. Если бы вы пытались работать с этим зоопарком, вы могли бы просто запросить zoo.staff и автоматически 
определить остальные зависимости.

### Эффекты от requires transitive

Учитывая объявления наших новых модулей и используя рисунок 12.12, каков эффект применения transitive модификатора к 
оператору requires в нашем модуле zoo.animal.care? Применение переходных модификаторов имеет следующие эффекты:

+ Модуль zoo.animal.talks может опционально объявить, requires модулю zoo.animal.feeding, но это не обязательно.
+ Модуль zoo.animal.care не может быть скомпилирован или выполнен без доступа к модулю zoo.animal.feeding.
+ Модуль zoo.animal.talks не может быть скомпилирован или выполнен без доступа к модулю zoo.animal.feeding.

Эти правила действуют, даже если модули zoo.animal.care и zoo.animal.talks не ссылаются явно на какие-либо пакеты в 
модуле zoo.animal.feeding. С другой стороны, без модификатора transitive в объявлении нашего модуля zoo.animal.care 
другим модулям пришлось бы явно использовать requires для ссылки на любые пакеты в модуле zoo.animal.feeding.

### Дублирующие операторы requires

Одно из мест, где экзамен может попытаться обмануть вас, - это смешивание requires и requires transitive. Можете ли вы 
назвать причину, по которой этот код не компилируется?

```
module bad.module {
   requires zoo.animal.talks;
   requires transitive zoo.animal.talks;
}
```

Java не позволяет вам повторять один и тот же модуль в предложении requires. Это избыточно и, скорее всего, ошибка в 
кодировании. Имейте в виду, что requires transitive - это как requires плюс некоторое дополнительное поведение.

### Вскрытие пакета

Java позволяет вызывающим абонентам проверять и вызывать код во время выполнения с помощью метода, называемого 
отражением(reflection). Это мощный подход, позволяющий вызывать код, который может быть недоступен во время компиляции. 
Его можно даже использовать для подрыва контроля доступа! Не волнуйтесь — для сдачи экзамена вам не нужно знать, как 
писать код с использованием reflection.

Директива opens используется для включения отражения пакета внутри модуля. Вам нужно только знать, что директива opens 
существует, а не разбираться в ней подробно для экзамена.

Поскольку отражение может быть опасным, модульная система требует, чтобы разработчики явно разрешали отражение в 
объявлении модуля, если они хотят, чтобы вызывающим модулям было разрешено его использовать. Ниже показано, как включить 
отражение для двух пакетов в модуле zoo.animal.talks:

```
module zoo.animal.talks {
   opens zoo.animal.talks.schedule;
   opens zoo.animal.talks.media to zoo.staff;
}
```

Первый пример позволяет любому модулю, использующему этот, использовать отражение. Второй пример предоставляет эту 
привилегию только модулю zoo.staff. Есть еще две директивы, которые вам необходимо знать для сдачи экзамена — provides 
и uses, — которые рассматриваются в следующем разделе.

---

_Сценарий реального мира_

**Открытие целого модуля**

В предыдущем примере мы открыли два пакета в модуле zoo.animal.talks, но предположим, что вместо этого мы хотели 
открыть все пакеты для отражения. Без проблем. Мы можем использовать модификатор open module, а не директиву opens 
(обратите внимание на разницу s):

```
open module zoo.animal.talks {
}
```

С помощью этого модификатора модуля Java знает, что мы хотим, чтобы все пакеты в модуле были открыты. Что произойдет, 
если вы примените и то, и другое вместе?

```
open module zoo.animal.talks {
   opens zoo.animal.talks.schedule;  // НЕ КОМПИЛИРУЕТСЯ
}
```

Это не компилируется, поскольку модификатору, использующему модификатор open, не разрешается использовать директиву 
opens. В конце концов, упаковки уже открыты!

---


## Создание сервиса

В этом разделе вы узнаете, как создать службу. Служба состоит из интерфейса, всех классов, на которые ссылается 
интерфейс, и способа поиска реализаций интерфейса. Реализации не являются частью сервиса.

Мы будем использовать туристическое приложение в разделе "Услуги". Он состоит из четырех модулей, показанных на 
рис. 12.13. В этом примере модули zoo.tours.api и zoo.tours.reservations составляют сервис, поскольку они состоят из 
интерфейса и функций поиска.

#### Рис. 12.13 - Модули в приложении tour


_Вам не обязательно иметь четыре отдельных модуля. Мы делаем это, чтобы проиллюстрировать концепции. Например, интерфейс 
поставщика услуг и указатель сервисов могут находиться в одном модуле._

### Объявление интерфейса поставщика услуг

Во-первых, модуль zoo.tours.api определяет Java-объект с именем Souvenir. Он считается частью сервиса, поскольку 
интерфейс будет ссылаться на него.

````
// Souvenir.java 
package zoo.tours.api;

public record Souvenir(String description) { }
````

Далее, модуль содержит тип интерфейса Java. Этот интерфейс называется service provider interface, поскольку он 
определяет, какое поведение будет иметь наш сервис. В данном случае это простой API с тремя методами.

```
// Tour.java 
package zoo.tours.api;

public interface Tour {
   String name();
   int length();
   Souvenir getSouvenir();
}
```

Все три метода используют неявный модификатор public. Поскольку мы работаем с модулями, нам также необходимо создать 
module-info.java файл, таким образом, наше определение модуля экспортирует пакет, содержащий интерфейс.

```
// module-info.java 
module zoo.tours.api {
   exports zoo.tours.api; 
}
```

Теперь, когда у нас есть оба файла, мы можем скомпилировать и упаковать этот модуль.

```
javac -d serviceProviderInterfaceModule
   serviceProviderInterfaceModule/zoo/tours/api/*.java
   serviceProviderInterfaceModule/module-info.java
   
jar -cvf mods/zoo.tours.api.jar -C serviceProviderInterfaceModule/ .
```

_“Интерфейс” поставщика услуг может быть классом abstract, а не реальным интерфейсом. Поскольку на экзамене вы увидите 
его только как интерфейс, мы используем этот термин в книге._

Для ознакомления служба включает в себя интерфейс поставщика услуг и вспомогательные классы, на которые она ссылается. 
Сервис также включает в себя функциональность поиска, которую мы определим далее.

### Создание локатора сервисов

Для завершения нашего сервиса нам нужен локатор сервисов. Локатор сервисов (service locator) может найти любые классы, 
реализующие интерфейс поставщика сервисов.

К счастью, Java предоставляет класс ServiceLoader, который помогает справиться с этой задачей. Вы передаете тип 
интерфейса поставщика услуг в его метод load(), и Java вернет все службы реализации, которые сможет найти. Следующий 
класс показывает это в действии:

```
// TourFinder.java 
package zoo.tours.reservations;

import java.util.*; 
import zoo.tours.api.*;

public class TourFinder {

   public static Tour findSingleTour() {
      ServiceLoader<Tour> loader = ServiceLoader.load(Tour.class);
      for (Tour tour : loader)
         return tour;
      return null;
   }
   public static List<Tour> findAllTours() {
      List<Tour> tours = new ArrayList<>();
      ServiceLoader<Tour> loader = ServiceLoader.load(Tour.class);
      for (Tour tour : loader)
         tours.add(tour);
      return tours;
   }
]
```

Как видите, мы предоставили два метода поиска. Первый — удобный метод, если вы ожидаете, что будет возвращен ровно один 
тур. Другой возвращает List, включающий любое количество поставщиков услуг. Во время выполнения локатор служб может 
найти множество поставщиков услуг (или ни одного).

_Вызов ServiceLoader относительно дорог. Если вы пишете настоящее приложение, лучше всего кэшировать результат._

Наше определение модуля экспортирует пакет с помощью класса поиска TourFinder. Для этого требуется пакет интерфейса 
поставщика услуг. Он также имеет директиву uses, поскольку он будет искать службу.

```
// module-info.java 
module zoo.tours.reservations {
   exports zoo.tours.reservations;
   requires zoo.tours.api;
   uses zoo.tours.api.Tour;
}
```

Помните, что необходимы как requires, так и uses: один для компиляции, другой для поиска. Наконец, мы 
компилируем и упаковываем модуль.

```
javac -p mods -d serviceLocatorModule
   serviceLocatorModule/zoo/tours/reservations/*.java
   serviceLocatorModule/module-info.java
   
jar -cvf mods/zoo.tours.reservations.jar -C serviceLocatorModule/ .
```

Теперь, когда у нас есть interface и логика поиска, мы завершили работу над нашим сервисом.

---

**Использование ServiceLoader**

В ServiceLoader есть два метода, которые вам необходимо знать для экзамена. Декларация выглядит следующим образом, без 
полной реализации:

```
public final class ServiceLoader<S> implements Iterable<S> {

   public static <S> ServiceLoader<S> load(Class<S> service) { ... }
   
   public Stream<Provider<S>> stream() { ... }
   
   // Additional methods
}
```

Как мы уже видели, вызов ServiceLoader.load() возвращает объект, который вы можете обработать в обычном цикле. Однако 
запрос Stream дает вам другой тип. Причина этого в том, что Stream контролирует, когда оцениваются элементы. Таким 
образом, ServiceLoader возвращает Stream объектов Provider. Вам нужно вызвать get(), чтобы получить желаемое значение 
от каждого Provider, как в этом примере:

```
ServiceLoader.load(Tour.class)
  .stream()
  .map(Provider::get)
  .mapToInt(Tour::length)
  .max()
  .ifPresent(System.out::println);
```

---

### Вызов от Consumer

Следующим шагом является вызов локатора службы потребителем. Потребитель (consumer) (или клиент(client)) 
относится к модулю, который получает и использует услугу. Как только потребитель получил услугу через локатор служб, он 
может вызывать методы, предоставляемые интерфейсом поставщика услуг.

```
// Tourist.java 
package zoo.visitor;

import java.util.*; 
import zoo.tours.api.*; 
import zoo.tours.reservations.*;

public class Tourist {
   public static void main(String[] args) {
      Tour tour = TourFinder.findSingleTour();
      System.out.println("Single tour: " + tour);
      
      List<Tour> tours = TourFinder.findAllTours();
      System.out.println("# tours: " + tours.size());
   }
}
```

Нашему определению модуля не нужно ничего знать о реализациях, поскольку поиск выполняет модуль zoo.tours.reservations.

```
// module-info.java 
module zoo.visitor {
   requires zoo.tours.api;
   requires zoo.tours.reservations;
}
```

На этот раз нам предстоит запустить программу после компиляции и упаковки.

```
javac -p mods -d consumerModule
   consumerModule/zoo/visitor/*.java consumerModule/module-info.java
   
jar -cvf mods/zoo.visitor.jar -C consumerModule/ .

java -p mods -m zoo.visitor/zoo.visitor.Tourist
```

Программа выводит следующее:

```
Single tour: null 
# tours: 0
```

Что ж, это имеет смысл. Мы еще не написали класс, реализующий интерфейс.

### Добавление Service Provider

Поставщик услуг (service provider) — это реализация интерфейса поставщика услуг. Как мы говорили ранее, во время 
выполнения возможно иметь несколько классов реализации или модулей. Для простоты мы остановимся здесь на одном.

Нашим поставщиком услуг является пакет zoo.tours.agency, поскольку мы передали организацию туров третьей стороне.

```
// TourImpl.java 
package zoo.tours.agency;

import zoo.tours.api.*;

public class TourImpl implements Tour {
   public String name() {
      return "Behind the Scenes";   
   }
   public int length() {
      return 120;
   }
   public Souvenir getSouvenir() {
      return new Souvenir("stuffed animal");
   }
}
```

Опять же, для создания модуля нам нужен файл module-info.java.

```
// module-info.java 
module zoo.tours.agency {
   requires zoo.tours.api;
   provides zoo.tours.api.Tour with zoo.tours.agency.TourImpl;
]
```

Объявление модуля требует, чтобы модуль, содержащий интерфейс, был зависимостью. Мы не экспортируем пакет, реализующий 
интерфейс, поскольку не хотим, чтобы вызывающие абоненты обращались к нему напрямую. Вместо этого мы используем 
директиву provides. Это позволяет нам указать, что мы предоставляем реализацию интерфейса с определенным классом 
реализации. Синтаксис выглядит следующим образом:

```
provides interfaceName with className;
```

_Мы не экспортировали пакет, содержащий реализацию. Вместо этого мы сделали реализацию доступной поставщику услуг, 
использующему интерфейс._

Наконец, мы компилируем его и упаковываем.

```
javac -p mods -d serviceProviderModule
   serviceProviderModule/zoo/tours/agency/*.java
   serviceProviderModule/module-info.java
jar -cvf mods/zoo.tours.agency.jar -C serviceProviderModule/ .
```

Теперь самое интересное. Мы можем снова запустить программу Java.

```
java -p mods -m zoo.visitor/zoo.visitor.Tourist
```

На этот раз мы видим следующий результат:

```
Single tour: zoo.tours.agency.TourImpl@1936f0f5
# tours: 1
```

Обратите внимание, что мы не перекомпилировали пакеты zoo.tours.reservations или zoo.visitor. Локатор сервисов смог 
обнаружить, что теперь доступна реализация поставщика услуг, и найти ее для нас.

Это полезно, когда у вас есть функциональность, которая меняется независимо от остальной части базы кода. Например, у 
вас могут быть собственные отчеты или ведение журналов.

_В разработке программного обеспечения концепция разделения различных компонентов на автономные части называется слабой 
связью. Одним из преимуществ слабосвязанного кода является то, что его можно легко заменить или заменить с минимальными 
(или нулевыми) изменениями в коде, который его использует. Использование слабосвязанной структуры позволяет легко 
расширять сервисные модули во время выполнения._

### Обзор директив и сервисов

В таблице 12.4 обобщено то, что мы рассмотрели в разделе о сервисах. Мы рекомендуем хорошо изучить, что нужно, когда 
каждый артефакт находится в отдельном модуле. Скорее всего, это то, что вы увидите на экзамене, и оно обеспечит 
понимание концепций. В Таблице 12.5 перечислены все директивы, которые вам необходимо знать для сдачи экзамена.

#### Таблица 12.4 - Обзор сервисов

|           Артефакт            | Часть сервиса |        Требуются директивы        |  
|:-----------------------------:|:-------------:|:---------------------------------:|
| Интерфейс поставщика сервисов |      Да       |              exports              |
|        Поставщик услуг        |      Нет      |      requires <br/> provides      |
|        Поиск сервисов         |      Да       | exports <br/> requires <br/> uses |
|         Потребитель           |     Нет       |             requires              |

#### Таблица 12.5 - Обзор директив 

|                      Директива                      |                 Описание                  |  
|:---------------------------------------------------:|:-----------------------------------------:|
| exports package; <br/>  exports package to module;  |     Делает пакет доступным вне модуля     |
| requires module; <br/>  requires transitive module; |  Указывает другой модуль как зависимость  |
|    opens package; <br/> opens package to module;    | Позволяет использовать пакет с отражением |
|      provides serviceInterface with implName;       |          Делает услугу доступной          |
|               uses serviceInterface;                |            Справочная служба              |


## Поиск модулей

До сих пор мы работали с написанными нами модулями. Даже классы, встроенные в JDK, являются модульными. В этом разделе 
мы покажем вам, как использовать команды для изучения модулей.

Вам не обязательно знать вывод команд в этом разделе. Однако вам необходимо знать синтаксис команд и то, что они делают. 
Мы включаем выходные данные там, где это облегчает запоминание того, что происходит. Но вам не нужно это запоминать 
(что освобождает больше места в вашей голове для запоминания параметров командной строки).

### Идентификация встроенных модулей

Самый важный модуль, который нужно знать, — это java.base. Он содержит большинство пакетов, которые вы изучали для 
экзамена. На самом деле, это настолько важно, что вам даже не нужно использовать директиву requires; он доступен для 
всех модульных приложений. Ваш файл module-info.java все равно будет скомпилирован, если вам явно требуется java.base. 
Однако это избыточно, поэтому лучше его опустить. В таблице 12.6 перечислены некоторые распространенные модули и их 
содержимое.

#### Таблица 12.6 - Общие модули

|  Имя модуля  |                        Что он содержит                        |            Покрытие в книге            |  
|:------------:|:-------------------------------------------------------------:|:--------------------------------------:|
|  java.base   | Коллекции, математика, ввод-вывод, NIO.2, параллелизм и т. д. |        Большая часть этой книги        |
| java.desktop |     Абстрактный набор инструментов Windows (AWT) и Swing      | Не на экзамене, кроме названия модуля  |
| java.logging |                        Ведение журнала                        | Не на экзамене, кроме названия модуля  |
|   java.sql   |                             JDBC                              |            Глава 15, “JDBC”            |
|  java.xml    |               Расширяемый язык разметки  (XML)                | Не на экзамене, кроме названия модуля  |


Создатели экзамена считают важным распознавать названия модулей, поставляемых JDK. Хотя вам не обязательно знать имена 
наизусть, вам нужно уметь выбирать их из состава.

Для сдачи экзамена вам необходимо знать, что имена модулей начинаются с java для API, которые вы, вероятно, будете 
использовать, и с jdk для API, специфичных для JDK. В таблице 12.7 перечислены все модули, имена которых начинаются с 
java.

#### Таблица 12.7 - Модули Java с префиксом java

|                      |                     |                     |  
|:--------------------:|:-------------------:|:-------------------:|
|      java.base       |     java.naming     |  java.smartcardio   |
|    java.compiler     |    java.net.http    |      java.sql       |
|  java.datatransfer   |     java.prefs      |   java.sql.rowset   |
|     java.desktop     |      java.rmi       | java.transaction.xa |
|   java.instrument    |   java.scripting    |      java.xml       |
|     java.logging     |       java.se       |  java.xml.crypto    |
|   java.management    | java.security.jgss  |                     |
| java.management.rmi  | java.security.sasl  |                     |


В таблице 12.8 перечислены все модули, имена которых начинаются с jdk. Мы рекомендуем просмотреть их прямо перед 
экзаменом, чтобы повысить вероятность того, что они покажутся вам знакомыми. Помните, что вам не обязательно их 
запоминать.

#### Таблица 12.8 - Модули Java с префиксом jdk

|                       |                 |                      |  
|:---------------------:|:---------------:|:--------------------:|
|   jdk.accessiblity    |   jdk.javadoc   | jdk.management.agent |
|      jdk.attach       |    jdk.jcmd     |  jdk.management.jfr  |
|     jdk.charsets      |  jdk.jconsole   |    jdk.naming.dns    |
|     jdk.compiler      |    jdk.jdeps    |    jdk.naming.rmi    |
|  jdk.crypto.cryptoki  |     jdk.jdi     |       jdk.net        |
|     jdk.crypto.ec     | jdk.jdwp.agent  |   jdk.nio.mapmode    |
|     jdk.dynalink      |     jdk.jfr     |       jdk.sctp       |
|      jdk.editpad      |    jdk.jlink    |  jdk.security.auth   |
|   jdk.hotspot.agent   |   jdk.jshell    |  jdk.security.jgss   |
|    jdk.httpserver     |  jdk.jsobject   |     jdk.xml.dom      |
| jdk.incubator.foreign |   jdk.jstatd    |      jdk.zipfs       |
| jdk.incubator.vector  | jdk.localedata  |                      |
|     jdk.jartool       | jdk.management  |                      |


### Получение деталей с помощью Java

Команда java имеет три параметра, связанных с модулем. Один описывает модуль, другой перечисляет доступные модули, а 
третий показывает логику разрешения модуля.

_Также можно добавлять модули, экспорт и многое другое из командной строки. Но, пожалуйста, не надо. Это сбивает с 
толку и трудно поддерживать. Обратите внимание, что эти флаги доступны в Java, но не для всех команд._

#### Описание модуля

Предположим, вам предоставлен JAR-файл модуля zoo.animal.feeding и вы хотите узнать о структуре его модуля. Вы можете 
«разархивировать» его и открыть файл module-info.java. Это покажет вам, что модуль экспортирует один пакет и явно не 
требует каких-либо модулей.

```
module zoo.animal.feeding {
   exports zoo.animal.feeding;
}
```

Однако есть более простой способ. Команда java имеет возможность описать модуль. Следующие две команды эквивалентны:

```
java -p mods
   -d zoo.animal.feeding
   
java -p mods
   --describe-module zoo.animal.feeding
```

Каждый печатает информацию о модуле. Например, он может напечатать это:

```
zoo.animal.feeding file:///absolutePath/mods/zoo.animal.feeding.jar
exports zoo.animal.feeding
requires java.base mandated
```

Первая строка — это модуль, о котором мы спрашивали: zoo.animal.feeding. Вторая строка начинается с информации о модуле. 
В нашем случае это тот же оператор exports пакета, который был в файле объявления модуля.

В третьей строке мы видим использование requires java.base. Теперь, подожди минутку. В объявлении модуля совершенно 
четко не указаны какие-либо модули, которые zoo.animal.feeding имеет в качестве зависимостей.

Помните, что модуль java.base особенный. Он автоматически добавляется как зависимость ко всем модулям. В этом модуле 
часто используются такие пакеты, как java.util. В этом и заключается мандат. Вы получаете java.base независимо от того, 
просили ли вы об этом.

В классах пакет java.lang импортируется автоматически независимо от того, вводите вы его или нет. Модуль java.base 
работает таким же образом. Он автоматически доступен для всех остальных модулей.

---

**Подробнее об описании модулей**

Вам нужно только знать, как запустить --describe-module для экзамена, а не интерпретировать выходные данные. 
Однако при экспериментировании с этой функцией вы можете столкнуться с некоторыми сюрпризами, поэтому мы опишем их 
здесь более подробно.

Предположим, что следующее содержимое module-info.java в zoo.animal.care:

```
module zoo.animal.care {
   exports zoo.animal.care.medical to zoo.staff;
   requires transitive zoo.animal.feeding;
}
```

Теперь у нас есть команда для описания модуля и вывода.

```
java -p mods -d zoo.animal.care

zoo.animal.care file:///absolutePath/mods/zoo.animal.care.jar
requires zoo.animal.feeding transitive
requires java.base mandated
qualified exports zoo.animal.care.medical to zoo.staff
contains zoo.animal.care.details
```

Первая строка выходных данных - это абсолютный путь к файлу модуля. Две строки requires также должны выглядеть знакомо. 
Первый находится в module-info, а другой добавляется ко всем модулям. Далее следует что-то новое. qualified exports  - 
это полное название пакета, который мы экспортируем в определенный модуль.

Наконец, contains означает, что в модуле есть пакет, который вообще не экспортируется. Это правда. Наш модуль имеет два 
пакета, и один доступен только для кода внутри модуля.

---

#### Список доступных модулей

В дополнение к описанию модулей, вы можете использовать команду java для составления списка доступных модулей. В 
простейшей форме перечислены модули, которые являются частью JDK.

```
java  --list-modules
```

Когда мы запустили его, вывод продолжался в течение 70 строк и выглядел следующим образом:

```
java.base@17
java.compiler@17
java.datatransfer@17
```

Это список всех модулей, поставляемых с Java, и номеров их версий. Вы можете сказать, что при тестировании этого 
примера мы использовали Java 17.

Что еще интереснее, вы можете использовать эту команду с собственным кодом. Давайте попробуем еще раз с каталогом, 
содержащим наши модули зоопарка.

```
java -p mods --list-modules
```

Сколько строк вы ожидаете получить в выводе на этот раз? Сейчас 78 строк: 70 встроенных модулей плюс 8, которые мы 
создали в этой главе. Две пользовательские строки выглядят следующим образом:

```
zoo.animal.care file:///absolutePath/mods/zoo.animal.care.jar
zoo.animal.feeding file:///absolutePath/mods/zoo.animal.feeding.jar
```

Поскольку это кастомные модули, мы получаем расположение в файловой системе. Если бы в проекте был номер версии модуля, 
он бы имел и номер версии, и путь к файловой системе.

_Обратите внимание, что --list-modules завершает работу, как только печатает наблюдаемые модули. 
Программа не запускается._

### Отображение разрешения модуля

Если перечисление модулей не дает достаточного результата, вы также можете использовать опцию --show-module-solve. 
Вы можете думать об этом как о способе отладки модулей. При запуске программы он выдает много вывода. Затем он 
запускает программу.

```
java --show-module-resolution
   -p feeding
   -m zoo.animal.feeding/zoo.animal.feeding.Task
```

К счастью, вам не нужно понимать этот вывод. Тем не менее, увидев это, вам будет легче запомнить. Вот фрагмент вывода:

```
root zoo.animal.feeding file:///absolutePath/feeding/
java.base binds java.desktop jrt:/java.desktop
java.base binds jdk.jartool jrt:/jdk.jartool
...
jdk.security.auth requires java.naming jrt:/java.naming
jdk.security.auth requires java.security.jgss jrt:/java.security.jgss
...
All fed!
```

Он начинается с перечисления корневого модуля. Это тот, который мы запускаем:zoo.animal.feeding. Затем он перечисляет 
множество строк пакетов, включенных в обязательный модуль java.base. Через некоторое время он перечисляет модули, 
имеющие зависимости. Наконец, программа выводит результат: All fed!.

### Описание с помощью jar

Как и команда java, команда jar может описывать модуль. Эти команды эквивалентны:

```
jar -f mods/zoo.animal.feeding.jar -d
jar --file mods/zoo.animal.feeding.jar --describe-module
```

Вывод немного отличается от того, когда мы использовали команду java для описания модуля. С jar он выводит следующее:

```
zoo.animal.feeding jar:file:///absolutePath/mods/zoo.animal.feeding.jar
/!module-info.class
exports zoo.animal.feeding
requires java.base mandated
```

Версия JAR включает в имя файла module-info.class, что не является особенно существенной разницей в схеме вещей. Вам не 
обязательно знать эту разницу. Вам нужно знать, что обе команды могут описывать модуль.

### Изучение зависимостей с помощью jdeps

Команда jdeps предоставляет информацию о зависимостях внутри модуля. В отличие от описания модуля, помимо объявления 
модуля он рассматривает код. Это говорит вам, какие зависимости фактически используются, а не просто объявляются. К 
счастью, от вас не требуется запоминать все варианты экзамена.

Ожидается, что вы поймете, как использовать jdeps с проектами, которые еще не были модульными, чтобы помочь в выявлении 
зависимостей и проблем. Сначала мы создадим JAR-файл из этого класса. Если вы следуете инструкциям, не стесняйтесь 
скопировать класс из онлайн-примеров, упомянутых в начале главы, а не вводить его.

```
// Animatronic.java 
package zoo.dinos;

import java.time.*;
import java.util.*;
import sun.misc.Unsafe;

public class Animatronic {
    private List<String> names;
    private LocalDate visitDate;
    
    public Animatronic(List<String> names, LocalDate visitDate) {
       this.names = names;
       this.visitDate = visitDate;
    }
    public void unsafeMethod() {
        Unsafe unsafe = Unsafe.getUnsafe();
    }
}
```

Это глупый пример. Он использует ряд несвязанных классов. В зоопарке Бронкса действительно какое-то время были 
электронные движущиеся динозавры, так что, по крайней мере, идея иметь динозавров в зоопарке не выходит за рамки 
возможного.

Теперь мы можем скомпилировать этот файл. Возможно, вы заметили, что файла module-info.java нет. Это потому, что мы не 
создаем модуль. Мы изучаем, какие зависимости нам понадобятся, когда мы будем модулировать этот JAR.

```
javac zoo/dinos/*.java
```

Компиляция работает, но выдает некоторые предупреждения о том, что Unsafe является внутренним API. Пока не беспокойтесь 
об этом — мы обсудим это в ближайшее время. (Возможно, динозавры вымерли, потому что сделали что-то небезопасное.)

Далее мы создаем JAR-файл.

```
jar -cvf zoo.dino.jar .
```

Мы можем запустить команду jdeps для этого JAR, чтобы узнать о его зависимостях. Сначала давайте запустим команду без 
каких-либо параметров. В первых двух строках команда печатает модули, которые нам нужно будет добавить с помощью 
директивы requires для перехода в систему модулей. Он также печатает таблицу, показывающую, какие пакеты используются и 
каким модулям они соответствуют.

```
jdeps zoo.dino.jar

zoo.dino.jar -> java.base
zoo.dino.jar -> jdk.unsupported
   zoo.dinos    -> java.lang       java.base
   zoo.dinos    -> java.time       java.base
   zoo.dinos    -> java.util       java.base
   zoo.dinos    -> sun.misc        JDK internal API (jdk.unsupported)
```

Обратите внимание, что java.base всегда включен. Там также указано, какие модули содержат классы, используемые JAR. 
Если мы запустим сводный режим, мы увидим только первую часть, где jdeps перечисляет модули. Существует два формата 
сводного флага:

```
jdeps -s zoo.dino.jar
jdeps -summary zoo.dino.jar

zoo.dino.jar -> java.base
zoo.dino.jar -> jdk.unsupported
```

Для реального проекта список зависимостей может включать десятки или даже сотни пакетов. Полезно просмотреть сводку 
только по модулям. Этот подход также упрощает проверку наличия jdk.unsupported в списке.

Существует также опция --module-path, которую вы можете использовать, если хотите искать модули вне JDK. В отличие от 
других команд, в jdeps для этой опции нет краткой формы.

_Возможно, вы заметили, что jdk.unsupported нет в списке модулей, который вы видели в таблице 12.8. Он особенный, 
поскольку содержит внутреннюю библиотеку, которую разработчикам предыдущих версий Java не уделяли внимания, хотя многие 
люди проигнорировали это предупреждение. Не следует ссылаться на него, поскольку он может исчезнуть в последующих 
версиях Java._

### Использование флага --jdk-internals

Команда jdeps имеет возможность предоставить подробную информацию об этих неподдерживаемых API. Вывод выглядит 
примерно так:

```
jdeps --jdk-internals zoo.dino.jar

zoo.dino.jar -> jdk.unsupported
   zoo.dinos.Animatronic  -> sun.misc.Unsafe
      JDK internal API (jdk.unsupported)

Warning: <omitted warning>

JDK Internal API      Suggested Replacement
________________      _____________________
sun.misc.Unsafe       See http://openjdk.java.net/jeps/260
```

Опция --jdk-internals перечисляет все используемые вами классы, которые вызывают внутренний API, а также какой API. В 
конце представлена таблица, предлагающая, что с этим делать. Если вы написали код, вызывающий внутренний API, это 
сообщение будет полезным. В противном случае сообщение будет полезно команде, написавшей код. С другой стороны, вам 
может потребоваться обновить или полностью заменить этот JAR-файл файлом, который устраняет проблему. Обратите внимание, 
что -jdkinternals эквивалентен --jdk-internals.

---

**Сценарий реального мира**

**О sun.misc.Unsafe**

До появления системы модулей платформы Java классы должны были быть общедоступными, если вы хотели, чтобы они 
использовались вне пакета. Было разумно использовать этот класс в коде JDK, поскольку это низкоуровневый код, который 
уже тесно связан с JDK. Поскольку он был необходим в нескольких пакетах, класс был опубликован. Sun даже назвала его 
Unsafe, полагая, что это предотвратит его использование кем-либо за пределами JDK.

Однако разработчики поступили умно и использовали этот класс, поскольку он был доступен. Ряд широко используемых 
библиотек с открытым исходным кодом начали использовать Unsafe. Хотя маловероятно, что вы используете этот класс 
напрямую в своем проекте, вы, вероятно, используете библиотеку с открытым исходным кодом, которая его использует.

Команда jdeps позволяет вам просмотреть эти JAR-файлы и определить, возникнут ли у вас какие-либо проблемы, когда Oracle 
наконец запретит использование этого класса. Если вы найдете какое-либо применение, вы можете посмотреть, существует 
ли более поздняя версия JAR, до которой можно обновиться.

---

### Использование файлов модулей с jmod

Последняя команда, которую вам нужно знать на экзамене, — это jmod. Вы можете подумать, что файл JMOD — это файл модуля 
Java. Не совсем. Oracle рекомендует использовать файлы JAR для большинства модулей. Файлы JMOD рекомендуется 
использовать только в том случае, если у вас есть собственные библиотеки или что-то, что не может быть помещено в файл 
JAR. Вряд ли это повлияет на вас в реальном мире.

Самое важное, что следует помнить, это то, что jmod предназначен только для работы с файлами JMOD. Удобно, что вам не 
нужно запоминать синтаксис jmod. В Таблице 12.9 перечислены общие режимы.

#### Таблица 12.9 - Режимы, использующие jmod

| Операция |                          Описание                           |  
|:--------:|:-----------------------------------------------------------:|
|  create  |                     Создает файл JMOD.                      |
| extract  | Извлекает все файлы из JMOD. Работает как разархивирование. |
| describe |      Печатает сведения о модуле, например, requires .       |
|   list   |             Перечисляет все файлы в файле JMOD.             |
|  hash    |               Печатает или записывает хэши.                 |


### Создание среды выполнения Java с помощью jlink

Одним из преимуществ модулей является возможность предоставить только те части Java, которые вам нужны. В нашем примере 
с зоопарком из начала главы не так уж много зависимостей. Если у пользователя еще нет Java или он использует устройство 
с небольшим объемом памяти, загрузка JDK размером более 150 МБ является большой проблемой. Давайте посмотрим, насколько 
большой на самом деле должна быть упаковка! Эта команда создает наш меньший дистрибутив:

```
jlink --module-path mods --add-modules zoo.animal.talks --output zooApp
```

Сначала мы указываем, где найти пользовательские модули, с помощью -p или --module-path. Затем мы указываем имена наших 
модулей с помощью --add-modules. Сюда будут включены необходимые зависимости, если их можно найти. Наконец, мы указываем 
имя папки нашего меньшего JDK с помощью --output.

Выходной каталог содержит каталоги bin, conf, include, legal, lib и man, а также файл выпуска. Они должны выглядеть 
знакомо, поскольку вы найдете их и в полной версии JDK.

Когда мы запустим эту команду и заархивируем каталог zooApp, размер файла составит всего 15 МБ. Это на порядок меньше, 
чем полный JDK. Откуда такая экономия места? В JDK есть много модулей, которые нам не нужны. Кроме того, такие 
инструменты разработки, как javac, не обязательно должны находиться в дистрибутиве среды выполнения.

Для настройки этого процесса существует гораздо больше элементов, которые вам не нужно знать для сдачи экзамена. 
Например, вы можете пропустить создание справочной документации и сэкономить еще больше места.

### Обзор параметров командной строки

В этом разделе представлен ряд таблиц, в которых описывается все, что вам нужно знать о запуске параметров командной 
строки для экзамена.

В таблице 12.10 показаны операции командной строки, с которыми вам следует столкнуться на экзамене. В документации есть 
еще много вариантов. Например, в javac есть опция --module, которая ограничивает компиляцию этим модулем. К счастью, вам 
не обязательно знать их для экзамена.

#### Таблица 12.10 - Сравнение операций командной строки

|           Описание            |                                                                                      Синтаксис                                                                                      |  
|:-----------------------------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Скомпилируйте немодульный код |  javac -cp classpath -d directory classesToCompile <br/> javac --class-path classpath -d directory classesToCompile <br/> javac -classpath classpath -d directory classesToCompile  |
|   Запуск немодульного кода    |                     java -cp classpath package.className <br/> java -classpath classpath package.className <br/> java --class-path  classpath package.className                     |
|     Компилировать модуль      |       javac -p moduleFolderName -d directory classesToCompileIncludingModuleInfo <br/> javac --module-path  moduleFolderName -d directory classesToCompileIncludingModuleInfo       |
|       Запустить модуль        |                      java -p  moduleFolderName -m moduleName/package.className <br/> java --module-path moduleFolderName --module moduleName/package.className                      |
|        Описать модуль         |  java -p moduleFolderName -d moduleName <br/> java --module-path moduleFolderName --describe-module moduleName <br/> jar --file jarName  --describe-module <br/> jar -f jarName -d  |
|     Просмотр зависимостей     | jdeps -summary --module-path moduleFolderName jarName <br/> jdeps -s --module-path moduleFolderName jarName <br/>  jdeps --jdk-internals jarName <br/>  jdeps -jdkinternals jarName |
|  Показать разрешение модуля   |               java --show-module-resolution -p moduleFolderName -m moduleName <br/> java --show-module-resolution --module-path moduleFolderName --module moduleName                |
| Создать JAR среды выполнения  |              jlink -p moduleFolderName  --add-modules moduleName --output zooApp <br/> jlink --module-path  moduleFolderName --add-modules moduleName --output zooApp               |


В таблице 12.11 показаны параметры javac, в таблице 12.12 показаны параметры Java, в таблице 12.13 показаны параметры 
jar, а в таблице 12.14 показаны параметры jdeps. Наконец, в таблице 12.15 показаны параметры jlink.

#### Таблица 12.11 - Опции, которые нужно знать для экзамена: javac

|                                   Вариант                                    |                              Описание                              |  
|:----------------------------------------------------------------------------:|:------------------------------------------------------------------:|
| -cp <classpath> <br/> -classpath <classpath> <br/> --class-path  <classpath> |          Расположение JAR-файлов в немодульной программе           |
|                                   -d <dir>                                   | Каталог, в котором можно разместить сгенерированные файлы классов. | 
|                    -p <path> <br/> --module-path <path>                      |           Расположение JAR-файлов в модульной программе            |

#### Таблица 12.12 - Опции, которые нужно знать для экзамена: java

|                Вариант                |                       Описание                        |  
|:-------------------------------------:|:-----------------------------------------------------:|
| -p <path> <br/>  --module-path <path> |     Расположение JAR-файлов в модульной программе     |
|    -m <name> <br/> --module <name>    |                Имя модуля для запуска                 |
|      -d <br/>  --describe-module      |                Описывает детали модуля                |
|            --list-modules             | Перечисляет наблюдаемые модули без запуска программы. |
|       --show-module-resolution        |       Показывает модули при запуске программы         |


#### Таблица 12.13 - Опции, которые нужно знать для экзамена: jar

|           Вариант           |                                 Описание                                 |  
|:---------------------------:|:------------------------------------------------------------------------:|
|      -c <br/> --create      |                          Создает новый файл JAR                          |
|     -v <br/> --verbose      |                 Печатает детали при работе с файлами JAR                 |
|       -f <br/> --file       |                              имя JAR-файла                               |
|             -C              | Каталог, содержащий файлы, которые будут использоваться для создания JAR |
| -d <br/> --describe-module  |                         Описывает детали модуля                          |

#### Таблица 12.14 - Опции, которые нужно знать для экзамена: jdeps

|                Вариант                |                   Описание                    |  
|:-------------------------------------:|:---------------------------------------------:|
|         --module-path  <path>         | Расположение JAR-файлов в модульной программе |
|          -s  <br/> -summary           |           Обобщает выходные данные            |
| --jdk-internals  <br/> -jdkinternals  |  Перечисляет использование внутренних API.    |

#### Таблица 12.15 - Опции, которые нужно знать для экзамена: jlink

|            Вариант            |                   Описание                    |  
|:-----------------------------:|:---------------------------------------------:|
| -p <br/> --module-path <path> | Расположение JAR-файлов в модульной программе |
|         --add-modules         |          Список модулей для упаковки          |
|           --output            |            Имя выходного каталога             |

 
## Сравнение типов модулей

Все модули, которые мы использовали до сих пор в этой главе, называются именованными модулями. Есть еще два типа 
модулей: автоматические модули и безымянные модули. В этом разделе мы опишем эти три типа модулей. На экзамене вам 
нужно будет их сравнить.

### Именованные модули

Именованный модуль — это модуль, содержащий файл module-info.java. Для просмотра этот файл отображается в корне JAR 
рядом с одним или несколькими пакетами. Если не указано иное, модуль является именованным модулем. Именованные модули 
отображаются в пути к модулю, а не в пути к классам. Позже вы узнаете, что произойдет, если JAR-файл, содержащий файл 
module-info.java, находится в пути к классам. А пока просто знайте, что он не считается именованным модулем, поскольку 
его нет в пути к модулю.

Чтобы запомнить это, именованный модуль имеет имя внутри файла module-info.java и находится в пути к модулю.

_Помните из главы 7 «За пределами классов», что единственный способ для подклассов запечатанных классов находиться в 
другом пакете — это находиться в одном и том же модуле._

### Автоматические модули

Автоматический модуль появляется на пути к модулю, но не содержит файла module-info.java. Это просто обычный JAR-файл, 
который помещается в путь к модулю и рассматривается как модуль.

Чтобы запомнить это, Java автоматически определяет имя модуля. Код, ссылающийся на автоматический модуль, обрабатывает 
его так, как будто существует файл module-info.java. Он автоматически экспортирует все пакеты. Он также определяет имя 
модуля. Вы спросите, как он определяет имя модуля? Отличный вопрос.

Чтобы ответить на этот вопрос, нам нужно рассказать немного истории о файлах JAR и внедрении модулей. Каждый файл JAR 
содержит специальную папку META-INF и текстовый файл MANIFEST.MF внутри нее. Он может быть создан автоматически при 
создании JAR или вручную автором JAR. Возвращаясь к модулям, многие библиотеки Java были еще не совсем готовы к 
модульности, когда эта функция была введена. Авторам было предложено объявить имя, которое они намеревались 
использовать для модуля, добавив свойство с именем Automatic-Module-Name в свой файл MANIFEST.MF.

---

**О файле MANIFEST.MF**

Файл JAR содержит специальный текстовый файл META-INF/MANIFEST.MF, содержащий информацию о JAR. Он существует 
значительно дольше, чем модули — точнее, с первых дней существования Java и JAR. На рисунке показано, как 
манифест вписывается в структуру каталогов файла JAR.

**_вставить рисунок!_**

Манифест содержит дополнительную информацию о файле JAR. Например, он часто содержит версию Java, использованную для 
создания файла JAR. Для программ командной строки обычно указывается класс с методом main().

Каждая строка манифеста представляет собой пару ключ/значение, разделенную двоеточием. Вы можете думать о манифесте как 
о карте имен и значений свойств. Манифест по умолчанию в Java 17 выглядит следующим образом:

```
Manifest-Version: 1.0
Created-By: 17 (Oracle Corporation)
```

---

Указание одного свойства в манифесте позволило поставщикам библиотек упростить работу приложений, которые хотели 
использовать свою библиотеку в модульном приложении. Вы можете думать об этом как об обещании, что, когда библиотека 
станет именованным модулем, она будет использовать указанное имя модуля.

Если в файле JAR не указано автоматическое имя модуля, Java все равно позволит вам использовать его в пути к модулю. В 
этом случае Java определит имя модуля за вас. Мы бы сказали, что это происходит автоматически, но шутка, вероятно, уже 
устарела.

Java автоматически определяет имя модуля, основываясь на имени файла JAR. Давайте рассмотрим правила, начав с примера. 
Предположим, у нас есть JAR-файл с именем holiday-calendar-1.0.0.jar.

Сначала Java удалит расширение .jar из имени. Затем Java удалит версию из конца имени файла JAR. Это важно, поскольку мы 
хотим, чтобы имена модулей были согласованными. Иметь новое имя автоматического модуля каждый раз при обновлении до 
новой версии было бы нехорошо! В конце концов, это заставило бы вас менять объявление модуля вашего красивого, чистого, 
модульного приложения каждый раз, когда вы добавляете более позднюю версию JAR-файла календаря праздников.

Удаление версии и расширения дает нам holiday-calendar. Это оставляет нам проблему. Дефисы (-) в именах модулей не 
допускаются. Java решает эту проблему, преобразуя любые специальные символы в имени в точки (.). В результате имя 
модуля — holiday.calendar. Любые символы, кроме букв и цифр, в этой замене считаются специальными символами. Наконец, 
все соседние точки или ведущие/конечные точки удаляются.

Поскольку правил несколько, рассмотрим алгоритм в виде списка для определения имени автоматического модуля:

+ Если в MANIFEST.MF указано автоматическое имя модуля, используйте его. В противном случае продолжайте следовать остальным правилам.
+ Удалите расширение файла из имени JAR.
+ Удалите всю информацию о версии из конца имени. Версия представляет собой цифры и точки с возможной дополнительной информацией в конце: например, -1.0.0 или -1.0-RC.
+ Замените все оставшиеся символы, кроме букв и цифр, точками.
+ Замените любые последовательности точек одной точкой.
+ Удалите точку, если это первый или последний символ результата.

В таблице 12.16 показано, как применить эти правила к двум примерам, где в манифесте не указано автоматическое имя модуля.

#### Таблица 12.15 - Опции, которые нужно знать для экзамена: jlink

| #   |                                       Описание                                        |            Пример 1            |     Пример 2     |  
|-----|:-------------------------------------------------------------------------------------:|:------------------------------:|:----------------:|
| 1   |                                   Начальное имя JAR                                   | commons2-x-1.0.0-SNAPSHOT .jar |  mod_$-1.0.jar   |
| 2   |                               Удалить расширение файла                                |   commons2-x-1.0.0-SNAPSHOT    |    mod_$-1.0     |
| 3   |                              Удалить информацию о версии                              |           commons2-x           |      mod_$       |
| 4   |                             Заменить специальные символы                              |           commons2.x           |      mod..       |
| 5   |                           Заменить последовательность точек                           |           commons2.x           |       mod.       |
| 6   | Удалить начальные/конечные точки (в результате получается автоматическое имя модуля)  |           commons2.x           |       mod        |


Хотя алгоритм создания автоматических имен модулей делает все возможное, он не всегда может придумать хорошее имя. 
Например, 1.2.0-calendar-1.2.2-good-1.jar не подходит. К счастью, такие имена редки и выходят за рамки экзамена.

### Unnamed Modules
