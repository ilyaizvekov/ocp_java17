# Параллелизм

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Управление параллельным выполнением кода

+ Создавайте рабочие потоки с помощью Runnable и Callable, управляйте жизненным циклом потоков, включая автоматизацию, предоставляемую различными службами Executor и параллельным API.
+ Разрабатывайте потокобезопасный код, используя различные механизмы блокировки и параллельный API.
+ Обработка коллекций Java одновременно, включая использование параллельных потоков.

#### Работа с потоками и лямбда-выражениями

+ Выполнение декомпозиции, конкатенации и сокращения, а также группировки и секционирования в последовательных и параллельных потоках.

---

Как вы узнаете из главы 14 “Ввод-вывод” и главы 15 “JDBC”, компьютеры способны считывать и записывать данные на внешние 
ресурсы. К сожалению, по сравнению с операциями центрального процессора, эти дисковые / сетевые операции, как правило, 
выполняются чрезвычайно медленно — фактически настолько медленно, что если бы операционная система вашего компьютера 
останавливалась и ждала завершения каждой дисковой или сетевой операции, ваш компьютер, казалось бы, постоянно зависал.

К счастью, все операционные системы поддерживают так называемую многопоточную обработку. Идея многопоточной обработки 
заключается в том, чтобы позволить приложению или группе приложений выполнять несколько задач одновременно. Это 
позволяет задачам, ожидающим других ресурсов, уступить место другим запросам на обработку.

В этой главе мы познакомим вас с концепцией потоков и предоставим множество способов управления потоками с помощью 
Concurrency API. Потоки и параллелизм - сложные темы для понимания многими программистами, поскольку проблемы с потоками 
могут расстраивать даже опытных разработчиков. На практике проблемы параллелизма являются одними из наиболее сложных 
для диагностики и устранения.

## Знакомство с потоками

Мы начинаем эту главу с рассмотрения общей терминологии, связанной с потоками. Поток - это наименьшая единица 
выполнения, которая может быть запланирована операционной системой. Процесс - это группа связанных потоков, которые 
выполняются в одной и той же общей среде. Из этого следует, что однопоточный процесс - это процесс, содержащий ровно 
один поток, в то время как многопоточный процесс поддерживает более одного потока.

Под общей средой мы подразумеваем, что потоки в одном и том же процессе совместно используют одно и то же пространство 
памяти и могут напрямую взаимодействовать друг с другом. Ознакомьтесь с рисунком 13.1 для получения общего представления 
о потоках и их общей среде в рамках процесса.

На этом рисунке показан один процесс с тремя потоками. Также показано, как они сопоставляются с произвольным количеством 
процессоров, доступных в системе. Имейте в виду эту схему, когда мы будем обсуждать планировщики задач позже в этом 
разделе.

В этой главе мы много говорим о задачах и их связях с потоками. Задача - это отдельная единица работы, выполняемая 
потоком. На протяжении всей этой главы задача обычно будет реализовываться в виде лямбда-выражения. Поток может 
выполнять несколько независимых задач, но только одну задачу за раз.

#### Рис. 13.1 - Модель процесса


Под разделяемой памятью на рис. 13.1 мы обычно подразумеваем статические переменные, а также переменные экземпляра и 
локальные переменные, передаваемые потоку. Да, вы наконец-то видите, как статические переменные могут быть полезны для 
выполнения сложных многопоточных задач! Помните из главы 5 “Методы”, что статические методы и переменные определены в 
одном объекте класса, который является общим для всех экземпляров. Например, если один поток обновляет значение 
статического объекта, эта информация немедленно становится доступной для чтения другим потокам внутри процесса.

### Понимание параллельности потоков

Свойство одновременного выполнения нескольких потоков и процессов называется параллельностью. Как система решает, что 
выполнять, когда доступно больше потоков, чем процессоров? Операционные системы используют планировщик потоков для 
определения того, какие потоки должны выполняться в данный момент, как показано на рисунке 13.1. Например, планировщик 
потоков может использовать циклическое расписание, в котором каждый доступный поток получает равное количество циклов 
процессора для выполнения, при этом потоки посещаются в циклическом порядке.

Когда выделенное потоку время истекает, но поток не завершил обработку, происходит переключение контекста. Переключение 
контекста - это процесс сохранения текущего состояния потока и последующего восстановления состояния потока для 
продолжения выполнения. Имейте в виду, что затраты часто связаны с переключением контекста из-за потери времени и 
необходимости перезагрузки состояния потока. Интеллектуальные планировщики потоков делают все возможное, чтобы свести к 
минимуму количество переключений контекста, сохраняя при этом бесперебойную работу приложения.

Наконец, поток может прерывать или заменять другой поток, если у него более высокий приоритет, чем у другого потока. 
Приоритет потока - это числовое значение, связанное с потоком, которое принимается во внимание планировщиком потоков при 
определении того, какие потоки должны выполняться в данный момент. В Java приоритеты потоков задаются в виде целых 
значений.

### Создание потока

Одним из наиболее распространенных способов определения задачи для потока является использование экземпляра Runnable. 
Runnable - это функциональный интерфейс, который не принимает аргументов и не возвращает данных.

```
@FunctionalInterface public interface Runnable {
   void run();
}
```

С его помощью легко создать и запустить поток. Фактически, вы можете сделать это в одной строке кода, используя класс 
Thread:

```
new Thread(() -> System.out.print("Hello")).start();
System.out.print("World");
```

Первая строка создает новый объект Thread, а затем запускает его с помощью метода start(). Выводит ли этот код 
HelloWorld или WorldHello? Ответ заключается в том, что мы не знаем. В зависимости от приоритета потока/планировщика 
возможно и то, и другое. Помните, что порядок выполнения потока часто не гарантируется. На экзамене обычно представлены 
вопросы, в которых одновременно запускается несколько заданий, и вы должны определить результат.

Давайте рассмотрим более сложный пример:

```
Runnable printInventory = () -> System.out.println("Printing zoo inventory");
Runnable printRecords = () -> {
   for (int i = 0; i < 3; i++)
      System.out.println("Printing record: " + i);
};
```

Учитывая эти примеры, каков результат следующего?

```
3: System.out.println("begin"); 
4: new Thread(printInventory).start(); 
5: new Thread(printRecords).start(); 
6: new Thread(printInventory).start(); 
7: System.out.println("end");
```

Ответ заключается в том, что это неизвестно до времени выполнения. Ниже приведен только один возможный результат:

```
begin
Printing record: 0 
Printing zoo inventory 
end
Printing record: 1
Printing zoo inventory
Printing record: 2
```

В этом примере используется в общей сложности четыре потока: main() и три дополнительных потока, созданных в строках 
4-6. Каждый поток, созданный в этих строках, выполняется как асинхронная задача. Под асинхронностью мы подразумеваем, 
что поток, выполняющий метод main(), не ожидает результатов каждого вновь созданного потока, прежде чем продолжить. 
Например, строки 5 и 6 могут быть выполнены до завершения потока, созданного в строке 4. Противоположностью такому 
поведению является асинхронная задача, в которой программа ожидает (или блокирует) в строке 4 завершения выполнения 
потока, прежде чем перейти к следующей строке. Подавляющее большинство вызовов методов, используемых в этой книге, 
были синхронными вплоть до этой главы.

В то время как порядок выполнения потоков не определен после запуска потоков, порядок внутри одного потока по-прежнему 
линейный. В частности, цикл for() по-прежнему упорядочен. Кроме того, begin всегда появляется перед end.

---

**Вызов run() вместо start()**

На экзамене помните о коде, который пытается запустить поток, вызывая run() вместо start(). Вызов run() для Thread или 
Runnable не запускает новый поток. Хотя следующие фрагменты кода будут скомпилированы, ни один из них не будет выполнять 
задачу в отдельном потоке:

```
System.out.println("begin");
new Thread(printInventory).run();
new Thread(printRecords).run();
new Thread(printInventory).run();
System.out.println("end");
```

В отличие от предыдущего примера, каждая строка этого кода будет ждать завершения метода run(), прежде чем перейти к 
следующей строке. Кроме того, в отличие от предыдущей программы, выходные данные этого примера кода будут одинаковыми 
при каждом выполнении.

---

В более общем смысле мы можем создать поток и связанную с ним задачу в Java одним из двух способов:

+ Предоставьте объект Runnable или лямбда-выражение конструктору потока.
+ Создайте класс, который расширяет Thread и переопределяет метод run().

На протяжении всей этой книги мы предпочитаем создавать задачи с помощью лямбда-выражений. В конце концов, это намного 
проще, особенно когда мы переходим к Concurrency API! Создание класса, расширяющего Thread, встречается относительно 
редко и должно выполняться только при определенных обстоятельствах, например, если вам нужно перезаписать другие 
методы потоков.

### Отличительные типы потоков

Возможно, вас удивит, что все Java-приложения, включая все те, которые мы представили в этой книге, являются 
многопоточными, поскольку они включают системные потоки. Системный поток создается виртуальной машиной Java (JVM) и 
запускается в фоновом режиме приложения. Например, сборкой мусора управляет системный поток, созданный JVM.

Альтернативно, пользовательский поток - это поток, созданный разработчиком приложения для выполнения определенной 
задачи. Большинство программ, которые мы представили до сих пор, содержали только один пользовательский поток, который 
вызывает метод main(). Для простоты мы обычно называем программы, содержащие только один пользовательский поток, 
однопоточными приложениями.

Системные и пользовательские потоки могут быть созданы как потоки-демоны. Поток демона - это поток, который не будет 
препятствовать выходу JVM после завершения работы программы. Java-приложение завершает работу, когда единственными 
запущенными потоками являются потоки демона. Например, если сборка мусора - единственный оставшийся запущенным поток, 
JVM автоматически завершит работу.

Давайте взглянем на пример. Как вы думаете, что это дает в результате?

```
1:  public class Zoo { 
2:     public static void pause() {                 // Defines the thread task 
3:        try { 
4:           Thread.sleep(10_000);                  // Wait for 10 seconds 
5:        } catch (InterruptedException e) {} 
6:        System.out.println("Thread finished!"); 
7:     }
8:     
9:     public static void main(String[] unused) { 
10:       var job = new Thread(() -> pause());      // Create thread 
11:
12:       job.start();                              // Start thread 
13:       System.out.println("Main method finished!"); 
14:    } }
```

Программа выведет два утверждения с интервалом примерно в 10 секунд:

```
Main method finished!
--- 10 second wait ---
Thread finished!
```

Верно. Несмотря на то, что метод main() выполнен, JVM будет ждать завершения пользовательского потока, прежде чем 
завершать программу. Что, если мы изменим задание на поток демона, добавив это в строку 11?

```
11:       job.setDaemon(true);
```

Программа напечатает первую инструкцию и завершит работу, так и не напечатав вторую строку.

```
Main method finished!
```

Для экзамена просто помните, что по умолчанию пользовательские потоки не являются демонами, и программа будет ждать их 
завершения.

### Управление жизненным циклом потока

После создания поток находится в одном из шести состояний, показанных на рисунке 13.2. Вы можете запросить состояние 
потока, вызвав getState() для объекта потока.

#### Рис. 13.2 - Состояния потока


Каждый поток инициализируется с NEW состоянием. Как только вызывается start(), поток переходит в состояние RUNNABLE. 
Означает ли это, что он действительно работает? Не совсем: может работать, а может и нет. Состояние RUNNABLE просто 
означает, что поток может быть запущен. Как только работа потока завершена или выдано неперехваченное исключение, 
состояние потока становится TERMINATED, и работа больше не выполняется.

Находясь в состоянии RUNNABLE, поток может перейти в одно из трех состояний, в которых он приостанавливает свою работу: 
BLOCKED, WAITING или TIMED_WAITING. На этом рисунке показаны общие переходы между состояниями потока, но есть и другие 
возможности. Например, поток в состоянии WAITING может быть запущен функцией notifyAll(). Аналогично, поток, прерванный 
другим потоком, выйдет из TIMED_WAITING и сразу вернется в RUNNABLE.

В этой главе мы рассмотрим некоторые (но не все) из этих переходов. Некоторые методы, связанные с потоками, такие как 
wait(), notify() и join(), выходят за рамки экзамена и, честно говоря, их сложно использовать. Вам следует избегать их 
и как можно чаще использовать Concurrency API. Чтобы правильно использовать эти методы, требуются большие навыки 
(и немного удачи!)

### Опрос в режиме сна

Несмотря на то, что многопоточное программирование позволяет выполнять несколько задач одновременно, одному потоку часто 
приходится ждать результатов другого потока. Одним из решений является использование опроса. Опрос — это процесс 
периодической проверки данных через некоторый фиксированный интервал.

Предположим, у вас есть поток, который изменяет значение общего static counter, и ваш поток main() ожидает, пока поток 
достигнет 1 миллиона:

```
public class CheckResults {
   private static int counter = 0;
   public static void main(String[] args) {
      new Thread(() -> {
         for(int i = 0; i < 1_000_000; i++) counter++;
      }).start();
      while(counter < 1_000_000) {
         System.out.println("Not reached yet");
      }
      System.out.println("Reached: "+counter);
   } }
```

Сколько раз эта программа печатает Not reached yet? Ответ: мы не знаем! Он может выводить 0, 10 или миллион раз. 
Использование цикла while() для проверки данных без какой-либо задержки считается плохой практикой кодирования, 
поскольку оно без причины связывает ресурсы ЦП.

Мы можем улучшить этот результат, используя метод Thread.sleep() для реализации опроса и перехода в режим сна на 1000 
миллисекунд, то есть на 1 секунду:

```
public class CheckResultsWithSleep {
   private static int counter = 0;
   public static void main(String[] a) {
      new Thread(() -> {
         for(int i = 0; i < 1_000_000; i++) counter++;
      }).start();
      while(counter < 1_000_000) {
         System.out.println("Not reached yet");
         try { 
            Thread.sleep(1_000);  // 1 SECOND
         } catch (InterruptedException e) {
            System.out.println("Interrupted!");
         }
      }
      System.out.println("Reached: "+counter);
   } }
```

Хотя одна секунда может показаться небольшим количеством, теперь мы освободили ЦП для выполнения другой работы вместо 
бесконечной проверки переменной counter в цикле. Обратите внимание, что поток main() переключается между TIMED_WAITING и 
RUNNABLE при входе и выходе из sleep() соответственно.

Сколько раз цикл while() выполняется в этом пересмотренном классе? Еще неизвестно! Хотя опрос предотвращает перегрузку 
процессора потенциально бесконечным циклом, он не гарантирует, когда цикл завершится. Например, отдельный поток может 
терять время ЦП на процесс с более высоким приоритетом, что приводит к многократному выполнению цикла while() до его 
завершения.

Еще одна проблема, о которой следует беспокоиться, — это общая переменная counter. Что, если один поток читает 
переменную счетчика, а другой поток ее записывает? Поток, читающий общую переменную, может получить недопустимое или 
неожиданное значение. Мы подробно обсудим эти проблемы в следующем разделе, посвященном написанию потокобезопасного 
кода.

### Прерывание потока

Хотя наше предыдущее решение не позволяло процессору бесконечно ждать в цикле while(), за это пришлось вставить в нашу 
программу односекундную задержку. Если выполнение задачи занимает 2,1 секунды, программа будет использовать полные 3 
секунды, теряя 0,9 секунды.

Один из способов улучшить эту программу — разрешить потоку прерывать поток main() по его завершению:

```
public class CheckResultsWithSleepAndInterrupt {
   private static int counter = 0;
   public static void main(String[] a) {
      final var mainThread = Thread.currentThread();
      new Thread(() -> {
         for(int i = 0; i < 1_000_000; i++) counter++;
         mainThread.interrupt();
      }).start();
      while(counter < 1_000_000) {
         System.out.println("Not reached yet");
         try {
            Thread.sleep(1_000);  // 1 SECOND
         } catch (InterruptedException e) {
            System.out.println("Interrupted!");
         }
      }
      System.out.println("Reached: "+counter);
   } }
```

Эта улучшенная версия включает в себя как метод sleep(), чтобы избежать перегрузки процессора, так и interrupt(), 
поэтому работа потока завершается без задержки выполнения программы. Как и раньше, состояние нашего потока main() 
меняется между TIMED_WAITING и RUNNABLE. Вызов interrupt() для потока в состоянии TIMED_WAITING или WAITING приводит к 
тому, что поток main() снова становится RUNNABLE, вызывая InterruptedException. Поток также может перейти в состояние 
BLOCKED, если ему необходимо повторно получить ресурсы после пробуждения.

_Вызов interrupt() для потока, уже находящегося в состоянии RUNNABLE, не меняет это состояние. Фактически, это меняет 
поведение только в том случае, если поток периодически проверяет состояние значения Thread.isInterrupted()._

## Создание потоков с помощью API параллелизма

Java включает пакет java.util.concurrent, который мы называем Concurrency API, который поможет вам выполнить сложную 
работу по управлению потоками. API Concurrency включает интерфейс ExecutorService, который определяет службы, которые 
создают потоки и управляют ими.

Сначала вы получаете экземпляр интерфейса ExecutorService, а затем отправляете на обработку задачи службы. Платформа 
включает в себя множество полезных функций, таких как объединение потоков и планирование. Рекомендуется использовать 
эту платформу каждый раз, когда вам нужно создать и выполнить отдельную задачу, даже если вам нужен только один поток.

_На практике при написании многопоточных программ часто лучше использовать Concurrency API (или какой-либо другой 
многопоточный SDK), а не работать с объектами Thread напрямую. Библиотеки гораздо более надежны, и в них легче 
обрабатывать сложные взаимодействия._

### Представляем однопоточный исполнитель

Поскольку ExecutorService - это интерфейс, как вы получаете его экземпляр? API Concurrency включает в себя заводской 
класс Executors, который можно использовать для создания экземпляров объекта ExecutorService. Давайте перепишем наш 
предыдущий пример с двумя запускаемыми экземплярами на использование ExecutorService.

```
ExecutorService service = Executors.newSingleThreadExecutor();
try {
   System.out.println("begin");
   service.execute(printInventory);
   service.execute(printRecords);
   service.execute(printInventory);
   System.out.println("end");
} finally {
   service.shutdown();
}
```

В этом примере мы используем метод newSingleThreadExecutor() для создания службы. В отличие от нашего предыдущего 
примера, в котором у нас было четыре потока (один main() и три новых потока), у нас есть только два потока (один main() 
и один новый поток). Это означает, что результат, хотя и непредсказуемый, будет иметь меньшие вариации, чем раньше. 
Например, один из возможных результатов:

```
begin
Printing zoo inventory 
Printing record: 0 
Printing record: 1
end
Printing record: 2
Printing zoo inventory
```

Обратите внимание, что цикл printRecords больше не прерывается другими задачами Runnable, отправленными исполнителю 
потока. При использовании однопоточного исполнителя задачи гарантированно выполняются последовательно. Обратите 
внимание, что конечный текст выводится, пока наши задачи исполнителя потока все еще выполняются. Это связано с тем, что 
метод main() по-прежнему является независимым потоком от ExecutorService.

### Завершение работы исполнителя потоков

После завершения использования исполнителя потока важно вызвать метод shutdown(). Исполнитель потока создает поток, не 
являющийся демоном, при первой выполняемой задаче, поэтому отказ от вызова shutdown() приведет к тому, что ваше 
приложение никогда не завершится.

Процесс завершения работы исполнителя потока включает в себя сначала отклонение любых новых задач, отправленных 
исполнителю потока, при этом продолжается выполнение любых ранее отправленных задач. В это время вызов isShutdown() 
вернет true, а isTermination() вернет false. Если новая задача передается исполнителю потока во время его завершения, 
будет выдано исключение RejectedExecutionException. После завершения всех активных задач методы isShutdown() и 
isTermination() вернут true. На рисунке 13.3 показан жизненный цикл объекта ExecutorService.

#### Рис. 13.3 - Жизненный цикл ExecutorService


На экзамене вы должны знать, что функция shutdown() не останавливает никакие задачи, которые уже были отправлены 
исполнителю потока.

Что делать, если вы хотите отменить все текущие и предстоящие задачи? Служба ExecutorService предоставляет метод под 
названием shutdownNow(), который пытается остановить все запущенные задачи и отбрасывает все, что еще не было запущено. 
Успех не гарантирован, поскольку можно создать поток, который никогда не завершится, поэтому любая попытка его 
прерывания может быть проигнорирована.

_Как вы узнали из главы 11 «Исключения и локализация», такие ресурсы, как исполнители потоков, должны быть правильно 
закрыты, чтобы предотвратить утечки памяти. К сожалению, интерфейс ExecutorService не расширяет интерфейс AutoCloseable, 
поэтому вы не можете использовать оператор try-with-resources. Вы по-прежнему можете использовать блок finally, как мы 
делаем в этой главе. Хотя вам не обязательно использовать блок finally, это считается хорошей практикой._

### Отправка задач

Вы можете отправлять задачи в экземпляр ExecutorService несколькими способами. Первый представленный нами метод, 
execute(), унаследован от интерфейса Executor, который расширяется интерфейсом ExecutorService. Метод execute() 
принимает экземпляр Runnable и асинхронно выполняет задачу. Поскольку тип возвращаемого значения метода — void, 
он ничего не говорит нам о результате выполнения задачи. Это считается методом «выстрелил и забыл», поскольку после его 
отправки результаты не доступны напрямую вызывающему потоку.

К счастью, авторы Java добавили в интерфейс ExecutorService методы submit(), которые, как и execute(), можно 
использовать для асинхронного выполнения задач. Однако, в отличие от метода execute(), метод submit() возвращает 
экземпляр Future, который можно использовать для определения того, завершена ли задача. Его также можно использовать для 
возврата общего объекта результата после завершения задачи.

В таблице 13.1 показаны пять методов, включая метод execute() и два метода submit(), которые вам следует знать для сдачи 
экзамена. Не волнуйтесь, если вы раньше не видели Future или Callable; мы обсудим их подробно в следующем разделе.

На практике использование метода submit() очень похоже на использование метода execute(), за исключением того, что метод 
submit() возвращает экземпляр Future, который можно использовать для определения того, завершила ли выполнение задача.

#### Таблица 13.1 - Методы ExecutorService

|                               Имя метода                                |                                                                          Описание                                                                          |  
|:-----------------------------------------------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------:|
|                     void execute(Runnable command)                      |                                                   Выполняет задачу Runnable в какой-то момент в будущем.                                                   |
|                     Future<?> submit(Runnable task)                     |                             Выполняет задачу Runnable в какой-то момент в будущем и возвращает задачу, представляющую будущее.                             |
|                 <T> Future<T> submit( Callable<T> task)                 |                   Выполняет Callable задачу в какой-то момент в будущем и возвращает Future, представляющий ожидающие результаты задачи.                   |
| <T> List<Future<T>> invokeAll( Collection<? extends Callable<T>> tasks) | Выполняет заданные задачи и ожидает завершения всех задач. Возвращает список экземпляров Future в том же порядке, в котором они были в исходной коллекции. |
|       <T> T invokeAny( Collection<? extends Callable<T>> tasks)         |                                               Выполняет заданные задачи и ожидает завершения хотя бы одной.                                                |

**Отправка задач: execute() vs. submit()**

Как вы могли заметить, методы execute() и submit() практически идентичны при применении к выражениям Runnable. Метод 
submit() имеет очевидное преимущество: он делает то же самое, что и метод execute(), но с возвращаемым объектом, который 
можно использовать для отслеживания результата. Из-за этого преимущества и того факта, что метод execute() не 
поддерживает выражения Callable, мы склонны предпочитать метод submit() методу execute(), даже если мы не сохраняем 
ссылку Future.

Для сдачи экзамена вам необходимо быть знакомым с методами execute() и submit(), но в вашем собственном коде мы 
рекомендуем, когда это возможно, использовать метод submit() вместо execute().

### Ожидание результатов

Как мы узнаем, что задача, отправленная в ExecutorService, завершена? Как упоминалось в предыдущем разделе, метод 
submit() возвращает экземпляр Future<V>, который можно использовать для определения этого результата.

```
Future<?> future = service.submit(() -> System.out.println("Hello"));
```

Тип Future на самом деле является интерфейсом. Для сдачи экзамена вам не нужно знать ни один из классов, реализующих 
Future, достаточно того, что экземпляр Future возвращается различными методами API. В таблице 13.2 представлены полезные 
методы определения состояния задачи.

#### Таблица 13.2 - Методы Future

|                  Имя метода                   |                                                                                    Описание                                                                                     |  
|:---------------------------------------------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|               boolean isDone()                |                                               Возвращает true, если задача была завершена, вызвала исключение или была отменена.                                                |
|             boolean isCancelled()             |                                                    Возвращает true, если задача была отменена до ее нормального завершения.                                                     |
| boolean cancel(boolean mayInterruptIfRunning) |                  Пытается отменить выполнение задачи и возвращает true, если она была успешно отменена, или false, если ее нельзя отменить или она завершена.                   |
|                    V get()                    |                                                      Получает результат задачи, ожидая бесконечно, если он еще недоступен.                                                      |
|      V get(long timeout, TimeUnit unit)       | Получает результат задачи, ожидая указанное количество времени. Если результат не готов по истечении времени ожидания, будет выброшено отмеченное исключение TimeoutException.  |


Ниже приведена обновленная версия нашего предыдущего примера опроса класса CheckResults, который использует экземпляр 
Future для ожидания результатов:

```
import java.util.concurrent.*;
public class CheckResults {
   private static int counter = 0;
   public static void main(String[] unused) throws Exception {
      ExecutorService service = Executors.newSingleThreadExecutor();
      try {
         Future<?> result = service.submit(() -> {
            for(int i = 0; i < 1_000_000; i++) counter++;
         });
         result.get(10, TimeUnit.SECONDS);  // Возвращает null для Runnable
         System.out.println("Reached!");
      } catch (TimeoutException e) {
         System.out.println("Not reached in time");
      } finally {
         service.shutdown();
      } } }
```

Этот пример похож на нашу предыдущую реализацию опроса, но в нем не используется класс Thread напрямую. Частично в этом 
и заключается суть Concurrency API: выполнять сложные задачи с потоками без необходимости управлять потоками напрямую. 
Он также ожидает не более 10 секунд, выдавая исключение TimeoutException при вызове result.get(), если задача не 
выполнена. 

Каково возвращаемое значение этой задачи? Поскольку Future<V> является универсальным интерфейсом, тип V определяется 
типом возвращаемого значения метода Runnable. Поскольку тип возвращаемого значения Runnable.run() — void, метод get() 
всегда возвращает значение null при работе с выражениями Runnable.

Метод Future.get() может принимать необязательное значение и тип перечисления java.util.concurrent.TimeUnit. В таблице 
13.3 представлен полный список значений TimeUnit, поскольку это перечисление используется во многих методах 
Concurrency API.

#### Таблица 13.3 - Методы TimeUnit

|      Имя метода       |                        Описание                         |  
|:---------------------:|:-------------------------------------------------------:|
| TimeUnit.NANOSECONDS  | Время в одну миллиардную долю секунды (1/1,000,000,000) |
| TimeUnit.MICROSECONDS |   Время в одну миллионную долю секунды (1/1,000,000)    |
| TimeUnit.MILLISECONDS |        Время в тысячных долях секунды (1/1,000)         |
|   TimeUnit.SECONDS    |                    Время в секундах                     |
|   TimeUnit.MINUTES    |                     Время в минутах                     |
|    TimeUnit.HOURS     |                      Время в часах                      |
|    TimeUnit.DAYS      |                      Время в днях                       |


### Представляем Callable

Функциональный интерфейс java.util.concurrent.Callable похож на Runnable, за исключением того, что его метод call() 
возвращает значение и может генерировать проверенное исключение. Ниже приводится определение интерфейса Callable:

```
@FunctionalInterface public interface Callable<V> {
   V call() throws Exception;
}
```

Интерфейс Callable часто предпочтительнее Runnable, поскольку он позволяет легко получить более подробную информацию о 
задаче после ее завершения. Тем не менее, в этой главе мы используем оба интерфейса, поскольку они взаимозаменяемы в 
ситуациях, когда лямбда-выражение не генерирует исключение и нет возвращаемого типа. К счастью, ExecutorService включает 
перегруженную версию метода submit(), который принимает объект Callable и возвращает универсальный экземпляр Future<T>.

В отличие от Runnable, в котором методы get() всегда возвращают значение null, методы get() экземпляра Future возвращают 
соответствующий универсальный тип (который также может быть значением null).

Давайте посмотрим на пример использования Callable:

```
var service = Executors.newSingleThreadExecutor();
try {
   Future<Integer> result = service.submit(() -> 30 + 11);
   System.out.println(result.get());   // 41
} finally {
   service.shutdown();
}
```

Мы могли бы переписать этот пример, используя Runnable, какой-нибудь общий объект и interrupt() или ожидание по времени, 
но эту реализацию намного проще кодировать и понимать. По сути, в этом суть Concurrency API: он предоставляет вам 
инструменты для написания многопоточного кода, который является потокобезопасным, производительным и простым в 
использовании.

### Ожидание завершения всех задач

После отправки набора задач исполнителю потока обычно приходится ждать результатов. Как вы видели в предыдущих 
разделах, одним из решений является вызов get() для каждого объекта Future, возвращаемого методом submit(). Если нам не 
нужны результаты выполнения задач и мы закончили с помощью нашего исполнителя потоков, есть более простой подход.

Сначала мы завершаем выполнение потока с помощью метода shutdown(). Далее мы используем метод awaitTermination(), 
доступный для всех исполнителей потоков. Метод ожидает указанного времени для завершения всех задач и возвращается 
раньше, если все задачи завершаются или обнаружено InterruptedException. Пример этого вы можете увидеть в следующем 
фрагменте кода:

```
ExecutorService service = Executors.newSingleThreadExecutor();
try {
   // Add tasks to the thread executor
   ...
} finally {
   service.shutdown();
}
service.awaitTermination(1, TimeUnit.MINUTES);

// Check whether all tasks are finished
if(service.isTerminated()) System.out.println("Finished!");
else System.out.println("At least one task is still running");
```

В этом примере мы отправляем ряд задач исполнителю потока, а затем завершаем работу исполнителя потока и ждем 
результатов до одной минуты. Обратите внимание, что мы можем вызвать isTerminate() после завершения метода 
awaitTermination(), чтобы подтвердить, что все задачи завершены.

### Планирование задач

Часто в Java нам нужно запланировать выполнение задачи на какой-то момент в будущем. Возможно, нам даже придется 
запланировать многократное выполнение задачи через определенный интервал. Например, представьте, что мы хотим раз в час 
проверять запас корма для животных зоопарка и пополнять его по мере необходимости. ScheduledExecutorService, являющийся 
подинтерфейсом ExecutorService, можно использовать именно для такой задачи.

Как и ExecutorService, мы получаем экземпляр ScheduledExecutorService, используя фабричный метод класса Executors, как 
показано в следующем фрагменте:

```
ScheduledExecutorService service
   = Executors.newSingleThreadScheduledExecutor();
```

Мы могли бы сохранить экземпляр ScheduledExecutorService в переменной ExecutorService, хотя это означало бы, что нам 
придется привести объект для вызова любых методов планирования.

В таблице 13.4 приведено краткое описание методов ScheduledExecutorService. Каждый из этих методов возвращает объект 
ScheduledFuture.

#### Таблица 13.4 - Методы ScheduledExecutorService 

|                                       Имя метода                                        |                                                                               Описание                                                                               |  
|:---------------------------------------------------------------------------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|                schedule(Callable<V> callable, long delay, TimeUnit unit)                |                                                    Создает и выполняет вызываемую задачу после заданной задержки.                                                    |
|                  schedule(Runnable command, long delay, TimeUnit unit)                  |                                                     Создает и выполняет задачу Runnable после заданной задержки.                                                     |
|  scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)   |                Создает и выполняет задачу Runnable после заданной начальной задержки, создавая новую задачу при каждом прохождении значения периода.                 |
| scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)  | Создает и выполняет задачу Runnable после заданной начальной задержки и впоследствии с заданной задержкой между завершением одного выполнения и началом следующего.  |


На практике эти методы являются одними из самых удобных в Concurrency API, поскольку они выполняют относительно сложные 
задачи с помощью одной строки кода. Параметры задержки и периода зависят от аргумента TimeUnit, определяющего формат 
значения, например секунды или миллисекунды.

Первые два метода schedule() в таблице 13.4 принимают Callable или Runnable соответственно; выполнить задание с 
некоторой задержкой; и верните экземпляр ScheduledFuture. Интерфейс ScheduledFuture идентичен интерфейсу Future, за 
исключением того, что он включает метод getDelay(), который возвращает оставшуюся задержку. Следующий пример использует 
метод schedule() с задачами Callable и Runnable:

```
ScheduledExecutorService service
   = Executors.newSingleThreadScheduledExecutor();
Runnable task1 = () -> System.out.println("Hello Zoo");
Callable<String> task2 = () -> "Monkey";
ScheduledFuture<?> r1 = service.schedule(task1, 10, TimeUnit.SECONDS);
ScheduledFuture<?> r2 = service.schedule(task2, 8,  TimeUnit.MINUTES);
```

Первая задача запланирована на 10 секунд вперед, а вторая задача запланирована на 8 минут вперед.

_Хотя эти задачи запланированы на будущее, фактическое выполнение может быть отложено. Например, может не быть доступных 
потоков для выполнения задач, и в этот момент они просто будут ждать в очереди. Кроме того, если ScheduledExecutorService 
будет закрыт к моменту достижения запланированного времени выполнения задачи, эти задачи будут отменены._

Каждый из методов ScheduledExecutorService важен и имеет реальное применение. Например, вы можете использовать команду 
schedule(), чтобы проверить состояние уборки клетки льва. Затем он может отправлять уведомления, если он не завершен, 
или даже вызывать schedule(), чтобы проверить его позже.

Последние два метода в таблице 13.4 могут вас немного сбить с толку, если вы не видели их раньше. Концептуально они 
похожи, поскольку оба выполняют одну и ту же задачу повторно после начальной задержки. Разница связана со сроками 
выполнения процесса и временем запуска следующей задачи.

Метод scheduleAtFixedRate() создает новую задачу и передает ее исполнителю каждый период, независимо от того, 
завершилась ли предыдущая задача. В следующем примере задача Runnable выполняется каждую минуту после начальной 
пятиминутной задержки: service.scheduleAtFixedRate(command, 5, 1, TimeUnit.MINUTES);

Метод scheduleAtFixedRate() полезен для задач, которые необходимо запускать через определенные промежутки времени, 
например, проверка здоровья животных один раз в день. Даже если осмотр животного в понедельник занимает два часа, это 
не означает, что осмотр во вторник должен начаться позже в тот же день.

_Плохие вещи могут случиться с ScheduleAtFixedRate(), если выполнение каждой задачи постоянно занимает больше времени, 
чем интервал выполнения. Представьте, если бы ваш начальник каждую минуту подходил к вашему столу и приносил листок 
бумаги. А теперь представьте, что на чтение каждого листка бумаги у вас ушло пять минут. Вскоре вы утонете в стопках 
бумаги. Вот что чувствует исполнитель. При наличии достаточного количества времени программа отправит службе исполнителя 
больше задач, чем может поместиться в памяти, что приведет к сбою программы._

С другой стороны, метод scheduleWithFixedDelay() создает новую задачу только после завершения предыдущей задачи. 
Например, если задача запускается в 12:00 и ее завершение занимает пять минут, а период между выполнением составляет две 
минуты, следующая задача начнется в 12:07.

```
service.scheduleWithFixedDelay(task1, 0, 2, TimeUnit.MINUTES);
```

Метод scheduleWithFixedDelay() полезен для процессов, которые вы хотите повторять, но конкретное время которых не имеет 
значения. Например, представьте, что у нас есть работник столовой зоопарка, который в течение дня периодически пополняет 
запасы салат-бара. Этот процесс может занять 20 минут и более, поскольку работнику потребуется вытащить большое 
количество предметов из подсобного помещения. После того, как работник наполнил салат-бар свежими продуктами, ему не
нужно проверять это в какое-то определенное время, просто по прошествии достаточного времени, чтобы запасы снова 
закончились.

### Повышение параллелизма с помощью пулов


