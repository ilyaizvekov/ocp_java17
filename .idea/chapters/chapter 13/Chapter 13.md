# Параллелизм

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Управление параллельным выполнением кода

+ Создавайте рабочие потоки с помощью Runnable и Callable, управляйте жизненным циклом потоков, включая автоматизацию, предоставляемую различными службами Executor и параллельным API.
+ Разрабатывайте потокобезопасный код, используя различные механизмы блокировки и параллельный API.
+ Обработка коллекций Java одновременно, включая использование параллельных потоков.

#### Работа с потоками и лямбда-выражениями

+ Выполнение декомпозиции, конкатенации и сокращения, а также группировки и секционирования в последовательных и параллельных потоках.

---

Как вы узнаете из главы 14 “Ввод-вывод” и главы 15 “JDBC”, компьютеры способны считывать и записывать данные на внешние 
ресурсы. К сожалению, по сравнению с операциями центрального процессора, эти дисковые / сетевые операции, как правило, 
выполняются чрезвычайно медленно — фактически настолько медленно, что если бы операционная система вашего компьютера 
останавливалась и ждала завершения каждой дисковой или сетевой операции, ваш компьютер, казалось бы, постоянно зависал.

К счастью, все операционные системы поддерживают так называемую многопоточную обработку. Идея многопоточной обработки 
заключается в том, чтобы позволить приложению или группе приложений выполнять несколько задач одновременно. Это 
позволяет задачам, ожидающим других ресурсов, уступить место другим запросам на обработку.

В этой главе мы познакомим вас с концепцией потоков и предоставим множество способов управления потоками с помощью 
Concurrency API. Потоки и параллелизм - сложные темы для понимания многими программистами, поскольку проблемы с потоками 
могут расстраивать даже опытных разработчиков. На практике проблемы параллелизма являются одними из наиболее сложных 
для диагностики и устранения.

## Знакомство с потоками

Мы начинаем эту главу с рассмотрения общей терминологии, связанной с потоками. Поток - это наименьшая единица 
выполнения, которая может быть запланирована операционной системой. Процесс - это группа связанных потоков, которые 
выполняются в одной и той же общей среде. Из этого следует, что однопоточный процесс - это процесс, содержащий ровно 
один поток, в то время как многопоточный процесс поддерживает более одного потока.

Под общей средой мы подразумеваем, что потоки в одном и том же процессе совместно используют одно и то же пространство 
памяти и могут напрямую взаимодействовать друг с другом. Ознакомьтесь с рисунком 13.1 для получения общего представления 
о потоках и их общей среде в рамках процесса.

На этом рисунке показан один процесс с тремя потоками. Также показано, как они сопоставляются с произвольным количеством 
процессоров, доступных в системе. Имейте в виду эту схему, когда мы будем обсуждать планировщики задач позже в этом 
разделе.

В этой главе мы много говорим о задачах и их связях с потоками. Задача - это отдельная единица работы, выполняемая 
потоком. На протяжении всей этой главы задача обычно будет реализовываться в виде лямбда-выражения. Поток может 
выполнять несколько независимых задач, но только одну задачу за раз.

#### Рис. 13.1 - Модель процесса


Под разделяемой памятью на рис. 13.1 мы обычно подразумеваем статические переменные, а также переменные экземпляра и 
локальные переменные, передаваемые потоку. Да, вы наконец-то видите, как статические переменные могут быть полезны для 
выполнения сложных многопоточных задач! Помните из главы 5 “Методы”, что статические методы и переменные определены в 
одном объекте класса, который является общим для всех экземпляров. Например, если один поток обновляет значение 
статического объекта, эта информация немедленно становится доступной для чтения другим потокам внутри процесса.

### Понимание параллельности потоков

Свойство одновременного выполнения нескольких потоков и процессов называется параллельностью. Как система решает, что 
выполнять, когда доступно больше потоков, чем процессоров? Операционные системы используют планировщик потоков для 
определения того, какие потоки должны выполняться в данный момент, как показано на рисунке 13.1. Например, планировщик 
потоков может использовать циклическое расписание, в котором каждый доступный поток получает равное количество циклов 
процессора для выполнения, при этом потоки посещаются в циклическом порядке.

Когда выделенное потоку время истекает, но поток не завершил обработку, происходит переключение контекста. Переключение 
контекста - это процесс сохранения текущего состояния потока и последующего восстановления состояния потока для 
продолжения выполнения. Имейте в виду, что затраты часто связаны с переключением контекста из-за потери времени и 
необходимости перезагрузки состояния потока. Интеллектуальные планировщики потоков делают все возможное, чтобы свести к 
минимуму количество переключений контекста, сохраняя при этом бесперебойную работу приложения.

Наконец, поток может прерывать или заменять другой поток, если у него более высокий приоритет, чем у другого потока. 
Приоритет потока - это числовое значение, связанное с потоком, которое принимается во внимание планировщиком потоков при 
определении того, какие потоки должны выполняться в данный момент. В Java приоритеты потоков задаются в виде целых 
значений.

### Создание потока

Одним из наиболее распространенных способов определения задачи для потока является использование экземпляра Runnable. 
Runnable - это функциональный интерфейс, который не принимает аргументов и не возвращает данных.

```
@FunctionalInterface public interface Runnable {
   void run();
}
```

С его помощью легко создать и запустить поток. Фактически, вы можете сделать это в одной строке кода, используя класс 
Thread:

```
new Thread(() -> System.out.print("Hello")).start();
System.out.print("World");
```

Первая строка создает новый объект Thread, а затем запускает его с помощью метода start(). Выводит ли этот код 
HelloWorld или WorldHello? Ответ заключается в том, что мы не знаем. В зависимости от приоритета потока/планировщика 
возможно и то, и другое. Помните, что порядок выполнения потока часто не гарантируется. На экзамене обычно представлены 
вопросы, в которых одновременно запускается несколько заданий, и вы должны определить результат.

Давайте рассмотрим более сложный пример:

```
Runnable printInventory = () -> System.out.println("Printing zoo inventory");
Runnable printRecords = () -> {
   for (int i = 0; i < 3; i++)
      System.out.println("Printing record: " + i);
};
```

Учитывая эти примеры, каков результат следующего?

```
3: System.out.println("begin"); 
4: new Thread(printInventory).start(); 
5: new Thread(printRecords).start(); 
6: new Thread(printInventory).start(); 
7: System.out.println("end");
```

Ответ заключается в том, что это неизвестно до времени выполнения. Ниже приведен только один возможный результат:

```
begin
Printing record: 0 
Printing zoo inventory 
end
Printing record: 1
Printing zoo inventory
Printing record: 2
```

В этом примере используется в общей сложности четыре потока: main() и три дополнительных потока, созданных в строках 
4-6. Каждый поток, созданный в этих строках, выполняется как асинхронная задача. Под асинхронностью мы подразумеваем, 
что поток, выполняющий метод main(), не ожидает результатов каждого вновь созданного потока, прежде чем продолжить. 
Например, строки 5 и 6 могут быть выполнены до завершения потока, созданного в строке 4. Противоположностью такому 
поведению является асинхронная задача, в которой программа ожидает (или блокирует) в строке 4 завершения выполнения 
потока, прежде чем перейти к следующей строке. Подавляющее большинство вызовов методов, используемых в этой книге, 
были синхронными вплоть до этой главы.

В то время как порядок выполнения потоков не определен после запуска потоков, порядок внутри одного потока по-прежнему 
линейный. В частности, цикл for() по-прежнему упорядочен. Кроме того, begin всегда появляется перед end.

---

**Вызов run() вместо start()**

На экзамене помните о коде, который пытается запустить поток, вызывая run() вместо start(). Вызов run() для Thread или 
Runnable не запускает новый поток. Хотя следующие фрагменты кода будут скомпилированы, ни один из них не будет выполнять 
задачу в отдельном потоке:

```
System.out.println("begin");
new Thread(printInventory).run();
new Thread(printRecords).run();
new Thread(printInventory).run();
System.out.println("end");
```

В отличие от предыдущего примера, каждая строка этого кода будет ждать завершения метода run(), прежде чем перейти к 
следующей строке. Кроме того, в отличие от предыдущей программы, выходные данные этого примера кода будут одинаковыми 
при каждом выполнении.

---

В более общем смысле мы можем создать поток и связанную с ним задачу в Java одним из двух способов:

+ Предоставьте объект Runnable или лямбда-выражение конструктору потока.
+ Создайте класс, который расширяет Thread и переопределяет метод run().

На протяжении всей этой книги мы предпочитаем создавать задачи с помощью лямбда-выражений. В конце концов, это намного 
проще, особенно когда мы переходим к Concurrency API! Создание класса, расширяющего Thread, встречается относительно 
редко и должно выполняться только при определенных обстоятельствах, например, если вам нужно перезаписать другие 
методы потоков.

### Отличительные типы потоков

Возможно, вас удивит, что все Java-приложения, включая все те, которые мы представили в этой книге, являются 
многопоточными, поскольку они включают системные потоки. Системный поток создается виртуальной машиной Java (JVM) и 
запускается в фоновом режиме приложения. Например, сборкой мусора управляет системный поток, созданный JVM.

Альтернативно, пользовательский поток - это поток, созданный разработчиком приложения для выполнения определенной 
задачи. Большинство программ, которые мы представили до сих пор, содержали только один пользовательский поток, который 
вызывает метод main(). Для простоты мы обычно называем программы, содержащие только один пользовательский поток, 
однопоточными приложениями.

Системные и пользовательские потоки могут быть созданы как потоки-демоны. Поток демона - это поток, который не будет 
препятствовать выходу JVM после завершения работы программы. Java-приложение завершает работу, когда единственными 
запущенными потоками являются потоки демона. Например, если сборка мусора - единственный оставшийся запущенным поток, 
JVM автоматически завершит работу.

Давайте взглянем на пример. Как вы думаете, что это дает в результате?

```
1:  public class Zoo { 
2:     public static void pause() {                 // Defines the thread task 
3:        try { 
4:           Thread.sleep(10_000);                  // Wait for 10 seconds 
5:        } catch (InterruptedException e) {} 
6:        System.out.println("Thread finished!"); 
7:     }
8:     
9:     public static void main(String[] unused) { 
10:       var job = new Thread(() -> pause());      // Create thread 
11:
12:       job.start();                              // Start thread 
13:       System.out.println("Main method finished!"); 
14:    } }
```

Программа выведет два утверждения с интервалом примерно в 10 секунд:

```
Main method finished!
--- 10 second wait ---
Thread finished!
```

Верно. Несмотря на то, что метод main() выполнен, JVM будет ждать завершения пользовательского потока, прежде чем 
завершать программу. Что, если мы изменим задание на поток демона, добавив это в строку 11?

```
11:       job.setDaemon(true);
```

Программа напечатает первую инструкцию и завершит работу, так и не напечатав вторую строку.

```
Main method finished!
```

Для экзамена просто помните, что по умолчанию пользовательские потоки не являются демонами, и программа будет ждать их 
завершения.

### Managing a Thread’s Life Cycle