# Параллелизм

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Управление параллельным выполнением кода

+ Создавайте рабочие потоки с помощью Runnable и Callable, управляйте жизненным циклом потоков, включая автоматизацию, предоставляемую различными службами Executor и параллельным API.
+ Разрабатывайте потокобезопасный код, используя различные механизмы блокировки и параллельный API.
+ Обработка коллекций Java одновременно, включая использование параллельных потоков.

#### Работа с потоками и лямбда-выражениями

+ Выполнение декомпозиции, конкатенации и сокращения, а также группировки и секционирования в последовательных и параллельных потоках.

---

Как вы узнаете из главы 14 “Ввод-вывод” и главы 15 “JDBC”, компьютеры способны считывать и записывать данные на внешние 
ресурсы. К сожалению, по сравнению с операциями центрального процессора, эти дисковые / сетевые операции, как правило, 
выполняются чрезвычайно медленно — фактически настолько медленно, что если бы операционная система вашего компьютера 
останавливалась и ждала завершения каждой дисковой или сетевой операции, ваш компьютер, казалось бы, постоянно зависал.

К счастью, все операционные системы поддерживают так называемую многопоточную обработку. Идея многопоточной обработки 
заключается в том, чтобы позволить приложению или группе приложений выполнять несколько задач одновременно. Это 
позволяет задачам, ожидающим других ресурсов, уступить место другим запросам на обработку.

В этой главе мы познакомим вас с концепцией потоков и предоставим множество способов управления потоками с помощью 
Concurrency API. Потоки и параллелизм - сложные темы для понимания многими программистами, поскольку проблемы с потоками 
могут расстраивать даже опытных разработчиков. На практике проблемы параллелизма являются одними из наиболее сложных 
для диагностики и устранения.

## Знакомство с потоками

Мы начинаем эту главу с рассмотрения общей терминологии, связанной с потоками. Поток - это наименьшая единица 
выполнения, которая может быть запланирована операционной системой. Процесс - это группа связанных потоков, которые 
выполняются в одной и той же общей среде. Из этого следует, что однопоточный процесс - это процесс, содержащий ровно 
один поток, в то время как многопоточный процесс поддерживает более одного потока.

Под общей средой мы подразумеваем, что потоки в одном и том же процессе совместно используют одно и то же пространство 
памяти и могут напрямую взаимодействовать друг с другом. Ознакомьтесь с рисунком 13.1 для получения общего представления 
о потоках и их общей среде в рамках процесса.

На этом рисунке показан один процесс с тремя потоками. Также показано, как они сопоставляются с произвольным количеством 
процессоров, доступных в системе. Имейте в виду эту схему, когда мы будем обсуждать планировщики задач позже в этом 
разделе.

В этой главе мы много говорим о задачах и их связях с потоками. Задача - это отдельная единица работы, выполняемая 
потоком. На протяжении всей этой главы задача обычно будет реализовываться в виде лямбда-выражения. Поток может 
выполнять несколько независимых задач, но только одну задачу за раз.

#### Рис. 13.1 - Модель процесса


Под разделяемой памятью на рис. 13.1 мы обычно подразумеваем статические переменные, а также переменные экземпляра и 
локальные переменные, передаваемые потоку. Да, вы наконец-то видите, как статические переменные могут быть полезны для 
выполнения сложных многопоточных задач! Помните из главы 5 “Методы”, что статические методы и переменные определены в 
одном объекте класса, который является общим для всех экземпляров. Например, если один поток обновляет значение 
статического объекта, эта информация немедленно становится доступной для чтения другим потокам внутри процесса.

### Понимание параллельности потоков

Свойство одновременного выполнения нескольких потоков и процессов называется параллельностью. Как система решает, что 
выполнять, когда доступно больше потоков, чем процессоров? Операционные системы используют планировщик потоков для 
определения того, какие потоки должны выполняться в данный момент, как показано на рисунке 13.1. Например, планировщик 
потоков может использовать циклическое расписание, в котором каждый доступный поток получает равное количество циклов 
процессора для выполнения, при этом потоки посещаются в циклическом порядке.

Когда выделенное потоку время истекает, но поток не завершил обработку, происходит переключение контекста. Переключение 
контекста - это процесс сохранения текущего состояния потока и последующего восстановления состояния потока для 
продолжения выполнения. Имейте в виду, что затраты часто связаны с переключением контекста из-за потери времени и 
необходимости перезагрузки состояния потока. Интеллектуальные планировщики потоков делают все возможное, чтобы свести к 
минимуму количество переключений контекста, сохраняя при этом бесперебойную работу приложения.

Наконец, поток может прерывать или заменять другой поток, если у него более высокий приоритет, чем у другого потока. 
Приоритет потока - это числовое значение, связанное с потоком, которое принимается во внимание планировщиком потоков при 
определении того, какие потоки должны выполняться в данный момент. В Java приоритеты потоков задаются в виде целых 
значений.

### Создание потока

Одним из наиболее распространенных способов определения задачи для потока является использование экземпляра Runnable. 
Runnable - это функциональный интерфейс, который не принимает аргументов и не возвращает данных.

```
@FunctionalInterface public interface Runnable {
   void run();
}
```

С его помощью легко создать и запустить поток. Фактически, вы можете сделать это в одной строке кода, используя класс 
Thread:

```
new Thread(() -> System.out.print("Hello")).start();
System.out.print("World");
```

Первая строка создает новый объект Thread, а затем запускает его с помощью метода start(). Выводит ли этот код 
HelloWorld или WorldHello? Ответ заключается в том, что мы не знаем. В зависимости от приоритета потока/планировщика 
возможно и то, и другое. Помните, что порядок выполнения потока часто не гарантируется. На экзамене обычно представлены 
вопросы, в которых одновременно запускается несколько заданий, и вы должны определить результат.

Давайте рассмотрим более сложный пример:

```
Runnable printInventory = () -> System.out.println("Printing zoo inventory");
Runnable printRecords = () -> {
   for (int i = 0; i < 3; i++)
      System.out.println("Printing record: " + i);
};
```

Учитывая эти примеры, каков результат следующего?

```
3: System.out.println("begin"); 
4: new Thread(printInventory).start(); 
5: new Thread(printRecords).start(); 
6: new Thread(printInventory).start(); 
7: System.out.println("end");
```

Ответ заключается в том, что это неизвестно до времени выполнения. Ниже приведен только один возможный результат:

```
begin
Printing record: 0 
Printing zoo inventory 
end
Printing record: 1
Printing zoo inventory
Printing record: 2
```

В этом примере используется в общей сложности четыре потока: main() и три дополнительных потока, созданных в строках 
4-6. Каждый поток, созданный в этих строках, выполняется как асинхронная задача. Под асинхронностью мы подразумеваем, 
что поток, выполняющий метод main(), не ожидает результатов каждого вновь созданного потока, прежде чем продолжить. 
Например, строки 5 и 6 могут быть выполнены до завершения потока, созданного в строке 4. Противоположностью такому 
поведению является асинхронная задача, в которой программа ожидает (или блокирует) в строке 4 завершения выполнения 
потока, прежде чем перейти к следующей строке. Подавляющее большинство вызовов методов, используемых в этой книге, 
были синхронными вплоть до этой главы.

В то время как порядок выполнения потоков не определен после запуска потоков, порядок внутри одного потока по-прежнему 
линейный. В частности, цикл for() по-прежнему упорядочен. Кроме того, begin всегда появляется перед end.

---

**Вызов run() вместо start()**

На экзамене помните о коде, который пытается запустить поток, вызывая run() вместо start(). Вызов run() для Thread или 
Runnable не запускает новый поток. Хотя следующие фрагменты кода будут скомпилированы, ни один из них не будет выполнять 
задачу в отдельном потоке:

```
System.out.println("begin");
new Thread(printInventory).run();
new Thread(printRecords).run();
new Thread(printInventory).run();
System.out.println("end");
```

В отличие от предыдущего примера, каждая строка этого кода будет ждать завершения метода run(), прежде чем перейти к 
следующей строке. Кроме того, в отличие от предыдущей программы, выходные данные этого примера кода будут одинаковыми 
при каждом выполнении.

---

В более общем смысле мы можем создать поток и связанную с ним задачу в Java одним из двух способов:

+ Предоставьте объект Runnable или лямбда-выражение конструктору потока.
+ Создайте класс, который расширяет Thread и переопределяет метод run().

На протяжении всей этой книги мы предпочитаем создавать задачи с помощью лямбда-выражений. В конце концов, это намного 
проще, особенно когда мы переходим к Concurrency API! Создание класса, расширяющего Thread, встречается относительно 
редко и должно выполняться только при определенных обстоятельствах, например, если вам нужно перезаписать другие 
методы потоков.

### Отличительные типы потоков

Возможно, вас удивит, что все Java-приложения, включая все те, которые мы представили в этой книге, являются 
многопоточными, поскольку они включают системные потоки. Системный поток создается виртуальной машиной Java (JVM) и 
запускается в фоновом режиме приложения. Например, сборкой мусора управляет системный поток, созданный JVM.

Альтернативно, пользовательский поток - это поток, созданный разработчиком приложения для выполнения определенной 
задачи. Большинство программ, которые мы представили до сих пор, содержали только один пользовательский поток, который 
вызывает метод main(). Для простоты мы обычно называем программы, содержащие только один пользовательский поток, 
однопоточными приложениями.

Системные и пользовательские потоки могут быть созданы как потоки-демоны. Поток демона - это поток, который не будет 
препятствовать выходу JVM после завершения работы программы. Java-приложение завершает работу, когда единственными 
запущенными потоками являются потоки демона. Например, если сборка мусора - единственный оставшийся запущенным поток, 
JVM автоматически завершит работу.

Давайте взглянем на пример. Как вы думаете, что это дает в результате?

```
1:  public class Zoo { 
2:     public static void pause() {                 // Defines the thread task 
3:        try { 
4:           Thread.sleep(10_000);                  // Wait for 10 seconds 
5:        } catch (InterruptedException e) {} 
6:        System.out.println("Thread finished!"); 
7:     }
8:     
9:     public static void main(String[] unused) { 
10:       var job = new Thread(() -> pause());      // Create thread 
11:
12:       job.start();                              // Start thread 
13:       System.out.println("Main method finished!"); 
14:    } }
```

Программа выведет два утверждения с интервалом примерно в 10 секунд:

```
Main method finished!
--- 10 second wait ---
Thread finished!
```

Верно. Несмотря на то, что метод main() выполнен, JVM будет ждать завершения пользовательского потока, прежде чем 
завершать программу. Что, если мы изменим задание на поток демона, добавив это в строку 11?

```
11:       job.setDaemon(true);
```

Программа напечатает первую инструкцию и завершит работу, так и не напечатав вторую строку.

```
Main method finished!
```

Для экзамена просто помните, что по умолчанию пользовательские потоки не являются демонами, и программа будет ждать их 
завершения.

### Управление жизненным циклом потока

После создания поток находится в одном из шести состояний, показанных на рисунке 13.2. Вы можете запросить состояние 
потока, вызвав getState() для объекта потока.

#### Рис. 13.2 - Состояния потока


Каждый поток инициализируется с NEW состоянием. Как только вызывается start(), поток переходит в состояние RUNNABLE. 
Означает ли это, что он действительно работает? Не совсем: может работать, а может и нет. Состояние RUNNABLE просто 
означает, что поток может быть запущен. Как только работа потока завершена или выдано неперехваченное исключение, 
состояние потока становится TERMINATED, и работа больше не выполняется.

Находясь в состоянии RUNNABLE, поток может перейти в одно из трех состояний, в которых он приостанавливает свою работу: 
BLOCKED, WAITING или TIMED_WAITING. На этом рисунке показаны общие переходы между состояниями потока, но есть и другие 
возможности. Например, поток в состоянии WAITING может быть запущен функцией notifyAll(). Аналогично, поток, прерванный 
другим потоком, выйдет из TIMED_WAITING и сразу вернется в RUNNABLE.

В этой главе мы рассмотрим некоторые (но не все) из этих переходов. Некоторые методы, связанные с потоками, такие как 
wait(), notify() и join(), выходят за рамки экзамена и, честно говоря, их сложно использовать. Вам следует избегать их 
и как можно чаще использовать Concurrency API. Чтобы правильно использовать эти методы, требуются большие навыки 
(и немного удачи!)

### Опрос в режиме сна

Несмотря на то, что многопоточное программирование позволяет выполнять несколько задач одновременно, одному потоку часто 
приходится ждать результатов другого потока. Одним из решений является использование опроса. Опрос — это процесс 
периодической проверки данных через некоторый фиксированный интервал.

Предположим, у вас есть поток, который изменяет значение общего static counter, и ваш поток main() ожидает, пока поток 
достигнет 1 миллиона:

```
public class CheckResults {
   private static int counter = 0;
   public static void main(String[] args) {
      new Thread(() -> {
         for(int i = 0; i < 1_000_000; i++) counter++;
      }).start();
      while(counter < 1_000_000) {
         System.out.println("Not reached yet");
      }
      System.out.println("Reached: "+counter);
   } }
```

Сколько раз эта программа печатает Not reached yet? Ответ: мы не знаем! Он может выводить 0, 10 или миллион раз. 
Использование цикла while() для проверки данных без какой-либо задержки считается плохой практикой кодирования, 
поскольку оно без причины связывает ресурсы ЦП.

Мы можем улучшить этот результат, используя метод Thread.sleep() для реализации опроса и перехода в режим сна на 1000 
миллисекунд, то есть на 1 секунду:

```
public class CheckResultsWithSleep {
   private static int counter = 0;
   public static void main(String[] a) {
      new Thread(() -> {
         for(int i = 0; i < 1_000_000; i++) counter++;
      }).start();
      while(counter < 1_000_000) {
         System.out.println("Not reached yet");
         try { 
            Thread.sleep(1_000);  // 1 SECOND
         } catch (InterruptedException e) {
            System.out.println("Interrupted!");
         }
      }
      System.out.println("Reached: "+counter);
   } }
```

Хотя одна секунда может показаться небольшим количеством, теперь мы освободили ЦП для выполнения другой работы вместо 
бесконечной проверки переменной counter в цикле. Обратите внимание, что поток main() переключается между TIMED_WAITING и 
RUNNABLE при входе и выходе из sleep() соответственно.

Сколько раз цикл while() выполняется в этом пересмотренном классе? Еще неизвестно! Хотя опрос предотвращает перегрузку 
процессора потенциально бесконечным циклом, он не гарантирует, когда цикл завершится. Например, отдельный поток может 
терять время ЦП на процесс с более высоким приоритетом, что приводит к многократному выполнению цикла while() до его 
завершения.

Еще одна проблема, о которой следует беспокоиться, — это общая переменная counter. Что, если один поток читает 
переменную счетчика, а другой поток ее записывает? Поток, читающий общую переменную, может получить недопустимое или 
неожиданное значение. Мы подробно обсудим эти проблемы в следующем разделе, посвященном написанию потокобезопасного 
кода.

### Прерывание потока

Хотя наше предыдущее решение не позволяло процессору бесконечно ждать в цикле while(), за это пришлось вставить в нашу 
программу односекундную задержку. Если выполнение задачи занимает 2,1 секунды, программа будет использовать полные 3 
секунды, теряя 0,9 секунды.

Один из способов улучшить эту программу — разрешить потоку прерывать поток main() по его завершению:

```
public class CheckResultsWithSleepAndInterrupt {
   private static int counter = 0;
   public static void main(String[] a) {
      final var mainThread = Thread.currentThread();
      new Thread(() -> {
         for(int i = 0; i < 1_000_000; i++) counter++;
         mainThread.interrupt();
      }).start();
      while(counter < 1_000_000) {
         System.out.println("Not reached yet");
         try {
            Thread.sleep(1_000);  // 1 SECOND
         } catch (InterruptedException e) {
            System.out.println("Interrupted!");
         }
      }
      System.out.println("Reached: "+counter);
   } }
```

Эта улучшенная версия включает в себя как метод sleep(), чтобы избежать перегрузки процессора, так и interrupt(), 
поэтому работа потока завершается без задержки выполнения программы. Как и раньше, состояние нашего потока main() 
меняется между TIMED_WAITING и RUNNABLE. Вызов interrupt() для потока в состоянии TIMED_WAITING или WAITING приводит к 
тому, что поток main() снова становится RUNNABLE, вызывая InterruptedException. Поток также может перейти в состояние 
BLOCKED, если ему необходимо повторно получить ресурсы после пробуждения.

_Вызов interrupt() для потока, уже находящегося в состоянии RUNNABLE, не меняет это состояние. Фактически, это меняет 
поведение только в том случае, если поток периодически проверяет состояние значения Thread.isInterrupted()._

## Создание потоков с помощью API параллелизма

Java включает пакет java.util.concurrent, который мы называем Concurrency API, который поможет вам выполнить сложную 
работу по управлению потоками. API Concurrency включает интерфейс ExecutorService, который определяет службы, которые 
создают потоки и управляют ими.

Сначала вы получаете экземпляр интерфейса ExecutorService, а затем отправляете на обработку задачи службы. Платформа 
включает в себя множество полезных функций, таких как объединение потоков и планирование. Рекомендуется использовать 
эту платформу каждый раз, когда вам нужно создать и выполнить отдельную задачу, даже если вам нужен только один поток.

_На практике при написании многопоточных программ часто лучше использовать Concurrency API (или какой-либо другой 
многопоточный SDK), а не работать с объектами Thread напрямую. Библиотеки гораздо более надежны, и в них легче 
обрабатывать сложные взаимодействия._

### Представляем однопоточный исполнитель

Поскольку ExecutorService - это интерфейс, как вы получаете его экземпляр? API Concurrency включает в себя заводской 
класс Executors, который можно использовать для создания экземпляров объекта ExecutorService. Давайте перепишем наш 
предыдущий пример с двумя запускаемыми экземплярами на использование ExecutorService.

```
ExecutorService service = Executors.newSingleThreadExecutor();
try {
   System.out.println("begin");
   service.execute(printInventory);
   service.execute(printRecords);
   service.execute(printInventory);
   System.out.println("end");
} finally {
   service.shutdown();
}
```

В этом примере мы используем метод newSingleThreadExecutor() для создания службы. В отличие от нашего предыдущего 
примера, в котором у нас было четыре потока (один main() и три новых потока), у нас есть только два потока (один main() 
и один новый поток). Это означает, что результат, хотя и непредсказуемый, будет иметь меньшие вариации, чем раньше. 
Например, один из возможных результатов:

```
begin
Printing zoo inventory 
Printing record: 0 
Printing record: 1
end
Printing record: 2
Printing zoo inventory
```

Обратите внимание, что цикл printRecords больше не прерывается другими задачами Runnable, отправленными исполнителю 
потока. При использовании однопоточного исполнителя задачи гарантированно выполняются последовательно. Обратите 
внимание, что конечный текст выводится, пока наши задачи исполнителя потока все еще выполняются. Это связано с тем, что 
метод main() по-прежнему является независимым потоком от ExecutorService.

### Завершение работы исполнителя потоков

После завершения использования исполнителя потока важно вызвать метод shutdown(). Исполнитель потока создает поток, не 
являющийся демоном, при первой выполняемой задаче, поэтому отказ от вызова shutdown() приведет к тому, что ваше 
приложение никогда не завершится.

Процесс завершения работы исполнителя потока включает в себя сначала отклонение любых новых задач, отправленных 
исполнителю потока, при этом продолжается выполнение любых ранее отправленных задач. В это время вызов isShutdown() 
вернет true, а isTermination() вернет false. Если новая задача передается исполнителю потока во время его завершения, 
будет выдано исключение RejectedExecutionException. После завершения всех активных задач методы isShutdown() и 
isTermination() вернут true. На рисунке 13.3 показан жизненный цикл объекта ExecutorService.

#### Рис. 13.3 - Жизненный цикл ExecutorService


На экзамене вы должны знать, что функция shutdown() не останавливает никакие задачи, которые уже были отправлены 
исполнителю потока.

Что делать, если вы хотите отменить все текущие и предстоящие задачи? Служба ExecutorService предоставляет метод под 
названием shutdownNow(), который пытается остановить все запущенные задачи и отбрасывает все, что еще не было запущено. 
Успех не гарантирован, поскольку можно создать поток, который никогда не завершится, поэтому любая попытка его 
прерывания может быть проигнорирована.

_Как вы узнали из главы 11 «Исключения и локализация», такие ресурсы, как исполнители потоков, должны быть правильно 
закрыты, чтобы предотвратить утечки памяти. К сожалению, интерфейс ExecutorService не расширяет интерфейс AutoCloseable, 
поэтому вы не можете использовать оператор try-with-resources. Вы по-прежнему можете использовать блок finally, как мы 
делаем в этой главе. Хотя вам не обязательно использовать блок finally, это считается хорошей практикой._

### Отправка задач

Вы можете отправлять задачи в экземпляр ExecutorService несколькими способами. Первый представленный нами метод, 
execute(), унаследован от интерфейса Executor, который расширяется интерфейсом ExecutorService. Метод execute() 
принимает экземпляр Runnable и асинхронно выполняет задачу. Поскольку тип возвращаемого значения метода — void, 
он ничего не говорит нам о результате выполнения задачи. Это считается методом «выстрелил и забыл», поскольку после его 
отправки результаты не доступны напрямую вызывающему потоку.

К счастью, авторы Java добавили в интерфейс ExecutorService методы submit(), которые, как и execute(), можно 
использовать для асинхронного выполнения задач. Однако, в отличие от метода execute(), метод submit() возвращает 
экземпляр Future, который можно использовать для определения того, завершена ли задача. Его также можно использовать для 
возврата общего объекта результата после завершения задачи.

В таблице 13.1 показаны пять методов, включая метод execute() и два метода submit(), которые вам следует знать для сдачи 
экзамена. Не волнуйтесь, если вы раньше не видели Future или Callable; мы обсудим их подробно в следующем разделе.

На практике использование метода submit() очень похоже на использование метода execute(), за исключением того, что метод 
submit() возвращает экземпляр Future, который можно использовать для определения того, завершила ли выполнение задача.

#### Таблица 13.1 - Методы ExecutorService

|                               Имя метода                                |                                                                          Описание                                                                          |  
|:-----------------------------------------------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------:|
|                     void execute(Runnable command)                      |                                                   Выполняет задачу Runnable в какой-то момент в будущем.                                                   |
|                     Future<?> submit(Runnable task)                     |                             Выполняет задачу Runnable в какой-то момент в будущем и возвращает задачу, представляющую будущее.                             |
|                 <T> Future<T> submit( Callable<T> task)                 |                   Выполняет Callable задачу в какой-то момент в будущем и возвращает Future, представляющий ожидающие результаты задачи.                   |
| <T> List<Future<T>> invokeAll( Collection<? extends Callable<T>> tasks) | Выполняет заданные задачи и ожидает завершения всех задач. Возвращает список экземпляров Future в том же порядке, в котором они были в исходной коллекции. |
|       <T> T invokeAny( Collection<? extends Callable<T>> tasks)         |                                               Выполняет заданные задачи и ожидает завершения хотя бы одной.                                                |

**Отправка задач: execute() vs. submit()**

Как вы могли заметить, методы execute() и submit() практически идентичны при применении к выражениям Runnable. Метод 
submit() имеет очевидное преимущество: он делает то же самое, что и метод execute(), но с возвращаемым объектом, который 
можно использовать для отслеживания результата. Из-за этого преимущества и того факта, что метод execute() не 
поддерживает выражения Callable, мы склонны предпочитать метод submit() методу execute(), даже если мы не сохраняем 
ссылку Future.

Для сдачи экзамена вам необходимо быть знакомым с методами execute() и submit(), но в вашем собственном коде мы 
рекомендуем, когда это возможно, использовать метод submit() вместо execute().

### Ожидание результатов

Как мы узнаем, что задача, отправленная в ExecutorService, завершена? Как упоминалось в предыдущем разделе, метод 
submit() возвращает экземпляр Future<V>, который можно использовать для определения этого результата.

```
Future<?> future = service.submit(() -> System.out.println("Hello"));
```

Тип Future на самом деле является интерфейсом. Для сдачи экзамена вам не нужно знать ни один из классов, реализующих 
Future, достаточно того, что экземпляр Future возвращается различными методами API. В таблице 13.2 представлены полезные 
методы определения состояния задачи.

#### Таблица 13.2 - Методы Future

|                  Имя метода                   |                                                                                    Описание                                                                                     |  
|:---------------------------------------------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|               boolean isDone()                |                                               Возвращает true, если задача была завершена, вызвала исключение или была отменена.                                                |
|             boolean isCancelled()             |                                                    Возвращает true, если задача была отменена до ее нормального завершения.                                                     |
| boolean cancel(boolean mayInterruptIfRunning) |                  Пытается отменить выполнение задачи и возвращает true, если она была успешно отменена, или false, если ее нельзя отменить или она завершена.                   |
|                    V get()                    |                                                      Получает результат задачи, ожидая бесконечно, если он еще недоступен.                                                      |
|      V get(long timeout, TimeUnit unit)       | Получает результат задачи, ожидая указанное количество времени. Если результат не готов по истечении времени ожидания, будет выброшено отмеченное исключение TimeoutException.  |


Ниже приведена обновленная версия нашего предыдущего примера опроса класса CheckResults, который использует экземпляр 
Future для ожидания результатов:

```
import java.util.concurrent.*;
public class CheckResults {
   private static int counter = 0;
   public static void main(String[] unused) throws Exception {
      ExecutorService service = Executors.newSingleThreadExecutor();
      try {
         Future<?> result = service.submit(() -> {
            for(int i = 0; i < 1_000_000; i++) counter++;
         });
         result.get(10, TimeUnit.SECONDS);  // Возвращает null для Runnable
         System.out.println("Reached!");
      } catch (TimeoutException e) {
         System.out.println("Not reached in time");
      } finally {
         service.shutdown();
      } } }
```

Этот пример похож на нашу предыдущую реализацию опроса, но в нем не используется класс Thread напрямую. Частично в этом 
и заключается суть Concurrency API: выполнять сложные задачи с потоками без необходимости управлять потоками напрямую. 
Он также ожидает не более 10 секунд, выдавая исключение TimeoutException при вызове result.get(), если задача не 
выполнена. 

Каково возвращаемое значение этой задачи? Поскольку Future<V> является универсальным интерфейсом, тип V определяется 
типом возвращаемого значения метода Runnable. Поскольку тип возвращаемого значения Runnable.run() — void, метод get() 
всегда возвращает значение null при работе с выражениями Runnable.

Метод Future.get() может принимать необязательное значение и тип перечисления java.util.concurrent.TimeUnit. В таблице 
13.3 представлен полный список значений TimeUnit, поскольку это перечисление используется во многих методах 
Concurrency API.

#### Таблица 13.3 - Методы TimeUnit

|      Имя метода       |                        Описание                         |  
|:---------------------:|:-------------------------------------------------------:|
| TimeUnit.NANOSECONDS  | Время в одну миллиардную долю секунды (1/1,000,000,000) |
| TimeUnit.MICROSECONDS |   Время в одну миллионную долю секунды (1/1,000,000)    |
| TimeUnit.MILLISECONDS |        Время в тысячных долях секунды (1/1,000)         |
|   TimeUnit.SECONDS    |                    Время в секундах                     |
|   TimeUnit.MINUTES    |                     Время в минутах                     |
|    TimeUnit.HOURS     |                      Время в часах                      |
|    TimeUnit.DAYS      |                      Время в днях                       |


### Представляем Callable

Функциональный интерфейс java.util.concurrent.Callable похож на Runnable, за исключением того, что его метод call() 
возвращает значение и может генерировать проверенное исключение. Ниже приводится определение интерфейса Callable:

```
@FunctionalInterface public interface Callable<V> {
   V call() throws Exception;
}
```

Интерфейс Callable часто предпочтительнее Runnable, поскольку он позволяет легко получить более подробную информацию о 
задаче после ее завершения. Тем не менее, в этой главе мы используем оба интерфейса, поскольку они взаимозаменяемы в 
ситуациях, когда лямбда-выражение не генерирует исключение и нет возвращаемого типа. К счастью, ExecutorService включает 
перегруженную версию метода submit(), который принимает объект Callable и возвращает универсальный экземпляр Future<T>.

В отличие от Runnable, в котором методы get() всегда возвращают значение null, методы get() экземпляра Future возвращают 
соответствующий универсальный тип (который также может быть значением null).

Давайте посмотрим на пример использования Callable:

```
var service = Executors.newSingleThreadExecutor();
try {
   Future<Integer> result = service.submit(() -> 30 + 11);
   System.out.println(result.get());   // 41
} finally {
   service.shutdown();
}
```

Мы могли бы переписать этот пример, используя Runnable, какой-нибудь общий объект и interrupt() или ожидание по времени, 
но эту реализацию намного проще кодировать и понимать. По сути, в этом суть Concurrency API: он предоставляет вам 
инструменты для написания многопоточного кода, который является потокобезопасным, производительным и простым в 
использовании.

### Ожидание завершения всех задач

После отправки набора задач исполнителю потока обычно приходится ждать результатов. Как вы видели в предыдущих 
разделах, одним из решений является вызов get() для каждого объекта Future, возвращаемого методом submit(). Если нам не 
нужны результаты выполнения задач и мы закончили с помощью нашего исполнителя потоков, есть более простой подход.

Сначала мы завершаем выполнение потока с помощью метода shutdown(). Далее мы используем метод awaitTermination(), 
доступный для всех исполнителей потоков. Метод ожидает указанного времени для завершения всех задач и возвращается 
раньше, если все задачи завершаются или обнаружено InterruptedException. Пример этого вы можете увидеть в следующем 
фрагменте кода:

```
ExecutorService service = Executors.newSingleThreadExecutor();
try {
   // Add tasks to the thread executor
   ...
} finally {
   service.shutdown();
}
service.awaitTermination(1, TimeUnit.MINUTES);

// Check whether all tasks are finished
if(service.isTerminated()) System.out.println("Finished!");
else System.out.println("At least one task is still running");
```

В этом примере мы отправляем ряд задач исполнителю потока, а затем завершаем работу исполнителя потока и ждем 
результатов до одной минуты. Обратите внимание, что мы можем вызвать isTerminate() после завершения метода 
awaitTermination(), чтобы подтвердить, что все задачи завершены.

### Планирование задач

Часто в Java нам нужно запланировать выполнение задачи на какой-то момент в будущем. Возможно, нам даже придется 
запланировать многократное выполнение задачи через определенный интервал. Например, представьте, что мы хотим раз в час 
проверять запас корма для животных зоопарка и пополнять его по мере необходимости. ScheduledExecutorService, являющийся 
подинтерфейсом ExecutorService, можно использовать именно для такой задачи.

Как и ExecutorService, мы получаем экземпляр ScheduledExecutorService, используя фабричный метод класса Executors, как 
показано в следующем фрагменте:

```
ScheduledExecutorService service
   = Executors.newSingleThreadScheduledExecutor();
```

Мы могли бы сохранить экземпляр ScheduledExecutorService в переменной ExecutorService, хотя это означало бы, что нам 
придется привести объект для вызова любых методов планирования.

В таблице 13.4 приведено краткое описание методов ScheduledExecutorService. Каждый из этих методов возвращает объект 
ScheduledFuture.

#### Таблица 13.4 - Методы ScheduledExecutorService 

|                                       Имя метода                                        |                                                                               Описание                                                                               |  
|:---------------------------------------------------------------------------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|                schedule(Callable<V> callable, long delay, TimeUnit unit)                |                                                    Создает и выполняет вызываемую задачу после заданной задержки.                                                    |
|                  schedule(Runnable command, long delay, TimeUnit unit)                  |                                                     Создает и выполняет задачу Runnable после заданной задержки.                                                     |
|  scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)   |                Создает и выполняет задачу Runnable после заданной начальной задержки, создавая новую задачу при каждом прохождении значения периода.                 |
| scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)  | Создает и выполняет задачу Runnable после заданной начальной задержки и впоследствии с заданной задержкой между завершением одного выполнения и началом следующего.  |


На практике эти методы являются одними из самых удобных в Concurrency API, поскольку они выполняют относительно сложные 
задачи с помощью одной строки кода. Параметры задержки и периода зависят от аргумента TimeUnit, определяющего формат 
значения, например секунды или миллисекунды.

Первые два метода schedule() в таблице 13.4 принимают Callable или Runnable соответственно; выполнить задание с 
некоторой задержкой; и верните экземпляр ScheduledFuture. Интерфейс ScheduledFuture идентичен интерфейсу Future, за 
исключением того, что он включает метод getDelay(), который возвращает оставшуюся задержку. Следующий пример использует 
метод schedule() с задачами Callable и Runnable:

```
ScheduledExecutorService service
   = Executors.newSingleThreadScheduledExecutor();
Runnable task1 = () -> System.out.println("Hello Zoo");
Callable<String> task2 = () -> "Monkey";
ScheduledFuture<?> r1 = service.schedule(task1, 10, TimeUnit.SECONDS);
ScheduledFuture<?> r2 = service.schedule(task2, 8,  TimeUnit.MINUTES);
```

Первая задача запланирована на 10 секунд вперед, а вторая задача запланирована на 8 минут вперед.

_Хотя эти задачи запланированы на будущее, фактическое выполнение может быть отложено. Например, может не быть доступных 
потоков для выполнения задач, и в этот момент они просто будут ждать в очереди. Кроме того, если ScheduledExecutorService 
будет закрыт к моменту достижения запланированного времени выполнения задачи, эти задачи будут отменены._

Каждый из методов ScheduledExecutorService важен и имеет реальное применение. Например, вы можете использовать команду 
schedule(), чтобы проверить состояние уборки клетки льва. Затем он может отправлять уведомления, если он не завершен, 
или даже вызывать schedule(), чтобы проверить его позже.

Последние два метода в таблице 13.4 могут вас немного сбить с толку, если вы не видели их раньше. Концептуально они 
похожи, поскольку оба выполняют одну и ту же задачу повторно после начальной задержки. Разница связана со сроками 
выполнения процесса и временем запуска следующей задачи.

Метод scheduleAtFixedRate() создает новую задачу и передает ее исполнителю каждый период, независимо от того, 
завершилась ли предыдущая задача. В следующем примере задача Runnable выполняется каждую минуту после начальной 
пятиминутной задержки: service.scheduleAtFixedRate(command, 5, 1, TimeUnit.MINUTES);

Метод scheduleAtFixedRate() полезен для задач, которые необходимо запускать через определенные промежутки времени, 
например, проверка здоровья животных один раз в день. Даже если осмотр животного в понедельник занимает два часа, это 
не означает, что осмотр во вторник должен начаться позже в тот же день.

_Плохие вещи могут случиться с ScheduleAtFixedRate(), если выполнение каждой задачи постоянно занимает больше времени, 
чем интервал выполнения. Представьте, если бы ваш начальник каждую минуту подходил к вашему столу и приносил листок 
бумаги. А теперь представьте, что на чтение каждого листка бумаги у вас ушло пять минут. Вскоре вы утонете в стопках 
бумаги. Вот что чувствует исполнитель. При наличии достаточного количества времени программа отправит службе исполнителя 
больше задач, чем может поместиться в памяти, что приведет к сбою программы._

С другой стороны, метод scheduleWithFixedDelay() создает новую задачу только после завершения предыдущей задачи. 
Например, если задача запускается в 12:00 и ее завершение занимает пять минут, а период между выполнением составляет две 
минуты, следующая задача начнется в 12:07.

```
service.scheduleWithFixedDelay(task1, 0, 2, TimeUnit.MINUTES);
```

Метод scheduleWithFixedDelay() полезен для процессов, которые вы хотите повторять, но конкретное время которых не имеет 
значения. Например, представьте, что у нас есть работник столовой зоопарка, который в течение дня периодически пополняет 
запасы салат-бара. Этот процесс может занять 20 минут и более, поскольку работнику потребуется вытащить большое 
количество предметов из подсобного помещения. После того, как работник наполнил салат-бар свежими продуктами, ему не
нужно проверять это в какое-то определенное время, просто по прошествии достаточного времени, чтобы запасы снова 
закончились.

### Повышение параллелизма с помощью пулов

Все наши примеры до сих пор были с однопоточным исполнителем, который, хотя и был интересен, но не был особенно полезен. 
В конце концов, название этой главы — «Параллелизм», и вы не сможете сделать многое из этого с помощью однопоточного 
исполнителя!

Теперь мы представляем три дополнительных фабричных метода в классе Executors, которые действуют на пул потоков, а не 
на один поток. Пул потоков — это группа предварительно созданных потоков многократного использования, которые доступны 
для выполнения набора произвольных задач. В таблице 13.5 представлены два предыдущих метода однопоточного исполнителя, а 
также новые, которые вам следует знать для экзамена.

#### Таблица 13.5 - Фабричные методы Executors

|                         Имя метода                          |                                                                                Описание                                                                                |  
|:-----------------------------------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|          ExecutorService newSingleThreadExecutor()          | Создает однопоточный исполнитель, использующий один рабочий поток, работающий в неограниченной очереди. Результаты обрабатываются последовательно в порядке их подачи. |
| ScheduledExecutorService newSingleThreadScheduledExecutor() |                    Создает однопоточный исполнитель, который может планировать запуск команд после заданной задержки или периодическое выполнение.                     |
|            ExecutorService newCachedThreadPool()            |              Создает пул потоков, который создает новые потоки по мере необходимости, но повторно использует ранее созданные потоки, когда они доступны.               |
|           ExecutorService newFixedThreadPool(int)           |                     Создает пул потоков, который повторно использует фиксированное количество потоков, работающих в общей неограниченной очереди.                      |
|    ScheduledExecutorService newScheduledThreadPool(int)     |                          Создает пул потоков, который может планировать запуск команд после заданной задержки или выполнять их периодически.                           |


Как показано в таблице 13.5, эти методы возвращают те же типы экземпляров, ExecutorService и ScheduledExecutorService, 
которые мы использовали ранее в этой главе. Другими словами, все наши предыдущие примеры совместимы с этими новыми 
исполнителями объединенных потоков!

Разница между однопоточным исполнителем и исполнителем из пула заключается в том, что происходит, когда задача уже 
запущена. В то время как исполнитель с одним потоком будет ждать, пока поток станет доступен, прежде чем запускать 
следующую задачу, исполнитель с пулом потоков может выполнять следующую задачу одновременно. Если в пуле закончились 
доступные потоки, задача будет поставлена в очередь исполнителем потока и ожидать завершения.

## Написание потокобезопасного кода

Потокобезопасность — это свойство объекта, гарантирующее безопасное выполнение несколькими потоками одновременно. 
Поскольку потоки выполняются в общей среде и пространстве памяти, как нам предотвратить взаимодействие двух потоков 
друг с другом? Мы должны организовать доступ к данным так, чтобы не получить неверных или неожиданных результатов.

В этой части главы мы покажем, как использовать различные методы защиты данных, включая атомарные классы, 
синхронизированные блоки, структуру блокировки и циклические барьеры.

### Понимание потокобезопасности

Представьте себе, что в нашем зоопарке есть программа для подсчета овец, желательно такая, которая не будет усыплять 
работников зоопарка! Каждый работник зоопарка выбегает в поле, добавляет в стадо новую овцу, подсчитывает общее 
количество овец и бежит обратно к нам, чтобы сообщить результаты. Мы представляем следующий код, чтобы представить это 
концептуально, выбирая размер пула потоков, чтобы все задачи могли выполняться одновременно:

```
1:  import java.util.concurrent.*; 
2:  public class SheepManager { 
3:     private int sheepCount = 0; 
4:     private void incrementAndReport() { 
5:        System.out.print((++sheepCount)+" "); 
6:     }
7:     public static void main(String[] args) { 
8:        ExecutorService service = Executors.newFixedThreadPool(20); 
9:        try { 
10:          SheepManager manager = new SheepManager(); 
11:          for(int i = 0; i < 10; i++) 
12:             service.submit(() -> manager.incrementAndReport()); 
13:       } finally { 
14:          service.shutdown(); 
15:       } } }
```

Что выводит эта программа? Вы можете подумать, что он выведет числа от 1 до 10 по порядку, но это далеко не 
гарантировано. Он может выводиться в другом порядке. Хуже того, некоторые числа могут быть напечатаны дважды, а 
некоторые вообще не напечатаны! Возможные результаты этой программы:

```
1 2 3 4 5 6 7 8 9 10
1 9 8 7 3 6 6 2 4 5
1 8 7 3 2 6 5 4 2 9
```

Итак, что же пошло не так? В этом примере мы используем оператор предварительного приращения (++) для обновления 
переменной SheepCount. Проблема возникает, когда два потока выполняют правую часть выражения, считывая «старое» значение 
до того, как любой из потоков запишет «новое» значение переменной. Эти два задания становятся излишними; оба они 
присваивают одно и то же новое значение, при этом один поток перезаписывает результаты другого. На рисунке 13.4 показана 
эта проблема с двумя потоками, предполагая, что у sheepCount начальное значение 1.

#### Рис. 13.4 - Отсутствие синхронизации потоков


На рисунке 13.4 вы можете видеть, что оба потока читают и записывают одни и те же значения, что приводит к потере одной 
из двух операций ++sheepCount. Следовательно, оператор инкремента ++ не является потокобезопасным. Как вы увидите далее 
в этой главе, неожиданный результат одновременного выполнения двух задач называется состоянием гонки.

Концептуально идея здесь заключается в том, что некоторые работники зоопарка могут бежать быстрее по дороге на поле, но 
медленнее на обратном пути и опаздывать на работу. Другие рабочие могут прийти на поле последними, но каким-то образом 
вернуться первыми и сообщить о результатах.

### Доступ к данным с помощью volatile

Ключевое слово volatile используется для обеспечения согласованности доступа к данным в памяти. Например, возможно 
(хотя и маловероятно), что наш пример SheepManager с использованием ++sheepCount вернет неожиданное значение из-за 
недопустимого доступа к памяти во время выполнения кода критической секции. Концептуально это соответствует тому, что 
один из сотрудников нашего зоопарка спотыкается на обратном пути с поля, и кто-то спрашивает его, сколько овец на 
данный момент, пока они все еще пытаются встать!

Атрибут volatile гарантирует, что только один поток изменяет переменную одновременно и что данные, считываемые 
несколькими потоками, согласованы. Таким образом, мы не прерываем работу одного из работников нашего зоопарка в 
середине выполнения. Итак, обеспечивает ли volatile потокобезопасность? Не совсем. Рассмотрим эту замену нашему 
предыдущему приложению:

```
3:     private volatile int sheepCount = 0; 
4:     private void incrementAndReport() { 
5:        System.out.print((++sheepCount)+" "); 
6:     }
```

К сожалению, этот код не является потокобезопасным и все равно может привести к пропуску чисел:

```
2 6 1 7 5 3 2 9 4 8
```

Причина, по которой этот код не является потокобезопасным, заключается в том, что ++sheepCount - это все еще две разные 
операции. Другими словами, если оператор инкремента представляет выражение sheep 
Count = sheep Count + 1, то каждая операция чтения и записи потокобезопасна, но комбинированная операция - нет. 
Возвращаясь к нашему примеру с овцами, мы не прерываем сотрудника во время работы, но у нас все равно может быть 
несколько человек в поле одновременно.

_На практике volatile используется редко. Мы рассматриваем его только потому, что известно, что он время от времени 
появляется на экзамене._

### Защита данных с помощью атомарных классов

В наших предыдущих приложениях SheepManager одни и те же значения печатались дважды, причем наибольшее значение было 9 
вместо 10. Как мы видели, оператор инкремента ++ не является потокобезопасным, даже когда используется volatile. Это не 
потокобезопасно, потому что операция не является атомарной, выполняя две задачи, чтение и запись, которые могут быть 
прерваны другими потоками.

Атомарность - это свойство операции выполняться как единая единица выполнения без какого-либо вмешательства со стороны 
другого потока. Потокобезопасная атомарная версия оператора инкремента выполняла бы чтение и запись переменной как 
единую операцию, не позволяя никаким другим потокам обращаться к переменной во время операции. На рисунке 13.5 показан 
результат создания переменной sheepCount атомарной.

В этом случае любой поток, пытающийся получить доступ к переменной sheepCount во время выполнения атомарной операции, 
должен будет дождаться завершения атомарной операции с переменной. Концептуально это похоже на установление правила для 
работников нашего зоопарка, согласно которому одновременно в поле может находиться только один сотрудник, хотя каждый из 
них может сообщать о своих результатах не по порядку.

#### Рис. 13.5 - Синхронизация потоков с использованием атомарных операций


Поскольку доступ к примитивам и ссылкам является обычным явлением в Java, Concurrency API включает множество полезных 
классов в пакете java.util.concurrent.atomic. В таблице 13.6 перечислены атомарные классы, с которыми вам следует 
ознакомиться для сдачи экзамена. Как и многие классы Concurrency API, эти классы созданы для того, чтобы облегчить 
вашу жизнь.

#### Таблица 13.6 - Атомарные классы

|               Имя класса                |                       Описание                        |  
|:---------------------------------------:|:-----------------------------------------------------:|
|              AtomicBoolean              | boolean значение, которое может обновляться атомарно. |
|              AtomicInteger              |   int значение, которое может обновляться атомарно.   |
|               AtomicLong                |  long значение, которое может обновляться атомарно.   |


Как мы используем атомарный класс? Каждый класс включает в себя множество методов, которые эквивалентны многим 
примитивным встроенным операторам, которые мы используем для примитивов, таким как оператор присваивания (=) и операторы 
приращения (++). Мы описываем распространенные атомарные методы, которые вам следует знать для экзамена, в таблице 13.7. 
Тип(type) определяется классом.

Предположим, что в следующем примере мы импортируем атомарный пакет, а затем обновляем наш класс SheepManager с помощью 
AtomicInteger:

```
3:     private AtomicInteger sheepCount = new AtomicInteger(0); 
4:     private void incrementAndReport() { 
5:        System.out.print(sheepCount.incrementAndGet()+" "); 
6:     }
```

#### Таблица 13.7 - Общие атомарные методы

|          Метод           |                                         Описание                                         |  
|:------------------------:|:----------------------------------------------------------------------------------------:|
|          get()           |                                Получает текущее значение                                 |
|    set(type newValue)    |         Устанавливает заданное значение, эквивалентное оператору присваивания =          |
| getAndSet(type newValue) |            Атомарно устанавливает новое значение и возвращает старое значение            |
|    incrementAndGet()     | Для числовых классов атомарная операция предварительного приращения эквивалентна ++value |
|    getAndIncrement()     | Для числовых классов атомарная операция предварительного приращения эквивалентна value++ |
|    decrementAndGet()     |       Для числовых классов атомарная операция пост-декремента эквивалентна --value       |
|    getAndDecrement()     |       Для числовых классов атомарная операция пост-декремента эквивалентна value--       |


Чем эта реализация отличается от наших предыдущих примеров? Когда мы запускаем эту модификацию, мы получаем различные 
выходные данные, например следующие:

```
2 3 1 4 5 6 7 8 9 10
1 4 3 2 5 6 7 8 9 10
1 4 3 5 6 2 7 8 10 9
```

В отличие от нашего предыдущего примера вывода, числа от 1 до 10 будут печататься всегда, хотя порядок по-прежнему не 
гарантируется. Не волнуйся; мы решим этот вопрос в ближайшее время. Ключевым моментом в этом разделе является то, что 
использование атомарных классов гарантирует согласованность данных между рабочими процессами и отсутствие потери 
значений из-за одновременных изменений.

### Улучшение доступа с помощью синхронизированных блоков


Хотя атомарные классы отлично защищают одну переменную, они не особенно полезны, если вам нужно выполнить серию 
команд или вызвать метод. Например, мы не можем использовать их для обновления двух атомарных переменных одновременно. 
Как нам улучшить результаты, чтобы каждый работник мог увеличивать их и сообщать о результатах по порядку?

Наиболее распространенным методом является использование монитора для синхронизации доступа. Монитор, также называемый 
блокировкой, представляет собой структуру, поддерживающую взаимное исключение, которое заключается в том, что не более 
одного потока выполняет определенный сегмент кода в данный момент времени.

В Java любой объект может использоваться в качестве монитора вместе с ключевым словом synchronized, как показано в 
следующем примере:

```
var manager = new SheepManager();
synchronized(manager) {
   // Work to be completed by one thread at a time
}
```

Этот пример называется синхронизированным блоком. Каждый поступающий поток сначала проверяет, выполняются ли какие-либо 
потоки, уже выполняющие блок. Если блокировка недоступна, поток переходит в BLOCKED состояние до тех пор, пока он не 
сможет “получить блокировку”. Если блокировка доступна (или поток уже удерживает блокировку), отдельный поток войдет в 
блок, предотвращая вход всех других потоков. Как только поток завершит выполнение блока, он снимет блокировку, позволяя 
одному из ожидающих потоков продолжить.

_Чтобы синхронизировать доступ между несколькими потоками, каждый поток должен иметь доступ к одному и тому же объекту. 
Если каждый поток синхронизируется с разными объектами, код не является потокобезопасным._

Давайте вернемся к нашему примеру SheepManager, в котором использовался ++sheepCount, и посмотрим, сможем ли мы улучшить 
результаты, чтобы каждый рабочий увеличивал и выводил счетчик по порядку. Предположим, что мы заменили наш цикл for() 
следующей реализацией:

```
11: for(int i = 0; i < 10; i++) { 
12:    synchronized(manager) { 
13:       service.submit(() -> manager.incrementAndReport()); 
14:    }
15: }
```

Устраняет ли это решение проблему? Нет, это не так! Можете ли вы определить проблему? Мы синхронизировали создание 
потоков, но не их выполнение. В этом примере потоки будут создаваться по одному за раз, но все они все равно могут 
выполняться и выполнять свою работу одновременно, что приведет к тому же типу выходных данных, который вы видели ранее. 
Мы говорили, что диагностировать и устранять проблемы с потоками на практике сложно!

Теперь мы представляем исправленную версию класса SheepManager, который отдает приказы рабочим:

```
1:  import java.util.concurrent.*; 
2:  public class SheepManager { 
3:     private int sheepCount = 0; 
4:     private void incrementAndReport() { 
5:        synchronized(this) { 
6:           System.out.print((++sheepCount)+" "); 
7:        }
8:     }
9:     public static void main(String[] args) { 
10:       ExecutorService service = Executors.newFixedThreadPool(20);
11:       try { 
12:          var manager = new SheepManager(); 
13:          for(int i = 0; i < 10; i++) 
14:             service.submit(() -> manager.incrementAndReport()); 
15:       } finally { 
16:          service.shutdown(); 
17:       } } }
```

Когда этот код будет выполнен, он будет последовательно выводить следующее:

```
1 2 3 4 5 6 7 8 9 10
```

Хотя все потоки по-прежнему создаются и выполняются одновременно, каждый из них ожидает в синхронизированном блоке, пока 
рабочий процесс увеличится, и сообщит результат перед входом. Таким образом, каждый работник зоопарка ждет возвращения 
предыдущего работника зоопарка, прежде чем выбежать на поле. Хотя то, какой работник зоопарка выбежит следующим, 
является случайным, гарантированно, что на поле будет не более одного, и что результаты будут сообщены по порядку.

Мы могли бы синхронизироваться с любым объектом, если бы это был один и тот же объект. Например, следующий фрагмент 
кода также будет работать:

```
4:     private final Object herd = new Object(); 
5:     private void incrementAndReport() { 
6:        synchronized(herd) { 
7:           System.out.print((++sheepCount)+" "); 
8:        }
9:     }
```

Хотя нам не нужно было делать переменную herd окончательной, это гарантирует, что она не будет переназначена после того, 
как потоки начнут ее использовать.

### Синхронизация методов

В предыдущем примере мы установили наш монитор, используя synchronized(this) вокруг тела метода. Java предоставляет для 
этого более удобное усовершенствование компилятора. Мы можем добавить модификатор synchronized к любому методу 
экземпляра для автоматической синхронизации самого объекта. Например, следующие два определения метода эквивалентны:

```
void sing() {
   synchronized(this) {
      System.out.print("La La La!");
   }
}
synchronized void sing() {
   System.out.print("La la la!");
}
```

Первый использует синхронизированный блок, тогда как второй использует модификатор синхронизированного метода.
Что вы будете использовать, зависит только от вас.

Мы также можем применить модификатор synchronized к статическим методам. Какой объект используется в качестве монитора 
при синхронизации статического метода? Объект класса, конечно! Например, следующие два метода эквивалентны для 
статической синхронизации внутри нашего класса SheepManager:

```
static void dance() {
   synchronized(SheepManager.class) {
      System.out.print("Time to dance!");
   }
}
static synchronized void dance() {
   System.out.print("Time to dance!");
}
```

Как и прежде, в первом примере используется синхронизированный блок, а во втором — модификатор synchronized. Вы можете 
использовать статическую синхронизацию, если вам нужно упорядочить доступ к потокам для всех экземпляров, а не для 
одного экземпляра.

### Понимание фреймворка Lock

Синхронизированный блок поддерживает только ограниченный набор функций. Например, что если мы хотим проверить, доступна 
ли блокировка, а если нет, выполнить какую-то другую задачу? Более того, если блокировка никогда не будет доступна и мы 
будем синхронизироваться по ней, мы можем ждать вечно.

Concurrency API включает в себя интерфейс Lock, который концептуально аналогичен использованию ключевого слова 
synchronized, но с гораздо большим количеством наворотов. Однако вместо синхронизации какого-либо объекта мы можем 
«заблокировать» только тот объект, который реализует интерфейс блокировки.

### Применение ReentrantLock

Интерфейс Lock довольно прост в использовании. Если вам нужно защитить фрагмент кода от многопоточной обработки, 
создайте экземпляр Lock, к которому будут иметь доступ все потоки. Затем каждый поток вызывает lock() перед входом в 
защищенный код и вызывает unlock() перед выходом из защищенного кода.

Для сравнения, ниже показаны две реализации: одна с синхронизированным блоком, другая с экземпляром Lock. Хотя решение 
Lock дольше, оно имеет ряд функций, недоступных синхронизированному блоку.

```
// Implementation #1 with a synchronized block
Object object = new Object();
synchronized(object) {
   // Protected code
}
// Implementation #2 with a Lock
Lock lock = new ReentrantLock();
try {
   lock.lock();
   // Protected code
} finally {
   lock.unlock();
}
```

Эти две реализации концептуально эквивалентны. Класс ReentrantLock — это простой монитор, реализующий интерфейс Lock и 
поддерживающий взаимное исключение. Другими словами, в любой момент времени не более одного потока может удерживать 
блокировку.

_Конечно, это не обязательно, но рекомендуется использовать блок try/finally с экземплярами Lock. Это гарантирует, что 
все полученные блокировки будут правильно сняты._

Класс ReentrantLock гарантирует, что после того, как поток вызвал lock() и получил блокировку, все остальные потоки, 
вызывающие lock(), будут ждать, пока первый поток не вызовет unlock(). Какой поток получит блокировку следующим, зависит 
от параметров, использованных для создания объекта Lock.

Класс ReentrantLock включает конструктор, который принимает одно логическое значение и устанавливает параметр 
«справедливости». Если для параметра установлено значение true, блокировка обычно предоставляется каждому потоку в том 
порядке, в котором она была запрошена. По умолчанию это значение false при использовании конструктора без аргументов. На 
практике включать справедливость следует только тогда, когда заказ абсолютно необходим, поскольку это может привести к 
значительному замедлению работы.

Помимо того, что вы всегда должны снимать блокировку, вам также необходимо быть уверенным, что вы снимаете только ту 
блокировку, которая у вас есть. Если вы попытаетесь снять блокировку, которой у вас нет, вы получите исключение во время 
выполнения.

```
Lock lock = new ReentrantLock();
lock.unlock();  // IllegalMonitorStateException
```

Интерфейс блокировки включает четыре метода, которые вам следует знать при сдаче экзамена, как указано в таблице 13.8.

### Попытка получить блокировку

Хотя класс ReentrantLock позволяет ожидать блокировки, он пока страдает от той же проблемы, что и синхронизированный 
блок. Поток может вечно ждать получения блокировки. К счастью, в таблице 13.8 есть два дополнительных метода, которые 
делают интерфейс Lock более безопасным в использовании, чем синхронизированный блок.

#### Таблица 13.8 - Методы Lock

|                     Метод                     |                                                                                            Описание                                                                                            |  
|:---------------------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|                  void lock()                  |                                                      Запрашивает блокировку и блокируется до тех пор, пока блокировка не будет получена.                                                       |
|                 void unlock()                 |                                                                                      Снимает блокировку.                                                                                       |
|               boolean tryLock()               |                               Запрашивает блокировку и немедленно возвращает. Возвращает логическое значение, указывающее, была ли блокировка успешно получена.                                |
| boolean tryLock(long timeout, TimeUnit unit)  | Запрашивает блокировку и блокирует ее на указанное время или до тех пор, пока блокировка не будет получена. Возвращает логическое значение, указывающее, была ли блокировка успешно получена.  |


Для удобства мы используем следующий метод printHello() для кода в этом разделе:

```
public static void printHello(Lock lock) {
   try {
      lock.lock();
      System.out.println("Hello");
   } finally {
      lock.unlock();
   } }
```

### tryLock()

Метод tryLock() попытается получить блокировку и немедленно вернет логический результат, указывающий, была ли получена 
блокировка. В отличие от метода lock(), он не ожидает, если другой поток уже удерживает блокировку. Он возвращается 
немедленно, независимо от того, доступна ли блокировка.

Ниже приведен пример реализации метода tryLock():

```
Lock lock = new ReentrantLock();
new Thread(() -> printHello(lock)).start();
if(lock.tryLock()) {
   try {
      System.out.println("Lock obtained, entering protected code");
   } finally {
      lock.unlock();
   }
} else {
   System.out.println("Unable to acquire lock, doing something else");
}
```

Когда вы запускаете этот код, он может выдать либо сообщение if, либо else, в зависимости от порядка выполнения. Однако 
он всегда будет печатать Hello, поскольку вызов lock() в printHello() будет ждать неопределенное время, пока блокировка 
станет доступной. Забавное упражнение — вставить в этот фрагмент несколько задержек Thread.sleep(), чтобы стимулировать 
отображение определенного сообщения.

Как и метод lock(), метод tryLock() следует использовать с блоком try/finally. К счастью, снимать блокировку нужно 
только в том случае, если она была успешно получена. По этой причине вывод функции tryLock() обычно используется в 
операторе if, чтобы метод unlock() вызывался только при получении блокировки.

_Крайне важно, чтобы ваша программа всегда проверяла возвращаемое значение метода tryLock(). Он сообщает вашей 
программе, безопасно ли продолжать операцию и нужно ли снять блокировку позже._

### tryLock(long,TimeUnit)

Интерфейс Lock включает перегруженную версию tryLock(long, TimeUnit), которая действует как гибрид lock() и tryLock(). 
Как и в двух других методах, если доступна блокировка, она немедленно возвращается с ней. Однако если блокировка 
недоступна, она будет ждать до указанного срока для блокировки.

В следующем фрагменте кода используется перегруженная версия tryLock(long,TimeUnit):

```
Lock lock = new ReentrantLock();
new Thread(() -> printHello(lock)).start();
if(lock.tryLock(10,TimeUnit.SECONDS)) {
   try {
      System.out.println("Lock obtained, entering protected code");
   } finally {
      lock.unlock();
   }
} else {
   System.out.println("Unable to acquire lock, doing something else");
}
```

Код тот же, что и раньше, за исключением того, что на этот раз один из потоков ждет до 10 секунд, чтобы получить 
блокировку.

### Получение одного и того же замка дважды

Класс ReentrantLock поддерживает счетчик количества раз, когда потоку была успешно предоставлена блокировка. Чтобы снять 
блокировку для использования другими потоками, метод unlock() должен быть вызван столько же раз, сколько раз была 
предоставлена блокировка. Следующий фрагмент кода содержит ошибку. Можете ли вы это заметить?

```
Lock lock = new ReentrantLock();
if(lock.tryLock()) {
   try {
      lock.lock();
      System.out.println("Lock obtained, entering protected code");
   } finally {
      lock.unlock();
   } }
```

Поток получает блокировку дважды, но освобождает ее только один раз. Вы можете убедиться в этом, создав новый поток 
после выполнения этого кода, который пытается получить блокировку. Следующее выводит false:

```
new Thread(() -> System.out.print(lock.tryLock())).start();  // false
```

Крайне важно снимать блокировку столько же раз, сколько она была получена! Для вызовов с помощью tryLock() вам 
необходимо вызывать unlock() только в том случае, если метод вернул true.

### Обзор фреймворка Lock

Напомним, что класс ReentrantLock поддерживает те же функции, что и синхронизированный блок, но с добавлением ряда 
улучшений:

+ Возможность запросить блокировку без блокировки.
+ Возможность запросить блокировку при блокировке на определенное время.
+ Блокировку можно создать с помощью свойства fairness, при котором блокировка предоставляется потокам в том порядке, в 
котором она была запрошена.

_Несмотря на то, что ReentrantReadWriteLock не на экзамене, это действительно полезный класс. Он включает в себя 
отдельные блокировки для чтения и записи данных и полезен в структурах данных, где чтение встречается гораздо чаще, 
чем запись. Например, если у вас есть тысяча потоков, читающих данные, но только один поток, записывающий данные, этот 
класс может помочь вам максимизировать одновременный доступ._

### Организация задач с помощью CyclicBarrier

Мы начали тему потокобезопасности с обсуждения защиты отдельных переменных, а затем перешли к блокам кода и блокировкам. 
Мы завершаем обсуждение потокобезопасности, показывая, как организовывать сложные задачи в несколько шагов.

Работники нашего зоопарка вернулись и на этот раз чистят загоны. Представьте себе загон для львов, который нужно 
опорожнить, почистить, а затем снова наполнить львами. Для выполнения задачи мы поручили четырем работникам зоопарка. 
Очевидно, мы не хотим начинать чистить клетку, пока в ней бродит лев, иначе мы потеряем работника зоопарка! Более того, 
мы не хотим пускать львов обратно в загон, пока его чистят.

Мы могли бы поручить всю работу одному работнику, но это было бы медленно и игнорировало бы тот факт, что у нас есть три 
работника зоопарка, готовых помочь. Лучшим решением было бы заставить всех четырех сотрудников зоопарка работать 
одновременно, делая паузу между завершением одного набора задач и началом следующего.

Для координации этих задач мы можем использовать класс CyclicBarrier:

```
import java.util.concurrent.*;
public class LionPenManager {
   private void removeLions() { System.out.println("Removing lions");   }
   private void cleanPen()    { System.out.println("Cleaning the pen"); }
   private void addLions()    { System.out.println("Adding lions");     }
   public void performTask() {
      removeLions();
      cleanPen();
      addLions();
   }
   public static void main(String[] args) {
      var service = Executors.newFixedThreadPool(4);
      try {
         var manager = new LionPenManager();
         for (int i = 0; i < 4; i++)
            service.submit(() -> manager.performTask());
      } finally {
         service.shutdown();
      } } }
```

Ниже приведен пример вывода, основанный на этой реализации:

```
Removing lions
Removing lions
Cleaning the pen
Adding lions
Removing lions
Cleaning the pen
Adding lions
Removing lions
Cleaning the pen
Adding lions
Cleaning the pen
Adding lions
```

Хотя результаты упорядочены внутри одного потока, выходные данные для нескольких рабочих процессов полностью случайны. 
Мы видим, что некоторых львов все еще удаляют, пока чистят клетку, а других добавляют еще до завершения процесса уборки. 
Будем надеяться, что никто из работников зоопарка не будет съеден!

Мы можем улучшить эти результаты, используя класс CyclicBarrier. CyclicBarrier принимает в своих конструкторах 
предельное значение, указывающее количество потоков, которые следует ожидать. По завершении каждого потока он вызывает 
метод await() на циклическом барьере. Как только указанное количество потоков вызовет await(), барьер снимается, и все 
потоки могут продолжить работу.

```
import java.util.concurrent.*;
public class LionPenManager {
   private void removeLions() { System.out.println("Removing lions");   }
   private void cleanPen()    { System.out.println("Cleaning the pen"); }
   private void addLions()    { System.out.println("Adding lions");     }
   public void performTask(CyclicBarrier c1, CyclicBarrier c2) {
      try {
         removeLions();
         c1.await();
         cleanPen();
         c2.await();
         addLions();
      } catch (InterruptedException | BrokenBarrierException e) {
         // Handle checked exceptions here
      }
   }
   public static void main(String[] args) {
      var service = Executors.newFixedThreadPool(4);
      try {
         var manager = new LionPenManager();
         var c1 = new CyclicBarrier(4);
         var c2 = new CyclicBarrier(4,
            () -> System.out.println("*** Pen Cleaned!"));
         for (int i = 0; i < 4; i++)
            service.submit(() -> manager.performTask(c1, c2));
      } finally {
         service.shutdown();
      } } }
```

Ниже приведен пример вывода, основанный на этой пересмотренной реализации нашего класса LionPenManager:

```
Removing lions
Removing lions
Removing lions
Removing lions
Cleaning the pen
Cleaning the pen
Cleaning the pen
Cleaning the pen
*** Pen Cleaned!
Adding lions
Adding lions
Adding lions
Adding lions
```

Как видите, все результаты теперь систематизированы. Удаление львов происходит за один шаг, как и очистка пера и 
повторное добавление львов. В этом примере мы использовали два разных конструктора для наших объектов CyclicBarrier, 
последний из которых по завершении запускает экземпляр Runnable.

Класс CyclicBarrier позволяет нам выполнять сложные многопоточные задачи, в то время как все потоки останавливаются и 
ждут логических барьеров. Это решение превосходит однопоточное решение, поскольку отдельные задачи, такие как удаление 
львов, могут выполняться параллельно всеми четырьмя работниками зоопарка.


---

**Повторное использование CyclicBarrier**

После достижения предела CyclicBarrier (то есть барьер разрушается) все потоки освобождаются, и количество потоков, 
ожидающих CyclicBarrier, возвращается к нулю. На этом этапе CyclicBarrier можно снова использовать для нового набора 
ожидающих потоков. Например, если наш лимит CyclicBarrier равен 5 и у нас есть 15 потоков, вызывающих await(), 
CyclicBarrier будет активирован в общей сложности три раза.

---

## Использование параллельных коллекций

Помимо управления потоками, API параллелизма включает в себя интерфейсы и классы, которые помогают координировать доступ 
к коллекциям, совместно используемым несколькими задачами. Говоря о коллекциях, мы, конечно же, имеем в виду Java 
Collections Framework, которую мы представили в главе 9 «Коллекции и дженерики». В этом разделе мы демонстрируем 
множество параллельных классов, доступных вам при использовании Concurrency API.

### Понимание ошибок согласованности памяти

Целью классов параллельной коллекции является устранение распространенных ошибок согласованности памяти. Ошибка 
согласованности памяти возникает, когда два потока имеют противоречивые представления о том, какие данные должны быть 
одинаковыми. Концептуально мы хотим, чтобы записи в одном потоке были доступны другому потоку, если он обращается к 
параллельной коллекции после того, как запись произошла.

Когда два потока пытаются изменить одну и ту же непараллельную коллекцию, JVM может выдать исключение 
ConcurrentModificationException во время выполнения. Фактически, это может произойти с одним потоком. Взгляните на 
следующий фрагмент кода:

```
11: var foodData = new HashMap<String, Integer>(); 
12: foodData.put("penguin", 1); 
13: foodData.put("flamingo", 2); 
14: for(String key: foodData.keySet()) 
15:    foodData.remove(key);
```

Этот фрагмент вызовет исключение ConcurrentModificationException во время второй итерации цикла, поскольку итератор в 
keySet() не обновляется должным образом после удаления первого элемента. Изменение первой строки для использования 
ConcurrentHashMap предотвратит выдачу исключения во время выполнения кода.

```
11: var foodData = new ConcurrentHashMap<String, Integer>();
```

Хотя мы обычно не изменяем переменную цикла, этот пример подчеркивает тот факт, что ConcurrentHashMap упорядочивает 
доступ для чтения/записи таким образом, что весь доступ к классу является согласованным. В этом фрагменте кода итератор, 
созданный функцией keySet(), обновляется, как только объект удаляется с карты.

Параллельные классы были созданы, чтобы помочь избежать распространенных проблем, при которых несколько потоков 
добавляют и удаляют объекты из одних и тех же коллекций. В любом случае все потоки должны иметь одинаковое и 
согласованное представление о структуре коллекции.

### Работа с параллельными классами

Вам следует использовать класс параллельной коллекции каждый раз, когда несколько потоков изменяют коллекцию вне 
синхронизированного блока или метода, даже если вы не ожидаете проблем с параллелизмом. Без параллельных коллекций 
обращение нескольких потоков к коллекции может привести к выдаче исключения или, что еще хуже, к повреждению данных!

_Если коллекция является неизменяемой (и содержит неизменяемые объекты), параллельные коллекции не нужны. Неизменяемые 
объекты доступны любому количеству потоков и не требуют синхронизации. По определению они не изменяются, поэтому 
вероятность ошибки согласованности памяти исключена._

При передаче параллельной коллекции вызывающему объекту может потребоваться знать конкретный класс реализации. 
Тем не менее, считается хорошей практикой передавать непараллельную ссылку на интерфейс, когда это возможно, 
аналогично тому, как мы создаем экземпляр HashMap, но часто передаем ссылку на Map:

```
Map<String,Integer> map = new ConcurrentHashMap<>();
```

В таблице 13.9 перечислены распространенные параллельные занятия, с которыми вам следует ознакомиться для сдачи экзамена.

#### Таблица 13.9 - Параллельные классы коллекций

|      Имя класса       |                                Интерфейсы коллекций Java                                | Сортировано? | Блокировка? |  
|:---------------------:|:---------------------------------------------------------------------------------------:|:------------:|:-----------:|
|   ConcurrentHashMap   |                                 Map <br/> ConcurrentMap                                 |     Нет      |     Нет     |
| ConcurrentLinkedQueue |                                          Queue                                          |     Нет      |     Нет     |
| ConcurrentSkipListMap | Map <br/> SortedMap <br/> NavigableMap <br/> ConcurrentMap <br/> ConcurrentNavigableMap |      Да      |     Нет     |
| ConcurrentSkipListSet |                         Set <br/> SortedSet <br/>  NavigableSet                         |      Да      |     Нет     |
| CopyOnWriteArrayList  |                                          List                                           |     Нет      |     Нет     |
|  CopyOnWriteArraySet  |                                           Set                                           |     Нет      |     Нет     |
| LinkedBlockingQueue   |                               Queue <br/> BlockingQueue                                 |     Нет      |     Да      |


Большинство классов в таблице 13.9 представляют собой просто параллельные версии своих непараллельных классов-аналогов, 
таких как ConcurrentHashMap vs. Map или ConcurrentLinkedQueue vs. Queue. Для сдачи экзамена вам не нужно знать 
какие-либо параллельные методы, специфичные для класса. Вам просто нужно знать унаследованные методы, такие как 
get() и set() для экземпляров List.

Классы Skip могут показаться странными, но они представляют собой просто «отсортированные» версии связанных 
параллельных коллекций. Когда вы видите класс с Skip в названии, просто подумайте об «отсортированных параллельных» 
коллекциях, а остальное должно следовать естественным путем.

Классы CopyOnWrite ведут себя немного иначе, чем другие параллельные примеры, которые вы видели. Эти классы создают 
копию коллекции каждый раз, когда ссылка добавляется, удаляется или изменяется в коллекции, а затем обновляют исходную 
ссылку на коллекцию, чтобы она указывала на копию. Эти классы обычно используются для того, чтобы итератор не видел 
изменений в коллекции.

Давайте посмотрим, как это работает на примере:

```
List<Integer> favNumbers = new CopyOnWriteArrayList<>(List.of(4, 3, 42));
for (var n : favNumbers) {
   System.out.print(n + " ");                      // 4 3 42
   favNumbers.add(n+1);
}
System.out.println();
System.out.println("Size: " + favNumbers.size());  // Size: 6
```

Несмотря на добавление элементов, итератор не изменяется, и цикл выполняется ровно три раза. Альтернативно, если бы мы 
использовали обычный объект ArrayList, исключение ConcurrentModificationException было бы выброшено во время выполнения. 
Классы CopyOnWrite могут использовать много памяти, поскольку новая структура коллекции создается при каждом изменении 
коллекции. Поэтому они обычно используются в многопоточных средах, где чтение встречается гораздо чаще, чем запись.

_Экземпляр CopyOnWrite похож на неизменяемый объект, поскольку новая базовая структура создается при каждом изменении 
коллекции. Однако в отличие от истинного неизменяемого объекта ссылка на объект остается неизменной даже при изменении 
базовых данных._

Наконец, таблица 13.9 включает LinkedBlockingQueue, который реализует параллельный интерфейс BlockingQueue. Этот класс 
похож на обычный Queue, за исключением того, что он включает перегруженные версии offer() и poll(), требующие тайм-аута. 
Эти методы ждут (или блокируют) определенное время для завершения операции.

### Получение синхронизированных коллекций

Помимо рассмотренных нами классов параллельных коллекций, API Concurrency также включает методы для получения 
синхронизированных версий существующих объектов непараллельных коллекций. Эти синхронизированные методы определены в 
классе Collections. Они работают с введенной коллекцией и возвращают ссылку того же типа, что и базовая коллекция. Мы 
перечислили эти статические методы в таблице 13.10.

#### Таблица 13.10 - Методы синхронизированных коллекций

|                                               |  
|:---------------------------------------------:|
|    synchronizedCollection(Collection<T> c)    |
|        synchronizedList(List<T> list)         |
|          synchronizedMap(Map<K,V> m)          |
| synchronizedNavigableMap(NavigableMap<K,V> m) |
|  synchronizedNavigableSet(NavigableSet<T> s)  |
|           synchronizedSet(Set<T> s)           |
|    synchronizedSortedMap(SortedMap<K,V> m)    |
|    synchronizedSortedSet(SortedSet<T> s)      |


Если вы пишете код для создания коллекции и требует синхронизации, вам следует использовать классы, определенные в 
таблице 13.9. С другой стороны, если вам передана непараллельная коллекция и вам требуется синхронизация, используйте 
методы, указанные в таблице 13.10.

## Выявление проблем с потоками

Теперь, когда вы знаете, как писать потокобезопасный код, давайте поговорим о том, что квалифицируется как проблема 
многопоточности. Проблема с потоками может возникнуть в многопоточных приложениях, когда два или более потоков 
взаимодействуют неожиданным и нежелательным образом. Например, два потока могут блокировать друг другу доступ к 
определенному сегменту кода.

Concurrency API был создан, чтобы помочь устранить потенциальные проблемы с потоковой передачей, общие для всех 
разработчиков. Как вы уже видели, Concurrency API создает потоки и управляет сложными взаимодействиями потоков для вас, 
часто всего за несколько строк кода.

Хотя Concurrency API снижает вероятность возникновения проблем с потоковой передачей, он не устраняет их. На практике 
поиск и идентификация проблем с потоковой передачей в приложении часто является одной из самых сложных задач, которые 
может решить разработчик.

### Понимание жизнеспособности

Как вы видели в этой главе, многие операции с потоками могут выполняться независимо, но некоторые требуют координации. 
Например, синхронизация метода требует, чтобы все потоки, вызывающие этот метод, ждали завершения других потоков, 
прежде чем продолжить. Ранее в этой главе вы также видели, что каждый поток в CyclicBarrier будет ждать достижения 
предела барьера, прежде чем продолжить.

Что происходит с приложением, пока все эти потоки ожидают? Во многих случаях ожидание кратковременно, и пользователь 
даже не подозревает, что произошла какая-либо задержка. Однако в других случаях ожидание может быть чрезвычайно долгим, 
а возможно, и бесконечным.

Liveness — это способность приложения выполняться своевременно. Таким образом, проблемы с работоспособностью — это те, 
при которых приложение перестает отвечать на запросы или находится в каком-то «зависшем» состоянии. Точнее, проблемы с 
работоспособностью часто являются результатом постоянного перехода потока в состояние BLOCKING или WAITING или 
многократного входа/выхода из этих состояний. Для экзамена есть три типа проблем с работоспособностью, с которыми вы 
должны быть знакомы: взаимоблокировка, голодание и активная блокировка.

### Deadlock

Deadlock возникает, когда два или более потоков блокируются навсегда, каждый из которых ожидает другого. Мы можем 
проиллюстрировать этот принцип на следующем примере. Представьте, что в нашем зоопарке живут две лисы: Фокси и Тейлз. 
Фокси любит сначала поесть, а потом попить воды, а Тейлз любит сначала выпить воды, а потом поесть. Более того, ни одно 
из животных не любит делиться, и они завершат трапезу только в том случае, если у них будет исключительный доступ как 
к пище, так и к воде.

Смотритель зоопарка размещает еду с одной стороны окружающей среды, а воду - с другой. Хотя наши лисы быстры, им все 
равно требуется 100 миллисекунд, чтобы перебежать с одной стороны окружающей среды на другую.

Что произойдет, если Фокси первым получит еду, а Тейлз - воду? Следующее приложение моделирует такое поведение:

```
import java.util.concurrent.*;
class Food {}
class Water {}
public record Fox(String name) {
   public void eatAndDrink(Food food, Water water) {
      synchronized(food) {
         System.out.println(name() + " Got Food!");
         move();
         synchronized(water) {
            System.out.println(name() + " Got Water!");
         } } }
   public void drinkAndEat(Food food, Water water) {
      synchronized(water) {
         System.out.println(name() + " Got Water!");
         move();
         synchronized(food) {
            System.out.println(name() + " Got Food!");
         } } }
   public void move() {
      try { Thread.sleep(100); } catch (InterruptedException e) {}
   }
   public static void main(String[] args) {
      // Create participants and resources
      var foxy = new Fox("Foxy");
      var tails = new Fox("Tails");
      var food = new Food();
      var water = new Water();
      // Process data
      var service = Executors.newScheduledThreadPool(10);
      try {
         service.submit(() -> foxy.eatAndDrink(food,water));
         service.submit(() -> tails.drinkAndEat(food,water));
      } finally {
         service.shutdown();
      } } }
```

В этом примере Фокси получает еду, а затем переходит на другую сторону окружающей среды, чтобы получить воду. К 
сожалению, Тейлз уже выпил воду и ждет, когда появится еда. В результате наша программа выводит следующее и зависает 
на неопределенный срок:

```
Foxy Got Food!
Tails Got Water!
```

Этот пример считается тупиком, поскольку оба участника постоянно заблокированы в ожидании ресурсов, которые никогда не 
станут доступными.

### Starvation

Starvation возникает, когда одному потоку постоянно отказывают в доступе к общему ресурсу или блокировке. Поток 
по-прежнему активен, но не может завершить свою работу из-за того, что другие потоки постоянно захватывают ресурс, к 
которому он пытается получить доступ.

В нашем примере с лисой представьте, что в нашем окружении есть стая очень голодных, очень конкурентоспособных лисиц. 
Каждый раз, когда Фокси встает, чтобы пойти за едой, одна из других лис видит ее и бросается есть раньше нее. Фокси 
может свободно бродить по вольеру, вздремнуть и позвать смотрителя зоопарка, но никогда не сможет получить доступ к еде. 
В этом примере Фокси в прямом и переносном смысле испытывает голод. Хорошо, что это всего лишь теоретический пример!

### Livelock

Livelock возникает, когда два или более потоков концептуально блокируются навсегда, хотя каждый из них все еще активен и 
пытается выполнить свою задачу. Livelock — это особый случай нехватки ресурсов, при котором два или более потоков 
активно пытаются получить набор блокировок, но не могут этого сделать и перезапускают часть процесса.

Livelock часто является результатом того, что два потока пытаются разрешить взаимоблокировку. Возвращаясь к нашему 
примеру с лисой, представьте, что Фокси и Тейлз владеют своими ресурсами еды и воды соответственно. Каждый из них 
понимает, что не может закончить трапезу в таком состоянии, поэтому они оба отпускают еду и воду, бегут на 
противоположную сторону окружающей среды и подбирают другой ресурс. Теперь у Фокси есть вода, у Тейлза есть еда, и ни 
один из них не может доесть!

Если Фокси и Тейлз продолжают этот процесс вечно, это называется живой блокировкой. И Фокси, и Тейлз активны, бегают 
туда-сюда по своей территории, но ни один из них не может закончить трапезу. Foxy и Tails выполняют своего рода 
неудачное восстановление из тупика. Каждая лиса замечает, что она потенциально входит в состояние тупика, и реагирует на 
это освобождением всех своих заблокированных ресурсов. К сожалению, процесс блокировки и разблокировки цикличен, и две 
лисы концептуально зашли в тупик.

На практике активную блокировку часто сложно обнаружить. Потоки в состоянии живой блокировки кажутся активными и 
способны отвечать на запросы, даже если они застряли в бесконечном цикле.

### Управление условиями гонки

Состояние гонки — это нежелательный результат, который возникает, когда две задачи, которые должны выполняться 
последовательно, выполняются одновременно. Ранее в этой главе мы встречались с примерами состояний гонки, когда вводили 
синхронизацию.

Хотя на рисунке 13.4 показан классический пример состояния гонки на основе потоков, теперь мы приведем более наглядный 
пример. Представьте, что два посетителя зоопарка, Оливия и София, регистрируют учетную запись на новом веб-сайте для 
посетителей зоопарка. Оба они хотят использовать одно и то же имя пользователя ZooFan, и каждый одновременно отправляет 
запрос на создание учетной записи, как показано на рисунке 13.6.

#### Рис. 13.6 - Состояние гонки при создании пользователя


Какой результат возвращает веб-сервер, когда оба пользователя пытаются создать учетную запись с одним и тем же именем 
пользователя, как показано на рисунке 13.6?

_Возможные результаты для этого состояния гонки_

+ Оба пользователя могут создавать учетные записи с именем ZooFan.
+ Ни один из пользователей не может создать учетную запись с именем ZooFan, и обоим пользователям возвращается сообщение 
об ошибке.
+ Один пользователь может создать учетную запись с именем ZooFan, а другой пользователь получает сообщение об ошибке.

Первый результат действительно плох, поскольку он приводит к тому, что пользователи пытаются войти в систему под одним 
и тем же именем пользователя. Чьи данные они видят при входе в систему? Второй результат приводит к тому, что обоим 
пользователям приходится повторять попытку, что расстраивает, но, по крайней мере, не приводит к повреждению или 
неверным данным.

Третий результат часто считается лучшим решением. Как и во второй ситуации, мы сохраняем целостность данных; но в 
отличие от второй ситуации, по крайней мере, один пользователь может продолжить работу по первому запросу, избегая 
дополнительных сценариев состояния гонки.

На экзамене вы должны понимать, что условия гонки приводят к неверным данным, если они не обрабатываются должным 
образом. Даже решение, при котором оба участника не могут продолжить работу, предпочтительнее решения, при котором в 
систему допускается попадание неверных данных.

## Работа с параллельными потоками

Мы завершаем эту главу, объединяя то, что вы узнали из главы 10 «Потоки», с концепциями, которые вы узнали в этой главе. 
Одной из самых мощных функций Stream API является встроенная поддержка параллелизма. До сих пор все потоки, с которыми 
вы работали, были последовательными потоками. Последовательный поток — это поток, в котором результаты упорядочены, при 
этом одновременно обрабатывается только одна запись.

Параллельный поток способен обрабатывать результаты одновременно, используя несколько потоков. Например, вы можете 
использовать параллельный поток и операцию map() для одновременной работы с элементами в потоке, что значительно 
повышает производительность по сравнению с обработкой одного элемента за раз.

Использование параллельного потока может изменить не только производительность вашего приложения, но и ожидаемые 
результаты. Как вы увидите, некоторые операции также требуют специальной обработки для параллельной обработки.

_Количество потоков, доступных в параллельном потоке, пропорционально количеству доступных процессоров в вашей среде._

### Создание параллельных потоков

