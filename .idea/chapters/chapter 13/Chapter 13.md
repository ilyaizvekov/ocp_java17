# Параллелизм

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Управление параллельным выполнением кода

+ Создавайте рабочие потоки с помощью Runnable и Callable, управляйте жизненным циклом потоков, включая автоматизацию, предоставляемую различными службами Executor и параллельным API.
+ Разрабатывайте потокобезопасный код, используя различные механизмы блокировки и параллельный API.
+ Обработка коллекций Java одновременно, включая использование параллельных потоков.

#### Работа с потоками и лямбда-выражениями

+ Выполнение декомпозиции, конкатенации и сокращения, а также группировки и секционирования в последовательных и параллельных потоках.

---

Как вы узнаете из главы 14 “Ввод-вывод” и главы 15 “JDBC”, компьютеры способны считывать и записывать данные на внешние 
ресурсы. К сожалению, по сравнению с операциями центрального процессора, эти дисковые / сетевые операции, как правило, 
выполняются чрезвычайно медленно — фактически настолько медленно, что если бы операционная система вашего компьютера 
останавливалась и ждала завершения каждой дисковой или сетевой операции, ваш компьютер, казалось бы, постоянно зависал.

К счастью, все операционные системы поддерживают так называемую многопоточную обработку. Идея многопоточной обработки 
заключается в том, чтобы позволить приложению или группе приложений выполнять несколько задач одновременно. Это 
позволяет задачам, ожидающим других ресурсов, уступить место другим запросам на обработку.

В этой главе мы познакомим вас с концепцией потоков и предоставим множество способов управления потоками с помощью 
Concurrency API. Потоки и параллелизм - сложные темы для понимания многими программистами, поскольку проблемы с потоками 
могут расстраивать даже опытных разработчиков. На практике проблемы параллелизма являются одними из наиболее сложных 
для диагностики и устранения.

## Знакомство с потоками

Мы начинаем эту главу с рассмотрения общей терминологии, связанной с потоками. Поток - это наименьшая единица 
выполнения, которая может быть запланирована операционной системой. Процесс - это группа связанных потоков, которые 
выполняются в одной и той же общей среде. Из этого следует, что однопоточный процесс - это процесс, содержащий ровно 
один поток, в то время как многопоточный процесс поддерживает более одного потока.

Под общей средой мы подразумеваем, что потоки в одном и том же процессе совместно используют одно и то же пространство 
памяти и могут напрямую взаимодействовать друг с другом. Ознакомьтесь с рисунком 13.1 для получения общего представления 
о потоках и их общей среде в рамках процесса.

На этом рисунке показан один процесс с тремя потоками. Также показано, как они сопоставляются с произвольным количеством 
процессоров, доступных в системе. Имейте в виду эту схему, когда мы будем обсуждать планировщики задач позже в этом 
разделе.

В этой главе мы много говорим о задачах и их связях с потоками. Задача - это отдельная единица работы, выполняемая 
потоком. На протяжении всей этой главы задача обычно будет реализовываться в виде лямбда-выражения. Поток может 
выполнять несколько независимых задач, но только одну задачу за раз.

#### Рис. 13.1 - Модель процесса


Под разделяемой памятью на рис. 13.1 мы обычно подразумеваем статические переменные, а также переменные экземпляра и 
локальные переменные, передаваемые потоку. Да, вы наконец-то видите, как статические переменные могут быть полезны для 
выполнения сложных многопоточных задач! Помните из главы 5 “Методы”, что статические методы и переменные определены в 
одном объекте класса, который является общим для всех экземпляров. Например, если один поток обновляет значение 
статического объекта, эта информация немедленно становится доступной для чтения другим потокам внутри процесса.

### Понимание параллельности потоков

Свойство одновременного выполнения нескольких потоков и процессов называется параллельностью. Как система решает, что 
выполнять, когда доступно больше потоков, чем процессоров? Операционные системы используют планировщик потоков для 
определения того, какие потоки должны выполняться в данный момент, как показано на рисунке 13.1. Например, планировщик 
потоков может использовать циклическое расписание, в котором каждый доступный поток получает равное количество циклов 
процессора для выполнения, при этом потоки посещаются в циклическом порядке.

Когда выделенное потоку время истекает, но поток не завершил обработку, происходит переключение контекста. Переключение 
контекста - это процесс сохранения текущего состояния потока и последующего восстановления состояния потока для 
продолжения выполнения. Имейте в виду, что затраты часто связаны с переключением контекста из-за потери времени и 
необходимости перезагрузки состояния потока. Интеллектуальные планировщики потоков делают все возможное, чтобы свести к 
минимуму количество переключений контекста, сохраняя при этом бесперебойную работу приложения.

Наконец, поток может прерывать или заменять другой поток, если у него более высокий приоритет, чем у другого потока. 
Приоритет потока - это числовое значение, связанное с потоком, которое принимается во внимание планировщиком потоков при 
определении того, какие потоки должны выполняться в данный момент. В Java приоритеты потоков задаются в виде целых 
значений.

### Создание потока

Одним из наиболее распространенных способов определения задачи для потока является использование экземпляра Runnable. 
Runnable - это функциональный интерфейс, который не принимает аргументов и не возвращает данных.

```
@FunctionalInterface public interface Runnable {
   void run();
}
```

С его помощью легко создать и запустить поток. Фактически, вы можете сделать это в одной строке кода, используя класс 
Thread:

```
new Thread(() -> System.out.print("Hello")).start();
System.out.print("World");
```

Первая строка создает новый объект Thread, а затем запускает его с помощью метода start(). Выводит ли этот код 
HelloWorld или WorldHello? Ответ заключается в том, что мы не знаем. В зависимости от приоритета потока/планировщика 
возможно и то, и другое. Помните, что порядок выполнения потока часто не гарантируется. На экзамене обычно представлены 
вопросы, в которых одновременно запускается несколько заданий, и вы должны определить результат.

Давайте рассмотрим более сложный пример:

```
Runnable printInventory = () -> System.out.println("Printing zoo inventory");
Runnable printRecords = () -> {
   for (int i = 0; i < 3; i++)
      System.out.println("Printing record: " + i);
};
```

Учитывая эти примеры, каков результат следующего?

```
3: System.out.println("begin"); 
4: new Thread(printInventory).start(); 
5: new Thread(printRecords).start(); 
6: new Thread(printInventory).start(); 
7: System.out.println("end");
```

Ответ заключается в том, что это неизвестно до времени выполнения. Ниже приведен только один возможный результат:

```
begin
Printing record: 0 
Printing zoo inventory 
end
Printing record: 1
Printing zoo inventory
Printing record: 2
```

В этом примере используется в общей сложности четыре потока: main() и три дополнительных потока, созданных в строках 
4-6. Каждый поток, созданный в этих строках, выполняется как асинхронная задача. Под асинхронностью мы подразумеваем, 
что поток, выполняющий метод main(), не ожидает результатов каждого вновь созданного потока, прежде чем продолжить. 
Например, строки 5 и 6 могут быть выполнены до завершения потока, созданного в строке 4. Противоположностью такому 
поведению является асинхронная задача, в которой программа ожидает (или блокирует) в строке 4 завершения выполнения 
потока, прежде чем перейти к следующей строке. Подавляющее большинство вызовов методов, используемых в этой книге, 
были синхронными вплоть до этой главы.

В то время как порядок выполнения потоков не определен после запуска потоков, порядок внутри одного потока по-прежнему 
линейный. В частности, цикл for() по-прежнему упорядочен. Кроме того, begin всегда появляется перед end.

---

**Вызов run() вместо start()**

На экзамене помните о коде, который пытается запустить поток, вызывая run() вместо start(). Вызов run() для Thread или 
Runnable не запускает новый поток. Хотя следующие фрагменты кода будут скомпилированы, ни один из них не будет выполнять 
задачу в отдельном потоке:

```
System.out.println("begin");
new Thread(printInventory).run();
new Thread(printRecords).run();
new Thread(printInventory).run();
System.out.println("end");
```

В отличие от предыдущего примера, каждая строка этого кода будет ждать завершения метода run(), прежде чем перейти к 
следующей строке. Кроме того, в отличие от предыдущей программы, выходные данные этого примера кода будут одинаковыми 
при каждом выполнении.

---

В более общем смысле мы можем создать поток и связанную с ним задачу в Java одним из двух способов:

+ Предоставьте объект Runnable или лямбда-выражение конструктору потока.
+ Создайте класс, который расширяет Thread и переопределяет метод run().

На протяжении всей этой книги мы предпочитаем создавать задачи с помощью лямбда-выражений. В конце концов, это намного 
проще, особенно когда мы переходим к Concurrency API! Создание класса, расширяющего Thread, встречается относительно 
редко и должно выполняться только при определенных обстоятельствах, например, если вам нужно перезаписать другие 
методы потоков.

### Отличительные типы потоков

Возможно, вас удивит, что все Java-приложения, включая все те, которые мы представили в этой книге, являются 
многопоточными, поскольку они включают системные потоки. Системный поток создается виртуальной машиной Java (JVM) и 
запускается в фоновом режиме приложения. Например, сборкой мусора управляет системный поток, созданный JVM.

Альтернативно, пользовательский поток - это поток, созданный разработчиком приложения для выполнения определенной 
задачи. Большинство программ, которые мы представили до сих пор, содержали только один пользовательский поток, который 
вызывает метод main(). Для простоты мы обычно называем программы, содержащие только один пользовательский поток, 
однопоточными приложениями.

Системные и пользовательские потоки могут быть созданы как потоки-демоны. Поток демона - это поток, который не будет 
препятствовать выходу JVM после завершения работы программы. Java-приложение завершает работу, когда единственными 
запущенными потоками являются потоки демона. Например, если сборка мусора - единственный оставшийся запущенным поток, 
JVM автоматически завершит работу.

Давайте взглянем на пример. Как вы думаете, что это дает в результате?

```
1:  public class Zoo { 
2:     public static void pause() {                 // Defines the thread task 
3:        try { 
4:           Thread.sleep(10_000);                  // Wait for 10 seconds 
5:        } catch (InterruptedException e) {} 
6:        System.out.println("Thread finished!"); 
7:     }
8:     
9:     public static void main(String[] unused) { 
10:       var job = new Thread(() -> pause());      // Create thread 
11:
12:       job.start();                              // Start thread 
13:       System.out.println("Main method finished!"); 
14:    } }
```

Программа выведет два утверждения с интервалом примерно в 10 секунд:

```
Main method finished!
--- 10 second wait ---
Thread finished!
```

Верно. Несмотря на то, что метод main() выполнен, JVM будет ждать завершения пользовательского потока, прежде чем 
завершать программу. Что, если мы изменим задание на поток демона, добавив это в строку 11?

```
11:       job.setDaemon(true);
```

Программа напечатает первую инструкцию и завершит работу, так и не напечатав вторую строку.

```
Main method finished!
```

Для экзамена просто помните, что по умолчанию пользовательские потоки не являются демонами, и программа будет ждать их 
завершения.

### Управление жизненным циклом потока

После создания поток находится в одном из шести состояний, показанных на рисунке 13.2. Вы можете запросить состояние 
потока, вызвав getState() для объекта потока.

#### Рис. 13.2 - Состояния потока


Каждый поток инициализируется с NEW состоянием. Как только вызывается start(), поток переходит в состояние RUNNABLE. 
Означает ли это, что он действительно работает? Не совсем: может работать, а может и нет. Состояние RUNNABLE просто 
означает, что поток может быть запущен. Как только работа потока завершена или выдано неперехваченное исключение, 
состояние потока становится TERMINATED, и работа больше не выполняется.

Находясь в состоянии RUNNABLE, поток может перейти в одно из трех состояний, в которых он приостанавливает свою работу: 
BLOCKED, WAITING или TIMED_WAITING. На этом рисунке показаны общие переходы между состояниями потока, но есть и другие 
возможности. Например, поток в состоянии WAITING может быть запущен функцией notifyAll(). Аналогично, поток, прерванный 
другим потоком, выйдет из TIMED_WAITING и сразу вернется в RUNNABLE.

В этой главе мы рассмотрим некоторые (но не все) из этих переходов. Некоторые методы, связанные с потоками, такие как 
wait(), notify() и join(), выходят за рамки экзамена и, честно говоря, их сложно использовать. Вам следует избегать их 
и как можно чаще использовать Concurrency API. Чтобы правильно использовать эти методы, требуются большие навыки 
(и немного удачи!)

### Опрос в режиме сна

Несмотря на то, что многопоточное программирование позволяет выполнять несколько задач одновременно, одному потоку часто 
приходится ждать результатов другого потока. Одним из решений является использование опроса. Опрос — это процесс 
периодической проверки данных через некоторый фиксированный интервал.

Предположим, у вас есть поток, который изменяет значение общего static counter, и ваш поток main() ожидает, пока поток 
достигнет 1 миллиона:

```
public class CheckResults {
   private static int counter = 0;
   public static void main(String[] args) {
      new Thread(() -> {
         for(int i = 0; i < 1_000_000; i++) counter++;
      }).start();
      while(counter < 1_000_000) {
         System.out.println("Not reached yet");
      }
      System.out.println("Reached: "+counter);
   } }
```

Сколько раз эта программа печатает Not reached yet? Ответ: мы не знаем! Он может выводить 0, 10 или миллион раз. 
Использование цикла while() для проверки данных без какой-либо задержки считается плохой практикой кодирования, 
поскольку оно без причины связывает ресурсы ЦП.

Мы можем улучшить этот результат, используя метод Thread.sleep() для реализации опроса и перехода в режим сна на 1000 
миллисекунд, то есть на 1 секунду:

```
public class CheckResultsWithSleep {
   private static int counter = 0;
   public static void main(String[] a) {
      new Thread(() -> {
         for(int i = 0; i < 1_000_000; i++) counter++;
      }).start();
      while(counter < 1_000_000) {
         System.out.println("Not reached yet");
         try { 
            Thread.sleep(1_000);  // 1 SECOND
         } catch (InterruptedException e) {
            System.out.println("Interrupted!");
         }
      }
      System.out.println("Reached: "+counter);
   } }
```

Хотя одна секунда может показаться небольшим количеством, теперь мы освободили ЦП для выполнения другой работы вместо 
бесконечной проверки переменной counter в цикле. Обратите внимание, что поток main() переключается между TIMED_WAITING и 
RUNNABLE при входе и выходе из sleep() соответственно.

Сколько раз цикл while() выполняется в этом пересмотренном классе? Еще неизвестно! Хотя опрос предотвращает перегрузку 
процессора потенциально бесконечным циклом, он не гарантирует, когда цикл завершится. Например, отдельный поток может 
терять время ЦП на процесс с более высоким приоритетом, что приводит к многократному выполнению цикла while() до его 
завершения.

Еще одна проблема, о которой следует беспокоиться, — это общая переменная counter. Что, если один поток читает 
переменную счетчика, а другой поток ее записывает? Поток, читающий общую переменную, может получить недопустимое или 
неожиданное значение. Мы подробно обсудим эти проблемы в следующем разделе, посвященном написанию потокобезопасного 
кода.

### Прерывание потока

Хотя наше предыдущее решение не позволяло процессору бесконечно ждать в цикле while(), за это пришлось вставить в нашу 
программу односекундную задержку. Если выполнение задачи занимает 2,1 секунды, программа будет использовать полные 3 
секунды, теряя 0,9 секунды.

Один из способов улучшить эту программу — разрешить потоку прерывать поток main() по его завершению:

```
public class CheckResultsWithSleepAndInterrupt {
   private static int counter = 0;
   public static void main(String[] a) {
      final var mainThread = Thread.currentThread();
      new Thread(() -> {
         for(int i = 0; i < 1_000_000; i++) counter++;
         mainThread.interrupt();
      }).start();
      while(counter < 1_000_000) {
         System.out.println("Not reached yet");
         try {
            Thread.sleep(1_000);  // 1 SECOND
         } catch (InterruptedException e) {
            System.out.println("Interrupted!");
         }
      }
      System.out.println("Reached: "+counter);
   } }
```

Эта улучшенная версия включает в себя как метод sleep(), чтобы избежать перегрузки процессора, так и interrupt(), 
поэтому работа потока завершается без задержки выполнения программы. Как и раньше, состояние нашего потока main() 
меняется между TIMED_WAITING и RUNNABLE. Вызов interrupt() для потока в состоянии TIMED_WAITING или WAITING приводит к 
тому, что поток main() снова становится RUNNABLE, вызывая InterruptedException. Поток также может перейти в состояние 
BLOCKED, если ему необходимо повторно получить ресурсы после пробуждения.

_Вызов interrupt() для потока, уже находящегося в состоянии RUNNABLE, не меняет это состояние. Фактически, это меняет 
поведение только в том случае, если поток периодически проверяет состояние значения Thread.isInterrupted()._

## Создание потоков с помощью API параллелизма

Java включает пакет java.util.concurrent, который мы называем Concurrency API, который поможет вам выполнить сложную 
работу по управлению потоками. API Concurrency включает интерфейс ExecutorService, который определяет службы, которые 
создают потоки и управляют ими.

Сначала вы получаете экземпляр интерфейса ExecutorService, а затем отправляете на обработку задачи службы. Платформа 
включает в себя множество полезных функций, таких как объединение потоков и планирование. Рекомендуется использовать 
эту платформу каждый раз, когда вам нужно создать и выполнить отдельную задачу, даже если вам нужен только один поток.

_На практике при написании многопоточных программ часто лучше использовать Concurrency API (или какой-либо другой 
многопоточный SDK), а не работать с объектами Thread напрямую. Библиотеки гораздо более надежны, и в них легче 
обрабатывать сложные взаимодействия._

### Представляем однопоточный исполнитель

Поскольку ExecutorService - это интерфейс, как вы получаете его экземпляр? API Concurrency включает в себя заводской 
класс Executors, который можно использовать для создания экземпляров объекта ExecutorService. Давайте перепишем наш 
предыдущий пример с двумя запускаемыми экземплярами на использование ExecutorService.

```
ExecutorService service = Executors.newSingleThreadExecutor();
try {
   System.out.println("begin");
   service.execute(printInventory);
   service.execute(printRecords);
   service.execute(printInventory);
   System.out.println("end");
} finally {
   service.shutdown();
}
```

В этом примере мы используем метод newSingleThreadExecutor() для создания службы. В отличие от нашего предыдущего 
примера, в котором у нас было четыре потока (один main() и три новых потока), у нас есть только два потока (один main() 
и один новый поток). Это означает, что результат, хотя и непредсказуемый, будет иметь меньшие вариации, чем раньше. 
Например, один из возможных результатов:

```
begin
Printing zoo inventory 
Printing record: 0 
Printing record: 1
end
Printing record: 2
Printing zoo inventory
```

Обратите внимание, что цикл printRecords больше не прерывается другими задачами Runnable, отправленными исполнителю 
потока. При использовании однопоточного исполнителя задачи гарантированно выполняются последовательно. Обратите 
внимание, что конечный текст выводится, пока наши задачи исполнителя потока все еще выполняются. Это связано с тем, что 
метод main() по-прежнему является независимым потоком от ExecutorService.

### Завершение работы исполнителя потоков

После завершения использования исполнителя потока важно вызвать метод shutdown(). Исполнитель потока создает поток, не 
являющийся демоном, при первой выполняемой задаче, поэтому отказ от вызова shutdown() приведет к тому, что ваше 
приложение никогда не завершится.

Процесс завершения работы исполнителя потока включает в себя сначала отклонение любых новых задач, отправленных 
исполнителю потока, при этом продолжается выполнение любых ранее отправленных задач. В это время вызов isShutdown() 
вернет true, а isTermination() вернет false. Если новая задача передается исполнителю потока во время его завершения, 
будет выдано исключение RejectedExecutionException. После завершения всех активных задач методы isShutdown() и 
isTermination() вернут true. На рисунке 13.3 показан жизненный цикл объекта ExecutorService.

#### Рис. 13.3 - Жизненный цикл ExecutorService


На экзамене вы должны знать, что функция shutdown() не останавливает никакие задачи, которые уже были отправлены 
исполнителю потока.

Что делать, если вы хотите отменить все текущие и предстоящие задачи? Служба ExecutorService предоставляет метод под 
названием shutdownNow(), который пытается остановить все запущенные задачи и отбрасывает все, что еще не было запущено. 
Успех не гарантирован, поскольку можно создать поток, который никогда не завершится, поэтому любая попытка его 
прерывания может быть проигнорирована.

_Как вы узнали из главы 11 «Исключения и локализация», такие ресурсы, как исполнители потоков, должны быть правильно 
закрыты, чтобы предотвратить утечки памяти. К сожалению, интерфейс ExecutorService не расширяет интерфейс AutoCloseable, 
поэтому вы не можете использовать оператор try-with-resources. Вы по-прежнему можете использовать блок finally, как мы 
делаем в этой главе. Хотя вам не обязательно использовать блок finally, это считается хорошей практикой._

### Отправка задач

Вы можете отправлять задачи в экземпляр ExecutorService несколькими способами. Первый представленный нами метод, 
execute(), унаследован от интерфейса Executor, который расширяется интерфейсом ExecutorService. Метод execute() 
принимает экземпляр Runnable и асинхронно выполняет задачу. Поскольку тип возвращаемого значения метода — void, 
он ничего не говорит нам о результате выполнения задачи. Это считается методом «выстрелил и забыл», поскольку после его 
отправки результаты не доступны напрямую вызывающему потоку.

К счастью, авторы Java добавили в интерфейс ExecutorService методы submit(), которые, как и execute(), можно 
использовать для асинхронного выполнения задач. Однако, в отличие от метода execute(), метод submit() возвращает 
экземпляр Future, который можно использовать для определения того, завершена ли задача. Его также можно использовать для 
возврата общего объекта результата после завершения задачи.

В таблице 13.1 показаны пять методов, включая метод execute() и два метода submit(), которые вам следует знать для сдачи 
экзамена. Не волнуйтесь, если вы раньше не видели Future или Callable; мы обсудим их подробно в следующем разделе.

На практике использование метода submit() очень похоже на использование метода execute(), за исключением того, что метод 
submit() возвращает экземпляр Future, который можно использовать для определения того, завершила ли выполнение задача.

#### Таблица 13.1 - Методы ExecutorService

|                               Имя метода                                |                                                                          Описание                                                                          |  
|:-----------------------------------------------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------:|
|                     void execute(Runnable command)                      |                                                   Выполняет задачу Runnable в какой-то момент в будущем.                                                   |
|                     Future<?> submit(Runnable task)                     |                             Выполняет задачу Runnable в какой-то момент в будущем и возвращает задачу, представляющую будущее.                             |
|                 <T> Future<T> submit( Callable<T> task)                 |                   Выполняет Callable задачу в какой-то момент в будущем и возвращает Future, представляющий ожидающие результаты задачи.                   |
| <T> List<Future<T>> invokeAll( Collection<? extends Callable<T>> tasks) | Выполняет заданные задачи и ожидает завершения всех задач. Возвращает список экземпляров Future в том же порядке, в котором они были в исходной коллекции. |
|       <T> T invokeAny( Collection<? extends Callable<T>> tasks)         |                                               Выполняет заданные задачи и ожидает завершения хотя бы одной.                                                |

**Отправка задач: execute() vs. submit()**

Как вы могли заметить, методы execute() и submit() практически идентичны при применении к выражениям Runnable. Метод 
submit() имеет очевидное преимущество: он делает то же самое, что и метод execute(), но с возвращаемым объектом, который 
можно использовать для отслеживания результата. Из-за этого преимущества и того факта, что метод execute() не 
поддерживает выражения Callable, мы склонны предпочитать метод submit() методу execute(), даже если мы не сохраняем 
ссылку Future.

Для сдачи экзамена вам необходимо быть знакомым с методами execute() и submit(), но в вашем собственном коде мы 
рекомендуем, когда это возможно, использовать метод submit() вместо execute().

### Ожидание результатов

Как мы узнаем, что задача, отправленная в ExecutorService, завершена? Как упоминалось в предыдущем разделе, метод 
submit() возвращает экземпляр Future<V>, который можно использовать для определения этого результата.

```
Future<?> future = service.submit(() -> System.out.println("Hello"));
```

Тип Future на самом деле является интерфейсом. Для сдачи экзамена вам не нужно знать ни один из классов, реализующих 
Future, достаточно того, что экземпляр Future возвращается различными методами API. В таблице 13.2 представлены полезные 
методы определения состояния задачи.

#### Таблица 13.1 - Методы Future


