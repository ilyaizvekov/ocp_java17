# Ввод/вывод

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование Java I/O API

+ Чтение и запись консольных и файловых данных с использованием потока ввода-вывода.
+ Сериализация и десериализация объектов Java.
+ Создавайте, перемещайте, читайте и записывайте объекты Path и их свойства с помощью API java.nio.file.

---

Что могут делать приложения Java помимо управления объектами и атрибутами в памяти? Как сохранить данные, чтобы 
информация не терялась каждый раз при завершении программы? Конечно, они используют файлы! Вы можете разработать код, 
который записывает текущее состояние приложения в файл каждый раз, когда приложение закрывается, а затем перезагружает 
данные при следующем запуске приложения. Таким образом, информация сохраняется между выполнениями программы.

В этой главе основное внимание уделяется использованию API-интерфейсов I/O (ввод-вывод) и NIO.2 (неблокирующий ввод-вывод) 
для взаимодействия с файлами и потоками ввода-вывода. Предпочтительным подходом к работе с файлами и каталогами с 
помощью новых программных приложений является использование NIO.2, а не ввода-вывода, где это возможно. Однако вы 
увидите, что эти два понятия взаимосвязаны и оба широко используются.

Мы начнем с описания того, как файлы и каталоги организованы в файловой системе, и покажем, как получить к ним доступ с 
помощью класса File и интерфейса Path. Затем мы покажем, как работать с файлами и каталогами. Мы завершаем эту главу 
более сложными темами, такими как сериализация данных, обсуждение способов чтения пользовательского ввода во время 
выполнения с использованием класса Console и взаимодействие с атрибутами файлов.


_NIO означает неблокирующий API ввода/вывода и иногда его называют новым вводом/выводом. На экзамене рассматривается NIO 
версии 2. Была версия 1, охватывающая каналы, но ее нет на экзамене._

## Ссылки на файлы и каталоги

Мы начнем эту главу с рассмотрения того, какие файлы и каталоги находятся в файловой системе. Мы также представляем 
класс File и интерфейс Path, а также способы их создания.

### Представление файловой системы

Начнем с основ. Данные хранятся на постоянных запоминающих устройствах, таких как жесткие диски и карты памяти. Файл на 
устройстве хранения содержит данные. Файлы организованы в иерархии с помощью каталогов. Каталог — это место, которое 
может содержать как файлы, так и другие каталоги. Работая с каталогами в Java, мы часто относимся к ним как к файлам. 
Фактически, мы используем одни и те же классы и интерфейсы для работы с файлами и каталогами. Например, файл и каталог 
можно переименовать одним и тем же методом Java. Обратите внимание, что в этой главе мы часто говорим «файл» для 
обозначения файла или каталога.

Для взаимодействия с файлами нам необходимо подключиться к файловой системе. Файловая система отвечает за чтение и 
запись данных на компьютере. Разные операционные системы используют разные файловые системы для управления своими 
данными. Например, системы на базе Windows используют другую файловую систему, чем системы на базе Unix. Для сдачи 
экзамена вам просто нужно знать, как вводить команды с помощью API Java. JVM автоматически подключится к локальной 
файловой системе, что позволит вам выполнять одни и те же операции на нескольких платформах.

Далее, корневой каталог — это самый верхний каталог файловой системы, от которого наследуются все файлы и каталоги. 
В Windows он обозначается буквой диска, например C:\, а в Linux — одной косой чертой /.

Путь — это представление файла или каталога в файловой системе. Каждая файловая система определяет свой собственный 
символ-разделитель путей, который используется между записями каталога. Значение слева от разделителя является 
родительским для значения справа от разделителя. Например, значение пути /user/home/zoo.txt означает, что файл zoo.txt 
находится внутри домашнего каталога, а каталог home находится внутри каталога user.

---

**Разделители файлов операционной системы**

Различные операционные системы различаются по формату имен путей. Например, в системах на базе Unix для пути 
используется косая черта /, тогда как в системах на базе Windows используется символ обратной косой черты \. Тем не 
менее, многие языки программирования и файловые системы поддерживают оба типа косой черты при написании операторов пути. 
Java предлагает системное свойство для получения символа локального разделителя для текущей среды:

```
System.out.print(System.getProperty("file.separator"));
```

---

На рисунке 14.1 мы показываем, как каталоги и файловая система организованы иерархически.

#### Рис. 14.1 - Иерархия каталогов и файлов


На этой диаграмме показан корневой каталог c:, содержащий два каталога: app и zoo, а также файл info.txt. В каталоге 
app есть еще две папки, animals и employees, а также файл java.exe. Наконец, каталог animals содержит два файла: 
Bear.java и Bear.class.

Мы используем как абсолютные, так и относительные пути к файлу или каталогу в файловой системе. Абсолютный путь к файлу 
или каталогу — это полный путь от корневого каталога до файла или каталога, включая все подкаталоги, содержащие файл или 
каталог. Альтернативно, относительный путь к файлу или каталогу — это путь от текущего рабочего каталога к файлу или 
каталогу. Например, ниже приведен абсолютный путь к файлу Bear.java:

```
C:\app\animals\Bear.java
```

Ниже приведен относительный путь к тому же файлу, при условии, что текущий каталог пользователя установлен как C:\app:

```
animals\Bear.java
```

Определение того, является ли путь относительным или абсолютным, зависит от файловой системы. Для соответствия экзамену 
мы принимаем следующие соглашения:

+ Если путь начинается с косой черты (/), он является абсолютным, с корневым каталогом /, например /bird/parrot.png.
+ Если путь начинается с буквы диска (c:), он является абсолютным, причем буква диска соответствует корневому каталогу, например C:/bird/info.
+ В противном случае это относительный путь, например bird/parrot.png.

Абсолютные и относительные пути могут содержать символы пути. Символ пути — это один из зарезервированных рядов символов, 
имеющих особое значение в некоторых файловых системах. Для сдачи экзамена вам необходимо знать два символа пути, 
перечисленных в таблице 14.1.

#### Таблица 14.1 - Символы файловой системы

| Символ |               Описание                |  
|:------:|:-------------------------------------:|
|   .    |       Ссылка на текущий каталог       |
|   ..   | Ссылка на родителя текущего каталога  |


Глядя на рисунок 14.2, предположим, что текущий каталог — /fish/shark/hammerhead. В этом случае ../swim.txt — это 
действительный относительный путь, эквивалентный /fish/shark/swim.txt. Аналогично, ./play.png ссылается на play.png в 
текущем каталоге. Эти символы также можно комбинировать для большего эффекта. Например, ../../clownfish — это 
относительный путь, эквивалентный /fish/clownfish в файловой системе.

Иногда вы увидите избыточные или ненужные символы пути. Например, абсолютный путь /fish/clownfish/../shark/./swim.txt 
можно упростить до /fish/shark/swim.txt. Мы увидим, как справиться с этой избыточностью позже в этой главе, когда будем 
рассматривать normalize().

#### Рис. 14.2 - Относительные пути с использованием символов пути


Символическая ссылка — это специальный файл в файловой системе, который служит ссылкой или указателем на другой файл или 
каталог. Предположим, у нас есть символическая ссылка из /zoo/user/favorite на /fish/shark. Доступ к папке shark и ее 
элементам можно получить напрямую или по символической ссылке. Например, следующие пути ссылаются на один и тот же файл:

```
/fish/shark/swim.txt
/zoo/user/favorite/swim.txt
```

В общем, символические ссылки прозрачны для пользователя, поскольку операционная система заботится о разрешении ссылки 
на реальный файл. Хотя API ввода-вывода не поддерживают символические ссылки, NIO.2 включает полную поддержку создания, 
обнаружения и навигации по символическим ссылкам в файловой системе.

### Создание файла или пути

Чтобы сделать что-нибудь полезное, вам сначала понадобится объект, представляющий путь к определенному файлу или 
каталогу в файловой системе. При использовании устаревшего ввода-вывода это класс java.io.File, тогда как в NIO.2 это 
интерфейс java.nio.file.Path. Класс File и интерфейс Path не могут читать или записывать данные в файле, хотя они 
передаются как ссылка на другие классы, как вы увидите в этой главе.

_Помните, что File или Path могут представлять файл или каталог._

### Создание File

Класс File создается путем вызова его конструктора. Этот код показывает три разных конструктора:

```
File zooFile1 = new File("/home/tiger/data/stripes.txt");
File zooFile2 = new File("/home/tiger", "data/stripes.txt");
File parent = new File("/home/tiger");
File zooFile3 = new File(parent, "data/stripes.txt");

System.out.println(zooFile1.exists());
```

Все три создают объект File, который указывает на одно и то же место на диске. Если бы мы передали null в качестве 
родительского элемента конечному конструктору, он был бы проигнорирован, и метод вел бы себя так же, как одиночный 
конструктор String. Ради интереса мы также покажем, как определить, существует ли файл в файловой системе.

### Создание Path

Поскольку Path — это интерфейс, мы не можем создать экземпляр напрямую. В конце концов, у интерфейсов нет конструкторов! 
Java предоставляет ряд классов и методов, которые можно использовать для получения объектов Path.

Самый простой и понятный способ получить объект Path — использовать статический фабричный метод, определенный в Path или 
Paths. Все четыре примера указывают на одну и ту же ссылку на диске:

```
Path zooPath1 = Path.of("/home/tiger/data/stripes.txt");
Path zooPath2 = Path.of("/home", "tiger", "data", "stripes.txt");

Path zooPath3 = Paths.get("/home/tiger/data/stripes.txt");
Path zooPath4 = Paths.get("/home", "tiger", "data", "stripes.txt");

System.out.println(Files.exists(zooPath1));
```

Оба метода позволяют передавать параметр varargs для передачи дополнительных элементов пути. Значения объединяются и 
автоматически разделяются с помощью разделителя файлов, зависящего от операционной системы. Мы также показываем 
вспомогательный класс Files, который может проверять, существует ли файл в файловой системе.

Как видите, здесь есть два способа сделать одно и то же. Метод Path.of() был представлен в Java 11 как статический метод 
интерфейса. Фабричный класс Paths также предоставляет метод get(), делающий то же самое. Обратите внимание на букву s в 
конце класса Paths, чтобы отличить его от интерфейса Path. В этой главе мы используем Path.of() и Paths.get() как 
взаимозаменяемые.

_Вы могли заметить, что классы I/O и NIO.2 могут взаимодействовать с URI. Единый идентификатор ресурса (URI) — это 
строка символов, идентифицирующая ресурс. Он начинается со схемы, указывающей тип ресурса, за которым следует значение 
пути, например file:// для локальных файловых систем и http://, https:// и ftp:// для удаленных файловых систем._

### Переключение между файлом и путем

Поскольку «Файл» и «Путь» ссылаются на местоположения на диске, полезно иметь возможность конвертировать между ними. 
К счастью, Java упрощает эту задачу, предоставляя такие методы:

```
File file = new File("rabbit");
Path nowPath = file.toPath();
File backToFile = nowPath.toFile();
```

Многие старые библиотеки используют File, что упрощает получение File по Path и наоборот. При работе с новыми 
приложениями вам следует полагаться на интерфейс Path NIO.2, поскольку он содержит гораздо больше функций. Например, 
только NIO.2 обеспечивает поддержку файловой системы, о чем мы собираемся поговорить.

### Получение пути из класса FileSystems

NIO.2 широко использует создание объектов с помощью фабричных классов. Класс FileSystems создает экземпляры абстрактного 
класса FileSystem. Последний включает в себя методы работы непосредственно с файловой системой. Оба Paths.get() и 
Path.of() являются ярлыками для этого метода файловой системы. Давайте перепишем наши предыдущие примеры еще раз, чтобы 
увидеть, как получить экземпляр Path в дальнейшем:

```
Path zooPath1 = FileSystems.getDefault()
   .getPath("/home/tiger/data/stripes.txt");
Path zooPath2 = FileSystems.getDefault()
   .getPath("/home", "tiger", "data", "stripes.txt");
```

### Обзор взаимосвязей ввода-вывода и NIO.2

Модель ввода-вывода меньше, и вам нужно только понять класс File. Напротив, NIO.2 имеет больше функций и широко 
использует фабричный шаблон. Вам должен быть удобен такой подход. Для многих ваших взаимодействий с NIO.2 потребуются 
два типа: абстрактный класс или интерфейс и фабричный или вспомогательный класс. На рисунке 14.3 показаны связи между 
классами и интерфейсом, которые мы использовали до сих пор в этой главе.

#### Рис. 14.3 - Взаимоотношения классов и интерфейсов ввода-вывода и NIO.2


Внимательно просмотрите рисунок 14.3. В частности, следите за тем, является ли имя класса в единственном или 
множественном числе. Классы с именами во множественном числе включают методы для создания или работы с экземплярами 
классов/интерфейсов с именами в единственном числе. Помните, что для удобства (и источника путаницы) Path также можно 
создать из интерфейса Path с использованием статического метода фабрики of().

_java.io.File — это класс ввода-вывода, а Files — вспомогательный класс NIO.2. Files работает с экземплярами Path, а не 
с экземплярами java.io.File. Мы знаем, что это сбивает с толку, но они из совершенно разных API!_

В таблице 14.2 представлены рассмотренные нами API для создания объектов java.io.File и java.nio.file.Path. Читая 
таблицу, помните, что статические методы работают с классом/интерфейсом, тогда как методы экземпляра требуют экземпляра 
объекта. Прежде чем переходить к остальной части главы, убедитесь, что вы это хорошо знаете.

#### Таблица 14.2 - Параметры создания File и Path

|   Создает   | Объявлено в  |                                                  Метод или конструктор                                                   |  
|:-----------:|:------------:|:------------------------------------------------------------------------------------------------------------------------:|
|    File     |     File     | public File(String pathname) <br/> public File(File parent, String child) <br/> public File(String parent, String child) |
|    File     |     Path     |                                               public default File toFile()                                               |
|    Path     |     File     |                                                   public Path toPath()                                                   |
|    Path     |     Path     |                 public static Path of(String first, String... more) <br/> public static Path of(URI uri)                 |
|    Path     |    Paths     |                public static Path get(String first, String... more) <br/> public static Path get(URI uri)                |
|    Path     |  FileSystem  |                                    public Path getPath(String first, String... more)                                     |
| FileSystem  | FileSystems  |                                          public static FileSystem getDefault()                                           |


## Операции с File и Path

Теперь, когда мы знаем, как создавать объекты File и Path, мы можем начать использовать их для полезных действий. В 
этом разделе мы исследуем доступные нам функциональные возможности, связанные с каталогами.

### Использование общей функциональности

Многие операции можно выполнять с использованием как библиотек ввода-вывода, так и NIO.2. Многие распространенные API 
представлены в таблицах 14.3 и 14.4. Хотя эти таблицы могут показаться набором методов для изучения, многие из них 
говорят сами за себя. Вы можете пока игнорировать параметры vararg. Мы объясним это позже в этой главе.

#### Таблица 14.3 - Общие операции с File и Path

|                            Описание                            | Метод экземпляра файла ввода-вывода | Метод экземпляра пути NIO.2 |  
|:--------------------------------------------------------------:|:-----------------------------------:|:---------------------------:|
|                  Получает имя файла/каталога                   |              getName()              |        getFileName()        |
| Получает родительский каталог или значение null, если его нет. |             getParent()             |         getParent()         |
|     Проверяет, является ли файл/каталог абсолютным путем       |            isAbsolute()             |        isAbsolute()         |


#### Таблица 14.4 - Общие операции с File и Path

|                              Описание                              | Метод экземпляра файла ввода-вывода |                  Статический метод файлов NIO.2                  |  
|:------------------------------------------------------------------:|:-----------------------------------:|:----------------------------------------------------------------:|
|                        Удаляет файл/каталог                        |              delete()               |            deleteIfExists(Path p) throws IOException             |
|               Проверяет, существует ли файл/каталог                |              exists()               |                 exists(Path p, LinkOption... o)                  |
|             Получает абсолютный путь к файлу/каталогу              |          getAbsolutePath()          |                         toAbsolutePath()                         |
|              Проверяет, является ли ресурс каталогом               |            isDirectory()            |               isDirectory(Path p, LinkOption... o)               |
|                Проверяет, является ли ресурс файлом                |              isFile()               |              isRegularFile(Path p, LinkOption... o)              |
|            Возвращает время последнего изменения файла             |           lastModified()            | getLastModifiedTime(Path p, LinkOption... o) throws IOException  |
|                 Получает количество байтов в файле                 |              length()               |                 size(Path p) throws IOException                  |
|                  Перечисляет содержимое каталога                   |             listFiles()             |                 list(Path p) throws IOException                  |
|                          Создает каталог                           |               mkdir()               |  createDirectory(Path p, FileAttribute... a) throws IOException  |
| Создает каталог, включая все несуществующие родительские каталоги. |              mkdirs()               | createDirectories(Path p, FileAttribute... a) throws IOException |
|            Переименовывает файл/каталог, обозначенный              |        renameTo( File dest)         |  move(Path src, Path dest, CopyOption... o) throws IOException   |

Теперь давайте попробуем использовать некоторые из этих API. Ниже приведен пример программы, использующей только 
устаревшие API ввода-вывода. Учитывая путь к файлу, он выводит информацию о файле или каталоге, например, существует ли 
он, какие файлы в нем содержатся и т. д.:

```
10: public static void io() { 
11:    var file = new File("C:\\data\\zoo.txt"); 
12:    if (file.exists()) { 
13:       System.out.println("Absolute Path: " + file.getAbsolutePath()); 
14:       System.out.println("Is Directory: " + file.isDirectory()); 
15:       System.out.println("Parent Path: " + file.getParent()); 
16:       if (file.isFile()) { 
17:          System.out.println("Size: " + file.length()); 
18:          System.out.println("Last Modified: " + file.lastModified()); 
19:       } else {
20:          for (File subfile : file.listFiles()) { 
21:             System.out.println("   " + subfile.getName()); 
22:       } } } }
```

Если указанный путь указывает на действительный файл, программа выводит что-то похожее на следующее из-за оператора if 
в строке 16:

```
Absolute Path: C:\data\zoo.txt
Is Directory: false
Parent Path: C:\data
Size: 12382
Last Modified: 1650610000000
```

Наконец, если указанный путь указывает на допустимый каталог, например C:\data, программа выводит что-то похожее на 
следующее, благодаря блоку else:

```
Absolute Path: C:\data
Is Directory: true
Parent Path: C:\
   employees.txt
   zoo.txt
   zoo-backup.txt
```

В этих примерах вы видите, что выходные данные программы ввода-вывода полностью зависят от каталогов и файлов, доступных 
во время выполнения в базовой файловой системе.

На экзамене вы можете увидеть пути, которые выглядят как файлы, но являются каталогами или наоборот. Например, 
/data/zoo.txt может быть файлом или каталогом, даже если у него есть расширение файла. Не думайте, что это так, если 
вопрос не говорит вам об этом!

_В предыдущем примере мы использовали две обратную косую черту (\\) в строке пути, например C:\\data\\zoo.txt. Когда 
компилятор видит \\ внутри выражения String, он интерпретирует его как одно значение \._

Теперь давайте напишем ту же самую программу, используя только NIO.2, и посмотрим, чем она отличается:

```
25: public static void nio() throws IOException { 
26:    var path = Path.of("C:\\data\\zoo.txt"); 
27:    if (Files.exists(path)) { 
28:       System.out.println("Absolute Path: " + path.toAbsolutePath()); 
29:       System.out.println("Is Directory: " + Files.isDirectory(path)); 
30:       System.out.println("Parent Path: " + path.getParent()); 
31:       if (Files.isRegularFile(path)) { 
32:          System.out.println("Size: " + Files.size(path));
33:          System.out.println("Last Modified: " 
34:             + Files.getLastModifiedTime(path)); 
35:       } else { 
36:          try (Stream<Path> stream = Files.list(path)) { 
37:             stream.forEach(p -> 
38:                System.out.println("   " + p.getName())); 
39:       } } } }
```

Большая часть этого примера эквивалентна и заменяет вызовы методов ввода-вывода в предыдущих таблицах версиями NIO.2. 
Однако есть ключевые различия. Во-первых, строка 25 объявляет проверенное исключение. Больше API в NIO.2 выбрасывают 
IOException, чем API ввода-вывода. В этом случае Files.size(), Files.getLastModifiedTime() и Files.list() вызывают 
исключение IOException.

Во-вторых, в строках 36-39 используются Stream и лямбда-выражение вместо цикла. Поскольку потоки используют отложенное 
вычисление, это означает, что метод будет загружать каждый элемент пути по мере необходимости, а не весь каталог сразу.

---

**Закрытие потока**

Вы заметили, что в последнем примере кода мы поместили наш объект Stream в try-with-resources? Потоковые методы NIO.2 
открывают соединение с файловой системой, которое необходимо правильно закрыть; в противном случае может произойти 
утечка ресурсов. Утечка ресурсов в файловой системе означает, что путь может быть заблокирован от изменения еще долгое 
время после завершения процесса, который его использовал.

Если вы предположили, что терминальная операция потока автоматически закроет соответствующие файловые ресурсы, вы 
ошиблись. Когда это поведение было впервые представлено, было много споров; Короче говоря, требование от разработчиков 
закрыть поток победило.

С другой стороны, не все потоки нужно закрывать: только те, которые открывают ресурсы, например те, что есть в NIO.2. 
Например, вам не нужно было закрывать ни один из потоков, с которыми вы работали в главе 10 «Потоки».

Наконец, экзамен не всегда правильно закрывает ресурсы NIO.2. Чтобы соответствовать экзамену, мы иногда пропускаем 
закрытие ресурсов NIO.2 в обзорных и практических вопросах. Всегда используйте операторы try-with-resources с этими 
методами NIO.2 в своем собственном коде.

---

В оставшейся части этого раздела мы обсуждаем только методы NIO.2, поскольку они более важны. О них также нужно знать 
больше, и они с большей вероятностью попадут на экзамен.

### Методы обработки, которые объявляют IOException

Многие из методов, представленных в этой главе, объявляют IOException. Общие причины возникновения этого исключения 
методом включают следующее:

+ Потеря связи с базовой файловой системой.
+ Файл или каталог существует, но к нему невозможно получить доступ или изменить его.
+ Файл существует, но не может быть перезаписан.
+ Файл или каталог необходим, но не существует.

Методы, которые получают доступ к файлам и каталогам или изменяют их, например, в классе Files, часто объявляют 
IOException. Как мы увидим, из этого правила есть исключения. Например, метод Files.exists() не объявляет IOException. 
Если бы он выдал исключение, когда файл не существовал, он бы никогда не смог вернуть false! Как правило, если метод 
NIO.2 объявляет исключение IOException, для него обычно требуются пути, по которым он работает.

### Предоставление дополнительных параметров NIO.2

Многие из методов NIO.2 в этой главе включают переменные аргументы, которые принимают необязательный список значений. В 
таблице 14.5 представлены аргументы, с которыми вам следует ознакомиться на экзамене.


#### Таблица 14.5 - Общие аргументы метода NIO.2

| Тип перечисления   |    Интерфейс унаследован    | Перечисляемое значение                                                              |                                                                                                                                                     Подробности                                                                                                                                                      |  
|--------------------|:---------------------------:|-------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| LinkOption         | CopyOption <br/> OpenOption | NOFOLLOW_LINKS                                                                      |                                                                                                                                       Не переходите по символическим ссылкам.                                                                                                                                        |
| StandardCopyOption |         CopyOption          | ATOMIC_MOVE <br/> COPY_ATTRIBUTES <br/> REPLACE_EXISTING                            |                                                                           Переместить файл как операцию атомарной файловой системы. <br/> Скопируйте существующие атрибуты в новый файл. <br/> Перезаписать файл, если он уже существует.                                                                            |
| StandardOpenOption |         OpenOption          | APPEND <br/> CREATE <br/> CREATE_NEW <br/> READ <br/> TRUNCATE_EXISTING <br/> WRITE | Если файл уже открыт для записи, добавьте его в конец. <br/> Создайте новый файл, если он не существует. <br/> Создавать новый файл, только если он не существует; иначе провалиться. <br/> Открыт для чтения. <br/> Если файл уже открыт для записи, сотрите файл и добавьте его в начало. <br/> Открыт для записи. |
| FileVisitOption    |            N/A              | FOLLOW_LINKS                                                                        |                                                                                                                                        Переходите по символическим ссылкам.                                                                                                                                          |
|                    |                             |                                                                                     |                                                                                                                                                                                                                                                                                                                      |
|                    |                             |                                                                                     |                                                                                                                                                                                                                                                                                                                      |
|                    |                             |                                                                                     |                                                                                                                                                                                                                                                                                                                      |


За исключением Files.copy() и Files.move(), мы не будем обсуждать эти параметры с переменными аргументами каждый раз, 
когда представляем метод. Однако их поведение должно быть прямолинейным. Например, можете ли вы выяснить, что делает 
следующий вызов Files.exists() с LinkOption в следующем фрагменте кода?

```
Path path = Paths.get("schedule.xml");
boolean exists = Files.exists(path, LinkOption.NOFOLLOW_LINKS);
```

Files.exists() просто проверяет, существует ли файл. Но если параметр является символической ссылкой, метод вместо этого 
проверяет, существует ли цель символической ссылки. Предоставление LinkOption.NOFOLLOW_LINKS означает, что поведение по 
умолчанию будет переопределено, и метод проверит, существует ли сама символическая ссылка.

Обратите внимание, что некоторые перечисления в таблице 14.5 наследуют интерфейс. Это означает, что некоторые методы 
принимают различные типы перечислений. Например, метод Files.move() принимает переменную переменную CopyOption, поэтому 
он может принимать перечисления разных типов, и со временем можно будет добавить дополнительные параметры.

```
void copy(Path source, Path target) throws IOException {
   Files.move(source, target,
      LinkOption.NOFOLLOW_LINKS,
      StandardCopyOption.ATOMIC_MOVE);
}
```

### Взаимодействие с путями NIO.2

Как и значения String, экземпляры Path неизменяемы. В следующем примере операция Path во второй строке теряется, 
поскольку p является неизменяемым:

```
Path p = Path.of("whale");
p.resolve("krill");
System.out.println(p);  // whale
```

Многие методы, доступные в интерфейсе Path, каким-то образом преобразуют значение пути и возвращают новый объект Path, 
позволяя объединять методы в цепочку. Мы продемонстрируем цепочку в следующем примере, детали которого мы обсудим в этом 
разделе главы:

```
Path.of("/zoo/../home").getParent().normalize().toAbsolutePath();
```

### Просмотр пути

Интерфейс Path содержит три метода для получения базовой информации о представлении пути. Метод toString() возвращает 
строковое представление всего пути. Фактически, это единственный метод интерфейса Path, возвращающий строку. Многие 
другие методы интерфейса Path возвращают экземпляры Path.

Методы getNameCount() и getName() часто используются вместе для получения количества элементов в пути и ссылки на каждый 
элемент соответственно. Эти два метода не включают корневой каталог как часть пути.

```
Path path = Paths.get("/land/hippo/harry.happy");
System.out.println("The Path Name is: " + path);
for(int i=0; i<path.getNameCount(); i++)
   System.out.println("   Element " + i + " is: " + path.getName(i));
```

Обратите внимание, что мы не вызывали toString() явно во второй строке. Помните, Java вызывает toString() для любого 
объекта как часть конкатенации строк. Мы используем эту функцию во всех примерах в этой главе.

Код печатает следующее:

```
The Path Name is: /land/hippo/harry.happy
   Element 0 is: land
   Element 1 is: hippo
   Element 2 is: harry.happy
```

Несмотря на то, что это абсолютный путь, корневой элемент не включен в список имен. Как мы уже говорили, эти методы не 
рассматривают корневую часть пути.

```
var p = Path.of("/");
System.out.print(p.getNameCount()); // 0
System.out.print(p.getName(0));     // IllegalArgumentException
```

Обратите внимание: если вы попытаетесь вызвать getName() с недопустимым индексом, во время выполнения будет выдано 
исключение.

_В наших примерах в качестве символа-разделителя файлов печатается / из-за используемой нами системы. Фактический 
результат может отличаться в этой главе._

### Создание части пути

Интерфейс Path включает метод subpath() для выбора частей пути. Он принимает два параметра: включающий beginIndex и 
эксклюзивный endIndex. Это должно звучать знакомо, поскольку именно так работает метод substring() в String, как вы 
видели в главе 4 «Основные API».

Следующий фрагмент кода показывает, как работает subpath(). Мы также печатаем элементы Path с помощью getName(), чтобы 
вы могли видеть, как используются индексы.

```
var p = Paths.get("/mammal/omnivore/raccoon.image");
System.out.println("Path is: " + p);
for (int i = 0; i < p.getNameCount(); i++) {
   System.out.println("   Element " + i + " is: " + p.getName(i));
}
System.out.println();
System.out.println("subpath(0,3): " + p.subpath(0, 3));
System.out.println("subpath(1,2): " + p.subpath(1, 2));
System.out.println("subpath(1,3): " + p.subpath(1, 3));
```

Вывод этого фрагмента кода следующий:

```
Path is: /mammal/omnivore/raccoon.image
   Element 0 is: mammal
   Element 1 is: omnivore
   Element 2 is: raccoon.image

subpath(0,3): mammal/omnivore/raccoon.image
subpath(1,2): omnivore
subpath(1,3): omnivore/raccoon.image
```

Подобно getNameCount() и getName(), метод subpath() имеет нулевой индекс и не включает корень. Также, как и getName(), 
subpath() выдает исключение, если предоставлены недопустимые индексы.

```
var q = p.subpath(0, 4); // IllegalArgumentException
var x = p.subpath(1, 1); // IllegalArgumentException
```

Первый пример создает исключение во время выполнения, поскольку максимальное допустимое значение индекса равно 3. 
Второй пример создает исключение, поскольку начальный и конечный индексы одинаковы, что приводит к пустому значению 
пути.

### Доступ к элементам пути

Интерфейс Path содержит множество методов для получения определенных элементов Path, возвращаемых как сами объекты Path. 
Метод getFileName() возвращает элемент Path текущего файла или каталога, а метод getParent() возвращает полный путь к 
содержащему его каталогу. Метод getParent() возвращает значение null, если он используется в корневом пути или в начале 
относительного пути. Метод getRoot() возвращает корневой элемент файла в файловой системе или значение null, если путь 
является относительным.

Рассмотрим следующий метод, который печатает различные элементы Path:

```
public void printPathInformation(Path path) {
   System.out.println("Filename is: " + path.getFileName());
   System.out.println("   Root is: " + path.getRoot());
   Path currentParent = path;
   while((currentParent = currentParent.getParent()) != null)
      System.out.println("   Current parent is: " + currentParent);
   System.out.println();
}
```

Цикл while в методе printPathInformation() продолжается до тех пор, пока getParent() не вернет значение null. Мы 
применяем этот метод к следующим трем путям:

```
printPathInformation(Path.of("zoo"));
printPathInformation(Path.of("/zoo/armadillo/shells.txt"));
printPathInformation(Path.of("./armadillo/../shells.txt"));
```

Этот пример приложения выдает следующий результат:

```
Filename is: zoo    
   Root is: null
   
Filename is: shells.txt
   Root is: /
   Current parent is: /zoo/armadillo
   Current parent is: /zoo
   Current parent is: /
   
Filename is: shells.txt
   Root is: null
   Current parent is: ./armadillo/..
   Current parent is: ./armadillo
   Current parent is: .
```

Просматривая пример вывода, вы можете увидеть разницу в поведении getRoot() на абсолютных и относительных путях. Как вы 
можете видеть в первом и последнем примерах, метод getParent() не пересекает относительные пути за пределами текущего 
рабочего каталога.

Вы также видите, что эти методы не разрешают символы пути и рассматривают их как отдельную часть пути. Хотя большинство 
методов в этой части главы рассматривают символы пути как часть пути, вскоре мы представим метод, который очищает 
символы пути.

### Разрешение путей

Предположим, вы хотите объединить пути аналогично тому, как мы объединяем строки. Метод resolve() предоставляет 
перегруженные версии, которые позволяют передавать параметр Path или String. Объект, для которого вызывается метод 
resolve(), становится основой нового объекта Path, а входной аргумент добавляется к Path. Давайте посмотрим, что 
произойдет, если мы применим метод resolve() к абсолютному и относительному пути:

```
Path path1 = Path.of("/cats/../panther");
Path path2 = Path.of("food");
System.out.println(path1.resolve(path2));
```

Фрагмент кода генерирует следующий вывод:

```
/cats/../panther/food
```

Как и другие методы, которые мы видели, resolve() не очищает символы пути. В этом примере входным аргументом метода 
resolve() был относительный путь, но что, если бы это был абсолютный путь?

```
Path path3 = Path.of("/turkey/food");
System.out.println(path3.resolve("/tiger/cage"));
```

Поскольку входной параметр является абсолютным путем, выходные данные будут следующими:

```
/tiger/cage
```

Для экзамена вы должны знать о смешивании абсолютных и относительных путей с помощью метода resolve(). Если абсолютный 
путь указан в качестве входных данных для метода, это возвращаемое значение. Проще говоря, вы не можете объединить два 
абсолютных пути с помощью resolve().

_На экзамене, когда вы увидите resolve(), подумайте о конкатенации._

### Релятивизация пути

Интерфейс Path включает метод relativize() для построения относительного пути от одного пути к другому, часто с 
использованием символов пути. Как вы думаете, что напечатают следующие примеры?

```
var path1 = Path.of("fish.txt");
var path2 = Path.of("friendly/birds.txt");
System.out.println(path1.relativize(path2));
System.out.println(path2.relativize(path1));
```

В примерах печатается следующее:

```
../friendly/birds.txt
../../fish.txt
```

Идея такова: если вам указывают путь в файловой системе, какие шаги вам нужно будет предпринять, чтобы добраться до 
другого пути? Например, чтобы перейти к файлу fish.txt из файла friendly/birds.txt, вам нужно подняться на два уровня 
вверх (сам файл считается за один уровень), а затем выбрать файл fish.txt.

Если оба значения пути являются относительными, метод relativize() вычисляет пути, как если бы они находились в одном и 
том же текущем рабочем каталоге. Альтернативно, если оба значения пути являются абсолютными, метод вычисляет 
относительный путь от одного абсолютного местоположения к другому, независимо от текущего рабочего каталога. В следующем 
примере показано это свойство при запуске на компьютере под управлением Windows:

```
Path path3 = Paths.get("E:\\habitat");
Path path4 = Paths.get("E:\\sanctuary\\raven\\poe.txt");
System.out.println(path3.relativize(path4));
System.out.println(path4.relativize(path3));
```

Этот фрагмент кода выдает следующий результат:

```
..\sanctuary\raven\poe.txt
..\..\..\habitat
```

Метод relativize() требует, чтобы оба пути были абсолютными или относительными, и выдает исключение, если типы смешаны.

```
Path path1 = Paths.get("/primate/chimpanzee");
Path path2 = Paths.get("bananas.txt");
path1.relativize(path2); // IllegalArgumentException
```

В системах на базе Windows также требуется, чтобы при использовании абсолютных путей оба пути имели один и тот же 
корневой каталог или букву диска. Например, следующее также может вызвать исключение IllegalArgumentException в системе 
под управлением Windows:

```
Path path3 = Paths.get("C:\\primate\\chimpanzee");
Path path4 = Paths.get("D:\\storage\\bananas.txt");
path3.relativize(path4); // IllegalArgumentException
```

### Нормализация пути

На данный момент мы представили ряд примеров, в которых были ненужные символы пути. К счастью, Java предоставляет метод 
normalize() для устранения ненужной избыточности в пути.

Помните, что символ пути .. относится к родительскому каталогу, а символ пути . ссылается на текущий каталог. Мы можем 
применить normalize() к некоторым из наших предыдущих путей.

```
var p1 = Path.of("./armadillo/../shells.txt");
System.out.println(p1.normalize()); // shells.txt

var p2 = Path.of("/cats/../panther/food");
System.out.println(p2.normalize()); // /panther/food

var p3 = Path.of("../../fish.txt");
System.out.println(p3.normalize()); // ../../fish.txt
```

В первых двух примерах символы пути применяются для устранения избыточности, а как насчет последнего? Это настолько 
упрощенно, насколько это возможно. Метод normalize() не удаляет все символы пути, а только те, которые можно уменьшить.

Метод normalize() также позволяет нам сравнивать эквивалентные пути. Рассмотрим следующий пример:

```
var p1 = Paths.get("/pony/../weather.txt");
var p2 = Paths.get("/weather.txt");
System.out.println(p1.equals(p2));                         // false
System.out.println(p1.normalize().equals(p2.normalize())); // true
```

Метод equals() возвращает true, если два пути представляют одно и то же значение. В первом сравнении значения пути 
разные. Во втором сравнении значения путей были уменьшены до одного и того же нормализованного значения /weather.txt. 
Это основная функция метода normalize(): позволить нам лучше сравнивать различные пути.

### Получение реального пути к файловой системе

Хотя работать с теоретическими путями полезно, иногда вам нужно проверить, существует ли путь в файловой системе, 
используя toRealPath(). Этот метод аналогичен методу normalize() тем, что он удаляет любые избыточные символы пути. Он 
также похож на метод toAbsolutePath() тем, что он соединяет путь с текущим рабочим каталогом, если путь относительный.

Однако, в отличие от этих двух методов, toRealPath() выдаст исключение, если путь не существует. Кроме того, он будет 
следовать по символическим ссылкам с дополнительным параметром LinkOption varargs, чтобы игнорировать их.

Допустим, у нас есть файловая система, в которой есть символическая ссылка от /zebra к /horse. Как вы думаете, что будет 
напечатано, учитывая текущий рабочий каталог /horse/schedule?

```
System.out.println(Paths.get("/zebra/food.txt").toRealPath());
System.out.println(Paths.get(".././food.txt").toRealPath());
```

Вывод обеих строк следующий:

```
/horse/food.txt
```

В этом примере абсолютный и относительный пути разрешаются к одному и тому же абсолютному файлу, поскольку символическая 
ссылка указывает на реальный файл в файловой системе. Мы также можем использовать метод toRealPath(), чтобы получить 
доступ к текущему рабочему каталогу как к объекту Path.

```
System.out.println(Paths.get(".").toRealPath());
```

### Обзор API-интерфейсов NIO.2 Path

В этом разделе мы рассмотрели множество методов экземпляра Path. В таблице 14.6 они перечислены для проверки.

#### Таблица 14.6 - API Path

|                                 Описание                                  |                      Метод или конструктор                      |  
|:-------------------------------------------------------------------------:|:---------------------------------------------------------------:|
|                        Путь к файлу в виде строки                         |                    public String toString()                     |
|                               Один сегмент                                |                 public Path getName(int index)                  |
|                           Количество сегментов                            |                    public int getNameCount()                    |
|                           Сегменты в диапазоне                            |        public Path subpath(int beginIndex, int endIndex)        |
|                          Заключительный сегмент                           |                    public Path getFileName()                    |
|                         Непосредственный родитель                         |                     public Path getParent()                     |
|                          Сегмент верхнего уровня                          |                      public Path getRoot()                      |
|                             Объединение путей                             | public Path resolve(String p) <br/> public Path resolve(Path p) |
|                Построить путь к одному из предоставленных                 |                 public Path relativize(Path p)                  |
|                         Удалить лишние части пути                         |                     public Path normalize()                     |
| Перейдите по символическим ссылкам, чтобы найти путь в файловой системе.  |                    public Path toRealPath()                     |


### Создание, перемещение и удаление файлов и каталогов

Поскольку создание, перемещение и удаление имеют некоторые нюансы, мы подробно рассмотрим их в этом разделе.

### Создание каталогов

Чтобы создать каталог, мы используем следующие методы Files:

```
public static Path createDirectory(Path dir,
   FileAttribute<?>... attrs) throws IOException

public static Path createDirectories(Path dir,
   FileAttribute<?>... attrs) throws IOException
```

Метод createDirectory() создаст каталог и выдаст исключение, если он уже существует или если пути, ведущие к каталогу, 
не существуют. Метод createDirectories() создает целевой каталог вместе со всеми несуществующими родительскими 
каталогами, ведущими к этому пути. Если все каталоги уже существуют, createDirectories() просто завершится, 
ничего не делая. Это полезно в ситуациях, когда вы хотите убедиться, что каталог существует, и создать его, если его нет.

Оба этих метода также принимают необязательный список значений FileAttribute<?> для применения к вновь созданному 
каталогу или каталогам. Мы обсудим атрибуты файлов ближе к концу главы.

Ниже показано, как создавать каталоги:

```
Files.createDirectory(Path.of("/bison/field"));
Files.createDirectories(Path.of("/bison/field/pasture/green"));
```

В первом примере создается новый каталог field в каталоге /bison, предполагая, что /bison существует; в противном 
случае выдается исключение. Сравните это со вторым примером, в котором создается зеленый каталог вместе с любым из 
следующих родительских каталогов, если они еще не существуют, включая bison, field и pasture.

### Копирование файлов

Класс Files предоставляет метод копирования файлов и каталогов внутри файловой системы.

```
public static Path copy(Path source, Path target,
   CopyOption... options) throws IOException
```

Метод копирует файл или каталог из одного места в другое, используя объекты Path. Ниже показан пример копирования файла 
и каталога:

```
Files.copy(Paths.get("/panda/bamboo.txt"),
   Paths.get("/panda-save/bamboo.txt"));
   
Files.copy(Paths.get("/turtle"), Paths.get("/turtleCopy"));
```

Когда каталоги копируются, копия неглубокая. Неглубокое копирование означает, что файлы и подкаталоги внутри каталога не 
копируются. Глубокая копия означает, что копируется все дерево, включая все его содержимое и подкаталоги. Глубокая копия 
обычно требует рекурсии, при которой метод вызывает сам себя.

```
public void copyPath(Path source, Path target) {
   try {
      Files.copy(source, target);
      if(Files.isDirectory(source)) {
        try (Stream<Path> s = Files.list(source)) {
           s.forEach(p -> copyPath(p,
              target.resolve(p.getFileName())));
        }
        } catch(IOException e) {
            // Handle exception
        }
      }
   }
```

Метод сначала копирует путь, будь то файл или каталог. Если это каталог, выполняется только поверхностное копирование. 
Затем он проверяет, является ли путь каталогом, и, если да, выполняет рекурсивное копирование каждого из его элементов. 
Что, если метод встретит символическую ссылку? Не волнуйтесь: JVM не будет следовать символическим ссылкам при 
использовании метода list().

### Копирование и замена файлов

По умолчанию, если цель уже существует, метод copy() выдаст исключение. Это поведение можно изменить, предоставив методу 
значение перечисления StandardCopyOption REPLACE_EXISTING. Следующий вызов метода перезапишет файл movie.txt, если он 
уже существует:

```
Files.copy(Paths.get("book.txt"), Paths.get("movie.txt"),
   StandardCopyOption.REPLACE_EXISTING);
```

Для экзамена вам нужно знать, что без опции REPLACE_EXISTING этот метод выдаст исключение, если файл уже существует.

### Копирование файлов с помощью потоков ввода-вывода

Класс Files включает два метода copy(), которые работают с потоками ввода-вывода.

```
public static long copy(InputStream in, Path target,
   CopyOption... options) throws IOException

public static long copy(Path source, OutputStream out)
   throws IOException
```

Первый метод считывает содержимое потока ввода-вывода и записывает выходные данные в файл. Второй метод считывает 
содержимое файла и записывает выходные данные в поток ввода-вывода. Эти методы весьма удобны, если вам нужно быстро 
прочитать/записать данные с/на диск.

Ниже приведены примеры каждого метода copy():

```
try (var is = new FileInputStream("source-data.txt")) {
  // Write I/O stream data to a file
  Files.copy(is, Paths.get("/mammals/wolf.txt"));
}

Files.copy(Paths.get("/fish/clown.xsl"), System.out);
```

Хотя в первом примере мы использовали FileInputStream, поток ввода-вывода мог быть любым допустимым потоком ввода-вывода, 
включая подключения к веб-сайту, ресурсы потока в памяти и т. д. Второй пример печатает содержимое файла непосредственно 
в поток System.out.

### Копирование файлов в каталог

На экзамене важно понимать, как метод copy() работает как с файлами, так и с каталогами. Например, предположим, что у 
нас есть файл food.txt и каталог /enclosure. И файл, и каталог существуют. Как вы думаете, каков результат выполнения 
следующего процесса?

```
var file = Paths.get("food.txt");
var directory = Paths.get("/enclosure");
Files.copy(file, directory);
```

Если вы сказали, что будет создан новый файл /enclosure/food.txt, вы ошиблись. Это вызывает исключение. Команда пытается 
создать новый файл с именем /enclosure. Поскольку путь /enclosure уже существует, во время выполнения выдается исключение.

С другой стороны, если бы каталог не существовал, процесс создал бы новый файл с содержимым food.txt, но этот файл будет 
называться /enclosure. Помните, мы говорили, что файлам могут не обязательно иметь расширения, и в данном примере это 
имеет значение.

Такое поведение применимо как к методам copy(), так и к методам move(), последний из которых мы рассмотрим далее. Если 
вам интересно, правильный способ скопировать файл в каталог — сделать следующее:

```
var file = Paths.get("food.txt");
var directory = Paths.get("/enclosure/food.txt");
Files.copy(file, directory);
```

### Перемещение или переименование путей с помощью move()

Класс Files предоставляет полезный метод для перемещения или переименования файлов и каталогов.

```
public static Path move(Path source, Path target,
   CopyOption... options) throws IOException
```

В следующем примере кода используется метод move():

```
Files.move(Path.of("C:\\zoo"), Path.of("C:\\zoo-new"));

Files.move(Path.of("C:\\user\\addresses.txt"),
   Path.of("C:\\zoo-new\\addresses2.txt"));
```

В первом примере каталог zoo переименовывается в каталог zoo-new, сохраняя все исходное содержимое из исходного 
каталога. Во втором примере файл «addresses.txt» перемещается из каталога «user» в каталог «zoo-new» и переименовывается 
в «addresses2.txt».

### Сходства между move() и copy()

Как и copy(), метод move() требует, чтобы REPLACE_EXISTING перезаписал цель, если она существует; в противном случае 
будет выдано исключение. Также, как и метод copy(), метод move() не помещает файл в каталог, если источником является 
файл, а целью — каталог. Вместо этого он создаст новый файл с именем каталога.

### Выполнение атомарного перемещения

Еще одно значение перечисления, которое вам необходимо знать на экзамене при работе с методом move(), — это значение 
ATOMIC_MOVE StandardCopyOption.

```
Files.move(Path.of("mouse.txt"), Path.of("gerbil.txt"),
   StandardCopyOption.ATOMIC_MOVE);
```

Возможно, вы помните свойство атомарности из главы 13 «Параллелизм», и принцип атомарного перемещения аналогичен. 
Атомарное перемещение — это перемещение файла внутри файловой системы как единая неделимая операция. Другими словами, 
любой процесс, контролирующий файловую систему, никогда не увидит неполный или частично записанный файл. Если файловая 
система не поддерживает эту функцию, будет создано исключение AtomicMoveNotSupportedException.

Обратите внимание: хотя ATOMIC_MOVE доступен как член типа StandardCopyOption, он, скорее всего, выдаст исключение, если 
передать его методу copy().

### Удаление файла с помощью delete() и deleteIfExists()

Класс Files включает два метода, которые удаляют файл или пустой каталог в файловой системе.

```
public static void delete(Path path) throws IOException

public static boolean deleteIfExists(Path path) throws IOException
```

Чтобы удалить каталог, он должен быть пустым. Оба эти метода выдают исключение, если работают с непустым каталогом. 
Кроме того, если путь является символической ссылкой, будет удалена символическая ссылка, а не путь, на который 
указывает символическая ссылка.

Методы различаются тем, как они обрабатывают несуществующий путь. Метод delete() генерирует исключение, если путь не 
существует, а метод deleteIfExists() возвращает true, если удаление было успешным, или false в противном случае. Подобно 
createDirectories(), метод deleteIfExists() полезен в ситуациях, когда вы хотите убедиться, что путь не существует, и 
удалить его, если он существует.

Здесь мы предоставляем пример кода, выполняющего операции delete():

```
Files.delete(Paths.get("/vulture/feathers.txt"));
Files.deleteIfExists(Paths.get("/pigeon"));
```

В первом примере удаляется файл feathers.txt в каталоге vulture и выдается исключение NoSuchFileException, если файл или 
каталог не существует. Второй пример удаляет каталог pigeon, предполагая, что он пуст. Если каталог pigeon не существует, 
вторая строка не выдаст исключение.

### Сравнение файлов с помощью isSameFile() и mismatch()

Поскольку путь может включать в себя символы пути и символические ссылки внутри файловой системы, нельзя полагаться на 
метод equals(), чтобы узнать, ссылаются ли два экземпляра Path на один и тот же файл. К счастью, существует метод 
isSameFile(). Этот метод принимает в качестве входных данных два объекта Path, разрешает все символы пути и следует по 
символическим ссылкам. Несмотря на название, этот метод также можно использовать для определения того, ссылаются ли два 
объекта Path на один и тот же каталог.

Хотя в большинстве случаев использование isSameFile() вызывает исключение, если пути не существуют, существует особый 
случай, когда этого не происходит. Если два объекта пути равны с точки зрения метода equals(), метод просто вернет true, 
не проверяя, существует ли файл.

Предположим, что файловая система существует, как показано на рисунке 14.4, с символической ссылкой из /animals/snake 
на /animals/cobra.

#### Рис. 14.4 - Сравнение уникальности файлов 


Учитывая структуру, определенную на рисунке 14.4, что дает следующий вывод?

```
System.out.println(Files.isSameFile(
   Path.of("/animals/cobra"),
   Path.of("/animals/snake")));
   
System.out.println(Files.isSameFile(
   Path.of("/animals/monkey/ears.png"),
   Path.of("/animals/wolf/ears.png")));
```

Поскольку snake является символической ссылкой на cobra, первый пример выдает true. Во втором примере пути относятся к 
разным файлам, поэтому выводится false.

Иногда вам нужно сравнить содержимое файла, а не то, является ли он физически одним и тем же файлом. Например, у нас 
может быть два файла с текстовым hello. Метод mismatch() был введен в Java 12, чтобы помочь нам в этом. В качестве 
входных данных он принимает два объекта Path. Метод возвращает -1, если файлы одинаковы; в противном случае возвращается 
индекс первой позиции в файле, которая отличается.

```
System.out.println(Files.mismatch(
   Path.of("/animals/monkey.txt"),
   Path.of("/animals/wolf.txt")));
```

Предположим, файл monkey.txt содержит имя Harold, а файл wolf.txt содержит имя Howler. В этом случае предыдущий код 
печатает 1, потому что вторая позиция отличается, а в Java мы используем индексацию с отсчетом от нуля. Учитывая эти 
значения, как вы думаете, что напечатает этот код?

```
System.out.println(Files.mismatch(
   Path.of("/animals/wolf.txt"),
   Path.of("/animals/monkey.txt")));
```

Ответ тот же, что и в предыдущем примере. Код снова печатает 1. Метод mismatch() симметричен и возвращает один и тот же 
результат независимо от порядка параметров.

## Знакомство с потоками ввода-вывода

Теперь, когда мы разобрались с основами, давайте перейдем к потокам ввода-вывода, которые гораздо интереснее. В этом 
разделе мы покажем вам, как использовать потоки ввода-вывода для чтения и записи данных. «Ввод-вывод» относится к 
характеру доступа к данным: либо путем чтения данных из ресурса (вход), либо путем записи данных в ресурс (выход).

_Когда мы говорим о потоках ввода-вывода в этой главе, мы имеем в виду те, которые находятся в API java.io. Если мы 
говорим просто «потоки», то имеются в виду потоки из главы 10. Мы согласны, что именование может немного сбить с толку!_

### Понимание основ потока ввода-вывода

К содержимому файла можно получить доступ или записать его через поток ввода-вывода, который представляет собой список 
элементов данных, представленных последовательно. Концептуально поток ввода-вывода можно рассматривать как длинный, 
почти бесконечный поток воды, данные в котором представлены по одной волне за раз.

Мы демонстрируем этот принцип на рисунке 14.5. Поток ввода-вывода настолько велик, что, начав его читать, мы понятия не 
имеем, где его начало и конец. У нас просто есть указатель на нашу текущую позицию в потоке ввода-вывода и мы читаем 
данные по одному блоку за раз.

#### Рис. 14.5 - Визуальное представление потока ввода-вывода


Каждый тип потока ввода-вывода сегментирует данные в волну или блок определенным образом. Например, некоторые классы 
потоков ввода-вывода считывают или записывают данные как отдельные байты. Другие классы потоков ввода-вывода читают или 
записывают отдельные символы или строки символов. Кроме того, некоторые классы потоков ввода-вывода одновременно 
считывают или записывают большие группы байтов или символов, особенно те, в названии которых есть слово Buffered.

_Хотя API java.io полон потоков ввода-вывода, которые обрабатывают символы, строки, группы байтов и т. д., почти все они 
построены на основе одновременного чтения или записи отдельного байта или массива байтов. Потоки ввода-вывода более 
высокого уровня существуют как для удобства, так и для повышения производительности._

Хотя потоки ввода-вывода обычно используются с файловым вводом-выводом, чаще всего они используются для обработки 
чтения/записи любого последовательного источника данных. Например, вы можете создать приложение Java, которое отправляет 
данные на веб-сайт с помощью потока вывода и считывает результат через поток ввода.

---

**Потоки ввода-вывода могут быть большими**

При написании кода, в котором вы не знаете, каким будет размер потока ввода-вывода во время выполнения, может быть 
полезно визуализировать поток ввода-вывода как настолько большой, что все содержащиеся в нем данные не могут поместиться 
в памяти. Например, большинство компьютерных систем (на момент написания этой книги) не могли полностью хранить в памяти 
файл размером 1 ТБ. Файл по-прежнему может быть прочитан и записан программой с очень небольшим объемом памяти, 
поскольку поток ввода-вывода позволяет приложению в любой момент времени сосредоточиться только на небольшой части общего 
потока ввода-вывода.

---

### Изучение номенклатуры потоков ввода-вывода

API java.io предоставляет множество классов для создания, доступа и управления потоками ввода-вывода — их настолько 
много, что это приводит к затруднениям у многих новых разработчиков Java. Успокойся! Мы рассмотрим основные различия 
между каждым классом потока ввода-вывода и покажем, как их различать.

Даже если на экзамене вы встретите определенный поток ввода-вывода, который вам не известен, имя потока ввода-вывода 
часто дает вам достаточно информации, чтобы точно понять, что он делает.

Цель этого раздела — познакомить вас с общей терминологией и соглашениями об именах, используемыми с потоками 
ввода-вывода. Не волнуйтесь, если вы не узнаете конкретные имена классов потоков, используемые в этом разделе, или их 
функции; в этой главе мы подробно расскажем, как их использовать.

### Хранение данных в байтах

Данные хранятся в файловой системе (и памяти) как 0 или 1, называемые битами. Поскольку людям очень сложно 
читать/записывать данные, состоящие только из 0 и 1, они группируются в набор из 8 бит, называемый байтом.

А как насчет байтового примитивного типа Java? Как вы узнаете позже, когда мы используем потоки ввода-вывода, значения 
часто считываются или записываются с использованием байтовых значений и массивов.

### Byte Streams vs. Character Streams

API java.io определяет два набора классов потоков ввода-вывода для чтения и записи потоков ввода-вывода: потоки 
байтового ввода-вывода и символьные потоки ввода-вывода. В этой главе мы используем оба типа потоков ввода-вывода.

**Различия между байтовыми и символьными потоками ввода-вывода**

+ Потоки байтового ввода-вывода читают/записывают двоичные данные (0 и 1) и имеют имена классов, оканчивающиеся на InputStream или OutputStream.
+ Потоки символьного ввода-вывода читают/записывают текстовые данные и имеют имена классов, оканчивающиеся на Reader или Writer.

API часто включает в себя аналогичные классы как для байтовых, так и для символьных потоков ввода-вывода, например 
FileInputStream и FileReader. Разница между этими двумя классами основана на том, как читаются или записываются байты.

Важно помнить, что даже несмотря на то, что символьные потоки ввода-вывода не содержат слова Stream в имени своего 
класса, они все равно являются потоками ввода-вывода. Использование Reader/Writer в названии предназначено только для 
того, чтобы отличить их от потоков байтов.

_На протяжении всей главы мы будем называть InputStream и Reader входными потоками, а OutputStream и Writer будем 
называть выходными потоками._

Байтовые потоки ввода-вывода в основном используются для работы с двоичными данными, такими как изображения или 
исполняемые файлы, а символьные потоки ввода-вывода используются для работы с текстовыми файлами. Например, вы можете 
использовать класс Writer для вывода значения String в файл, не беспокоясь о базовой кодировке символов файла.

Кодировка символов определяет, как символы кодируются и сохраняются в байтах в потоке ввода-вывода, а затем считываются 
или декодируются как символы. Хотя это может показаться простым, Java поддерживает широкий спектр кодировок символов: 
от тех, которые могут использовать один байт для латинских символов, например UTF-8 и ASCII, до использования двух или 
более байтов на символ, таких как UTF-16. Для экзамена вам не нужно запоминать кодировки символов, но вы должны быть 
знакомы с названиями.

---

**Кодировка символов в Java**

В Java кодировку символов можно указать с помощью класса Charset, передав значение имени статическому 
методу Charset.forName(), как показано в следующих примерах:

```
Charset usAsciiCharset = Charset.forName("US-ASCII");
Charset utf8Charset = Charset.forName("UTF-8");
Charset utf16Charset = Charset.forName("UTF-16");
```

Java поддерживает множество кодировок символов, каждая из которых определяется своим стандартным значением имени.

---

### Input vs. Output Streams

Большинству классов InputStream соответствует соответствующий класс OutputStream, и наоборот. Например, класс 
FileOutputStream записывает данные, которые могут быть прочитаны FileInputStream. Если вы понимаете особенности 
конкретного класса потока ввода или вывода, вы, естественно, должны знать, что делает его дополняющий класс.

Отсюда следует, что большинству классов Reader соответствует класс Writer. Например, класс FileWriter записывает 
данные, которые могут быть прочитаны FileReader.

Из этого правила есть исключения. Для сдачи экзамена вы должны знать, что PrintWriter не имеет сопутствующего класса 
PrintReader. Аналогично, PrintStream — это OutputStream, у которого нет соответствующего класса InputStream. В его 
названии также нет вывода. Мы обсудим эти классы позже в этой главе.

### Низкоуровневые и высокоуровневые потоки

Другой способ ознакомиться с API java.io — сегментировать потоки ввода-вывода на потоки низкого и высокого уровня.

Поток низкого уровня напрямую соединяется с источником данных, например файлом, массивом или строкой. Потоки 
ввода-вывода низкого уровня обрабатывают необработанные данные или ресурсы, и доступ к ним осуществляется напрямую и 
без фильтрации. Например, FileInputStream — это класс, который считывает данные файла по одному байту за раз.

Альтернативно, поток высокого уровня создается поверх другого потока ввода-вывода с использованием переноса. 
Обертывание — это процесс, при котором экземпляр передается конструктору другого класса, а операции над результирующим 
экземпляром фильтруются и применяются к исходному экземпляру. Например, взгляните на объекты FileReader и BufferedReader 
в следующем примере кода:

```
try (var br = new BufferedReader(new FileReader("zoo-data.txt"))) {
   System.out.println(br.readLine());
}
```

В этом примере FileReader — это поток ввода-вывода низкого уровня, тогда как BufferedReader — это поток ввода-вывода 
высокого уровня, который принимает FileReader в качестве входных данных. Многие операции над потоком ввода-вывода 
высокого уровня передаются как операции в базовый поток ввода-вывода низкого уровня, например read() или close(). 
Другие операции переопределяют или добавляют новые функциональные возможности к методам потока ввода-вывода низкого 
уровня. В поток ввода-вывода высокого уровня могут быть добавлены новые методы, такие как readLine(), а также улучшена 
производительность чтения и фильтрации данных низкого уровня.

Потоки ввода-вывода высокого уровня также могут принимать в качестве входных данных другие потоки ввода-вывода высокого 
уровня. Например, хотя следующий код на первый взгляд может показаться немного странным, на практике такой стиль 
переноса потока ввода-вывода довольно распространен:

```
try (var ois = new ObjectInputStream(
      new BufferedInputStream(
         new FileInputStream("zoo-data.txt")))) {
   System.out.print(ois.readObject());
}
```

В этом примере FileInputStream низкого уровня напрямую взаимодействует с файлом, который обернут BufferedInputStream 
высокого уровня для повышения производительности. Наконец, весь объект обертывается другим объектом ObjectInputStream 
высокого уровня, который позволяет нам интерпретировать данные как объект Java.

Для сдачи экзамена вам необходимо знать только низкоуровневые потоковые классы, которые работают с файлами. Все 
остальные неабстрактные потоковые классы являются потоками высокого уровня.

### Базовые классы потока

Библиотека java.io определяет четыре абстрактных класса, которые являются родительскими для всех классов потоков 
ввода-вывода, определенных в API: InputStream, OutputStream, Reader и Writer.

Конструкторы потоков ввода-вывода высокого уровня часто используют ссылку на абстрактный класс. Например, 
BufferedWriter принимает в качестве входных данных объект Writer, что позволяет ему принимать любой подкласс Writer.

Одна из распространенных областей, где экзамен любит подшучивать над вами, — это смешивание и сопоставление классов 
потоков ввода-вывода, которые несовместимы друг с другом. Например, взгляните на каждый из следующих примеров и 
посмотрите, сможете ли вы определить, почему они не компилируются:

```
new BufferedInputStream(new FileReader("z.txt"));  // DOES NOT COMPILE
new BufferedWriter(new FileOutputStream("z.txt")); // DOES NOT COMPILE
new ObjectInputStream(    
   new FileOutputStream("z.txt"));                 // DOES NOT COMPILE
new BufferedInputStream(new InputStream());        // DOES NOT COMPILE
```

Первые два примера не компилируются, поскольку они смешивают классы Reader/Writer с классами InputStream/OutputStream 
соответственно. Третий пример не компилируется, поскольку мы смешиваем OutputStream с InputStream. Хотя можно читать 
данные из входного потока и записывать их в выходной поток, обертывание потока ввода-вывода не является способом сделать 
это. Как вы увидите далее в этой главе, данные необходимо скопировать. Наконец, последний пример не компилируется, 
поскольку InputStream — это абстрактный класс, и поэтому вы не можете создать его экземпляр.

### Расшифровка имен классов ввода-вывода

Обратите пристальное внимание на название класса ввода-вывода на экзамене, поскольку его расшифровка часто дает вам 
контекстные подсказки о том, что делает этот класс. Например, без необходимости поиска должно быть ясно, что FileReader 
— это класс, который считывает данные из файла в виде символов или строк. Более того, ObjectOutputStream выглядит как 
класс, который записывает данные объекта в поток байтов.

В таблице 14.7 перечислены абстрактные базовые классы, от которых наследуются все потоки ввода-вывода.

#### Таблица 14.7 - Базовые классы абстрактного потока java.io

|  Имя класса  |                       Описание                       |  
|:------------:|:----------------------------------------------------:|
| InputStream  |  Абстрактный класс для всех входных потоков байтов   |
| OutputStream |  Абстрактный класс для всех потоков выходных байтов  |
|    Reader    | Абстрактный класс для всех потоков входных символов  |
|   Writer     | Абстрактный класс для всех потоков выходных символов |


В таблице 14.8 перечислены конкретные потоки ввода-вывода, с которыми вам следует ознакомиться на экзамене. Обратите 
внимание, что большая часть информации о каждом потоке ввода-вывода, например, является ли он потоком ввода или вывода 
или обращается ли он к данным с использованием байтов или символов, может быть декодирована только по имени.

#### Таблица 14.8 - Конкретные классы потоков ввода-вывода java.io

|      Имя класса      | Низкий/высокий уровень |                                                               Описание                                                                |  
|:--------------------:|:----------------------:|:-------------------------------------------------------------------------------------------------------------------------------------:|
|   FileInputStream    |          Low           |                                                 Считывает данные файла в виде байтов                                                  |
|   FileOutputStream   |          Low           |                                                 Записывает данные файла в виде байтов                                                 |
|      FileReader      |          Low           |                                                  Считывает данные файла как символы                                                   |
|      FileWriter      |          Low           |                                                Записывает данные файла в виде символов                                                |
| BufferedInputStream  |          High          |     Считывает байтовые данные из существующего InputStream в буферизованном виде, что повышает эффективность и производительность     |
| BufferedOutputStream |          High          |  Записывает байтовые данные в существующий поток OutputStream в буферизованном виде, что повышает эффективность и производительность  |
|    BufferedReader    |          High          | Считывает символьные данные из существующего устройства чтения в буферизованном виде, что повышает эффективность и производительность |
|    BufferedWriter    |          High          |      Записывает символьные данные в существующий Writer в буферизованном режиме, что повышает эффективность и производительность      |
|  ObjectInputStream   |          High          |                     Десериализует примитивные типы данных Java и графы объектов Java из существующего InputStream                     |
|  ObjectOutputStream  |          High          |                     Сериализует примитивные типы данных Java и графики объектов Java в существующий OutputStream                      |
|     PrintStream      |          High          |                                Записывает форматированные представления объектов Java в бинарный поток                                |
|     PrintWriter      |          High          |                               Записывает форматированные представления объектов Java в поток символов                                 |


Держите под рукой таблицу 14.7 и таблицу 14.8, поскольку в этой главе вы узнаете больше о потоках ввода-вывода. 
Мы обсудим их более подробно, включая примеры каждого из них.

## Чтение и запись файлов

Существует несколько способов чтения и записи файла. Мы показываем их в этом разделе, копируя один файл в другой.

### Использование потоков ввода-вывода

Потоки ввода-вывода предназначены для чтения/записи данных, поэтому неудивительно, что наиболее важными методами 
являются read() и write(). И InputStream, и Reader объявляют метод read() для чтения байтовых данных из потока 
ввода-вывода. Аналогично, OutputStream и Writer определяют метод write() для записи байта в поток:

Следующие методы copyStream() показывают пример чтения всех значений InputStream и Reader и записи их в OutputStream и 
Writer соответственно. В обоих примерах -1 используется для обозначения конца потока.

```
void copyStream(InputStream in, OutputStream out) throws IOException {
   int b;
   while ((b = in.read()) != -1) {
      out.write(b);
   }
}

void copyStream(Reader in, Writer out) throws IOException {
   int b;
   while ((b = in.read()) != -1) {
      out.write(b);
   }
}
```

Подожди. Мы сказали, что читаем и записываем байты, так почему же методы используют int вместо byte? Помните, что тип 
данных byte имеет диапазон в 256 символов. Им требовалось дополнительное значение, указывающее на конец потока 
ввода-вывода. Авторы Java решили использовать более крупный тип данных, int, чтобы специальные значения, такие как -1, 
указывали на конец потока ввода-вывода. Классы выходного потока также используют int, чтобы быть согласованными с 
классами входного потока.

Чтение и запись по одному байту за раз — не особенно эффективный способ сделать это. К счастью, существуют перегруженные 
методы для одновременного чтения и записи нескольких байтов. Значения offset и length применяются к самому массиву. 
Например, offset 3 и length 5 указывают, что поток должен прочитать до пяти байтов/символов данных и поместить их в 
массив, начиная с позиции 3. Давайте рассмотрим пример:

```
10: void copyStream(InputStream in, OutputStream out) throws IOException { 
11:    int batchSize = 1024; 
12:    var buffer = new byte[batchSize]; 
13:    int lengthRead; 
14:    while ((lengthRead = in.read(buffer, 0, batchSize)) > 0) { 
15:       out.write(buffer, 0, lengthRead); 
16:       out.flush(); 
17:    }
```

Вместо чтения данных по одному байту мы читаем и записываем до 1024 байтов за раз в строке 14. Возвращаемое значение 
lengthRead имеет решающее значение для определения того, находимся ли мы в конце потока, и определения того, сколько 
байтов нам следует записать в наш выходной поток.

Если размер нашего файла не кратен 1024 байтам, последняя итерация цикла while запишет некоторое значение размером 
меньше 1024 байт. Например, если размер буфера составляет 1024 байта, а размер файла — 1054 байта, последнее чтение 
будет иметь размер всего 30 байт. Если бы мы проигнорировали это возвращаемое значение и вместо этого записали 1024 
байта, в конец файла было бы записано 994 байта из предыдущего цикла.

Мы также добавили метод flush() в строке 16, чтобы уменьшить объем потерянных данных в случае неожиданного завершения 
работы приложения. Когда данные записываются в выходной поток, базовая операционная система не гарантирует, что данные 
немедленно попадут в файловую систему. Метод flush() требует немедленной записи всех накопленных данных на диск. Однако 
это не без затрат. Каждый раз при его использовании может возникнуть заметная задержка в работе приложения, особенно для 
больших файлов. Если данные, которые вы записываете, не являются чрезвычайно важными, метод flush() следует использовать 
только время от времени. Например, его не обязательно следует вызывать после каждой записи, как в этом примере.

Эквивалентные методы существуют в Reader и Writer, но они используют char, а не byte, что делает эквивалентный метод 
copyStream() очень похожим.

В предыдущем примере чтение и запись файла кажутся предметом размышлений. Это потому, что он использует только потоки 
ввода-вывода низкого уровня. Давайте попробуем еще раз, используя потоки высокого уровня.

```
26: void copyTextFile(File src, File dest) throws IOException { 
27:    try (var reader = new BufferedReader(new FileReader(src)); 
28:       var writer = new BufferedWriter(new FileWriter(dest))) { 
29:       String line = null; 
30:       while ((line = reader.readLine()) != null) { 
31:          writer.write(line); 
32:          writer.newLine(); 
33:       } } }
```

Ключевым моментом является выбор наиболее полезных классов высокого уровня. В данном случае мы имеем дело с File, 
поэтому хотим использовать FileReader и FileWriter. Оба класса имеют конструкторы, которые могут напрямую принимать либо
String, представляющую местоположение, либо File.

Если исходный файл не существует, будет создано исключение FileNotFoundException, которое наследует IOException. Если 
целевой файл уже существует, эта реализация перезапишет его. Мы можем передать в FileWriter необязательный второй 
логический параметр для флага добавления, если хотим изменить это поведение.

Мы также решили использовать BufferedReader и BufferedWriter, чтобы можно было читать целую строку за раз. Это дает нам 
преимущества чтения пакетов символов в строке 30 без необходимости писать собственную логику. В строке 31 записывается 
сразу вся строка данных. Поскольку при чтении строки разрывы строк удаляются, мы добавляем их обратно в строку 32. В 
строках 27 и 28 демонстрируются конструкторы цепочки. Конструктор try-with-resources заботится о закрытии всех объектов 
в цепочке.

Теперь представьте, что нам нужны байтовые данные вместо символов. Нам нужно будет выбрать разные классы высокого 
уровня: BufferedInputStream, BufferedOutputStream, FileInputStream и FileOuputStream. Мы бы вызвали readAllBytes() 
вместо readLine() и сохранили результат в byte[] вместо String. Наконец, нам не нужно будет обрабатывать новые строки, 
поскольку данные являются двоичными.

Мы можем добиться большего, чем BufferedOutputStream и BufferedWriter, используя PrintStream и PrintWriter. Эти классы 
содержат четыре ключевых метода. Методы print() и println() печатают данные с новой строкой и без нее соответственно. 
Существуют также методы format() и printf(), которые мы описываем в разделе о взаимодействии с пользователем.

```
void copyTextFile(File src, File dest) throws IOException {
   try (var reader = new BufferedReader(new FileReader(src));
      var writer = new PrintWriter(new FileWriter(dest))) {
      String line = null;
      while ((line = reader.readLine()) != null)
          writer.println(line);
      }
}
```

Хотя мы использовали String, существует множество перегруженных версий println(), которые переносят все — от примитивов 
и строковых значений до объектов. Под прикрытием эти методы часто просто выполняют String.valueOf().

Классы потоков печати отличаются тем, что являются единственными рассматриваемыми классами потоков ввода-вывода, которые 
не имеют соответствующих классов входных потоков. И в отличие от других классов OutputStream, PrintStream не имеет в 
своем имени вывода.

_Вас может удивить тот факт, что на протяжении всей этой книги вы регулярно использовали PrintStream. И System.out, и 
System.err являются объектами PrintStream. Аналогично, System.in, часто полезный для чтения пользовательского ввода, 
является InputStream._

В отличие от большинства других потоков ввода-вывода, которые мы рассмотрели, методы классов потоков печати не вызывают 
никаких проверяемых исключений. Если бы они это сделали, вам пришлось бы перехватывать проверенное исключение каждый 
раз, когда вы вызывали System.out.print()!

Разделителем строк является \n или \r\n, в зависимости от вашей операционной системы. Метод println() позаботится об 
этом за вас. Если вам нужно получить персонаж напрямую, его вернет одно из следующих действий:

```
System.getProperty("line.separator");
System.lineSeparator();
```

### Улучшение с помощью Files

API-интерфейсы NIO.2 предоставляют еще более простые способы чтения и записи файла с помощью класса Files. Давайте 
начнем с рассмотрения трех способов копирования файла путем чтения данных и их обратной записи:

```
private void copyPathAsString(Path input, Path output) throws IOException {
   String string = Files.readString(input);
   Files.writeString(output, string);
}
private void copyPathAsBytes(Path input, Path output) throws IOException {
    byte[] bytes = Files.readAllBytes(input);
    Files.write(output, bytes);
}
private void copyPathAsLines(Path input, Path output) throws IOException {
   List<String> lines = Files.readAllLines(input);
   Files.write(output, lines);
}
```

Это довольно кратко! Вы можете прочитать Path как String, byte массив или List. Имейте в виду, что весь файл считывается 
одновременно для всех трех, тем самым сохраняя все содержимое файла в памяти одновременно. Если файл значительно велик, 
вы можете вызвать ошибку OutOfMemoryError при попытке загрузить весь файл в память. К счастью, есть альтернатива. На 
этот раз мы распечатываем файл по мере его чтения.

```
private void readLazily(Path path) throws IOException {
   try (Stream<String> s = Files.lines(path)) {
      s.forEach(System.out::println);
   }
}
```

Теперь содержимое файла считывается и обрабатывается лениво, а это означает, что в любой момент времени в памяти 
хранится только небольшая часть файла. Сделав еще один шаг вперед, мы можем использовать другие потоковые методы для 
более мощного примера.

```
try (var s = Files.lines(path)) {
   s.filter(f -> f.startsWith("WARN:"))
      .map(f -> f.substring(5))
      .forEach(System.out::println);
}
```

Этот пример кода ищет в журнале строки, начинающиеся с WARN:, и выводит следующий текст. Предположим, что входной файл 
sharks.log имеет следующий вид:

```
INFO:Server starting
DEBUG:Processes available = 10
WARN:No database could be detected
DEBUG:Processes available reset to 0
WARN:Performing manual recovery
INFO:Server successfully started
```

Тогда пример вывода будет следующим:

```
No database could be detected
Performing manual recovery
```

Как видите, у нас есть возможность манипулировать файлами сложными способами, часто с помощью всего лишь нескольких 
коротких выражений.

---

**Files.readAllLines() vs. Files.lines()**

Для экзамена вам нужно знать разницу между readAllLines() и lines(). Оба эти примера компилируются и запускаются:

```
Files.readAllLines(Paths.get("birds.txt")).forEach(System.out::println);
Files.lines(Paths.get("birds.txt")).forEach(System.out::println);
```

Первая строка считывает весь файл в память и выполняет операцию печати результата, а вторая строка лениво обрабатывает 
каждую строку и печатает ее по мере ее чтения. Преимущество второго фрагмента кода состоит в том, что он не требует 
сохранения всего файла в памяти в любое время.

Также следует знать, когда на экзамене смешивают несовместимые типы. Вы понимаете, почему следующее не компилируется?

```
Files.readAllLines(Paths.get("birds.txt"))
   .filter(s -> s.length()> 2)
   .forEach(System.out::println);
```

Метод readAllLines() возвращает список, а не поток, поэтому метод filter() недоступен.

---

### Объединение с newBufferedReader() и newBufferedWriter()

Иногда вам нужно смешивать потоки ввода-вывода и NIO.2. Удобно, что Files включает в себя два удобных метода получения 
потоков ввода-вывода.

```
private void copyPath(Path input, Path output) throws IOException {
   try (var reader = Files.newBufferedReader(input);
        var writer = Files.newBufferedWriter(output)) {
        
        String line = null;
        while ((line = reader.readLine()) != null)
           writer.write(line);
           writer.newLine();
        } } }
```

Вы можете обернуть конструкторы потоков ввода-вывода, чтобы получить тот же эффект, хотя гораздо проще использовать 
фабричный метод. Первый метод, newBufferedReader(), читает файл, указанный в местоположении Path, с помощью объекта 
BufferedReader.

### Обзор распространенных методов чтения и записи

В таблице 14.9 представлены общедоступные методы потоков ввода-вывода, которые вам следует знать для чтения и записи. 
Мы также включаем close() и flush(), поскольку они используются при выполнении этих действий. В таблице 14.10 делается 
то же самое для распространенных общедоступных методов чтения и записи NIO.2.

#### Таблица 14.9 - Общие методы чтения и записи ввода-вывода

|        Класс        |                     Имя метода                      |                                 Описание                                  |  
|:-------------------:|:---------------------------------------------------:|:-------------------------------------------------------------------------:|
| Все входные потоки  |                  public int read()                  |     Считывает один байт или возвращает -1, если доступных байтов нет.     |
|     InputStream     |              public int read(byte[] b)              |                        Считывает значения в буфер.                        |
|       Reader        |              public int read(char[] c)              |          Возвращает количество прочитанных байтов или символов.           |
|     InputStream     |  public int read(byte[] b, int offset, int length)  |      Считывает значения длины в буфер, начиная со смещения позиции.       |
|       Reader        |  public int read(char[] c, int offset, int length)  |          Возвращает количество прочитанных байтов или символов.           |
| Все выходные потоки |              public void write(int b)               |                           Записывает один байт.                           |
|    OutputStream     |             public void write(byte[] b)             |                    Записывает массив значений в поток.                    |
|       Writer        |             public void write(char[] c)             |                                                                           |
|    OutputStream     | public void write(byte[] b, int offset, int length) | Записывает значения длины из массива в поток, начиная с индекса смещения. |
|       Writer        | public void write(char[] c, int offset, int length) |                                                                           |
| BufferedInputStream |            public byte[] readAllBytes()             |                        Считывает данные в байтах.                         |
|   BufferedReader    |              public String readLine()               |                         Считывает строку данных.                          |
|   BufferedWriter    |           public void write( String line)           |                           Writes line of data.                            |
|   BufferedWriter    |                public void newLine()                |                            Пишет новую строку.                            |
| Все выходные потоки |                 public void flush()                 |               Сбрасывает буферизованные данные через поток.               |
|     Все потоки      |                public void close()                  |                  Закрывает поток и освобождает ресурсы.                   |

#### Таблица 14.10 - Общие методы чтения и записи файлов NIO.2

|                        Имя метода                        |                                                      Описание                                                      |  
|:--------------------------------------------------------:|:------------------------------------------------------------------------------------------------------------------:|
|           public static byte[] readAllBytes()            |                                         Считывает все данные в виде байтов                                         |
|            public static String readString()             |                                           Считывает все данные в String                                            |
|        public static List<String> readAllLines()         |                                             Считать все данные в List                                              |
|           public static Stream<String> lines()           |                                                Лениво читает данные                                                |
|    public static void write(Path path, byte[] bytes)     |                                              Записывает массив байтов                                              |
| public static void writeString(Path path, String string) |                                                 Записывает String                                                  |
| public static void write(Path path, List<String> list)   | Записывает список строк (технически это любой Iterable из CharSequence, но для экзамена это знать не обязательно)  |

## Сериализация данных

На протяжении всей этой книги мы управляли нашей моделью данных с помощью классов, поэтому имеет смысл сохранять эти 
объекты между выполнением программы. Данные о здоровье животных нашего зоопарка не были бы особенно полезны, если бы их 
приходилось вводить каждый раз при запуске программы!

Вы, конечно, можете использовать классы потока ввода-вывода, о которых вы узнали до сих пор, для хранения текстовых и 
двоичных данных, но вам все равно придется выяснить, как поместить данные в поток ввода-вывода, а затем декодировать их 
позже. Существуют различные форматы файлов, такие как XML и CSV, которые вы можете стандартизировать, но вам часто 
приходится создавать перевод самостоятельно.

В качестве альтернативы мы можем использовать сериализацию для решения проблемы преобразования объектов в/из потока 
ввода-вывода. Сериализация — это процесс преобразования объекта в памяти в поток байтов. Аналогично, десериализация — 
это процесс преобразования потока байтов в объект. Сериализация часто включает запись объекта в хранимый или 
передаваемый формат, тогда как десериализация является обратным процессом.

На рисунке 14.6 показано визуальное представление сериализации и десериализации объекта Giraffe в файл giraffe.txt и из 
него.

#### Рис. 14.6 - Процесс сериализации



В этом разделе мы покажем вам, как Java предоставляет встроенные механизмы для сериализации и десериализации потоков 
ввода-вывода объектов непосредственно на диск и с диска соответственно.


### Применение интерфейса Serializable 

Чтобы сериализовать объект с помощью API ввода-вывода, объект должен реализовать интерфейс java.io.Serializable. 
Интерфейс Serializable является интерфейсом маркера, что означает, что он не имеет никаких методов. Любой класс может 
реализовать интерфейс Serializable, поскольку для реализации не требуются обязательные методы.

_Поскольку Serializable — это интерфейс маркера без абстрактных членов, почему бы просто не применить его к каждому 
классу? Вообще говоря, вам следует помечать сериализуемыми только классы, ориентированные на данные. Классы, 
ориентированные на процессы, такие как потоки ввода-вывода, обсуждаемые в этой главе, или экземпляры потоков, о которых 
вы узнали в главе 13, часто являются плохими кандидатами для сериализации, поскольку внутреннее состояние этих классов 
имеет тенденцию быть эфемерным или недолговечным._

Цель использования интерфейса Serializable — информировать любой процесс, пытающийся сериализовать объект, о том, что 
вы предприняли правильные шаги, чтобы сделать объект сериализуемым. Все примитивы Java и многие встроенные классы Java, 
с которыми вы работали на протяжении всей книги, являются сериализуемыми. Например, этот класс можно сериализовать:

```
import java.io.Serializable;
public class Gorilla implements Serializable {
   private static final long serialVersionUID = 1L;
   private String name;
   private int age;
   private Boolean friendly;
   private transient String favoriteFood;
   
   // Constructors/Getters/Setters/toString() omitted
}
```

В этом примере класс Gorilla содержит три члена экземпляра (name, age, friendly), которые будут сохранены в 
потоке ввода-вывода, если класс сериализуется. Обратите внимание: поскольку Serializable не является частью 
пакета java.lang, его необходимо импортировать или указать в имени пакета.

А как насчет поля FavoriteFood, помеченного как transient? Любое поле, помеченное как transient, не будет сохранено в 
потоке ввода-вывода при сериализации класса. Далее мы обсудим это более подробно.

---

Сценарий реального мира

**Поддержание SerialVersionUID**

Хорошей практикой является объявление статической переменной SerialVersionUID в каждом классе, реализующем Serializable. 
Версия сохраняется вместе с каждым объектом как часть сериализации. Затем каждый раз, когда структура класса изменяется, 
это значение обновляется или увеличивается.

Возможно, наш класс Gorilla получит новый член экземпляра Double banana, или, возможно, поле возраста будет 
переименовано. Идея заключается в том, что класс можно было сериализовать с помощью более старой версии класса и 
десериализовать с помощью более новой версии класса.

SerialVersionUID помогает сообщить JVM о том, что сохраненные данные могут не соответствовать новому определению класса. 
Если во время десериализации встречается более старая версия класса, может быть выброшено исключение 
java.io.InvalidClassException. Альтернативно, некоторые API поддерживают преобразование данных между версиями.

---

### Маркировка данных transient

Модификатор transient можно использовать для конфиденциальных данных класса, таких как password. Есть и другие объекты, 
сериализовать которые не имеет смысла, например состояние в памяти Thread. Если объект является частью сериализуемого 
объекта, мы просто помечаем его как transient, чтобы игнорировать эти выбранные члены экземпляра.

Что происходит с данными, помеченными как transient при десериализации? Они возвращаются к своим значениям Java по 
умолчанию, таким как 0.0 для double или null для объекта. Вы увидите примеры этого вскоре, когда мы представим классы 
object stream.

_Пометка статических полей как transient мало влияет на сериализацию. Кроме serialVersionUID, сериализуются только 
экземпляры-члены класса._

### Проверка возможности сериализации класса

Поскольку Serializable — это интерфейс маркера, вы можете подумать, что для его использования нет никаких правил. Не 
совсем! Любой процесс, пытающийся сериализовать объект, выдаст исключение NotSerializableException, если класс не 
реализует интерфейс Serializable должным образом.

**Как сделать класс сериализуемым**

+ Класс должен быть помечен как Serializable.
+ Каждый экземпляр члена класса должен быть сериализуемым, помеченным как transient или иметь null значение на момент сериализации.

Будьте осторожны со вторым правилом. Чтобы класс был сериализуемым, мы должны рекурсивно применять второе правило. 
Вы понимаете, почему следующий класс Cat не подлежит сериализации?

```
public class Cat implements Serializable {
   private Tail tail = new Tail();
}

public class Tail implements Serializable {
   private Fur fur = new Fur();
}

public class Fur {}
```

Cat содержит экземпляр Tail, и оба этих класса помечены как Serializable, поэтому проблем нет. К сожалению, Tail 
содержит экземпляр Fur, который не помечен как Serializable.

Любое из следующих изменений устраняет проблему и позволяет сериализовать Cat:

```
public class Tail implements Serializable {
   private transient Fur fur = new Fur();
}

public class Fur implements Serializable {}
```

Мы также могли бы сделать члены экземпляров tail или fur нулевыми, хотя это сделало бы Cat сериализуемым только для 
определенных экземпляров, а не для всех экземпляров.

---

**Сериализация записей**

Как вы думаете, эту запись можно сериализовать?

```
record Record(String name) {}
```

Он не является сериализуемым, поскольку не реализует Serializable. Запись подчиняется тем же правилам, что и другие типы 
классов, в отношении возможности сериализации. Следовательно, это может быть:

```
record Record(String name) implements Serializable {}
```

---

### Хранение данных с помощью ObjectOutputStream и ObjectInputStream

Класс ObjectInputStream используется для десериализации объекта, а ObjectOutputStream — для сериализации объекта. 
Это потоки высокого уровня, которые работают с существующими потоками ввода-вывода. Хотя оба этих класса содержат ряд 
методов для встроенных типов данных, таких как примитивы, два метода, которые вам нужно знать для экзамена, связаны с 
работой с объектами.

```
// ObjectInputStream
public Object readObject() throws IOException, ClassNotFoundException

// ObjectOutputStream
public void writeObject(Object obj) throws IOException
```

Обратите внимание на параметры, типы возвращаемых значений и возникающие исключения. Теперь мы предоставляем пример 
метода, который сериализует List объектов Gorilla в файл:

```
void saveToFile(List<Gorilla> gorillas, File dataFile)
      throws IOException {
      try (var out = new ObjectOutputStream(
              new BufferedOutputStream(
                 new FileOutputStream(dataFile)))) {
         for (Gorilla gorilla : gorillas)
            out.writeObject(gorilla);
      }
}
```

Довольно легко, правда? Обратите внимание, что мы начинаем с файлового потока, оборачиваем его буферизованным потоком 
ввода-вывода для повышения производительности, а затем обертываем его объектным потоком. Сериализация данных так же 
проста, как передача их в writeObject().

Как только данные сохранены в файле, мы можем десериализовать их, используя следующий метод:

```
List<Gorilla> readFromFile(File dataFile) throws IOException,
      ClassNotFoundException {
   var gorillas = new ArrayList<Gorilla>();
   try (var in = new ObjectInputStream(
           new BufferedInputStream(
              new FileInputStream(dataFile)))) {
      while (true) {
         var object = in.readObject();
         if (object instanceof Gorilla g)
            gorillas.add(g);
      }
   } catch (EOFException e) {
      // File end reached
   }
   return gorillas;
}
```

Ах, это не так просто, как наш метод сохранения, не так ли? При вызове readObject() значения null и -1 не имеют особого 
значения, поскольку у кого-то могут быть сериализованные объекты с этими значениями. В отличие от наших предыдущих 
методов чтения методов из входного потока, нам нужно использовать бесконечный цикл для обработки данных, который выдает 
исключение EOFException при достижении конца потока ввода-вывода.

_Если вашей программе известно количество объектов в потоке ввода-вывода, вы можете вызывать readObject() фиксированное 
количество раз вместо использования бесконечного цикла._

Поскольку тип возвращаемого значения readObject() — Object, нам необходимо проверить тип перед получением доступа к 
нашим свойствам Gorilla. Обратите внимание, что readObject() объявляет проверенное исключение ClassNotFoundException, 
поскольку класс может быть недоступен при десериализации.

В следующем фрагменте кода показано, как вызывать методы сериализации:

```
var gorillas = new ArrayList<Gorilla>();
gorillas.add(new Gorilla("Grodd", 5, false));
gorillas.add(new Gorilla("Ishmael", 8, true));
File dataFile = new File("gorilla.data");

saveToFile(gorillas, dataFile);
var gorillasFromDisk = readFromFile(dataFile);
System.out.print(gorillasFromDisk);
```

Если предположить, что метод toString() был правильно переопределен в классе Gorilla, во время выполнения будет 
выведено следующее:

```
[[name=Grodd, age=5, friendly=false],
 [name=Ishmael, age=8, friendly=true]]
```

_ObjectInputStream наследует метод available() от InputStream, который, как вы думаете, можно использовать для проверки 
конца потока ввода-вывода, а не для выдачи исключения EOFException. К сожалению, это говорит вам только о количестве 
блоков, которые можно прочитать, не блокируя другой поток. Другими словами, он может вернуть 0, даже если нужно 
прочитать больше байтов._

### Понимание процесса создания десериализации

Для экзамена вам необходимо понять, как создается десериализованный объект. При десериализации объекта конструктор 
сериализованного класса вместе со всеми инициализаторами экземпляра не вызывается при создании объекта. Java вызовет 
конструктор без аргументов первого несериализуемого родительского класса, который он сможет найти в иерархии классов. 
В нашем примере с Gorilla это будет просто конструктор Object без аргументов.

Как мы говорили ранее, любые static или transient поля игнорируются. Неуказанным значениям будет присвоено значение 
Java по умолчанию, например null для String или 0 для значений int.

Давайте взглянем на новый класс Chimpanzee. На этот раз мы перечисляем конструкторы, чтобы проиллюстрировать, что ни 
один из них не используется при десериализации.

```
import java.io.Serializable;
public class Chimpanzee implements Serializable {
   private static final long serialVersionUID = 2L;
   private transient String name;
   private transient int age = 10;
   private static char type = 'C';
   { this.age = 14; }
   
   public Chimpanzee() {
      this.name = "Unknown";
      this.age = 12;
      this.type = 'Q';
   }
   
   public Chimpanzee(String name, int age, char type) {
      this.name = name;
      this.age = age;
      this.type = type;
   }
   
   // Getters/Setters/toString() omitted
}
```

Предполагая, что мы перепишем наши предыдущие методы сериализации и десериализации, чтобы обработать объект Chimpanzee 
вместо объекта Gorilla, как вы думаете, что получится в результате следующего?

```
var chimpanzees = new ArrayList<Chimpanzee>();
chimpanzees.add(new Chimpanzee("Ham", 2, 'A'));
chimpanzees.add(new Chimpanzee("Enos", 4, 'B'));
File dataFile = new File("chimpanzee.data");

saveToFile(chimpanzees, dataFile);
var chimpanzeesFromDisk = readFromFile(dataFile);
System.out.println(chimpanzeesFromDisk);
```

Подумайте об этом. Давайте, мы подождем.

Готовы к ответу? Ну, для начала, ни один из элементов экземпляра не сериализуется в файл. Переменные name и age помечены 
как transient, в то время как переменная type является static. Мы намеренно получили доступ к переменной type, 
используя this, чтобы посмотреть, обратили ли вы внимание.

При десериализации ни один из конструкторов Chimpanzee не вызывается. Даже конструктор без аргументов, который 
устанавливает значения [name=Unknown,age=12,type=Q], игнорируется. Инициализатор экземпляра, который устанавливает
age равным 14, также не выполняется.

В этом случае переменная name инициализируется null значением, поскольку это значение по умолчанию для String в Java. 
Аналогично, переменная age инициализируется значением 0. Программа печатает следующее, предполагая, что метод toString() 
реализован:

```
[[name=null,age=0,type=B],
 [name=null,age=0,type=B]]
```

А как насчет переменной type? Поскольку она static, он будет отображать любое значение, установленное последним. Если 
данные сериализуются и десериализуются в рамках одного и того же выполнения, они будут отображать B, поскольку это был 
последний созданный нами Chimpanzee. С другой стороны, если программа выполняет десериализацию и печатает при запуске, 
она выведет C, поскольку это значение, которым инициализируется класс.

Перед экзаменом убедитесь, что вы понимаете, что конструктор и любые инициализации экземпляров, определенные в 
сериализованном классе, игнорируются в процессе десериализации. Java вызывает только конструктор первого 
несериализуемого родительского класса в иерархии классов.

Наконец, давайте добавим подкласс:

```
public class BabyChimpanzee extends Chimpanzee {
   private static final long serialVersionUID = 3L;
   
   private String mother = "Mom";
   
   public BabyChimpanzee() { super(); }
   
   public BabyChimpanzee(String name, char type) {
      super(name, 0, type);
   }
   // Getters/Setters/toString() omitted
}
```

Обратите внимание, что этот подкласс является сериализуемым, поскольку суперкласс реализовал Serializable. Теперь у нас 
есть дополнительная переменная экземпляра. Код для сериализации и десериализации остается прежним. Мы даже можем 
выполнить преобразование к Chimpanzee, потому что это подкласс.

## Взаимодействие с пользователями

Java включает в себя множество классов для взаимодействия с пользователем. Например, вы можете написать приложение, 
которое запрашивает пользователя для входа в систему, а затем печатает сообщение об успехе. Этот раздел содержит 
множество методов обработки и реагирования на вводимые пользователем данные.

### Печать данных для пользователя

Java включает два экземпляра PrintStream для предоставления информации пользователю: System.out и System.err. Хотя 
System.out должен быть для вас устаревшим, System.err может быть для вас новым. Синтаксис вызова и использования 
System.err такой же, как и System.out, но используется для сообщения об ошибках пользователю в отдельном потоке 
ввода-вывода из обычной выходной информации.

```
try (var in = new FileInputStream("zoo.txt")) {
   System.out.println("Found file!");
} catch (FileNotFoundException e) {
   System.err.println("File not found!");
}
```

Чем они отличаются на практике? Частично это зависит от того, что выполняет программу. Например, если вы работаете из 
командной строки, они, скорее всего, напечатают текст в том же формате. С другой стороны, если вы работаете в 
интегрированной среде разработки (IDE), текст System.err может быть распечатан другим цветом. Наконец, если код 
выполняется на сервере, поток System.err может записываться в другой файл журнала.

---

_Сценарий реального мира_

**Использование API-интерфейсов ведения журнала**

Хотя System.out и System.err невероятно полезны для отладки отдельных или простых приложений, они редко используются в 
профессиональной разработке программного обеспечения. Большинство приложений полагаются на службу журналирования или API.

Хотя доступно множество API-интерфейсов ведения журналов, они, как правило, имеют ряд схожих атрибутов. Сначала вы 
создаете статический объект журналирования в каждом классе. Затем вы регистрируете сообщение с соответствующим уровнем 
протоколирования: debug(), info(), warn() или error(). Методы debug() и info() полезны, поскольку позволяют 
разработчикам регистрировать события, которые не являются ошибками, но могут быть полезны.

---

### Закрытие системных потоков

Вы могли заметить, что мы никогда не создавали и не закрывали System.out, System.err и System.in, когда использовали их. 
Фактически, это единственные потоки ввода-вывода во всей главе, в которых мы не использовали блок try-with-resources!

Поскольку это статические объекты, системные потоки используются всем приложением. JVM создает и открывает их для нас. 
Их можно использовать в инструкции try-with-resources или путем вызова close(), хотя закрывать их не рекомендуется. 
Закрытие системных потоков делает их навсегда недоступными для всех потоков в оставшейся части программы.

Как вы думаете, что выведет следующий фрагмент кода?

```
try (var out = System.out) {}
System.out.println("Hello");
```

Ничего. Он ничего не печатает. Методы PrintStream не выбрасывают никаких проверенных исключений и полагаются на функцию 
checkError() для сообщения об ошибках, поэтому они терпят неудачу без уведомления.

Что насчет этого примера?

```
try (var err = System.err) {} 
System.err.println("Hello");
```

Этот тоже ничего не печатает. Как и System.out, System.err является PrintStream. Даже если бы оно действительно выдало 
исключение, нам было бы трудно его увидеть, поскольку наш поток ввода-вывода для сообщений об ошибках закрыт! Закрытие 
System.err — особенно плохая идея, поскольку трассировка стека всех исключений будет скрыта.

Наконец, как вы думаете, что делает этот фрагмент кода?

```
var reader = new BufferedReader(new InputStreamReader(System.in));
try (reader) {}
String data = reader.readLine();  // IOException
```

Он печатает исключение во время выполнения. В отличие от класса PrintStream, большинство реализаций InputStream выдадут 
исключение, если вы попытаетесь работать с закрытым потоком ввода-вывода.

### Получение входных данных с помощью Console

Класс java.io.Console специально разработан для обработки взаимодействия с пользователем. В конце концов, System.in и 
System.out — это просто необработанные потоки, тогда как Console — это класс с многочисленными методами, 
ориентированными на ввод пользователя.

Класс Console является одноэлементным, поскольку он доступен только из фабричного метода и JVM создает только один его 
экземпляр. Например, если на экзамене вы встретите такой код, как следующий, он не скомпилируется, поскольку все 
конструкторы являются private:

```
Console c = new Console();  // НЕ КОМПИЛИРУЕТСЯ
```

В следующем фрагменте показано, как получить консоль и использовать ее для получения вводимых пользователем данных:

```
Console console = System.console();
if (console != null) {
   String userInput = console.readLine();
   console.writer().println("You entered: " + userInput);
} else {    
   System.err.println("Console not available");
}
```

_Объект Console может быть недоступен в зависимости от того, где вызывается код. Если он недоступен, System.console() 
возвращает значение null. Прежде чем пытаться использовать объект Console, обязательно проверьте null значение!_

Эта программа сначала получает экземпляр Console и проверяет его доступность, выдавая сообщение в System.err, если это 
не так. Если он доступен, программа получает строку ввода от пользователя и печатает результат. Как вы могли заметить, 
этот пример эквивалентен нашему предыдущему примеру чтения пользовательского ввода с помощью System.in и System.out.

### Получение базовых потоков ввода-вывода

Класс Console включает доступ к двум потокам для чтения и записи данных.

```
public Reader reader()
public PrintWriter writer()
```

Доступ к этим классам аналогичен прямому вызову System.in и System.out, хотя они используют потоки символов, а не потоки 
байтов. Таким образом, они более подходят для обработки текстовых данных.

### Форматирование данных консоли

В главе 4 вы узнали о методе format() для String; а в главе 11, “Исключения и локализация”, вы работали с форматированием 
с использованием локализаций. Удобно, что каждый класс потока печати включает метод format(), который включает 
перегруженную версию, которая использует языковой стандарт для объединения обоих этих методов:

```
// PrintStream
public PrintStream format(String format, Object... args)
public PrintStream format(Locale loc, String format, Object... args)

// PrintWriter
public PrintWriter format(String format, Object... args)
public PrintWriter format(Locale loc, String format, Object... args)
```

_Для удобства (а также для того, чтобы разработчики C чувствовали себя более комфортно) Java включает методы printf(), 
которые функционируют идентично методам format(). Единственное, что вам нужно знать об этих методах, это то, что они 
взаимозаменяемы с format()._

Давайте посмотрим на использование нескольких методов для печати информации для пользователя:

```
Console console = System.console();
if (console == null) {
   throw new RuntimeException("Console not available");
} else {
   console.writer().println("Welcome to Our Zoo!");
   console.format("It has %d animals and employs %d people", 391, 25);
   console.writer().println();
   console.printf("The zoo spans %5.1f acres", 128.91);
}
```

Предполагая, что консоль доступна во время выполнения, она печатает следующее:

```
Welcome to Our Zoo!
It has 391 animals and employs 25 people
The zoo spans 128.9 acres.
```

---

**Использование консоли с Locale**

В отличие от классов потока печати, Console не включает перегруженный метод format(), который принимает экземпляр Locale. 
Вместо этого Console использует языковой стандарт системы. Конечно, вы всегда можете использовать конкретную Locale, 
получив объект Writer и передав свой собственный экземпляр Locale, как в следующем примере:

```
Console console = System.console();
console.writer().format(new Locale("fr", "CA"), "Hello World");
```

---

### Чтение данных консоли

Класс Console включает четыре метода для получения от пользователя обычных текстовых данных.

```
public String readLine()
public String readLine(String fmt, Object... args)

public char[] readPassword()
public char[] readPassword(String fmt, Object... args)
```

Подобно использованию System.in с BufferedReader, метод readLine() консоли считывает ввод до тех пор, пока пользователь 
не нажмет клавишу Enter. Перегруженная версия readLine() отображает отформатированное сообщение перед запросом ввода.

Методы readPassword() аналогичны методу readLine(), но имеют два важных отличия:

+ Текст, который вводит пользователь, не возвращается и не отображается на экране во время набора текста.
+ Данные возвращаются в виде char[] вместо String.

Первая функция повышает безопасность, не показывая пароль на экране, если кто-то сидит рядом с вами. Вторая функция 
предполагает предотвращение попадания паролей в String пул.

### Обзор консольных методов

Последний пример кода, который мы представляем, задает пользователю ряд вопросов и распечатывает результаты на основе 
этой информации, используя множество различных методов, которые мы изучили в этом разделе:

```
Console console = System.console();
if (console == null) {
   throw new RuntimeException("Console not available");
} else {
   String name = console.readLine("Please enter your name: ");
   console.writer().format("Hi %s", name);
   console.writer().println();
   
   console.format("What is your address? ");
   String address = console.readLine();
   
   char[] password = console.readPassword("Enter a password "
      + "between %d and %d characters: ", 5, 10);
   char[] verify = console.readPassword("Enter the password again: ");
   console.printf("Passwords "
      + (Arrays.equals(password, verify) ? "match" : "do not match"));
}
```

Предполагая, что Console доступна, выходные данные должны выглядеть следующим образом:

```
Please enter your name: Max
Hi Max
What is your address? Spoonerville
Enter a password between 5 and 10 characters:
Enter the password again:
Passwords match
```

## Работа с продвинутыми API

Файлы, пути, потоки ввода-вывода: в этой главе вы много работали! В этом заключительном разделе мы рассмотрим некоторые 
расширенные функции потоков ввода-вывода и NIO.2, которые могут быть весьма полезны на практике и, как известно, время 
от времени появляются на экзамене!

### Управление потоками ввода

Все классы входных потоков включают следующие методы для управления порядком чтения данных из потока ввода-вывода:

```
// InputStream and Reader
public boolean markSupported()
public void mark(int readLimit)
public void reset() throws IOException
public long skip(long n) throws IOException
```

Методы mark() и reset() возвращают поток ввода-вывода на более раннюю позицию. Прежде чем вызывать любой из этих методов, 
вам следует вызвать метод markSupported(), который возвращает true, только если mark() поддерживается. Метод skip() 
довольно прост; он в основном считывает данные из потока ввода-вывода и отбрасывает их содержимое.

_Не все классы входного потока поддерживают mark() и reset(). Обязательно вызовите markSupported() в потоке ввода-вывода 
перед вызовом этих методов, иначе во время выполнения будет выброшено исключение._

### Маркировочные данные

Предположим, что у нас есть экземпляр InputStream, следующие значения которого — LION. Рассмотрим следующий фрагмент 
кода:

```
public void readData(InputStream is) throws IOException {
   System.out.print((char) is.read());     // L
   if (is.markSupported()) {
      is.mark(100);  // Marks up to 100 bytes
      System.out.print((char) is.read());  // I
      System.out.print((char) is.read());  // O
      is.reset();    // Resets stream to position before I
   }
   System.out.print((char) is.read());    // I
   System.out.print((char) is.read());    // O
   System.out.print((char) is.read());    // N
}
```

Фрагмент кода выведет LIOION, если поддерживается mark(), и LION в противном случае. Хорошей практикой является 
организация операций read() так, чтобы поток ввода-вывода заканчивался в одной и той же позиции независимо от того, 
поддерживается ли mark().

А как насчет значения 100, которое мы передали методу mark()? Это значение называется readLimit. Он указывает потоку 
ввода-вывода, что мы ожидаем вызвать функцию reset() не позднее, чем через 100 байт. Если наша программа вызывает 
функцию reset() после чтения более 100 байт из вызова mark(100), она может выдать исключение, в зависимости от класса 
потока ввода-вывода.

_На самом деле, mark() и reset() не возвращают данные обратно в поток ввода-вывода, а сохраняют данные во временном 
буфере в памяти для повторного чтения. Поэтому не следует вызывать операцию mark() со слишком большим значением, 
поскольку это может занять много памяти._

### Пропуск данных

Предположим, что у нас есть экземпляр InputStream, следующие значения которого — TIGERS. Рассмотрим следующий фрагмент 
кода:

```
System.out.print ((char)is.read()); // T
is.skip(2);  // Skips I and G
is.read();   // Reads E but doesn't output it
System.out.print((char)is.read());  // R
System.out.print((char)is.read());  // S
```

Этот код печатает TRS во время выполнения. Мы пропустили два символа, I и G. Мы также прочитали E, но нигде его не 
использовали, поэтому он вел себя как вызов skip(1).

Возвращаемый параметр skip() сообщает нам, сколько значений было пропущено. Например, если мы находимся недалеко от 
конца потока ввода-вывода и вызываем skip(1000), возвращаемое значение может быть 20, что указывает на то, что конец 
потока ввода-вывода был достигнут после того, как было пропущено 20 значений. Использование возвращаемого значения 
skip() важно, если вам нужно отслеживать, где вы находитесь в потоке ввода-вывода и сколько байтов было обработано.

### Обзор API-интерфейсов для манипулирования

В таблице 14.11 рассматриваются эти API, связанные с управлением входными потоками ввода-вывода. Хотя вы, возможно, не 
использовали их на практике, вам необходимо знать их для экзамена.

#### Таблица 14.11 - Общие методы чтения и записи файлов NIO.2

|           Имя метода           |                        Описание                        |  
|:------------------------------:|:------------------------------------------------------:|
| public boolean markSupported() | Возвращает true, если класс потока поддерживает mark() |
|   public mark(int readLimit)   |           Отмечает текущую позицию в потоке            |
|      public void reset()       |        Попытки сбросить поток в позицию mark()         |
|   public long skip(long n)     | Считывает и отбрасывает указанное количество символов  |


### Поиск атрибутов файла

Мы начнем наше обсуждение с представления основных методов чтения атрибутов файлов. Эти методы можно использовать в 
любой файловой системе, хотя в некоторых файловых системах они могут иметь ограниченное значение.

### Проверка символических ссылок

Ранее мы видели, что класс Files имеет методы isDirectory() и isRegularFile(), которые аналогичны методам isDirectory() 
и isFile() класса File. Хотя объект File не может сообщить вам, является ли ссылка символической ссылкой, метод 
isSymbolicLink() в Files может это сделать.

Функция isDirectory() или isRegularFile() может возвращать true для символической ссылки, если ссылка разрешается в 
каталог или обычный файл соответственно. Давайте посмотрим на пример кода:

```
System.out.print(Files.isDirectory(Paths.get("/canine/fur.jpg")));
System.out.print(Files.isSymbolicLink(Paths.get("/canine/coyote")));
System.out.print(Files.isRegularFile(Paths.get("/canine/types.txt")));
```

В первом примере выводится true, если fur.jpg является каталогом или символической ссылкой на каталог, и false в 
противном случае. Второй пример выводит true, если /canine/coyote является символической ссылкой, независимо от того, 
существует ли файл или каталог, на который она указывает. Третий пример выводит true, если types.txt указывает на 
обычный файл или символическую ссылку, указывающую на обычный файл.

### Проверка доступа к файлу

Во многих файловых системах можно установить boolean атрибут файла, который пометит его как скрытый, доступный для 
чтения или исполняемый. Класс Files включает методы, предоставляющие эту информацию: isHidden(), isReadable(), 
isWriteable() и isExecutable().

Скрытый файл обычно нельзя просмотреть при перечислении содержимого каталога. Флаги readable, writable и executable 
важны в файловых системах, где имя файла можно просмотреть, но у пользователя может не быть разрешения открывать 
содержимое файла, изменять файл или запускать файл как программу соответственно.

Здесь мы приводим пример каждого метода:

```
System.out.print(Files.isHidden(Paths.get("/walrus.txt")));
System.out.print(Files.isReadable(Paths.get("/seal/baby.png")));
System.out.print(Files.isWritable(Paths.get("dolphin.txt")));
System.out.print(Files.isExecutable(Paths.get("whale.png")));
```

Если файл walrus.txt существует и скрыт в файловой системе, первый пример выводит true. Второй пример выводит true, если 
файл baby.png существует и его содержимое доступно для чтения. Третий пример выводит true, если файл dolphin.txt можно 
изменить. Наконец, последний пример выводит true, если файл может быть выполнен в операционной системе. Обратите 
внимание, что расширение файла не обязательно определяет, является ли файл исполняемым. Например, файл изображения, 
который заканчивается на .png, может быть помечен как исполняемый в некоторых файловых системах.

За исключением метода isHidden(), эти методы не объявляют никаких проверенных исключений и возвращают false, если файл 
не существует.

### Улучшение доступа к атрибутам

До сих пор мы получали доступ к отдельным атрибутам файла с помощью нескольких вызовов методов. Хотя это функционально 
правильно, часто за каждый вызов одного из этих методов приходится платить. Проще говоря, гораздо эффективнее запросить 
у файловой системы все атрибуты одновременно, чем выполнять несколько обращений к файловой системе. Более того, 
некоторые атрибуты зависят от файловой системы и не могут быть легко обобщены для всех файловых систем.

NIO.2 решает обе эти проблемы, позволяя создавать представления для различных файловых систем с помощью одного вызова 
метода. Представление — это группа связанных атрибутов для определенного типа файловой системы. Это не значит, что 
предыдущие методы атрибутов, которые мы только что закончили обсуждать, бесполезны. Если вам нужно прочитать только 
один атрибут файла или каталога, запрашивать представление необязательно.

### Понимание  атрибутов и типов представлений

NIO.2 включает два метода для работы с атрибутами в одном вызове метода: метод атрибутов только для чтения и метод 
обновляемого представления. Для каждого метода вам необходимо предоставить объект типа файловой системы, который 
сообщает методу NIO.2, какой тип представления вы запрашиваете. Под обновляемым представлением мы подразумеваем, что мы 
можем как читать, так и записывать атрибуты одного и того же объекта.

В таблице 14.12 перечислены часто используемые атрибуты и типы представлений. Для сдачи экзамена вам нужно знать только 
об основных типах атрибутов файлов. Другие представления предназначены для управления информацией, относящейся к 
операционной системе.

#### Таблица 14.12 - Атрибуты и типы представлений 

| Интерфейс атрибутов  | Просмотр интерфейса     |                                                    Описание                                                     |  
|:--------------------:|-------------------------|:---------------------------------------------------------------------------------------------------------------:|
| BasicFileAttributes  | BasicFileAttributeView  |                       Базовый набор атрибутов, поддерживаемый всеми файловыми системами.                        |
|  DosFileAttributes   | DosFileAttributeView    |                Базовый набор атрибутов, а также атрибуты, поддерживаемые системами DOS/Windows.                 |
| PosixFileAttributes  | PosixFileAttributeView  | Базовый набор атрибутов, а также атрибуты, поддерживаемые системами POSIX, такими как Unix, Linux, Mac и т. д.  |

### Получение атрибутов

Класс Files включает следующий метод для чтения атрибутов класса, доступных только для чтения:

```
public static <A extends BasicFileAttributes> A readAttributes(
   Path path,
   Class<A> type,
   LinkOption... options) throws IOException
```

Для его применения необходимо указать параметры Path и BasicFileAttributes.class.

```
var path = Paths.get("/turtles/sea.txt");
BasicFileAttributes data = Files.readAttributes(path,
   BasicFileAttributes.class);
   
System.out.println("Is a directory? " + data.isDirectory());
System.out.println("Is a regular file? " + data.isRegularFile());
System.out.println("Is a symbolic link? " + data.isSymbolicLink());
System.out.println("Size (in bytes): " + data.size());
System.out.println("Last modified: " + data.lastModifiedTime());
```

Класс BasicFileAttributes включает множество значений с теми же именами, что и методы атрибутов в классе Files. Однако 
преимущество использования этого метода заключается в том, что для некоторых операционных систем все атрибуты 
извлекаются одновременно.

### Изменение атрибутов

Следующий метод Files возвращает обновляемое представление:

```
public static <V extends FileAttributeView> V getFileAttributeView(
   Path path,
   Class<V> type,
   LinkOption... options)
```

Мы можем использовать обновляемое представление, чтобы увеличить значение даты и времени последнего изменения файла на 
10,000 миллисекунд или 10 секунд.

```
// Read file attributes
var path = Paths.get("/turtles/sea.txt");
BasicFileAttributeView view = Files.getFileAttributeView(path,
   BasicFileAttributeView.class);
BasicFileAttributes attributes = view.readAttributes();

// Modify file last modified time
FileTime lastModifiedTime = FileTime.fromMillis(
   attributes.lastModifiedTime().toMillis() + 10_000);
view.setTimes(lastModifiedTime, null, null);
```

После получения обновляемого представления нам нужно вызвать readAttributes() для представления, чтобы получить 
метаданные файла. Отсюда мы создаем новое значение FileTime и устанавливаем его с помощью метода setTimes():

```
// BasicFileAttributeView instance method
public void setTimes(FileTime lastModifiedTime,
   FileTime lastAccessTime, FileTime createTime)
```

Этот метод позволяет нам передавать значение null для любого значения даты/времени, которое мы не хотим изменять. 
В нашем примере кода изменяется только дата и время последнего изменения.

_Не все атрибуты файла можно изменить с помощью представления. Например, вы не можете установить свойство, которое 
преобразует файл в каталог. Аналогично, вы не можете изменить размер объекта, не изменив его содержимое._

### Перемещение по дереву каталогов

Хотя метод Files.list() полезен, он просматривает содержимое только одного каталога. Что, если мы хотим посетить все 
пути в дереве каталогов? Прежде чем продолжить, нам необходимо рассмотреть некоторые основные понятия о файловых 
системах. Помните, что каталог организован иерархически. Например, каталог может содержать файлы и другие каталоги, 
которые, в свою очередь, могут содержать другие файлы и каталоги. Каждая запись в файловой системе имеет ровно одного 
родителя, за исключением корневого каталога, который находится поверх всего.

Файловую систему обычно представляют в виде дерева с одним корневым узлом и множеством ветвей и листьев. В этой модели 
каталог является ветвью или внутренним узлом, а файл — конечным узлом.

Обычной задачей в файловой системе является перебор потомков пути, либо записывая информацию о них, либо, что чаще, 
фильтруя их для определенного набора файлов. Например, вы можете выполнить поиск в папке и распечатать список всех 
файлов .java. Более того, файловые системы хранят файловые записи в иерархическом порядке. Вообще говоря, если вы 
хотите найти файл, вам нужно начать с родительского каталога, прочитать его дочерние элементы, затем прочитать их 
дочерние элементы и так далее.

Обход каталога, также называемый обходом по дереву каталогов, — это процесс, при котором вы начинаете с родительского 
каталога и перебираете все его потомки до тех пор, пока не будет выполнено какое-либо условие или пока не останется 
элементов, по которым можно выполнять итерацию. Например, если мы ищем один файл, мы можем завершить поиск, когда файл 
будет найден, или мы проверим все файлы и получим пустой результат. Начальным путем обычно является определенный 
каталог; в конце концов, поиск по всей файловой системе по каждому запросу занял бы много времени!

---

**Не используйте DirectoryStream и FileVisitor**

Просматривая Java-документацию NIO.2, вы можете встретить методы, использующие классы DirectoryStream и FileVisitor для 
перемещения по каталогу. Эти методы появились еще до появления Stream API и даже требовали знаний для старых 
сертификационных экзаменов по Java.

Лучший совет, который мы можем вам дать, — не использовать их. Новые методы на основе Stream API превосходят их и 
выполняют то же самое, часто с гораздо меньшим количеством кода.

---

### Выбор стратегии поиска

С обходом дерева каталогов связаны две общие стратегии: поиск в глубину и поиск в ширину. Поиск в глубину проходит 
структуру от корня до произвольного листа, а затем возвращается обратно к корню, полностью проходя все пути, которые он 
пропустил на этом пути. Глубина поиска — это расстояние от корня до текущего узла. Чтобы предотвратить бесконечный поиск, 
Java включает глубину поиска, которая используется для ограничения количества уровней (или прыжков) от корня, которые 
разрешено проходить поиску.

Альтернативно, поиск в ширину начинается с корня и обрабатывает все элементы каждой конкретной глубины, прежде чем 
перейти к следующему уровню глубины. Результаты упорядочены по глубине: все узлы на глубине 1 считываются раньше всех 
узлов на глубине 2 и так далее. Хотя поиск в ширину имеет тенденцию быть сбалансированным и предсказуемым, он также 
требует больше памяти, поскольку необходимо поддерживать список посещенных узлов.

Для сдачи экзамена вам не обязательно разбираться в деталях каждой стратегии поиска, которую использует Java; вам просто 
нужно знать, что методы NIO.2 Stream API используют поиск в глубину с пределом глубины, который можно при необходимости 
изменить.

### Обход каталога

Этой вводной информации достаточно; давайте перейдем к другим методам Stream API. Класс Files включает два метода для 
обхода дерева каталогов с использованием поиска в глубину.

```
public static Stream<Path> walk(Path start,
   FileVisitOption... options) throws IOException
   
public static Stream<Path> walk(Path start, int maxDepth,
   FileVisitOption... options) throws IOException
```

Как и другие наши потоковые методы, walk() использует ленивые вычисления и оценивает путь Path по мере его достижения. 
Это означает, что даже если дерево каталогов включает сотни или тысячи файлов, памяти, необходимой для обработки дерева 
каталогов, недостаточно. Первый метод walk() использует максимальную глубину по умолчанию Integer.MAX_VALUE, а 
перегруженная версия позволяет пользователю устанавливать максимальную глубину. Это полезно в тех случаях, когда 
файловая система может быть большой и мы знаем, что искомая информация находится рядом с корнем.

Вместо того, чтобы просто печатать содержимое дерева каталогов, мы снова можем сделать что-то более интересное. 
Следующий метод getPathSize() просматривает дерево каталогов и возвращает общий размер всех файлов в каталоге:

```
private long getSize(Path p) {
   try {
      return  Files.size(p);
   } catch (IOException e) {
      throw new UncheckedIOException(e);
   }
}

public long getPathSize(Path source) throws IOException {
   try (var s = Files.walk(source)) {
      return s.parallel()
            .filter(p -> !Files.isDirectory(p))
            .mapToLong(this::getSize)
            .sum();
   }
}
```

Вспомогательный метод getSize() необходим, поскольку Files.size() объявляет IOException, и мы предпочитаем не помещать 
блок try/catch внутри лямбда-выражения. Вместо этого мы оборачиваем его в непроверяемый класс исключений 
UncheckedIOException. Мы можем распечатать данные, используя метод format():

```
var size = getPathSize(Path.of("/fox/data"));
System.out.format("Total Size: %.2f megabytes", (size/1000000.0));
```

В зависимости от каталога, в котором вы это запускаете, он напечатает что-то вроде этого:

```
Total Size: 15.30 megabytes 
```

### Применение ограничения глубины

Допустим, наше дерево каталогов довольно глубокое, поэтому мы применяем ограничение глубины, изменяя одну строку кода в 
нашем методе getPathSize().

```
try (var s = Files.walk(source, 5)) {
```

Эта новая версия проверяет файлы только в пределах 5 шагов от начального узла. Значение глубины 0 указывает сам текущий 
путь. Поскольку метод вычисляет значения только для файлов, вам придется установить ограничение глубины не менее 1, 
чтобы получить ненулевой результат при применении этого метода к дереву каталогов.

### Избегание круговых путей

Многие из наших более ранних методов NIO.2 по умолчанию проходят символические ссылки, а для отключения этого поведения 
используется NOFOLLOW_LINKS. Метод walk() отличается тем, что по умолчанию он не следует по символическим ссылкам и 
требует включения опции FOLLOW_LINKS. Мы можем изменить наш метод getPathSize(), чтобы включить следующие символические 
ссылки, добавив FileVisitOption:

```
try (var s = Files.walk(source,
      FileVisitOption.FOLLOW_LINKS)) {
```

При перемещении по дереву каталогов ваша программа должна быть осторожна с символическими ссылками, если они включены. 
Например, если наш процесс встретит символическую ссылку, указывающую на корневой каталог файловой системы, будет 
проверен каждый файл в системе!

Хуже того, символическая ссылка может привести к циклу, в котором путь посещается неоднократно. Цикл — это бесконечная 
циклическая зависимость, в которой запись в дереве каталогов указывает на один из своих родительских каталогов. 
Допустим, у нас есть дерево каталогов, как показано на рисунке 14.7, с символической ссылкой /birds/robin/allBirds, 
указывающей на /birds.

#### Рис. 14.7 - Файловая система с циклом


Что произойдет, если мы попытаемся обойти это дерево и пройти по всем символическим ссылкам, начиная с /birds/robin? 
В таблице 14.13 показаны пути, которые посетили после прохождения глубины 3. Для простоты мы проходим по дереву в 
порядке ширины, хотя цикл происходит независимо от используемой стратегии поиска.

#### Таблица 14.13 - Прогулка по каталогу с помощью цикла с использованием поиска в ширину 

| Глубина |                                      Путь достигнут                                       |  
|:-------:|:-----------------------------------------------------------------------------------------:|
|    0    |                                       /birds/robin                                        |
|    1    |                                   /birds/robin/pictures                                   |
|    1    |                           /birds/robin/allBirds <br/> ➢ /birds                            |
|    2    |                              /birds/robin/pictures/nest.png                               |
|    2    |                              /birds/robin/pictures/wings.gif                              |
|    2    |                     /birds/robin/allBirds/robin <br/>  ➢ /birds/robin                     |
|    3    |            /birds/robin/allBirds/robin/pictures <br/>  ➢ /birds/robin/pictures            |
|    3    | /birds/robin/allBirds/robin/pictures/allBirds <br/> /birds/robin/allBirds <br/> ➢ /birds  |

Пройдя расстояние 1 от начала, мы нажимаем символическую ссылку /birds/robin/allBirds и возвращаемся на вершину дерева 
каталогов /birds. Это нормально, потому что мы еще не посещали /birds, поэтому цикла еще нет!

К сожалению, на глубине 2 мы сталкиваемся с циклом. На первом этапе мы уже посещали каталог /birds/robin и теперь 
сталкиваемся с ним снова. Если процесс продолжится, мы будем обречены посещать каталог снова и снова.

Имейте в виду, что при использовании параметра FOLLOW_LINKS метод walk() будет отслеживать все пути, которые он посетил, 
выдавая исключение FileSystemLoopException, если путь посещается дважды.

### Поиск по каталогу 913

В предыдущем примере мы применили фильтр к объекту Stream<Path> для фильтрации результатов, хотя существует более 
удобный метод.

```
public static Stream<Path> find(Path start,
   int maxDepth,
   BiPredicate<Path, BasicFileAttributes> matcher,
   FileVisitOption... options) throws IOException
```

Метод find() ведет себя аналогично методу walk(), за исключением того, что для фильтрации данных он использует 
BiPredicate. Также необходимо установить предел глубины. Как и walk(), find() также поддерживает опцию FOLLOW_LINK.

Два параметра BiPredicate — это объект Path и объект BasicFileAttributes, которые вы видели ранее в этой главе. 
Таким образом, Java автоматически извлекает для вас основную информацию о файле, позволяя вам писать сложные 
лямбда-выражения, которые имеют прямой доступ к этому объекту. Проиллюстрируем это следующим примером:

```
Path path = Paths.get("/bigcats");
long minSize = 1_000;
try (var s = Files.find(path, 10,
       (p, a) -> a.isRegularFile()
                 && p.toString().endsWith(".java")
                 && a.size() > minSize)) {
       s.forEach(System.out::println);
}
```

В этом примере выполняется поиск в дереве каталогов и печатаются все файлы .java размером не менее 1000 байт с 
ограничением глубины 10. Хотя мы могли бы добиться этого, используя метод walk() вместе с вызовом readAttributes(), это 
реализация намного короче и удобнее, чем была бы. Нам также не нужно беспокоиться о том, что какие-либо методы в 
лямбда-выражении объявляют проверенное исключение, как мы видели в примере getPathSize().

## Обзор ключевых API

Ключевые API, которые вам необходимо знать для сдачи экзамена, перечислены в таблице 14.14. Мы знаем, что некоторые 
классы выглядят одинаково. Прежде чем сдавать экзамен, вам необходимо хорошо знать эту таблицу.

#### Таблица 14.14 - Прогулка по каталогу с помощью цикла с использованием поиска в ширину

|    Класс    |                             Цель                             |  
|:-----------:|:------------------------------------------------------------:|
|    File     | Представление ввода-вывода местоположения в файловой системе |
|    Files    |           Вспомогательные методы для работы с Path           |
|    Path     |    Представление NIO.2 местоположения в файловой системе     |
|    Paths    |         Содержит фабричные методы для получения Path         |
|     URI     | Единый идентификатор ресурса для файлов, URL-адресов и т. д. |
| FileSystem  |             Представление файловой системы NIO.2             |
| FileSystems |      Содержит фабричные методы для получения FileSystem      |
| InputStream |            Суперкласс для чтения файлов по байтам            |
| OuputStream |        Суперкласс для записи файлов на основе байтов         |
|   Reader    |           Суперкласс для чтения файлов по символам           |
|   Writer    |       Суперкласс для записи файлов на основе символов        |


Кроме того, на рисунке 14.8 показаны все классы потоков ввода-вывода, с которыми вам следует ознакомиться на экзамене, 
за исключением потоков фильтров. FilterInputStream и FilterOutputStream — это суперклассы высокого уровня, которые 
фильтруют или преобразуют данные. Они редко используются напрямую.

#### Рис. 14.8 - Схема классов потоков ввода-вывода



InputStreamReader и OutputStreamWriter невероятно удобны, а также уникальны тем, что являются единственными классами 
потоков ввода-вывода, в имени которых есть как InputStream/OutputStream, так и Reader/Writer.

## Резюме

Эта глава посвящена чтению и записи данных. Мы начали с демонстрации того, как создать File из ввода-вывода и путь из 
NIO.2. Затем мы рассмотрели функциональные возможности, которые работают как с вводом-выводом, так и с NIO.2, прежде 
чем перейти к API-интерфейсам, специфичным для NIO.2. Вы должны быть знакомы с тем, как комбинировать или разрешать 
объекты Path с другими объектами Path. Кроме того, NIO.2 включает методы Stream API, которые можно использовать для 
обработки файлов и каталогов. Мы обсудили методы получения списка каталогов, обхода дерева каталогов, поиска в дереве 
каталогов и чтения строк файла.

Мы потратили время на рассмотрение различных методов, доступных во вспомогательном классе Files. Как уже говорилось, 
имя функции часто точно говорит вам, что она делает. Мы объяснили, что большинство этих методов способны генерировать 
исключение IOException, и многие из них принимают необязательные значения перечисления varargs.

Затем мы представили потоки ввода-вывода и объяснили, как они используются для чтения или записи больших объемов данных. 
Хотя существует множество потоков ввода-вывода, они различаются по некоторым ключевым моментам:

+ Байтовые и символьные потоки
+ Входные и выходные потоки
+ Потоки низкого и высокого уровня

Часто имя потока ввода-вывода может многое рассказать о том, что он делает. Мы посетили многие классы потоков 
ввода-вывода, которые вам нужно будет знать для экзамена, в порядке возрастания сложности. Обычной практикой является 
начало с низкоуровневого потока ресурсов или файлов и обертывание его буферизованным потоком ввода-вывода для повышения 
производительности. Вы также можете применить поток высокого уровня для управления данными, например поток объекта или 
печати. Мы описали, что значит быть сериализуемым в Java, и показали, как использовать классы объектного потока для 
сохранения объектов непосредственно на диске и с него.

Мы объяснили, как читать входные данные от пользователя, используя как объекты системного потока, так и класс Console. 
Класс Console имеет множество полезных функций, таких как встроенная поддержка паролей и форматирования.

Мы также обсудили, как NIO.2 предоставляет методы для чтения и записи метаданных файлов. NIO.2 включает два метода для 
получения всех атрибутов файловой системы для пути за один вызов без многочисленных обращений к операционной системе. 
Для одного метода требуется тип атрибута только для чтения, а для второго метода требуется обновляемый тип 
представления. Это также позволяет NIO.2 поддерживать атрибуты файлов, специфичные для операционной системы.

## Основы экзамена

**Разбирайтесь в файлах и каталогах.** Файлы — это записи, которые хранят данные на постоянном запоминающем устройстве, 
например на жестком диске, которое становится доступным после завершения выполнения приложения. Файлы организованы в 
файловой системе в каталогах, которые, в свою очередь, могут содержать другие каталоги. Корневой каталог — это самый 
верхний каталог в файловой системе.

**Уметь использовать File и Path.** Экземпляр файла ввода-вывода создается путем вызова конструктора. Он содержит ряд 
методов экземпляра для создания файла или каталога и управления ими. Экземпляр NIO.2 Path — это неизменяемый объект, 
который обычно создается из фабричного метода Paths.get() или Path.of(). Его также можно создать из экземпляров 
FileSystem, java.net.URI или java.io.File. Интерфейс Path включает множество методов экземпляра для чтения и управления 
значением абстрактного пути.

**Различайте типы потоков ввода-вывода.** Потоки ввода-вывода классифицируются по байтам/символам, вводу/выводу и 
низкоуровневому/высокоуровневому потоку. Потоки байтов работают с двоичными данными и имеют имена, оканчивающиеся на 
Stream, тогда как потоки символов работают с текстовыми данными и имеют имена, оканчивающиеся на Reader или Writer. 
Классы InputStream и Reader — это абстрактные классы верхнего уровня, получающие данные, а классы OutputStream и Writer 
— абстрактные классы верхнего уровня, отправляющие данные. Поток низкого уровня — это поток, который работает 
непосредственно с базовым ресурсом, например с файлом или сетевым подключением. Поток высокого уровня работает с потоком 
изкого уровня или другим потоком высокого уровня для фильтрации данных, преобразования данных или повышения 
производительности.

**Разберитесь, как использовать сериализацию Java.** Класс считается сериализуемым, если он реализует интерфейс 
java.io.Serializable и содержит члены экземпляра, которые либо сериализуемы, либо помечены как transient. Все примитивы 
Java и класс String являются сериализуемыми. Классы ObjectInputStream и ObjectOutputStream можно использовать для чтения 
и записи Serializable объекта из потока ввода-вывода и в него соответственно.

**Умейте взаимодействовать с пользователем.** Уметь взаимодействовать с пользователем, используя системные потоки 
(System.out, System.err и System.in), а также класс Console. Класс Console включает специальные методы для 
форматирования данных и получения сложных входных данных, таких как пароли.

**Управляйте атрибутами файла.** Класс NIO.2 Files включает в себя множество методов для чтения атрибутов одного файла, 
таких как его размер, каталог, символическая ссылка, скрытый и т. д. NIO.2 также поддерживает чтение всех атрибутов за 
один вызов. Тип атрибута используется для поддержки представлений, специфичных для операционной системы. Наконец, NIO.2 
поддерживает обновляемые представления для изменения выбранных атрибутов.