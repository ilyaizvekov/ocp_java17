# Ввод/вывод

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование Java I/O API

+ Чтение и запись консольных и файловых данных с использованием потока ввода-вывода.
+ Сериализация и десериализация объектов Java.
+ Создавайте, перемещайте, читайте и записывайте объекты Path и их свойства с помощью API java.nio.file.

---

Что могут делать приложения Java помимо управления объектами и атрибутами в памяти? Как сохранить данные, чтобы 
информация не терялась каждый раз при завершении программы? Конечно, они используют файлы! Вы можете разработать код, 
который записывает текущее состояние приложения в файл каждый раз, когда приложение закрывается, а затем перезагружает 
данные при следующем запуске приложения. Таким образом, информация сохраняется между выполнениями программы.

В этой главе основное внимание уделяется использованию API-интерфейсов I/O (ввод-вывод) и NIO.2 (неблокирующий ввод-вывод) 
для взаимодействия с файлами и потоками ввода-вывода. Предпочтительным подходом к работе с файлами и каталогами с 
помощью новых программных приложений является использование NIO.2, а не ввода-вывода, где это возможно. Однако вы 
увидите, что эти два понятия взаимосвязаны и оба широко используются.

Мы начнем с описания того, как файлы и каталоги организованы в файловой системе, и покажем, как получить к ним доступ с 
помощью класса File и интерфейса Path. Затем мы покажем, как работать с файлами и каталогами. Мы завершаем эту главу 
более сложными темами, такими как сериализация данных, обсуждение способов чтения пользовательского ввода во время 
выполнения с использованием класса Console и взаимодействие с атрибутами файлов.


_NIO означает неблокирующий API ввода/вывода и иногда его называют новым вводом/выводом. На экзамене рассматривается NIO 
версии 2. Была версия 1, охватывающая каналы, но ее нет на экзамене._

## Ссылки на файлы и каталоги

Мы начнем эту главу с рассмотрения того, какие файлы и каталоги находятся в файловой системе. Мы также представляем 
класс File и интерфейс Path, а также способы их создания.

### Представление файловой системы

Начнем с основ. Данные хранятся на постоянных запоминающих устройствах, таких как жесткие диски и карты памяти. Файл на 
устройстве хранения содержит данные. Файлы организованы в иерархии с помощью каталогов. Каталог — это место, которое 
может содержать как файлы, так и другие каталоги. Работая с каталогами в Java, мы часто относимся к ним как к файлам. 
Фактически, мы используем одни и те же классы и интерфейсы для работы с файлами и каталогами. Например, файл и каталог 
можно переименовать одним и тем же методом Java. Обратите внимание, что в этой главе мы часто говорим «файл» для 
обозначения файла или каталога.

Для взаимодействия с файлами нам необходимо подключиться к файловой системе. Файловая система отвечает за чтение и 
запись данных на компьютере. Разные операционные системы используют разные файловые системы для управления своими 
данными. Например, системы на базе Windows используют другую файловую систему, чем системы на базе Unix. Для сдачи 
экзамена вам просто нужно знать, как вводить команды с помощью API Java. JVM автоматически подключится к локальной 
файловой системе, что позволит вам выполнять одни и те же операции на нескольких платформах.

Далее, корневой каталог — это самый верхний каталог файловой системы, от которого наследуются все файлы и каталоги. 
В Windows он обозначается буквой диска, например C:\, а в Linux — одной косой чертой /.

Путь — это представление файла или каталога в файловой системе. Каждая файловая система определяет свой собственный 
символ-разделитель путей, который используется между записями каталога. Значение слева от разделителя является 
родительским для значения справа от разделителя. Например, значение пути /user/home/zoo.txt означает, что файл zoo.txt 
находится внутри домашнего каталога, а каталог home находится внутри каталога user.

---

**Разделители файлов операционной системы**

Различные операционные системы различаются по формату имен путей. Например, в системах на базе Unix для пути 
используется косая черта /, тогда как в системах на базе Windows используется символ обратной косой черты \. Тем не 
менее, многие языки программирования и файловые системы поддерживают оба типа косой черты при написании операторов пути. 
Java предлагает системное свойство для получения символа локального разделителя для текущей среды:

```
System.out.print(System.getProperty("file.separator"));
```

---

На рисунке 14.1 мы показываем, как каталоги и файловая система организованы иерархически.

#### Рис. 14.1 - Иерархия каталогов и файлов


На этой диаграмме показан корневой каталог c:, содержащий два каталога: app и zoo, а также файл info.txt. В каталоге 
app есть еще две папки, animals и employees, а также файл java.exe. Наконец, каталог animals содержит два файла: 
Bear.java и Bear.class.

Мы используем как абсолютные, так и относительные пути к файлу или каталогу в файловой системе. Абсолютный путь к файлу 
или каталогу — это полный путь от корневого каталога до файла или каталога, включая все подкаталоги, содержащие файл или 
каталог. Альтернативно, относительный путь к файлу или каталогу — это путь от текущего рабочего каталога к файлу или 
каталогу. Например, ниже приведен абсолютный путь к файлу Bear.java:

```
C:\app\animals\Bear.java
```

Ниже приведен относительный путь к тому же файлу, при условии, что текущий каталог пользователя установлен как C:\app:

```
animals\Bear.java
```

Определение того, является ли путь относительным или абсолютным, зависит от файловой системы. Для соответствия экзамену 
мы принимаем следующие соглашения:

+ Если путь начинается с косой черты (/), он является абсолютным, с корневым каталогом /, например /bird/parrot.png.
+ Если путь начинается с буквы диска (c:), он является абсолютным, причем буква диска соответствует корневому каталогу, например C:/bird/info.
+ В противном случае это относительный путь, например bird/parrot.png.

Абсолютные и относительные пути могут содержать символы пути. Символ пути — это один из зарезервированных рядов символов, 
имеющих особое значение в некоторых файловых системах. Для сдачи экзамена вам необходимо знать два символа пути, 
перечисленных в таблице 14.1.

#### Таблица 14.1 - Символы файловой системы

| Символ |               Описание                |  
|:------:|:-------------------------------------:|
|   .    |       Ссылка на текущий каталог       |
|   ..   | Ссылка на родителя текущего каталога  |


Глядя на рисунок 14.2, предположим, что текущий каталог — /fish/shark/hammerhead. В этом случае ../swim.txt — это 
действительный относительный путь, эквивалентный /fish/shark/swim.txt. Аналогично, ./play.png ссылается на play.png в 
текущем каталоге. Эти символы также можно комбинировать для большего эффекта. Например, ../../clownfish — это 
относительный путь, эквивалентный /fish/clownfish в файловой системе.

Иногда вы увидите избыточные или ненужные символы пути. Например, абсолютный путь /fish/clownfish/../shark/./swim.txt 
можно упростить до /fish/shark/swim.txt. Мы увидим, как справиться с этой избыточностью позже в этой главе, когда будем 
рассматривать normalize().

#### Рис. 14.2 - Относительные пути с использованием символов пути


Символическая ссылка — это специальный файл в файловой системе, который служит ссылкой или указателем на другой файл или 
каталог. Предположим, у нас есть символическая ссылка из /zoo/user/favorite на /fish/shark. Доступ к папке shark и ее 
элементам можно получить напрямую или по символической ссылке. Например, следующие пути ссылаются на один и тот же файл:

```
/fish/shark/swim.txt
/zoo/user/favorite/swim.txt
```

В общем, символические ссылки прозрачны для пользователя, поскольку операционная система заботится о разрешении ссылки 
на реальный файл. Хотя API ввода-вывода не поддерживают символические ссылки, NIO.2 включает полную поддержку создания, 
обнаружения и навигации по символическим ссылкам в файловой системе.

### Создание файла или пути

Чтобы сделать что-нибудь полезное, вам сначала понадобится объект, представляющий путь к определенному файлу или 
каталогу в файловой системе. При использовании устаревшего ввода-вывода это класс java.io.File, тогда как в NIO.2 это 
интерфейс java.nio.file.Path. Класс File и интерфейс Path не могут читать или записывать данные в файле, хотя они 
передаются как ссылка на другие классы, как вы увидите в этой главе.

_Помните, что File или Path могут представлять файл или каталог._

### Создание File

Класс File создается путем вызова его конструктора. Этот код показывает три разных конструктора:

```
File zooFile1 = new File("/home/tiger/data/stripes.txt");
File zooFile2 = new File("/home/tiger", "data/stripes.txt");
File parent = new File("/home/tiger");
File zooFile3 = new File(parent, "data/stripes.txt");

System.out.println(zooFile1.exists());
```

Все три создают объект File, который указывает на одно и то же место на диске. Если бы мы передали null в качестве 
родительского элемента конечному конструктору, он был бы проигнорирован, и метод вел бы себя так же, как одиночный 
конструктор String. Ради интереса мы также покажем, как определить, существует ли файл в файловой системе.

### Создание Path

Поскольку Path — это интерфейс, мы не можем создать экземпляр напрямую. В конце концов, у интерфейсов нет конструкторов! 
Java предоставляет ряд классов и методов, которые можно использовать для получения объектов Path.

Самый простой и понятный способ получить объект Path — использовать статический фабричный метод, определенный в Path или 
Paths. Все четыре примера указывают на одну и ту же ссылку на диске:

```
Path zooPath1 = Path.of("/home/tiger/data/stripes.txt");
Path zooPath2 = Path.of("/home", "tiger", "data", "stripes.txt");

Path zooPath3 = Paths.get("/home/tiger/data/stripes.txt");
Path zooPath4 = Paths.get("/home", "tiger", "data", "stripes.txt");

System.out.println(Files.exists(zooPath1));
```

Оба метода позволяют передавать параметр varargs для передачи дополнительных элементов пути. Значения объединяются и 
автоматически разделяются с помощью разделителя файлов, зависящего от операционной системы. Мы также показываем 
вспомогательный класс Files, который может проверять, существует ли файл в файловой системе.

Как видите, здесь есть два способа сделать одно и то же. Метод Path.of() был представлен в Java 11 как статический метод 
интерфейса. Фабричный класс Paths также предоставляет метод get(), делающий то же самое. Обратите внимание на букву s в 
конце класса Paths, чтобы отличить его от интерфейса Path. В этой главе мы используем Path.of() и Paths.get() как 
взаимозаменяемые.

_Вы могли заметить, что классы I/O и NIO.2 могут взаимодействовать с URI. Единый идентификатор ресурса (URI) — это 
строка символов, идентифицирующая ресурс. Он начинается со схемы, указывающей тип ресурса, за которым следует значение 
пути, например file:// для локальных файловых систем и http://, https:// и ftp:// для удаленных файловых систем._

### Переключение между файлом и путем

Поскольку «Файл» и «Путь» ссылаются на местоположения на диске, полезно иметь возможность конвертировать между ними. 
К счастью, Java упрощает эту задачу, предоставляя такие методы:

```
File file = new File("rabbit");
Path nowPath = file.toPath();
File backToFile = nowPath.toFile();
```

Многие старые библиотеки используют File, что упрощает получение File по Path и наоборот. При работе с новыми 
приложениями вам следует полагаться на интерфейс Path NIO.2, поскольку он содержит гораздо больше функций. Например, 
только NIO.2 обеспечивает поддержку файловой системы, о чем мы собираемся поговорить.

### Получение пути из класса FileSystems

NIO.2 широко использует создание объектов с помощью фабричных классов. Класс FileSystems создает экземпляры абстрактного 
класса FileSystem. Последний включает в себя методы работы непосредственно с файловой системой. Оба Paths.get() и 
Path.of() являются ярлыками для этого метода файловой системы. Давайте перепишем наши предыдущие примеры еще раз, чтобы 
увидеть, как получить экземпляр Path в дальнейшем:

```
Path zooPath1 = FileSystems.getDefault()
   .getPath("/home/tiger/data/stripes.txt");
Path zooPath2 = FileSystems.getDefault()
   .getPath("/home", "tiger", "data", "stripes.txt");
```

### Обзор взаимосвязей ввода-вывода и NIO.2

Модель ввода-вывода меньше, и вам нужно только понять класс File. Напротив, NIO.2 имеет больше функций и широко 
использует фабричный шаблон. Вам должен быть удобен такой подход. Для многих ваших взаимодействий с NIO.2 потребуются 
два типа: абстрактный класс или интерфейс и фабричный или вспомогательный класс. На рисунке 14.3 показаны связи между 
классами и интерфейсом, которые мы использовали до сих пор в этой главе.

#### Рис. 14.3 - Взаимоотношения классов и интерфейсов ввода-вывода и NIO.2


Внимательно просмотрите рисунок 14.3. В частности, следите за тем, является ли имя класса в единственном или 
множественном числе. Классы с именами во множественном числе включают методы для создания или работы с экземплярами 
классов/интерфейсов с именами в единственном числе. Помните, что для удобства (и источника путаницы) Path также можно 
создать из интерфейса Path с использованием статического метода фабрики of().

_java.io.File — это класс ввода-вывода, а Files — вспомогательный класс NIO.2. Files работает с экземплярами Path, а не 
с экземплярами java.io.File. Мы знаем, что это сбивает с толку, но они из совершенно разных API!_

В таблице 14.2 представлены рассмотренные нами API для создания объектов java.io.File и java.nio.file.Path. Читая 
таблицу, помните, что статические методы работают с классом/интерфейсом, тогда как методы экземпляра требуют экземпляра 
объекта. Прежде чем переходить к остальной части главы, убедитесь, что вы это хорошо знаете.

#### Таблица 14.2 - Параметры создания File и Path

|   Создает   | Объявлено в  |                                                  Метод или конструктор                                                   |  
|:-----------:|:------------:|:------------------------------------------------------------------------------------------------------------------------:|
|    File     |     File     | public File(String pathname) <br/> public File(File parent, String child) <br/> public File(String parent, String child) |
|    File     |     Path     |                                               public default File toFile()                                               |
|    Path     |     File     |                                                   public Path toPath()                                                   |
|    Path     |     Path     |                 public static Path of(String first, String... more) <br/> public static Path of(URI uri)                 |
|    Path     |    Paths     |                public static Path get(String first, String... more) <br/> public static Path get(URI uri)                |
|    Path     |  FileSystem  |                                    public Path getPath(String first, String... more)                                     |
| FileSystem  | FileSystems  |                                          public static FileSystem getDefault()                                           |


## Операции с File и Path

Теперь, когда мы знаем, как создавать объекты File и Path, мы можем начать использовать их для полезных действий. В 
этом разделе мы исследуем доступные нам функциональные возможности, связанные с каталогами.

### Использование общей функциональности

Многие операции можно выполнять с использованием как библиотек ввода-вывода, так и NIO.2. Многие распространенные API 
представлены в таблицах 14.3 и 14.4. Хотя эти таблицы могут показаться набором методов для изучения, многие из них 
говорят сами за себя. Вы можете пока игнорировать параметры vararg. Мы объясним это позже в этой главе.

#### Таблица 14.3 - Общие операции с File и Path

|                            Описание                            | Метод экземпляра файла ввода-вывода | Метод экземпляра пути NIO.2 |  
|:--------------------------------------------------------------:|:-----------------------------------:|:---------------------------:|
|                  Получает имя файла/каталога                   |              getName()              |        getFileName()        |
| Получает родительский каталог или значение null, если его нет. |             getParent()             |         getParent()         |
|     Проверяет, является ли файл/каталог абсолютным путем       |            isAbsolute()             |        isAbsolute()         |


#### Таблица 14.4 - Общие операции с File и Path

|                              Описание                              | Метод экземпляра файла ввода-вывода |                  Статический метод файлов NIO.2                  |  
|:------------------------------------------------------------------:|:-----------------------------------:|:----------------------------------------------------------------:|
|                        Удаляет файл/каталог                        |              delete()               |            deleteIfExists(Path p) throws IOException             |
|               Проверяет, существует ли файл/каталог                |              exists()               |                 exists(Path p, LinkOption... o)                  |
|             Получает абсолютный путь к файлу/каталогу              |          getAbsolutePath()          |                         toAbsolutePath()                         |
|              Проверяет, является ли ресурс каталогом               |            isDirectory()            |               isDirectory(Path p, LinkOption... o)               |
|                Проверяет, является ли ресурс файлом                |              isFile()               |              isRegularFile(Path p, LinkOption... o)              |
|            Возвращает время последнего изменения файла             |           lastModified()            | getLastModifiedTime(Path p, LinkOption... o) throws IOException  |
|                 Получает количество байтов в файле                 |              length()               |                 size(Path p) throws IOException                  |
|                  Перечисляет содержимое каталога                   |             listFiles()             |                 list(Path p) throws IOException                  |
|                          Создает каталог                           |               mkdir()               |  createDirectory(Path p, FileAttribute... a) throws IOException  |
| Создает каталог, включая все несуществующие родительские каталоги. |              mkdirs()               | createDirectories(Path p, FileAttribute... a) throws IOException |
|            Переименовывает файл/каталог, обозначенный              |        renameTo( File dest)         |  move(Path src, Path dest, CopyOption... o) throws IOException   |

Теперь давайте попробуем использовать некоторые из этих API. Ниже приведен пример программы, использующей только 
устаревшие API ввода-вывода. Учитывая путь к файлу, он выводит информацию о файле или каталоге, например, существует ли 
он, какие файлы в нем содержатся и т. д.:

```
10: public static void io() { 
11:    var file = new File("C:\\data\\zoo.txt"); 
12:    if (file.exists()) { 
13:       System.out.println("Absolute Path: " + file.getAbsolutePath()); 
14:       System.out.println("Is Directory: " + file.isDirectory()); 
15:       System.out.println("Parent Path: " + file.getParent()); 
16:       if (file.isFile()) { 
17:          System.out.println("Size: " + file.length()); 
18:          System.out.println("Last Modified: " + file.lastModified()); 
19:       } else {
20:          for (File subfile : file.listFiles()) { 
21:             System.out.println("   " + subfile.getName()); 
22:       } } } }
```

Если указанный путь указывает на действительный файл, программа выводит что-то похожее на следующее из-за оператора if 
в строке 16:

```
Absolute Path: C:\data\zoo.txt
Is Directory: false
Parent Path: C:\data
Size: 12382
Last Modified: 1650610000000
```

Наконец, если указанный путь указывает на допустимый каталог, например C:\data, программа выводит что-то похожее на 
следующее, благодаря блоку else:

```
Absolute Path: C:\data
Is Directory: true
Parent Path: C:\
   employees.txt
   zoo.txt
   zoo-backup.txt
```

В этих примерах вы видите, что выходные данные программы ввода-вывода полностью зависят от каталогов и файлов, доступных 
во время выполнения в базовой файловой системе.

На экзамене вы можете увидеть пути, которые выглядят как файлы, но являются каталогами или наоборот. Например, 
/data/zoo.txt может быть файлом или каталогом, даже если у него есть расширение файла. Не думайте, что это так, если 
вопрос не говорит вам об этом!

_В предыдущем примере мы использовали две обратную косую черту (\\) в строке пути, например C:\\data\\zoo.txt. Когда 
компилятор видит \\ внутри выражения String, он интерпретирует его как одно значение \._

Теперь давайте напишем ту же самую программу, используя только NIO.2, и посмотрим, чем она отличается:

```
25: public static void nio() throws IOException { 
26:    var path = Path.of("C:\\data\\zoo.txt"); 
27:    if (Files.exists(path)) { 
28:       System.out.println("Absolute Path: " + path.toAbsolutePath()); 
29:       System.out.println("Is Directory: " + Files.isDirectory(path)); 
30:       System.out.println("Parent Path: " + path.getParent()); 
31:       if (Files.isRegularFile(path)) { 
32:          System.out.println("Size: " + Files.size(path));
33:          System.out.println("Last Modified: " 
34:             + Files.getLastModifiedTime(path)); 
35:       } else { 
36:          try (Stream<Path> stream = Files.list(path)) { 
37:             stream.forEach(p -> 
38:                System.out.println("   " + p.getName())); 
39:       } } } }
```

Большая часть этого примера эквивалентна и заменяет вызовы методов ввода-вывода в предыдущих таблицах версиями NIO.2. 
Однако есть ключевые различия. Во-первых, строка 25 объявляет проверенное исключение. Больше API в NIO.2 выбрасывают 
IOException, чем API ввода-вывода. В этом случае Files.size(), Files.getLastModifiedTime() и Files.list() вызывают 
исключение IOException.

Во-вторых, в строках 36-39 используются Stream и лямбда-выражение вместо цикла. Поскольку потоки используют отложенное 
вычисление, это означает, что метод будет загружать каждый элемент пути по мере необходимости, а не весь каталог сразу.

---

**Закрытие потока**

Вы заметили, что в последнем примере кода мы поместили наш объект Stream в try-with-resources? Потоковые методы NIO.2 
открывают соединение с файловой системой, которое необходимо правильно закрыть; в противном случае может произойти 
утечка ресурсов. Утечка ресурсов в файловой системе означает, что путь может быть заблокирован от изменения еще долгое 
время после завершения процесса, который его использовал.

Если вы предположили, что терминальная операция потока автоматически закроет соответствующие файловые ресурсы, вы 
ошиблись. Когда это поведение было впервые представлено, было много споров; Короче говоря, требование от разработчиков 
закрыть поток победило.

С другой стороны, не все потоки нужно закрывать: только те, которые открывают ресурсы, например те, что есть в NIO.2. 
Например, вам не нужно было закрывать ни один из потоков, с которыми вы работали в главе 10 «Потоки».

Наконец, экзамен не всегда правильно закрывает ресурсы NIO.2. Чтобы соответствовать экзамену, мы иногда пропускаем 
закрытие ресурсов NIO.2 в обзорных и практических вопросах. Всегда используйте операторы try-with-resources с этими 
методами NIO.2 в своем собственном коде.

---

В оставшейся части этого раздела мы обсуждаем только методы NIO.2, поскольку они более важны. О них также нужно знать 
больше, и они с большей вероятностью попадут на экзамен.

### Методы обработки, которые объявляют IOException

Многие из методов, представленных в этой главе, объявляют IOException. Общие причины возникновения этого исключения 
методом включают следующее:

+ Потеря связи с базовой файловой системой.
+ Файл или каталог существует, но к нему невозможно получить доступ или изменить его.
+ Файл существует, но не может быть перезаписан.
+ Файл или каталог необходим, но не существует.

Методы, которые получают доступ к файлам и каталогам или изменяют их, например, в классе Files, часто объявляют 
IOException. Как мы увидим, из этого правила есть исключения. Например, метод Files.exists() не объявляет IOException. 
Если бы он выдал исключение, когда файл не существовал, он бы никогда не смог вернуть false! Как правило, если метод 
NIO.2 объявляет исключение IOException, для него обычно требуются пути, по которым он работает.

### Предоставление дополнительных параметров NIO.2

Многие из методов NIO.2 в этой главе включают переменные аргументы, которые принимают необязательный список значений. В 
таблице 14.5 представлены аргументы, с которыми вам следует ознакомиться на экзамене.


#### Таблица 14.5 - Общие аргументы метода NIO.2

| Тип перечисления   |    Интерфейс унаследован    | Перечисляемое значение                                                              |                                                                                                                                                     Подробности                                                                                                                                                      |  
|--------------------|:---------------------------:|-------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| LinkOption         | CopyOption <br/> OpenOption | NOFOLLOW_LINKS                                                                      |                                                                                                                                       Не переходите по символическим ссылкам.                                                                                                                                        |
| StandardCopyOption |         CopyOption          | ATOMIC_MOVE <br/> COPY_ATTRIBUTES <br/> REPLACE_EXISTING                            |                                                                           Переместить файл как операцию атомарной файловой системы. <br/> Скопируйте существующие атрибуты в новый файл. <br/> Перезаписать файл, если он уже существует.                                                                            |
| StandardOpenOption |         OpenOption          | APPEND <br/> CREATE <br/> CREATE_NEW <br/> READ <br/> TRUNCATE_EXISTING <br/> WRITE | Если файл уже открыт для записи, добавьте его в конец. <br/> Создайте новый файл, если он не существует. <br/> Создавать новый файл, только если он не существует; иначе провалиться. <br/> Открыт для чтения. <br/> Если файл уже открыт для записи, сотрите файл и добавьте его в начало. <br/> Открыт для записи. |
| FileVisitOption    |            N/A              | FOLLOW_LINKS                                                                        |                                                                                                                                        Переходите по символическим ссылкам.                                                                                                                                          |
|                    |                             |                                                                                     |                                                                                                                                                                                                                                                                                                                      |
|                    |                             |                                                                                     |                                                                                                                                                                                                                                                                                                                      |
|                    |                             |                                                                                     |                                                                                                                                                                                                                                                                                                                      |


За исключением Files.copy() и Files.move(), мы не будем обсуждать эти параметры с переменными аргументами каждый раз, 
когда представляем метод. Однако их поведение должно быть прямолинейным. Например, можете ли вы выяснить, что делает 
следующий вызов Files.exists() с LinkOption в следующем фрагменте кода?

```
Path path = Paths.get("schedule.xml");
boolean exists = Files.exists(path, LinkOption.NOFOLLOW_LINKS);
```

Files.exists() просто проверяет, существует ли файл. Но если параметр является символической ссылкой, метод вместо этого 
проверяет, существует ли цель символической ссылки. Предоставление LinkOption.NOFOLLOW_LINKS означает, что поведение по 
умолчанию будет переопределено, и метод проверит, существует ли сама символическая ссылка.

Обратите внимание, что некоторые перечисления в таблице 14.5 наследуют интерфейс. Это означает, что некоторые методы 
принимают различные типы перечислений. Например, метод Files.move() принимает переменную переменную CopyOption, поэтому 
он может принимать перечисления разных типов, и со временем можно будет добавить дополнительные параметры.

```
void copy(Path source, Path target) throws IOException {
   Files.move(source, target,
      LinkOption.NOFOLLOW_LINKS,
      StandardCopyOption.ATOMIC_MOVE);
}
```

### Взаимодействие с путями NIO.2

Как и значения String, экземпляры Path неизменяемы. В следующем примере операция Path во второй строке теряется, 
поскольку p является неизменяемым:

```
Path p = Path.of("whale");
p.resolve("krill");
System.out.println(p);  // whale
```

Многие методы, доступные в интерфейсе Path, каким-то образом преобразуют значение пути и возвращают новый объект Path, 
позволяя объединять методы в цепочку. Мы продемонстрируем цепочку в следующем примере, детали которого мы обсудим в этом 
разделе главы:

```
Path.of("/zoo/../home").getParent().normalize().toAbsolutePath();
```

### Просмотр пути

Интерфейс Path содержит три метода для получения базовой информации о представлении пути. Метод toString() возвращает 
строковое представление всего пути. Фактически, это единственный метод интерфейса Path, возвращающий строку. Многие 
другие методы интерфейса Path возвращают экземпляры Path.

Методы getNameCount() и getName() часто используются вместе для получения количества элементов в пути и ссылки на каждый 
элемент соответственно. Эти два метода не включают корневой каталог как часть пути.

```
Path path = Paths.get("/land/hippo/harry.happy");
System.out.println("The Path Name is: " + path);
for(int i=0; i<path.getNameCount(); i++)
   System.out.println("   Element " + i + " is: " + path.getName(i));
```

Обратите внимание, что мы не вызывали toString() явно во второй строке. Помните, Java вызывает toString() для любого 
объекта как часть конкатенации строк. Мы используем эту функцию во всех примерах в этой главе.

Код печатает следующее:

```
The Path Name is: /land/hippo/harry.happy
   Element 0 is: land
   Element 1 is: hippo
   Element 2 is: harry.happy
```

Несмотря на то, что это абсолютный путь, корневой элемент не включен в список имен. Как мы уже говорили, эти методы не 
рассматривают корневую часть пути.

```
var p = Path.of("/");
System.out.print(p.getNameCount()); // 0
System.out.print(p.getName(0));     // IllegalArgumentException
```

Обратите внимание: если вы попытаетесь вызвать getName() с недопустимым индексом, во время выполнения будет выдано 
исключение.

_В наших примерах в качестве символа-разделителя файлов печатается / из-за используемой нами системы. Фактический 
результат может отличаться в этой главе._

### Создание части пути

Интерфейс Path включает метод subpath() для выбора частей пути. Он принимает два параметра: включающий beginIndex и 
эксклюзивный endIndex. Это должно звучать знакомо, поскольку именно так работает метод substring() в String, как вы 
видели в главе 4 «Основные API».

Следующий фрагмент кода показывает, как работает subpath(). Мы также печатаем элементы Path с помощью getName(), чтобы 
вы могли видеть, как используются индексы.

```
var p = Paths.get("/mammal/omnivore/raccoon.image");
System.out.println("Path is: " + p);
for (int i = 0; i < p.getNameCount(); i++) {
   System.out.println("   Element " + i + " is: " + p.getName(i));
}
System.out.println();
System.out.println("subpath(0,3): " + p.subpath(0, 3));
System.out.println("subpath(1,2): " + p.subpath(1, 2));
System.out.println("subpath(1,3): " + p.subpath(1, 3));
```

Вывод этого фрагмента кода следующий:

```
Path is: /mammal/omnivore/raccoon.image
   Element 0 is: mammal
   Element 1 is: omnivore
   Element 2 is: raccoon.image

subpath(0,3): mammal/omnivore/raccoon.image
subpath(1,2): omnivore
subpath(1,3): omnivore/raccoon.image
```

Подобно getNameCount() и getName(), метод subpath() имеет нулевой индекс и не включает корень. Также, как и getName(), 
subpath() выдает исключение, если предоставлены недопустимые индексы.

```
var q = p.subpath(0, 4); // IllegalArgumentException
var x = p.subpath(1, 1); // IllegalArgumentException
```

Первый пример создает исключение во время выполнения, поскольку максимальное допустимое значение индекса равно 3. 
Второй пример создает исключение, поскольку начальный и конечный индексы одинаковы, что приводит к пустому значению 
пути.

### Доступ к элементам пути

Интерфейс Path содержит множество методов для получения определенных элементов Path, возвращаемых как сами объекты Path. 
Метод getFileName() возвращает элемент Path текущего файла или каталога, а метод getParent() возвращает полный путь к 
содержащему его каталогу. Метод getParent() возвращает значение null, если он используется в корневом пути или в начале 
относительного пути. Метод getRoot() возвращает корневой элемент файла в файловой системе или значение null, если путь 
является относительным.

Рассмотрим следующий метод, который печатает различные элементы Path:

```
public void printPathInformation(Path path) {
   System.out.println("Filename is: " + path.getFileName());
   System.out.println("   Root is: " + path.getRoot());
   Path currentParent = path;
   while((currentParent = currentParent.getParent()) != null)
      System.out.println("   Current parent is: " + currentParent);
   System.out.println();
}
```

Цикл while в методе printPathInformation() продолжается до тех пор, пока getParent() не вернет значение null. Мы 
применяем этот метод к следующим трем путям:

```
printPathInformation(Path.of("zoo"));
printPathInformation(Path.of("/zoo/armadillo/shells.txt"));
printPathInformation(Path.of("./armadillo/../shells.txt"));
```

Этот пример приложения выдает следующий результат:

```
Filename is: zoo    
   Root is: null
   
Filename is: shells.txt
   Root is: /
   Current parent is: /zoo/armadillo
   Current parent is: /zoo
   Current parent is: /
   
Filename is: shells.txt
   Root is: null
   Current parent is: ./armadillo/..
   Current parent is: ./armadillo
   Current parent is: .
```

Просматривая пример вывода, вы можете увидеть разницу в поведении getRoot() на абсолютных и относительных путях. Как вы 
можете видеть в первом и последнем примерах, метод getParent() не пересекает относительные пути за пределами текущего 
рабочего каталога.

Вы также видите, что эти методы не разрешают символы пути и рассматривают их как отдельную часть пути. Хотя большинство 
методов в этой части главы рассматривают символы пути как часть пути, вскоре мы представим метод, который очищает 
символы пути.

### Разрешение путей

Предположим, вы хотите объединить пути аналогично тому, как мы объединяем строки. Метод resolve() предоставляет 
перегруженные версии, которые позволяют передавать параметр Path или String. Объект, для которого вызывается метод 
resolve(), становится основой нового объекта Path, а входной аргумент добавляется к Path. Давайте посмотрим, что 
произойдет, если мы применим метод resolve() к абсолютному и относительному пути:

```
Path path1 = Path.of("/cats/../panther");
Path path2 = Path.of("food");
System.out.println(path1.resolve(path2));
```

Фрагмент кода генерирует следующий вывод:

```
/cats/../panther/food
```

Как и другие методы, которые мы видели, resolve() не очищает символы пути. В этом примере входным аргументом метода 
resolve() был относительный путь, но что, если бы это был абсолютный путь?

```
Path path3 = Path.of("/turkey/food");
System.out.println(path3.resolve("/tiger/cage"));
```

Поскольку входной параметр является абсолютным путем, выходные данные будут следующими:

```
/tiger/cage
```

Для экзамена вы должны знать о смешивании абсолютных и относительных путей с помощью метода resolve(). Если абсолютный 
путь указан в качестве входных данных для метода, это возвращаемое значение. Проще говоря, вы не можете объединить два 
абсолютных пути с помощью resolve().

_На экзамене, когда вы увидите resolve(), подумайте о конкатенации._

### Релятивизация пути

Интерфейс Path включает метод relativize() для построения относительного пути от одного пути к другому, часто с 
использованием символов пути. Как вы думаете, что напечатают следующие примеры?

```
var path1 = Path.of("fish.txt");
var path2 = Path.of("friendly/birds.txt");
System.out.println(path1.relativize(path2));
System.out.println(path2.relativize(path1));
```

В примерах печатается следующее:

```
../friendly/birds.txt
../../fish.txt
```

Идея такова: если вам указывают путь в файловой системе, какие шаги вам нужно будет предпринять, чтобы добраться до 
другого пути? Например, чтобы перейти к файлу fish.txt из файла friendly/birds.txt, вам нужно подняться на два уровня 
вверх (сам файл считается за один уровень), а затем выбрать файл fish.txt.

Если оба значения пути являются относительными, метод relativize() вычисляет пути, как если бы они находились в одном и 
том же текущем рабочем каталоге. Альтернативно, если оба значения пути являются абсолютными, метод вычисляет 
относительный путь от одного абсолютного местоположения к другому, независимо от текущего рабочего каталога. В следующем 
примере показано это свойство при запуске на компьютере под управлением Windows:

```
Path path3 = Paths.get("E:\\habitat");
Path path4 = Paths.get("E:\\sanctuary\\raven\\poe.txt");
System.out.println(path3.relativize(path4));
System.out.println(path4.relativize(path3));
```

Этот фрагмент кода выдает следующий результат:

```
..\sanctuary\raven\poe.txt
..\..\..\habitat
```

Метод relativize() требует, чтобы оба пути были абсолютными или относительными, и выдает исключение, если типы смешаны.

```
Path path1 = Paths.get("/primate/chimpanzee");
Path path2 = Paths.get("bananas.txt");
path1.relativize(path2); // IllegalArgumentException
```

В системах на базе Windows также требуется, чтобы при использовании абсолютных путей оба пути имели один и тот же 
корневой каталог или букву диска. Например, следующее также может вызвать исключение IllegalArgumentException в системе 
под управлением Windows:

```
Path path3 = Paths.get("C:\\primate\\chimpanzee");
Path path4 = Paths.get("D:\\storage\\bananas.txt");
path3.relativize(path4); // IllegalArgumentException
```

### Нормализация пути

На данный момент мы представили ряд примеров, в которых были ненужные символы пути. К счастью, Java предоставляет метод 
normalize() для устранения ненужной избыточности в пути.

Помните, что символ пути .. относится к родительскому каталогу, а символ пути . ссылается на текущий каталог. Мы можем 
применить normalize() к некоторым из наших предыдущих путей.

```
var p1 = Path.of("./armadillo/../shells.txt");
System.out.println(p1.normalize()); // shells.txt

var p2 = Path.of("/cats/../panther/food");
System.out.println(p2.normalize()); // /panther/food

var p3 = Path.of("../../fish.txt");
System.out.println(p3.normalize()); // ../../fish.txt
```

В первых двух примерах символы пути применяются для устранения избыточности, а как насчет последнего? Это настолько 
упрощенно, насколько это возможно. Метод normalize() не удаляет все символы пути, а только те, которые можно уменьшить.

Метод normalize() также позволяет нам сравнивать эквивалентные пути. Рассмотрим следующий пример:

```
var p1 = Paths.get("/pony/../weather.txt");
var p2 = Paths.get("/weather.txt");
System.out.println(p1.equals(p2));                         // false
System.out.println(p1.normalize().equals(p2.normalize())); // true
```

Метод equals() возвращает true, если два пути представляют одно и то же значение. В первом сравнении значения пути 
разные. Во втором сравнении значения путей были уменьшены до одного и того же нормализованного значения /weather.txt. 
Это основная функция метода normalize(): позволить нам лучше сравнивать различные пути.

### Получение реального пути к файловой системе

Хотя работать с теоретическими путями полезно, иногда вам нужно проверить, существует ли путь в файловой системе, 
используя toRealPath(). Этот метод аналогичен методу normalize() тем, что он удаляет любые избыточные символы пути. Он 
также похож на метод toAbsolutePath() тем, что он соединяет путь с текущим рабочим каталогом, если путь относительный.

Однако, в отличие от этих двух методов, toRealPath() выдаст исключение, если путь не существует. Кроме того, он будет 
следовать по символическим ссылкам с дополнительным параметром LinkOption varargs, чтобы игнорировать их.

Допустим, у нас есть файловая система, в которой есть символическая ссылка от /zebra к /horse. Как вы думаете, что будет 
напечатано, учитывая текущий рабочий каталог /horse/schedule?

```
System.out.println(Paths.get("/zebra/food.txt").toRealPath());
System.out.println(Paths.get(".././food.txt").toRealPath());
```

Вывод обеих строк следующий:

```
/horse/food.txt
```

В этом примере абсолютный и относительный пути разрешаются к одному и тому же абсолютному файлу, поскольку символическая 
ссылка указывает на реальный файл в файловой системе. Мы также можем использовать метод toRealPath(), чтобы получить 
доступ к текущему рабочему каталогу как к объекту Path.

```
System.out.println(Paths.get(".").toRealPath());
```

### Обзор API-интерфейсов NIO.2 Path

В этом разделе мы рассмотрели множество методов экземпляра Path. В таблице 14.6 они перечислены для проверки.

#### Таблица 14.6 - API Path

|                                 Описание                                  |                      Метод или конструктор                      |  
|:-------------------------------------------------------------------------:|:---------------------------------------------------------------:|
|                        Путь к файлу в виде строки                         |                    public String toString()                     |
|                               Один сегмент                                |                 public Path getName(int index)                  |
|                           Количество сегментов                            |                    public int getNameCount()                    |
|                           Сегменты в диапазоне                            |        public Path subpath(int beginIndex, int endIndex)        |
|                          Заключительный сегмент                           |                    public Path getFileName()                    |
|                         Непосредственный родитель                         |                     public Path getParent()                     |
|                          Сегмент верхнего уровня                          |                      public Path getRoot()                      |
|                             Объединение путей                             | public Path resolve(String p) <br/> public Path resolve(Path p) |
|                Построить путь к одному из предоставленных                 |                 public Path relativize(Path p)                  |
|                         Удалить лишние части пути                         |                     public Path normalize()                     |
| Перейдите по символическим ссылкам, чтобы найти путь в файловой системе.  |                    public Path toRealPath()                     |


### Создание, перемещение и удаление файлов и каталогов

Поскольку создание, перемещение и удаление имеют некоторые нюансы, мы подробно рассмотрим их в этом разделе.

### Создание каталогов

Чтобы создать каталог, мы используем следующие методы Files:

```
public static Path createDirectory(Path dir,
   FileAttribute<?>... attrs) throws IOException

public static Path createDirectories(Path dir,
   FileAttribute<?>... attrs) throws IOException
```

Метод createDirectory() создаст каталог и выдаст исключение, если он уже существует или если пути, ведущие к каталогу, 
не существуют. Метод createDirectories() создает целевой каталог вместе со всеми несуществующими родительскими 
каталогами, ведущими к этому пути. Если все каталоги уже существуют, createDirectories() просто завершится, 
ничего не делая. Это полезно в ситуациях, когда вы хотите убедиться, что каталог существует, и создать его, если его нет.

Оба этих метода также принимают необязательный список значений FileAttribute<?> для применения к вновь созданному 
каталогу или каталогам. Мы обсудим атрибуты файлов ближе к концу главы.

Ниже показано, как создавать каталоги:

```
Files.createDirectory(Path.of("/bison/field"));
Files.createDirectories(Path.of("/bison/field/pasture/green"));
```

В первом примере создается новый каталог field в каталоге /bison, предполагая, что /bison существует; в противном 
случае выдается исключение. Сравните это со вторым примером, в котором создается зеленый каталог вместе с любым из 
следующих родительских каталогов, если они еще не существуют, включая bison, field и pasture.

### Копирование файлов

Класс Files предоставляет метод копирования файлов и каталогов внутри файловой системы.

```
public static Path copy(Path source, Path target,
   CopyOption... options) throws IOException
```

Метод копирует файл или каталог из одного места в другое, используя объекты Path. Ниже показан пример копирования файла 
и каталога:

```
Files.copy(Paths.get("/panda/bamboo.txt"),
   Paths.get("/panda-save/bamboo.txt"));
   
Files.copy(Paths.get("/turtle"), Paths.get("/turtleCopy"));
```

Когда каталоги копируются, копия неглубокая. Неглубокое копирование означает, что файлы и подкаталоги внутри каталога не 
копируются. Глубокая копия означает, что копируется все дерево, включая все его содержимое и подкаталоги. Глубокая копия 
обычно требует рекурсии, при которой метод вызывает сам себя.

```
public void copyPath(Path source, Path target) {
   try {
      Files.copy(source, target);
      if(Files.isDirectory(source)) {
        try (Stream<Path> s = Files.list(source)) {
           s.forEach(p -> copyPath(p,
              target.resolve(p.getFileName())));
        }
        } catch(IOException e) {
            // Handle exception
        }
      }
   }
```

Метод сначала копирует путь, будь то файл или каталог. Если это каталог, выполняется только поверхностное копирование. 
Затем он проверяет, является ли путь каталогом, и, если да, выполняет рекурсивное копирование каждого из его элементов. 
Что, если метод встретит символическую ссылку? Не волнуйтесь: JVM не будет следовать символическим ссылкам при 
использовании метода list().

### Копирование и замена файлов

По умолчанию, если цель уже существует, метод copy() выдаст исключение. Это поведение можно изменить, предоставив методу 
значение перечисления StandardCopyOption REPLACE_EXISTING. Следующий вызов метода перезапишет файл movie.txt, если он 
уже существует:

```
Files.copy(Paths.get("book.txt"), Paths.get("movie.txt"),
   StandardCopyOption.REPLACE_EXISTING);
```

Для экзамена вам нужно знать, что без опции REPLACE_EXISTING этот метод выдаст исключение, если файл уже существует.

### Копирование файлов с помощью потоков ввода-вывода

Класс Files включает два метода copy(), которые работают с потоками ввода-вывода.

```
public static long copy(InputStream in, Path target,
   CopyOption... options) throws IOException

public static long copy(Path source, OutputStream out)
   throws IOException
```

Первый метод считывает содержимое потока ввода-вывода и записывает выходные данные в файл. Второй метод считывает 
содержимое файла и записывает выходные данные в поток ввода-вывода. Эти методы весьма удобны, если вам нужно быстро 
прочитать/записать данные с/на диск.

Ниже приведены примеры каждого метода copy():

```
try (var is = new FileInputStream("source-data.txt")) {
  // Write I/O stream data to a file
  Files.copy(is, Paths.get("/mammals/wolf.txt"));
}

Files.copy(Paths.get("/fish/clown.xsl"), System.out);
```

Хотя в первом примере мы использовали FileInputStream, поток ввода-вывода мог быть любым допустимым потоком ввода-вывода, 
включая подключения к веб-сайту, ресурсы потока в памяти и т. д. Второй пример печатает содержимое файла непосредственно 
в поток System.out.

### Копирование файлов в каталог

На экзамене важно понимать, как метод copy() работает как с файлами, так и с каталогами. Например, предположим, что у 
нас есть файл food.txt и каталог /enclosure. И файл, и каталог существуют. Как вы думаете, каков результат выполнения 
следующего процесса?

```
var file = Paths.get("food.txt");
var directory = Paths.get("/enclosure");
Files.copy(file, directory);
```

Если вы сказали, что будет создан новый файл /enclosure/food.txt, вы ошиблись. Это вызывает исключение. Команда пытается 
создать новый файл с именем /enclosure. Поскольку путь /enclosure уже существует, во время выполнения выдается исключение.

С другой стороны, если бы каталог не существовал, процесс создал бы новый файл с содержимым food.txt, но этот файл будет 
называться /enclosure. Помните, мы говорили, что файлам могут не обязательно иметь расширения, и в данном примере это 
имеет значение.

Такое поведение применимо как к методам copy(), так и к методам move(), последний из которых мы рассмотрим далее. Если 
вам интересно, правильный способ скопировать файл в каталог — сделать следующее:

```
var file = Paths.get("food.txt");
var directory = Paths.get("/enclosure/food.txt");
Files.copy(file, directory);
```

### Перемещение или переименование путей с помощью move()

Класс Files предоставляет полезный метод для перемещения или переименования файлов и каталогов.

```
public static Path move(Path source, Path target,
   CopyOption... options) throws IOException
```

В следующем примере кода используется метод move():

```
Files.move(Path.of("C:\\zoo"), Path.of("C:\\zoo-new"));

Files.move(Path.of("C:\\user\\addresses.txt"),
   Path.of("C:\\zoo-new\\addresses2.txt"));
```

В первом примере каталог zoo переименовывается в каталог zoo-new, сохраняя все исходное содержимое из исходного 
каталога. Во втором примере файл «addresses.txt» перемещается из каталога «user» в каталог «zoo-new» и переименовывается 
в «addresses2.txt».

### Сходства между move() и copy()

Как и copy(), метод move() требует, чтобы REPLACE_EXISTING перезаписал цель, если она существует; в противном случае 
будет выдано исключение. Также, как и метод copy(), метод move() не помещает файл в каталог, если источником является 
файл, а целью — каталог. Вместо этого он создаст новый файл с именем каталога.

### Выполнение атомарного перемещения

Еще одно значение перечисления, которое вам необходимо знать на экзамене при работе с методом move(), — это значение 
ATOMIC_MOVE StandardCopyOption.

```
Files.move(Path.of("mouse.txt"), Path.of("gerbil.txt"),
   StandardCopyOption.ATOMIC_MOVE);
```

Возможно, вы помните свойство атомарности из главы 13 «Параллелизм», и принцип атомарного перемещения аналогичен. 
Атомарное перемещение — это перемещение файла внутри файловой системы как единая неделимая операция. Другими словами, 
любой процесс, контролирующий файловую систему, никогда не увидит неполный или частично записанный файл. Если файловая 
система не поддерживает эту функцию, будет создано исключение AtomicMoveNotSupportedException.

Обратите внимание: хотя ATOMIC_MOVE доступен как член типа StandardCopyOption, он, скорее всего, выдаст исключение, если 
передать его методу copy().

### Удаление файла с помощью delete() и deleteIfExists()

Класс Files включает два метода, которые удаляют файл или пустой каталог в файловой системе.

```
public static void delete(Path path) throws IOException

public static boolean deleteIfExists(Path path) throws IOException
```

Чтобы удалить каталог, он должен быть пустым. Оба эти метода выдают исключение, если работают с непустым каталогом. 
Кроме того, если путь является символической ссылкой, будет удалена символическая ссылка, а не путь, на который 
указывает символическая ссылка.

Методы различаются тем, как они обрабатывают несуществующий путь. Метод delete() генерирует исключение, если путь не 
существует, а метод deleteIfExists() возвращает true, если удаление было успешным, или false в противном случае. Подобно 
createDirectories(), метод deleteIfExists() полезен в ситуациях, когда вы хотите убедиться, что путь не существует, и 
удалить его, если он существует.

Здесь мы предоставляем пример кода, выполняющего операции delete():

```
Files.delete(Paths.get("/vulture/feathers.txt"));
Files.deleteIfExists(Paths.get("/pigeon"));
```

В первом примере удаляется файл feathers.txt в каталоге vulture и выдается исключение NoSuchFileException, если файл или 
каталог не существует. Второй пример удаляет каталог pigeon, предполагая, что он пуст. Если каталог pigeon не существует, 
вторая строка не выдаст исключение.

### Сравнение файлов с помощью isSameFile() и mismatch()

Поскольку путь может включать в себя символы пути и символические ссылки внутри файловой системы, нельзя полагаться на 
метод equals(), чтобы узнать, ссылаются ли два экземпляра Path на один и тот же файл. К счастью, существует метод 
isSameFile(). Этот метод принимает в качестве входных данных два объекта Path, разрешает все символы пути и следует по 
символическим ссылкам. Несмотря на название, этот метод также можно использовать для определения того, ссылаются ли два 
объекта Path на один и тот же каталог.

Хотя в большинстве случаев использование isSameFile() вызывает исключение, если пути не существуют, существует особый 
случай, когда этого не происходит. Если два объекта пути равны с точки зрения метода equals(), метод просто вернет true, 
не проверяя, существует ли файл.

Предположим, что файловая система существует, как показано на рисунке 14.4, с символической ссылкой из /animals/snake 
на /animals/cobra.

#### Рис. 14.4 - Сравнение уникальности файлов 


Учитывая структуру, определенную на рисунке 14.4, что дает следующий вывод?

```
System.out.println(Files.isSameFile(
   Path.of("/animals/cobra"),
   Path.of("/animals/snake")));
   
System.out.println(Files.isSameFile(
   Path.of("/animals/monkey/ears.png"),
   Path.of("/animals/wolf/ears.png")));
```

Поскольку snake является символической ссылкой на cobra, первый пример выдает true. Во втором примере пути относятся к 
разным файлам, поэтому выводится false.

Иногда вам нужно сравнить содержимое файла, а не то, является ли он физически одним и тем же файлом. Например, у нас 
может быть два файла с текстовым hello. Метод mismatch() был введен в Java 12, чтобы помочь нам в этом. В качестве 
входных данных он принимает два объекта Path. Метод возвращает -1, если файлы одинаковы; в противном случае возвращается 
индекс первой позиции в файле, которая отличается.

```
System.out.println(Files.mismatch(
   Path.of("/animals/monkey.txt"),
   Path.of("/animals/wolf.txt")));
```

Предположим, файл monkey.txt содержит имя Harold, а файл wolf.txt содержит имя Howler. В этом случае предыдущий код 
печатает 1, потому что вторая позиция отличается, а в Java мы используем индексацию с отсчетом от нуля. Учитывая эти 
значения, как вы думаете, что напечатает этот код?

```
System.out.println(Files.mismatch(
   Path.of("/animals/wolf.txt"),
   Path.of("/animals/monkey.txt")));
```

Ответ тот же, что и в предыдущем примере. Код снова печатает 1. Метод mismatch() симметричен и возвращает один и тот же 
результат независимо от порядка параметров.

## Знакомство с потоками ввода-вывода

