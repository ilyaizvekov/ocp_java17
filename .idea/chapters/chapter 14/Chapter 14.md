# Ввод/вывод

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование Java I/O API

+ Чтение и запись консольных и файловых данных с использованием потока ввода-вывода.
+ Сериализация и десериализация объектов Java.
+ Создавайте, перемещайте, читайте и записывайте объекты Path и их свойства с помощью API java.nio.file.

---

Что могут делать приложения Java помимо управления объектами и атрибутами в памяти? Как сохранить данные, чтобы 
информация не терялась каждый раз при завершении программы? Конечно, они используют файлы! Вы можете разработать код, 
который записывает текущее состояние приложения в файл каждый раз, когда приложение закрывается, а затем перезагружает 
данные при следующем запуске приложения. Таким образом, информация сохраняется между выполнениями программы.

В этой главе основное внимание уделяется использованию API-интерфейсов I/O (ввод-вывод) и NIO.2 (неблокирующий ввод-вывод) 
для взаимодействия с файлами и потоками ввода-вывода. Предпочтительным подходом к работе с файлами и каталогами с 
помощью новых программных приложений является использование NIO.2, а не ввода-вывода, где это возможно. Однако вы 
увидите, что эти два понятия взаимосвязаны и оба широко используются.

Мы начнем с описания того, как файлы и каталоги организованы в файловой системе, и покажем, как получить к ним доступ с 
помощью класса File и интерфейса Path. Затем мы покажем, как работать с файлами и каталогами. Мы завершаем эту главу 
более сложными темами, такими как сериализация данных, обсуждение способов чтения пользовательского ввода во время 
выполнения с использованием класса Console и взаимодействие с атрибутами файлов.


_NIO означает неблокирующий API ввода/вывода и иногда его называют новым вводом/выводом. На экзамене рассматривается NIO 
версии 2. Была версия 1, охватывающая каналы, но ее нет на экзамене._

## Ссылки на файлы и каталоги

Мы начнем эту главу с рассмотрения того, какие файлы и каталоги находятся в файловой системе. Мы также представляем 
класс File и интерфейс Path, а также способы их создания.

### Представление файловой системы

Начнем с основ. Данные хранятся на постоянных запоминающих устройствах, таких как жесткие диски и карты памяти. Файл на 
устройстве хранения содержит данные. Файлы организованы в иерархии с помощью каталогов. Каталог — это место, которое 
может содержать как файлы, так и другие каталоги. Работая с каталогами в Java, мы часто относимся к ним как к файлам. 
Фактически, мы используем одни и те же классы и интерфейсы для работы с файлами и каталогами. Например, файл и каталог 
можно переименовать одним и тем же методом Java. Обратите внимание, что в этой главе мы часто говорим «файл» для 
обозначения файла или каталога.

Для взаимодействия с файлами нам необходимо подключиться к файловой системе. Файловая система отвечает за чтение и 
запись данных на компьютере. Разные операционные системы используют разные файловые системы для управления своими 
данными. Например, системы на базе Windows используют другую файловую систему, чем системы на базе Unix. Для сдачи 
экзамена вам просто нужно знать, как вводить команды с помощью API Java. JVM автоматически подключится к локальной 
файловой системе, что позволит вам выполнять одни и те же операции на нескольких платформах.

Далее, корневой каталог — это самый верхний каталог файловой системы, от которого наследуются все файлы и каталоги. 
В Windows он обозначается буквой диска, например C:\, а в Linux — одной косой чертой /.

Путь — это представление файла или каталога в файловой системе. Каждая файловая система определяет свой собственный 
символ-разделитель путей, который используется между записями каталога. Значение слева от разделителя является 
родительским для значения справа от разделителя. Например, значение пути /user/home/zoo.txt означает, что файл zoo.txt 
находится внутри домашнего каталога, а каталог home находится внутри каталога user.

---

**Разделители файлов операционной системы**

Различные операционные системы различаются по формату имен путей. Например, в системах на базе Unix для пути 
используется косая черта /, тогда как в системах на базе Windows используется символ обратной косой черты \. Тем не 
менее, многие языки программирования и файловые системы поддерживают оба типа косой черты при написании операторов пути. 
Java предлагает системное свойство для получения символа локального разделителя для текущей среды:

```
System.out.print(System.getProperty("file.separator"));
```

---

На рисунке 14.1 мы показываем, как каталоги и файловая система организованы иерархически.

#### Рис. 14.1 - Иерархия каталогов и файлов


На этой диаграмме показан корневой каталог c:, содержащий два каталога: app и zoo, а также файл info.txt. В каталоге 
app есть еще две папки, animals и employees, а также файл java.exe. Наконец, каталог animals содержит два файла: 
Bear.java и Bear.class.

Мы используем как абсолютные, так и относительные пути к файлу или каталогу в файловой системе. Абсолютный путь к файлу 
или каталогу — это полный путь от корневого каталога до файла или каталога, включая все подкаталоги, содержащие файл или 
каталог. Альтернативно, относительный путь к файлу или каталогу — это путь от текущего рабочего каталога к файлу или 
каталогу. Например, ниже приведен абсолютный путь к файлу Bear.java:

```
C:\app\animals\Bear.java
```

Ниже приведен относительный путь к тому же файлу, при условии, что текущий каталог пользователя установлен как C:\app:

```
animals\Bear.java
```

Определение того, является ли путь относительным или абсолютным, зависит от файловой системы. Для соответствия экзамену 
мы принимаем следующие соглашения:

+ Если путь начинается с косой черты (/), он является абсолютным, с корневым каталогом /, например /bird/parrot.png.
+ Если путь начинается с буквы диска (c:), он является абсолютным, причем буква диска соответствует корневому каталогу, например C:/bird/info.
+ В противном случае это относительный путь, например bird/parrot.png.

Абсолютные и относительные пути могут содержать символы пути. Символ пути — это один из зарезервированных рядов символов, 
имеющих особое значение в некоторых файловых системах. Для сдачи экзамена вам необходимо знать два символа пути, 
перечисленных в таблице 14.1.

#### Таблица 14.1 - Символы файловой системы

| Символ |               Описание                |  
|:------:|:-------------------------------------:|
|   .    |       Ссылка на текущий каталог       |
|   ..   | Ссылка на родителя текущего каталога  |


Глядя на рисунок 14.2, предположим, что текущий каталог — /fish/shark/hammerhead. В этом случае ../swim.txt — это 
действительный относительный путь, эквивалентный /fish/shark/swim.txt. Аналогично, ./play.png ссылается на play.png в 
текущем каталоге. Эти символы также можно комбинировать для большего эффекта. Например, ../../clownfish — это 
относительный путь, эквивалентный /fish/clownfish в файловой системе.

Иногда вы увидите избыточные или ненужные символы пути. Например, абсолютный путь /fish/clownfish/../shark/./swim.txt 
можно упростить до /fish/shark/swim.txt. Мы увидим, как справиться с этой избыточностью позже в этой главе, когда будем 
рассматривать normalize().

#### Рис. 14.2 - Относительные пути с использованием символов пути


Символическая ссылка — это специальный файл в файловой системе, который служит ссылкой или указателем на другой файл или 
каталог. Предположим, у нас есть символическая ссылка из /zoo/user/favorite на /fish/shark. Доступ к папке shark и ее 
элементам можно получить напрямую или по символической ссылке. Например, следующие пути ссылаются на один и тот же файл:

```
/fish/shark/swim.txt
/zoo/user/favorite/swim.txt
```

В общем, символические ссылки прозрачны для пользователя, поскольку операционная система заботится о разрешении ссылки 
на реальный файл. Хотя API ввода-вывода не поддерживают символические ссылки, NIO.2 включает полную поддержку создания, 
обнаружения и навигации по символическим ссылкам в файловой системе.

### Создание файла или пути

Чтобы сделать что-нибудь полезное, вам сначала понадобится объект, представляющий путь к определенному файлу или 
каталогу в файловой системе. При использовании устаревшего ввода-вывода это класс java.io.File, тогда как в NIO.2 это 
интерфейс java.nio.file.Path. Класс File и интерфейс Path не могут читать или записывать данные в файле, хотя они 
передаются как ссылка на другие классы, как вы увидите в этой главе.

_Помните, что File или Path могут представлять файл или каталог._

### Создание File

Класс File создается путем вызова его конструктора. Этот код показывает три разных конструктора:

```
File zooFile1 = new File("/home/tiger/data/stripes.txt");
File zooFile2 = new File("/home/tiger", "data/stripes.txt");
File parent = new File("/home/tiger");
File zooFile3 = new File(parent, "data/stripes.txt");

System.out.println(zooFile1.exists());
```

Все три создают объект File, который указывает на одно и то же место на диске. Если бы мы передали null в качестве 
родительского элемента конечному конструктору, он был бы проигнорирован, и метод вел бы себя так же, как одиночный 
конструктор String. Ради интереса мы также покажем, как определить, существует ли файл в файловой системе.

### Создание Path

Поскольку Path — это интерфейс, мы не можем создать экземпляр напрямую. В конце концов, у интерфейсов нет конструкторов! 
Java предоставляет ряд классов и методов, которые можно использовать для получения объектов Path.

Самый простой и понятный способ получить объект Path — использовать статический фабричный метод, определенный в Path или 
Paths. Все четыре примера указывают на одну и ту же ссылку на диске:

```
Path zooPath1 = Path.of("/home/tiger/data/stripes.txt");
Path zooPath2 = Path.of("/home", "tiger", "data", "stripes.txt");

Path zooPath3 = Paths.get("/home/tiger/data/stripes.txt");
Path zooPath4 = Paths.get("/home", "tiger", "data", "stripes.txt");

System.out.println(Files.exists(zooPath1));
```

Оба метода позволяют передавать параметр varargs для передачи дополнительных элементов пути. Значения объединяются и 
автоматически разделяются с помощью разделителя файлов, зависящего от операционной системы. Мы также показываем 
вспомогательный класс Files, который может проверять, существует ли файл в файловой системе.

Как видите, здесь есть два способа сделать одно и то же. Метод Path.of() был представлен в Java 11 как статический метод 
интерфейса. Фабричный класс Paths также предоставляет метод get(), делающий то же самое. Обратите внимание на букву s в 
конце класса Paths, чтобы отличить его от интерфейса Path. В этой главе мы используем Path.of() и Paths.get() как 
взаимозаменяемые.

_Вы могли заметить, что классы I/O и NIO.2 могут взаимодействовать с URI. Единый идентификатор ресурса (URI) — это 
строка символов, идентифицирующая ресурс. Он начинается со схемы, указывающей тип ресурса, за которым следует значение 
пути, например file:// для локальных файловых систем и http://, https:// и ftp:// для удаленных файловых систем._

### Переключение между файлом и путем

Поскольку «Файл» и «Путь» ссылаются на местоположения на диске, полезно иметь возможность конвертировать между ними. 
К счастью, Java упрощает эту задачу, предоставляя такие методы:

```
File file = new File("rabbit");
Path nowPath = file.toPath();
File backToFile = nowPath.toFile();
```

Многие старые библиотеки используют File, что упрощает получение File по Path и наоборот. При работе с новыми 
приложениями вам следует полагаться на интерфейс Path NIO.2, поскольку он содержит гораздо больше функций. Например, 
только NIO.2 обеспечивает поддержку файловой системы, о чем мы собираемся поговорить.

### Получение пути из класса FileSystems

NIO.2 широко использует создание объектов с помощью фабричных классов. Класс FileSystems создает экземпляры абстрактного 
класса FileSystem. Последний включает в себя методы работы непосредственно с файловой системой. Оба Paths.get() и 
Path.of() являются ярлыками для этого метода файловой системы. Давайте перепишем наши предыдущие примеры еще раз, чтобы 
увидеть, как получить экземпляр Path в дальнейшем:

```
Path zooPath1 = FileSystems.getDefault()
   .getPath("/home/tiger/data/stripes.txt");
Path zooPath2 = FileSystems.getDefault()
   .getPath("/home", "tiger", "data", "stripes.txt");
```

### Обзор взаимосвязей ввода-вывода и NIO.2

Модель ввода-вывода меньше, и вам нужно только понять класс File. Напротив, NIO.2 имеет больше функций и широко 
использует фабричный шаблон. Вам должен быть удобен такой подход. Для многих ваших взаимодействий с NIO.2 потребуются 
два типа: абстрактный класс или интерфейс и фабричный или вспомогательный класс. На рисунке 14.3 показаны связи между 
классами и интерфейсом, которые мы использовали до сих пор в этой главе.

#### Рис. 14.3 - Взаимоотношения классов и интерфейсов ввода-вывода и NIO.2


Внимательно просмотрите рисунок 14.3. В частности, следите за тем, является ли имя класса в единственном или 
множественном числе. Классы с именами во множественном числе включают методы для создания или работы с экземплярами 
классов/интерфейсов с именами в единственном числе. Помните, что для удобства (и источника путаницы) Path также можно 
создать из интерфейса Path с использованием статического метода фабрики of().

_java.io.File — это класс ввода-вывода, а Files — вспомогательный класс NIO.2. Files работает с экземплярами Path, а не 
с экземплярами java.io.File. Мы знаем, что это сбивает с толку, но они из совершенно разных API!_

В таблице 14.2 представлены рассмотренные нами API для создания объектов java.io.File и java.nio.file.Path. Читая 
таблицу, помните, что статические методы работают с классом/интерфейсом, тогда как методы экземпляра требуют экземпляра 
объекта. Прежде чем переходить к остальной части главы, убедитесь, что вы это хорошо знаете.

#### Таблица 14.2 - Параметры создания File и Path

|   Создает   | Объявлено в  |                                                  Метод или конструктор                                                   |  
|:-----------:|:------------:|:------------------------------------------------------------------------------------------------------------------------:|
|    File     |     File     | public File(String pathname) <br/> public File(File parent, String child) <br/> public File(String parent, String child) |
|    File     |     Path     |                                               public default File toFile()                                               |
|    Path     |     File     |                                                   public Path toPath()                                                   |
|    Path     |     Path     |                 public static Path of(String first, String... more) <br/> public static Path of(URI uri)                 |
|    Path     |    Paths     |                public static Path get(String first, String... more) <br/> public static Path get(URI uri)                |
|    Path     |  FileSystem  |                                    public Path getPath(String first, String... more)                                     |
| FileSystem  | FileSystems  |                                          public static FileSystem getDefault()                                           |


## Операции с File и Path

Теперь, когда мы знаем, как создавать объекты File и Path, мы можем начать использовать их для полезных действий. В 
этом разделе мы исследуем доступные нам функциональные возможности, связанные с каталогами.

### Использование общей функциональности



