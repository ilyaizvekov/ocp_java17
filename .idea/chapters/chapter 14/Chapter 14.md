# Ввод/вывод

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование Java I/O API

+ Чтение и запись консольных и файловых данных с использованием потока ввода-вывода.
+ Сериализация и десериализация объектов Java.
+ Создавайте, перемещайте, читайте и записывайте объекты Path и их свойства с помощью API java.nio.file.

---

Что могут делать приложения Java помимо управления объектами и атрибутами в памяти? Как сохранить данные, чтобы 
информация не терялась каждый раз при завершении программы? Конечно, они используют файлы! Вы можете разработать код, 
который записывает текущее состояние приложения в файл каждый раз, когда приложение закрывается, а затем перезагружает 
данные при следующем запуске приложения. Таким образом, информация сохраняется между выполнениями программы.

В этой главе основное внимание уделяется использованию API-интерфейсов I/O (ввод-вывод) и NIO.2 (неблокирующий ввод-вывод) 
для взаимодействия с файлами и потоками ввода-вывода. Предпочтительным подходом к работе с файлами и каталогами с 
помощью новых программных приложений является использование NIO.2, а не ввода-вывода, где это возможно. Однако вы 
увидите, что эти два понятия взаимосвязаны и оба широко используются.

Мы начнем с описания того, как файлы и каталоги организованы в файловой системе, и покажем, как получить к ним доступ с 
помощью класса File и интерфейса Path. Затем мы покажем, как работать с файлами и каталогами. Мы завершаем эту главу 
более сложными темами, такими как сериализация данных, обсуждение способов чтения пользовательского ввода во время 
выполнения с использованием класса Console и взаимодействие с атрибутами файлов.


_NIO означает неблокирующий API ввода/вывода и иногда его называют новым вводом/выводом. На экзамене рассматривается NIO 
версии 2. Была версия 1, охватывающая каналы, но ее нет на экзамене._

## Ссылки на файлы и каталоги

Мы начнем эту главу с рассмотрения того, какие файлы и каталоги находятся в файловой системе. Мы также представляем 
класс File и интерфейс Path, а также способы их создания.

### Представление файловой системы

Начнем с основ. Данные хранятся на постоянных запоминающих устройствах, таких как жесткие диски и карты памяти. Файл на 
устройстве хранения содержит данные. Файлы организованы в иерархии с помощью каталогов. Каталог — это место, которое 
может содержать как файлы, так и другие каталоги. Работая с каталогами в Java, мы часто относимся к ним как к файлам. 
Фактически, мы используем одни и те же классы и интерфейсы для работы с файлами и каталогами. Например, файл и каталог 
можно переименовать одним и тем же методом Java. Обратите внимание, что в этой главе мы часто говорим «файл» для 
обозначения файла или каталога.

Для взаимодействия с файлами нам необходимо подключиться к файловой системе. Файловая система отвечает за чтение и 
запись данных на компьютере. Разные операционные системы используют разные файловые системы для управления своими 
данными. Например, системы на базе Windows используют другую файловую систему, чем системы на базе Unix. Для сдачи 
экзамена вам просто нужно знать, как вводить команды с помощью API Java. JVM автоматически подключится к локальной 
файловой системе, что позволит вам выполнять одни и те же операции на нескольких платформах.

Далее, корневой каталог — это самый верхний каталог файловой системы, от которого наследуются все файлы и каталоги. 
В Windows он обозначается буквой диска, например C:\, а в Linux — одной косой чертой /.

Путь — это представление файла или каталога в файловой системе. Каждая файловая система определяет свой собственный 
символ-разделитель путей, который используется между записями каталога. Значение слева от разделителя является 
родительским для значения справа от разделителя. Например, значение пути /user/home/zoo.txt означает, что файл zoo.txt 
находится внутри домашнего каталога, а каталог home находится внутри каталога user.

---

**Разделители файлов операционной системы**

Различные операционные системы различаются по формату имен путей. Например, в системах на базе Unix для пути 
используется косая черта /, тогда как в системах на базе Windows используется символ обратной косой черты \. Тем не 
менее, многие языки программирования и файловые системы поддерживают оба типа косой черты при написании операторов пути. 
Java предлагает системное свойство для получения символа локального разделителя для текущей среды:

```
System.out.print(System.getProperty("file.separator"));
```

---

На рисунке 14.1 мы показываем, как каталоги и файловая система организованы иерархически.

#### Рис. 14.1 - Иерархия каталогов и файлов


На этой диаграмме показан корневой каталог c:, содержащий два каталога: app и zoo, а также файл info.txt. В каталоге 
app есть еще две папки, animals и employees, а также файл java.exe. Наконец, каталог animals содержит два файла: 
Bear.java и Bear.class.

Мы используем как абсолютные, так и относительные пути к файлу или каталогу в файловой системе. Абсолютный путь к файлу 
или каталогу — это полный путь от корневого каталога до файла или каталога, включая все подкаталоги, содержащие файл или 
каталог. Альтернативно, относительный путь к файлу или каталогу — это путь от текущего рабочего каталога к файлу или 
каталогу. Например, ниже приведен абсолютный путь к файлу Bear.java:

```
C:\app\animals\Bear.java
```

Ниже приведен относительный путь к тому же файлу, при условии, что текущий каталог пользователя установлен как C:\app:

```
animals\Bear.java
```

Определение того, является ли путь относительным или абсолютным, зависит от файловой системы. Для соответствия экзамену 
мы принимаем следующие соглашения:

+ Если путь начинается с косой черты (/), он является абсолютным, с корневым каталогом /, например /bird/parrot.png.
+ Если путь начинается с буквы диска (c:), он является абсолютным, причем буква диска соответствует корневому каталогу, например C:/bird/info.
+ В противном случае это относительный путь, например bird/parrot.png.

Абсолютные и относительные пути могут содержать символы пути. Символ пути — это один из зарезервированных рядов символов, 
имеющих особое значение в некоторых файловых системах. Для сдачи экзамена вам необходимо знать два символа пути, 
перечисленных в таблице 14.1.

#### Таблица 14.1 - Символы файловой системы

| Символ |               Описание                |  
|:------:|:-------------------------------------:|
|   .    |       Ссылка на текущий каталог       |
|   ..   | Ссылка на родителя текущего каталога  |


Глядя на рисунок 14.2, предположим, что текущий каталог — /fish/shark/hammerhead. В этом случае ../swim.txt — это 
действительный относительный путь, эквивалентный /fish/shark/swim.txt. Аналогично, ./play.png ссылается на play.png в 
текущем каталоге. Эти символы также можно комбинировать для большего эффекта. Например, ../../clownfish — это 
относительный путь, эквивалентный /fish/clownfish в файловой системе.

Иногда вы увидите избыточные или ненужные символы пути. Например, абсолютный путь /fish/clownfish/../shark/./swim.txt 
можно упростить до /fish/shark/swim.txt. Мы увидим, как справиться с этой избыточностью позже в этой главе, когда будем 
рассматривать normalize().

#### Рис. 14.2 - Относительные пути с использованием символов пути


Символическая ссылка — это специальный файл в файловой системе, который служит ссылкой или указателем на другой файл или 
каталог. Предположим, у нас есть символическая ссылка из /zoo/user/favorite на /fish/shark. Доступ к папке shark и ее 
элементам можно получить напрямую или по символической ссылке. Например, следующие пути ссылаются на один и тот же файл:

```
/fish/shark/swim.txt
/zoo/user/favorite/swim.txt
```

В общем, символические ссылки прозрачны для пользователя, поскольку операционная система заботится о разрешении ссылки 
на реальный файл. Хотя API ввода-вывода не поддерживают символические ссылки, NIO.2 включает полную поддержку создания, 
обнаружения и навигации по символическим ссылкам в файловой системе.

### Создание файла или пути

Чтобы сделать что-нибудь полезное, вам сначала понадобится объект, представляющий путь к определенному файлу или 
каталогу в файловой системе. При использовании устаревшего ввода-вывода это класс java.io.File, тогда как в NIO.2 это 
интерфейс java.nio.file.Path. Класс File и интерфейс Path не могут читать или записывать данные в файле, хотя они 
передаются как ссылка на другие классы, как вы увидите в этой главе.

_Помните, что File или Path могут представлять файл или каталог._

### Создание File

Класс File создается путем вызова его конструктора. Этот код показывает три разных конструктора:

```
File zooFile1 = new File("/home/tiger/data/stripes.txt");
File zooFile2 = new File("/home/tiger", "data/stripes.txt");
File parent = new File("/home/tiger");
File zooFile3 = new File(parent, "data/stripes.txt");

System.out.println(zooFile1.exists());
```

Все три создают объект File, который указывает на одно и то же место на диске. Если бы мы передали null в качестве 
родительского элемента конечному конструктору, он был бы проигнорирован, и метод вел бы себя так же, как одиночный 
конструктор String. Ради интереса мы также покажем, как определить, существует ли файл в файловой системе.

### Создание Path

Поскольку Path — это интерфейс, мы не можем создать экземпляр напрямую. В конце концов, у интерфейсов нет конструкторов! 
Java предоставляет ряд классов и методов, которые можно использовать для получения объектов Path.

Самый простой и понятный способ получить объект Path — использовать статический фабричный метод, определенный в Path или 
Paths. Все четыре примера указывают на одну и ту же ссылку на диске:

```
Path zooPath1 = Path.of("/home/tiger/data/stripes.txt");
Path zooPath2 = Path.of("/home", "tiger", "data", "stripes.txt");

Path zooPath3 = Paths.get("/home/tiger/data/stripes.txt");
Path zooPath4 = Paths.get("/home", "tiger", "data", "stripes.txt");

System.out.println(Files.exists(zooPath1));
```

Оба метода позволяют передавать параметр varargs для передачи дополнительных элементов пути. Значения объединяются и 
автоматически разделяются с помощью разделителя файлов, зависящего от операционной системы. Мы также показываем 
вспомогательный класс Files, который может проверять, существует ли файл в файловой системе.

Как видите, здесь есть два способа сделать одно и то же. Метод Path.of() был представлен в Java 11 как статический метод 
интерфейса. Фабричный класс Paths также предоставляет метод get(), делающий то же самое. Обратите внимание на букву s в 
конце класса Paths, чтобы отличить его от интерфейса Path. В этой главе мы используем Path.of() и Paths.get() как 
взаимозаменяемые.

_Вы могли заметить, что классы I/O и NIO.2 могут взаимодействовать с URI. Единый идентификатор ресурса (URI) — это 
строка символов, идентифицирующая ресурс. Он начинается со схемы, указывающей тип ресурса, за которым следует значение 
пути, например file:// для локальных файловых систем и http://, https:// и ftp:// для удаленных файловых систем._

### Переключение между файлом и путем

Поскольку «Файл» и «Путь» ссылаются на местоположения на диске, полезно иметь возможность конвертировать между ними. 
К счастью, Java упрощает эту задачу, предоставляя такие методы:

```
File file = new File("rabbit");
Path nowPath = file.toPath();
File backToFile = nowPath.toFile();
```

Многие старые библиотеки используют File, что упрощает получение File по Path и наоборот. При работе с новыми 
приложениями вам следует полагаться на интерфейс Path NIO.2, поскольку он содержит гораздо больше функций. Например, 
только NIO.2 обеспечивает поддержку файловой системы, о чем мы собираемся поговорить.

### Получение пути из класса FileSystems

NIO.2 широко использует создание объектов с помощью фабричных классов. Класс FileSystems создает экземпляры абстрактного 
класса FileSystem. Последний включает в себя методы работы непосредственно с файловой системой. Оба Paths.get() и 
Path.of() являются ярлыками для этого метода файловой системы. Давайте перепишем наши предыдущие примеры еще раз, чтобы 
увидеть, как получить экземпляр Path в дальнейшем:

```
Path zooPath1 = FileSystems.getDefault()
   .getPath("/home/tiger/data/stripes.txt");
Path zooPath2 = FileSystems.getDefault()
   .getPath("/home", "tiger", "data", "stripes.txt");
```

### Обзор взаимосвязей ввода-вывода и NIO.2

Модель ввода-вывода меньше, и вам нужно только понять класс File. Напротив, NIO.2 имеет больше функций и широко 
использует фабричный шаблон. Вам должен быть удобен такой подход. Для многих ваших взаимодействий с NIO.2 потребуются 
два типа: абстрактный класс или интерфейс и фабричный или вспомогательный класс. На рисунке 14.3 показаны связи между 
классами и интерфейсом, которые мы использовали до сих пор в этой главе.

#### Рис. 14.3 - Взаимоотношения классов и интерфейсов ввода-вывода и NIO.2


Внимательно просмотрите рисунок 14.3. В частности, следите за тем, является ли имя класса в единственном или 
множественном числе. Классы с именами во множественном числе включают методы для создания или работы с экземплярами 
классов/интерфейсов с именами в единственном числе. Помните, что для удобства (и источника путаницы) Path также можно 
создать из интерфейса Path с использованием статического метода фабрики of().

_java.io.File — это класс ввода-вывода, а Files — вспомогательный класс NIO.2. Files работает с экземплярами Path, а не 
с экземплярами java.io.File. Мы знаем, что это сбивает с толку, но они из совершенно разных API!_

В таблице 14.2 представлены рассмотренные нами API для создания объектов java.io.File и java.nio.file.Path. Читая 
таблицу, помните, что статические методы работают с классом/интерфейсом, тогда как методы экземпляра требуют экземпляра 
объекта. Прежде чем переходить к остальной части главы, убедитесь, что вы это хорошо знаете.

#### Таблица 14.2 - Параметры создания File и Path

|   Создает   | Объявлено в  |                                                  Метод или конструктор                                                   |  
|:-----------:|:------------:|:------------------------------------------------------------------------------------------------------------------------:|
|    File     |     File     | public File(String pathname) <br/> public File(File parent, String child) <br/> public File(String parent, String child) |
|    File     |     Path     |                                               public default File toFile()                                               |
|    Path     |     File     |                                                   public Path toPath()                                                   |
|    Path     |     Path     |                 public static Path of(String first, String... more) <br/> public static Path of(URI uri)                 |
|    Path     |    Paths     |                public static Path get(String first, String... more) <br/> public static Path get(URI uri)                |
|    Path     |  FileSystem  |                                    public Path getPath(String first, String... more)                                     |
| FileSystem  | FileSystems  |                                          public static FileSystem getDefault()                                           |


## Операции с File и Path

Теперь, когда мы знаем, как создавать объекты File и Path, мы можем начать использовать их для полезных действий. В 
этом разделе мы исследуем доступные нам функциональные возможности, связанные с каталогами.

### Использование общей функциональности

Многие операции можно выполнять с использованием как библиотек ввода-вывода, так и NIO.2. Многие распространенные API 
представлены в таблицах 14.3 и 14.4. Хотя эти таблицы могут показаться набором методов для изучения, многие из них 
говорят сами за себя. Вы можете пока игнорировать параметры vararg. Мы объясним это позже в этой главе.

#### Таблица 14.3 - Общие операции с File и Path

|                            Описание                            | Метод экземпляра файла ввода-вывода | Метод экземпляра пути NIO.2 |  
|:--------------------------------------------------------------:|:-----------------------------------:|:---------------------------:|
|                  Получает имя файла/каталога                   |              getName()              |        getFileName()        |
| Получает родительский каталог или значение null, если его нет. |             getParent()             |         getParent()         |
|     Проверяет, является ли файл/каталог абсолютным путем       |            isAbsolute()             |        isAbsolute()         |


#### Таблица 14.4 - Общие операции с File и Path

|                              Описание                              | Метод экземпляра файла ввода-вывода |                  Статический метод файлов NIO.2                  |  
|:------------------------------------------------------------------:|:-----------------------------------:|:----------------------------------------------------------------:|
|                        Удаляет файл/каталог                        |              delete()               |            deleteIfExists(Path p) throws IOException             |
|               Проверяет, существует ли файл/каталог                |              exists()               |                 exists(Path p, LinkOption... o)                  |
|             Получает абсолютный путь к файлу/каталогу              |          getAbsolutePath()          |                         toAbsolutePath()                         |
|              Проверяет, является ли ресурс каталогом               |            isDirectory()            |               isDirectory(Path p, LinkOption... o)               |
|                Проверяет, является ли ресурс файлом                |              isFile()               |              isRegularFile(Path p, LinkOption... o)              |
|            Возвращает время последнего изменения файла             |           lastModified()            | getLastModifiedTime(Path p, LinkOption... o) throws IOException  |
|                 Получает количество байтов в файле                 |              length()               |                 size(Path p) throws IOException                  |
|                  Перечисляет содержимое каталога                   |             listFiles()             |                 list(Path p) throws IOException                  |
|                          Создает каталог                           |               mkdir()               |  createDirectory(Path p, FileAttribute... a) throws IOException  |
| Создает каталог, включая все несуществующие родительские каталоги. |              mkdirs()               | createDirectories(Path p, FileAttribute... a) throws IOException |
|            Переименовывает файл/каталог, обозначенный              |        renameTo( File dest)         |  move(Path src, Path dest, CopyOption... o) throws IOException   |

Теперь давайте попробуем использовать некоторые из этих API. Ниже приведен пример программы, использующей только 
устаревшие API ввода-вывода. Учитывая путь к файлу, он выводит информацию о файле или каталоге, например, существует ли 
он, какие файлы в нем содержатся и т. д.:

```
10: public static void io() { 
11:    var file = new File("C:\\data\\zoo.txt"); 
12:    if (file.exists()) { 
13:       System.out.println("Absolute Path: " + file.getAbsolutePath()); 
14:       System.out.println("Is Directory: " + file.isDirectory()); 
15:       System.out.println("Parent Path: " + file.getParent()); 
16:       if (file.isFile()) { 
17:          System.out.println("Size: " + file.length()); 
18:          System.out.println("Last Modified: " + file.lastModified()); 
19:       } else {
20:          for (File subfile : file.listFiles()) { 
21:             System.out.println("   " + subfile.getName()); 
22:       } } } }
```

Если указанный путь указывает на действительный файл, программа выводит что-то похожее на следующее из-за оператора if 
в строке 16:

```
Absolute Path: C:\data\zoo.txt
Is Directory: false
Parent Path: C:\data
Size: 12382
Last Modified: 1650610000000
```

Наконец, если указанный путь указывает на допустимый каталог, например C:\data, программа выводит что-то похожее на 
следующее, благодаря блоку else:

```
Absolute Path: C:\data
Is Directory: true
Parent Path: C:\
   employees.txt
   zoo.txt
   zoo-backup.txt
```

В этих примерах вы видите, что выходные данные программы ввода-вывода полностью зависят от каталогов и файлов, доступных 
во время выполнения в базовой файловой системе.

На экзамене вы можете увидеть пути, которые выглядят как файлы, но являются каталогами или наоборот. Например, 
/data/zoo.txt может быть файлом или каталогом, даже если у него есть расширение файла. Не думайте, что это так, если 
вопрос не говорит вам об этом!

_В предыдущем примере мы использовали две обратную косую черту (\\) в строке пути, например C:\\data\\zoo.txt. Когда 
компилятор видит \\ внутри выражения String, он интерпретирует его как одно значение \._

Теперь давайте напишем ту же самую программу, используя только NIO.2, и посмотрим, чем она отличается:

```
25: public static void nio() throws IOException { 
26:    var path = Path.of("C:\\data\\zoo.txt"); 
27:    if (Files.exists(path)) { 
28:       System.out.println("Absolute Path: " + path.toAbsolutePath()); 
29:       System.out.println("Is Directory: " + Files.isDirectory(path)); 
30:       System.out.println("Parent Path: " + path.getParent()); 
31:       if (Files.isRegularFile(path)) { 
32:          System.out.println("Size: " + Files.size(path));
33:          System.out.println("Last Modified: " 
34:             + Files.getLastModifiedTime(path)); 
35:       } else { 
36:          try (Stream<Path> stream = Files.list(path)) { 
37:             stream.forEach(p -> 
38:                System.out.println("   " + p.getName())); 
39:       } } } }
```

Большая часть этого примера эквивалентна и заменяет вызовы методов ввода-вывода в предыдущих таблицах версиями NIO.2. 
Однако есть ключевые различия. Во-первых, строка 25 объявляет проверенное исключение. Больше API в NIO.2 выбрасывают 
IOException, чем API ввода-вывода. В этом случае Files.size(), Files.getLastModifiedTime() и Files.list() вызывают 
исключение IOException.

Во-вторых, в строках 36-39 используются Stream и лямбда-выражение вместо цикла. Поскольку потоки используют отложенное 
вычисление, это означает, что метод будет загружать каждый элемент пути по мере необходимости, а не весь каталог сразу.

---

**Закрытие потока**

Вы заметили, что в последнем примере кода мы поместили наш объект Stream в try-with-resources? Потоковые методы NIO.2 
открывают соединение с файловой системой, которое необходимо правильно закрыть; в противном случае может произойти 
утечка ресурсов. Утечка ресурсов в файловой системе означает, что путь может быть заблокирован от изменения еще долгое 
время после завершения процесса, который его использовал.

Если вы предположили, что терминальная операция потока автоматически закроет соответствующие файловые ресурсы, вы 
ошиблись. Когда это поведение было впервые представлено, было много споров; Короче говоря, требование от разработчиков 
закрыть поток победило.

С другой стороны, не все потоки нужно закрывать: только те, которые открывают ресурсы, например те, что есть в NIO.2. 
Например, вам не нужно было закрывать ни один из потоков, с которыми вы работали в главе 10 «Потоки».

Наконец, экзамен не всегда правильно закрывает ресурсы NIO.2. Чтобы соответствовать экзамену, мы иногда пропускаем 
закрытие ресурсов NIO.2 в обзорных и практических вопросах. Всегда используйте операторы try-with-resources с этими 
методами NIO.2 в своем собственном коде.

---

В оставшейся части этого раздела мы обсуждаем только методы NIO.2, поскольку они более важны. О них также нужно знать 
больше, и они с большей вероятностью попадут на экзамен.

### Методы обработки, которые объявляют IOException

Многие из методов, представленных в этой главе, объявляют IOException. Общие причины возникновения этого исключения 
методом включают следующее:

+ Потеря связи с базовой файловой системой.
+ Файл или каталог существует, но к нему невозможно получить доступ или изменить его.
+ Файл существует, но не может быть перезаписан.
+ Файл или каталог необходим, но не существует.

Методы, которые получают доступ к файлам и каталогам или изменяют их, например, в классе Files, часто объявляют 
IOException. Как мы увидим, из этого правила есть исключения. Например, метод Files.exists() не объявляет IOException. 
Если бы он выдал исключение, когда файл не существовал, он бы никогда не смог вернуть false! Как правило, если метод 
NIO.2 объявляет исключение IOException, для него обычно требуются пути, по которым он работает.

### Предоставление дополнительных параметров NIO.2

Многие из методов NIO.2 в этой главе включают переменные аргументы, которые принимают необязательный список значений. В 
таблице 14.5 представлены аргументы, с которыми вам следует ознакомиться на экзамене.


#### Таблица 14.2 - Общие аргументы метода NIO.2

| Тип перечисления   |    Интерфейс унаследован    | Перечисляемое значение                                                              |                                                                                                                                                     Подробности                                                                                                                                                      |  
|--------------------|:---------------------------:|-------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| LinkOption         | CopyOption <br/> OpenOption | NOFOLLOW_LINKS                                                                      |                                                                                                                                       Не переходите по символическим ссылкам.                                                                                                                                        |
| StandardCopyOption |         CopyOption          | ATOMIC_MOVE <br/> COPY_ATTRIBUTES <br/> REPLACE_EXISTING                            |                                                                           Переместить файл как операцию атомарной файловой системы. <br/> Скопируйте существующие атрибуты в новый файл. <br/> Перезаписать файл, если он уже существует.                                                                            |
| StandardOpenOption |         OpenOption          | APPEND <br/> CREATE <br/> CREATE_NEW <br/> READ <br/> TRUNCATE_EXISTING <br/> WRITE | Если файл уже открыт для записи, добавьте его в конец. <br/> Создайте новый файл, если он не существует. <br/> Создавать новый файл, только если он не существует; иначе провалиться. <br/> Открыт для чтения. <br/> Если файл уже открыт для записи, сотрите файл и добавьте его в начало. <br/> Открыт для записи. |
| FileVisitOption    |            N/A              | FOLLOW_LINKS                                                                        |                                                                                                                                        Переходите по символическим ссылкам.                                                                                                                                          |
|                    |                             |                                                                                     |                                                                                                                                                                                                                                                                                                                      |
|                    |                             |                                                                                     |                                                                                                                                                                                                                                                                                                                      |
|                    |                             |                                                                                     |                                                                                                                                                                                                                                                                                                                      |


За исключением Files.copy() и Files.move(), мы не будем обсуждать эти параметры с переменными аргументами каждый раз, 
когда представляем метод. Однако их поведение должно быть прямолинейным. Например, можете ли вы выяснить, что делает 
следующий вызов Files.exists() с LinkOption в следующем фрагменте кода?

```
Path path = Paths.get("schedule.xml");
boolean exists = Files.exists(path, LinkOption.NOFOLLOW_LINKS);
```

Files.exists() просто проверяет, существует ли файл. Но если параметр является символической ссылкой, метод вместо этого 
проверяет, существует ли цель символической ссылки. Предоставление LinkOption.NOFOLLOW_LINKS означает, что поведение по 
умолчанию будет переопределено, и метод проверит, существует ли сама символическая ссылка.

Обратите внимание, что некоторые перечисления в таблице 14.5 наследуют интерфейс. Это означает, что некоторые методы 
принимают различные типы перечислений. Например, метод Files.move() принимает переменную переменную CopyOption, поэтому 
он может принимать перечисления разных типов, и со временем можно будет добавить дополнительные параметры.

```
void copy(Path source, Path target) throws IOException {
   Files.move(source, target,
      LinkOption.NOFOLLOW_LINKS,
      StandardCopyOption.ATOMIC_MOVE);
}
```

### Взаимодействие с путями NIO.2

Как и значения String, экземпляры Path неизменяемы. В следующем примере операция Path во второй строке теряется, 
поскольку p является неизменяемым:

```
Path p = Path.of("whale");
p.resolve("krill");
System.out.println(p);  // whale
```

Многие методы, доступные в интерфейсе Path, каким-то образом преобразуют значение пути и возвращают новый объект Path, 
позволяя объединять методы в цепочку. Мы продемонстрируем цепочку в следующем примере, детали которого мы обсудим в этом 
разделе главы:

```
Path.of("/zoo/../home").getParent().normalize().toAbsolutePath();
```

### Просмотр пути

Интерфейс Path содержит три метода для получения базовой информации о представлении пути. Метод toString() возвращает 
строковое представление всего пути. Фактически, это единственный метод интерфейса Path, возвращающий строку. Многие 
другие методы интерфейса Path возвращают экземпляры Path.

Методы getNameCount() и getName() часто используются вместе для получения количества элементов в пути и ссылки на каждый 
элемент соответственно. Эти два метода не включают корневой каталог как часть пути.

```
Path path = Paths.get("/land/hippo/harry.happy");
System.out.println("The Path Name is: " + path);
for(int i=0; i<path.getNameCount(); i++)
   System.out.println("   Element " + i + " is: " + path.getName(i));
```

Обратите внимание, что мы не вызывали toString() явно во второй строке. Помните, Java вызывает toString() для любого 
объекта как часть конкатенации строк. Мы используем эту функцию во всех примерах в этой главе.

Код печатает следующее:

```
The Path Name is: /land/hippo/harry.happy
   Element 0 is: land
   Element 1 is: hippo
   Element 2 is: harry.happy
```

Несмотря на то, что это абсолютный путь, корневой элемент не включен в список имен. Как мы уже говорили, эти методы не 
рассматривают корневую часть пути.

```
var p = Path.of("/");
System.out.print(p.getNameCount()); // 0
System.out.print(p.getName(0));     // IllegalArgumentException
```

Обратите внимание: если вы попытаетесь вызвать getName() с недопустимым индексом, во время выполнения будет выдано 
исключение.

_В наших примерах в качестве символа-разделителя файлов печатается / из-за используемой нами системы. Фактический 
результат может отличаться в этой главе._

### Создание части пути

Интерфейс Path включает метод subpath() для выбора частей пути. Он принимает два параметра: включающий beginIndex и 
эксклюзивный endIndex. Это должно звучать знакомо, поскольку именно так работает метод substring() в String, как вы 
видели в главе 4 «Основные API».

Следующий фрагмент кода показывает, как работает subpath(). Мы также печатаем элементы Path с помощью getName(), чтобы 
вы могли видеть, как используются индексы.

```
var p = Paths.get("/mammal/omnivore/raccoon.image");
System.out.println("Path is: " + p);
for (int i = 0; i < p.getNameCount(); i++) {
   System.out.println("   Element " + i + " is: " + p.getName(i));
}
System.out.println();
System.out.println("subpath(0,3): " + p.subpath(0, 3));
System.out.println("subpath(1,2): " + p.subpath(1, 2));
System.out.println("subpath(1,3): " + p.subpath(1, 3));
```

Вывод этого фрагмента кода следующий:

```
Path is: /mammal/omnivore/raccoon.image
   Element 0 is: mammal
   Element 1 is: omnivore
   Element 2 is: raccoon.image

subpath(0,3): mammal/omnivore/raccoon.image
subpath(1,2): omnivore
subpath(1,3): omnivore/raccoon.image
```

Подобно getNameCount() и getName(), метод subpath() имеет нулевой индекс и не включает корень. Также, как и getName(), 
subpath() выдает исключение, если предоставлены недопустимые индексы.

```
var q = p.subpath(0, 4); // IllegalArgumentException
var x = p.subpath(1, 1); // IllegalArgumentException
```

Первый пример создает исключение во время выполнения, поскольку максимальное допустимое значение индекса равно 3. 
Второй пример создает исключение, поскольку начальный и конечный индексы одинаковы, что приводит к пустому значению 
пути.

### Accessing Path Elements

