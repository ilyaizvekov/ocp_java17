# JDBC

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Доступ к базам данных с помощью JDBC

+ Создавайте соединения, создавайте и выполняйте базовые, подготовленные и вызываемые операторы, обрабатывайте 
результаты запросов и управляйте транзакциями с помощью JDBC API.

---

JDBC означает подключение к базе данных Java. Эта глава познакомит вас с основами доступа к базам данных из Java. Мы 
рассмотрим ключевые интерфейсы для подключения, выполнения запросов, обработки результатов и работы с транзакциями.

Если вы новичок в JDBC, обратите внимание, что в этой главе рассматриваются только основы JDBC и работа с базами данных. 
Того, что мы проходим, достаточно для экзамена. Чтобы быть готовым использовать JDBC в работе, мы рекомендуем вам 
прочитать книги по SQL, а также по Java и базам данных. Например, вы можете попробовать SQL для чайников, 9-е издание 
Аллена Г. Тейлора (Wiley, 2018) и «Практическое программирование баз данных на Java» Ин Бай (Wiley-IEEE Press, 2011).

---

**Для опытных разработчиков**

Если вы опытный разработчик и хорошо знаете JDBC, вы можете пропустить раздел «Введение в реляционные базы данных и 
SQL». Однако внимательно прочитайте остальную часть этой главы. Мы обнаружили, что экзамен охватывает некоторые темы, 
которые разработчики не используют на практике, в частности:

+ Вероятно, вы настроили URL-адрес один раз для проекта для конкретной базы данных. Часто разработчики просто копируют 
и вставляют его откуда-то еще. Для экзамена вы должны понять это, а не полагаться на поиск.
+ Вероятно, вы используете DataSource. Для экзамена вам придется вспомнить или заново изучить, как работает DriverManager.

---

## Знакомство с реляционными базами данных и SQL

Данные — это информация. Часть данных — это один факт, например ваше имя. База данных — это организованный набор данных. 
В реальном мире картотека — это разновидность базы данных. В нем есть папки с файлами, в каждой из которых лежат 
листочки бумаги. Папки с файлами организованы определенным образом, часто в алфавитном порядке. Каждый листок бумаги 
подобен фрагменту данных. Точно так же папки на вашем компьютере подобны базе данных. Папки обеспечивают организацию, 
а каждый файл представляет собой часть данных.

Реляционная база данных — это база данных, организованная в таблицы, состоящие из строк и столбцов. Вы можете думать о 
таблице как о электронной таблице. Существует два основных способа доступа к реляционной базе данных из Java:

+ Подключение к базе данных Java (JDBC): доступ к данным в виде строк и столбцов. JDBC — это API, описанный в этой главе.
+ Java Persistence API (JPA): доступ к данным через объекты Java, используя концепцию, называемую объектно-реляционным 
сопоставлением (ORM). Идея состоит в том, что вам не нужно писать так много кода, и вы получаете данные в объектах Java. 
JPA не входит в экзамен, поэтому он не рассматривается в этой главе.

Доступ к реляционной базе данных осуществляется через язык структурированных запросов (SQL). SQL — это язык 
программирования, используемый для взаимодействия с записями базы данных. JDBC работает, отправляя команду SQL в базу 
данных и затем обрабатывая ответ.

Помимо реляционных баз данных, существует еще один тип баз данных, называемый базой данных NoSQL. Эти базы данных хранят 
свои данные в формате, отличном от таблиц, например ключ-значение, хранилища документов и базы данных на основе графов. 
NoSQL также выходит за рамки экзамена.

В следующих разделах мы представим небольшую реляционную базу данных, которую мы будем использовать для примеров в этой 
главе, и представим SQL для доступа к ней. Мы также рассмотрим некоторую лексику, которую вам необходимо знать.

---

**Выполнение примеров из главы**

В большинстве глав этой книги вам придется писать код и пробовать множество примеров. Эта глава другая. По-прежнему 
приятно попробовать примеры, но вы, вероятно, сможете правильно ответить на вопросы JDBC на экзамене, просто прочитав 
эту главу и освоив контрольные вопросы.

Хотя экзамен не зависит от базы данных, нам пришлось использовать базу данных для примеров, и мы выбрали базу данных 
HyperSQL. Это небольшая база данных в памяти. Фактически, для его запуска вам понадобится только один JAR-файл. Для 
реальных проектов нам нравятся MySQL и PostgreSQL.

Инструкции по загрузке и настройке базы данных для примеров в главе находятся в:

```
www.selikoff.net/ocp17
```

На данный момент вам не нужно разбираться ни в каком коде на веб-сайте. Это просто для того, чтобы вас настроить. 
Короче говоря, он подключается к базе данных и создает две таблицы. К концу этой главы вы должны понять, как таким 
образом создать Connection и ReadedStatement.

Существует множество руководств по установке и началу работы с любым из них. Настройка базы данных выходит за рамки 
книги и экзамена, но не стесняйтесь задавать вопросы в разделе базы данных/JDBC на CodeRanch. Возможно, вы даже 
получите ответ от авторов.

---

### Определение структуры реляционной базы данных

В нашей примерной базе данных есть две таблицы. В одном есть ряд для каждого вида, который есть в нашем зоопарке. 
В другом есть ряд для каждого животного. Эти два связаны друг с другом, потому что животное принадлежит к виду. 
Эти отношения являются причиной того, что этот тип базы данных называется реляционной базой данных. На рисунке 15.1 
показана структура нашей базы данных.

#### Рис. 15.1 - Таблицы в нашей реляционной базе данных


Как вы можете видеть на рисунке 15.1, у нас есть две таблицы. Один назван exhibits, а другой назван names. Каждая 
таблица имеет первичный ключ, который дает нам уникальный способ ссылки на каждую строку. В конце концов, у двух 
животных может быть одно и то же имя, но у них не может быть одного и того же идентификатора. Вам не нужно знать ключи 
к экзамену. Мы упоминаем их, чтобы дать вам немного контекста. В нашем примере так получилось, что первичным ключом 
является только один столбец. В некоторых ситуациях это комбинация столбцов, называемая составным ключом. Например, 
идентификатор студента и год могут быть составным ключом.

В таблице exhibits две строки и три столбца, а в таблице names — пять строк и три столбца. Для экзамена вам необходимо 
знать о строках и столбцах.

### Написание базовых операторов SQL

Самое главное, что вам нужно знать о SQL для экзамена, это то, что существует четыре типа операторов для работы с 
данными в таблицах. Они называются CRUD (Создание, Чтение, Обновление, Удаление). Ключевые слова SQL не соответствуют 
аббревиатуре, поэтому обратите внимание на ключевое слово SQL для каждого из них в таблице 15.1.

#### Таблица 15.1 - CRUD-операции

| Операция | Ключевое слово SQL |                   Описание                   |  
|:--------:|:------------------:|:--------------------------------------------:|
| Создать  |       INSERT       |       Добавляет новую строку в таблицу       |
|  Читать  |       SELECT       |          Получает данные из таблицы          |
| Обновить |       UPDATE       | Изменяет ноль или несколько строк в таблице  |
| Удалить  |      DELETE        | Удаляет ноль или несколько строк из таблицы  |

Вот и все. От вас не требуется определять корректность операторов SQL. От вас не ожидается обнаружения синтаксических 
ошибок в операторах SQL. От вас не требуется писать операторы SQL. Обратили внимание на тему?

В отличие от Java, ключевые слова SQL нечувствительны к регистру. Это означает, что select, SELECT и Select эквивалентны. 
Подобно примитивным типам Java, SQL имеет несколько типов данных. Большинство из них говорят сами за себя, например 
INTEGER. Еще есть DECIMAL, который в Java во многом похож на оператор double. Самым странным является VARCHAR, что 
означает «переменный символ», который похож на String в Java. Переменная part означает, что база данных должна 
использовать ровно столько места, сколько ей необходимо для хранения значения.

Хотя вам не обязательно знать, как их писать, мы приводим основные четыре инструкции SQL в таблице 15.2, поскольку они 
встречаются во многих вопросах.

#### Таблица 15.2 - SQL

|                                    Ключевое слово SQL                                     |                                                                                                                                                 Объяснение                                                                                                                                                 |  
|:-----------------------------------------------------------------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|               INSERT INTO exhibits <br/> VALUES (3, 'Asian Elephant', 7.5);               |                                                                                      Добавляет новую строку с указанными значениями. По умолчанию используется порядок, в котором столбцы были определены в таблице.                                                                                       | 
|                        SELECT * FROM exhibits <br/> WHERE ID = 3;                         | Считывает данные из таблицы с необязательным предложением WHERE для ограничения возвращаемых данных. В SELECT можно использовать * для возврата всех столбцов, перечислять определенные столбцы для возврата или даже вызывать функции, такие как COUNT(*), чтобы возвращать количество совпадающих строк. |
| UPDATE exhibits <br/> SET num_acres = num_acres + .5 <br/> WHERE name = 'Asian Elephant'; |                                                                                              Устанавливает значение столбца с помощью необязательного предложения WHERE, чтобы ограничить обновляемые строки.                                                                                              |
|                DELETE FROM exhibits <br/> WHERE name = 'Asian Elephant';                  |                                                                                                     Удаляет строки с необязательным предложением WHERE, чтобы ограничить количество удаляемых строк.                                                                                                       |

## Знакомство с интерфейсами JDBC

Для сдачи экзамена вам необходимо знать пять ключевых интерфейсов JDBC. Интерфейсы объявлены в JDK. Они такие же, как и 
все другие интерфейсы и классы, которые вы видели в этой книге. Например, в главе 9 «Коллекции и обобщения» вы работали 
с интерфейсом List и конкретным классом ArrayList.

В JDBC конкретные классы берутся из драйвера JDBC. Каждая база данных имеет отдельный файл JAR с этими классами. 
Например, JAR PostgreSQL называется примерно так: postgresql-9.4–1201.jdbc4.jar. JAR MySQL называется примерно так: 
mysql-connector-java-5.1.36.jar. Точное имя зависит от производителя и версии JAR драйвера.

Этот JAR-файл драйвера содержит реализацию этих ключевых интерфейсов, а также ряда других интерфейсов. Ключевым 
моментом является то, что предоставленные реализации знают, как взаимодействовать с базой данных. Существуют также 
разные типы драйверов; к счастью, вам не нужно знать об этом на экзамене.

На рисунке 15.2 показаны пять ключевых интерфейсов, которые вам необходимо знать. Это также показывает, что реализация 
обеспечивается воображаемым JAR-файлом драйвера Foo. Они ловко прикрепляют имя Foo во всех классах.

Вы, наверное, заметили, что мы не сказали вам, как называются реализующие классы в любой реальной базе данных. Главное, 
что вы не должны этого знать. Используя JDBC, вы используете только интерфейсы в своем коде и никогда непосредственно 
не используете классы реализации. Фактически, они могут даже не быть публичными классами.

Что делают эти пять интерфейсов? На очень высоком уровне мы имеем следующее:

+ Driver: Устанавливает соединение с базой данных
+ Connection: Отправляет команды в базу данных
+ PreparedStatement: Выполняет SQL-запрос
+ CallableStatement: Выполняет команды, хранящиеся в базе данных.
+ ResultSet: Читает результаты запроса

#### Рис. 15.2 - Ключевые интерфейсы JDBC


Все интерфейсы базы данных находятся в пакете java.sql, поэтому в этой главе мы часто опускаем импорт.

В следующем примере мы покажем вам, как выглядит код JDBC, от начала до конца. Если вы новичок в JDBC, обратите 
внимание, что три из пяти интерфейсов присутствуют в коде. Если у вас есть опыт, помните, что на экзамене используется 
класс DriverManager вместо интерфейса DataSource.

```
public class MyFirstDatabaseConnection {
   public static void main(String[] args) throws SQLException {
      String url = "jdbc:hsqldb:file:zoo";
      try (Connection conn = DriverManager.getConnection(url);
         PreparedStatement ps = conn.prepareStatement(
            "SELECT name FROM exhibits");
         ResultSet rs = ps.executeQuery()) {
         while (rs.next())
            System.out.println(rs.getString(1));
   }   }   }
```

Если бы URL-адрес использовал наш воображаемый драйвер Foo, DriverManager вернул бы экземпляр FooConnection. Вызов метода 
prepareStatement() затем вернет экземпляр FooPreparedStatement, а вызов метода executeQuery() вернет экземпляр 
FooResultSet. Поскольку вместо этого URL-адрес использует hsqldb, он возвращает реализации, предоставленные HyperSQL для 
этих интерфейсов. Вам не обязательно знать их имена. В оставшейся части главы мы объясним, как использовать все пять 
интерфейсов, и более подробно расскажем о том, что они делают. К концу главы вы сами будете писать подобный код.

---

**Компиляция с модулями**

Почти все пакеты на экзамене находятся в модуле java.base. Как вы, возможно, помните из главы 12 «Модули», этот модуль 
включается автоматически, когда вы запускаете приложение в качестве модуля.

Напротив, все классы JDBC находятся в модуле java.sql. Они также находятся в пакете java.sql. Имена одинаковые, поэтому 
их легко запомнить. При работе с SQL вам понадобится модуль java.sql и импортируйте java.sql.*.

Мы рекомендуем разделить обучение JDBC и модулям. Вы можете использовать путь к классам при работе с JDBC и 
зарезервировать свою практику с путем к модулю для изучения модулей.

Тем не менее, если вы хотите использовать код JDBC с модулями, не забудьте обновить файл module-info, включив в него 
следующее:

```
requires java.sql;
```

---

## Подключение к базе данных

Первым шагом при работе с базой данных является подключение к ней. Сначала мы покажем вам, как создать URL-адрес JDBC. 
Затем мы покажем вам, как использовать его для подключения к базе данных.

### Создание URL-адреса JDBC

Чтобы получить доступ к веб-сайту, вам необходимо знать его URL. Чтобы получить доступ к электронной почте, вам 
необходимо знать свое имя пользователя и пароль. JDBC ничем не отличается. Чтобы получить доступ к базе данных, вам 
необходимо знать эту информацию о ней.

В отличие от веб-URL-адресов, URL-адреса JDBC имеют различные форматы. У них есть три общие части, как показано на 
рисунке 15.3. Первая часть всегда одна и та же. Это протокол jdbc. Вторая часть — это подпротокол, представляющий собой 
имя базы данных, например hsqldb, mysql или postgres. Третья часть — это подимя, которое представляет собой формат, 
специфичный для базы данных. Двоеточие (:) разделяет три части.

Подимя обычно содержит информацию о базе данных, такую как ее местоположение и/или имя. Синтаксис варьируется. Вам нужно 
знать о трех основных частях. Вам не нужно запоминать форматы подимен. Фух! Вы уже видели один такой URL:

```
jdbc:hsqldb:file:zoo
```

#### Рис. 15.3 - Формат URL-адреса JDBC


Обратите внимание на три части. Он начинается с jdbc, а затем идет подпротокол hsqldb. Оно заканчивается подименем, 
которое говорит нам, что мы используем файловую систему. В этом случае местоположение является именем базы данных.

Другие примеры подимен показаны здесь:

```
jdbc:postgresql://localhost/zoo
jdbc:oracle:thin:@123.123.123.123:1521:zoo
jdbc:mysql://localhost:3306
jdbc:mysql://localhost:3306/zoo?profileSQL=true
```

Вы можете видеть, что каждый из этих URL-адресов JDBC начинается с jdbc, за которым следует двоеточие, а затем имя 
поставщика/продукта. После этого URL-адреса меняются. Обратите внимание, что все они включают расположение базы данных: 
localhost, 123.123.123.123:1521 и localhost:3306. Также обратите внимание, что порт не является обязательным при 
использовании местоположения по умолчанию.

### Получение базы данных Connection

Существует два основных способа получения соединения (Connection): DriverManager и DataSource. DriverManager — это тот, 
который рассматривается на экзамене. Не используйте DriverManager в коде, за написание которого вам платят. Источник 
данных имеет больше возможностей, чем DriverManager. Например, он может объединять соединения или хранить информацию о 
соединениях с базой данных вне приложения.

Класс DriverManager находится в JDK, поскольку это API, поставляемый с Java. Он использует шаблон фабрики, что означает, 
что вы вызываете статический метод для получения Connection, а не вызов конструктора. Как вы видели в главе 11 
«Исключения и локализация», шаблон фабрики означает, что при вызове метода вы можете получить любую реализацию 
интерфейса. Хорошей новостью является то, что у метода легко запоминающееся имя: getConnection().

Чтобы получить соединение из базы данных HyperSQL, вы пишете следующее:

```
import java.sql.*;
public class TestConnect {
   public static void main(String[] args) throws SQLException {
      try (Connection conn = 
           DriverManager.getConnection("jdbc:hsqldb:file:zoo")) {
           System.out.println(conn);
   }  }  }
```

Как и в главе 11, мы используем оператор try-with-resources, чтобы гарантировать закрытие ресурсов базы данных. Более 
подробно о закрытии ресурсов базы данных мы поговорим далее в этой главе. Мы также выбрасываем проверенное 
SQLException, что означает, что что-то пошло не так. Например, вы могли забыть указать расположение драйвера базы данных 
в пути к классам.

Предполагая, что программа работает успешно, она выводит что-то вроде этого:

```
org.hsqldb.jdbc.JDBCConnection@3dfc5fb8
```

Детали вывода не важны. Просто обратите внимание, что класс не Connection. Это реализация Connection от поставщика.

Существует также подпись, которая принимает имя пользователя и пароль.

```
import java.sql.*;
public class TestExternal {
   public static void main(String[] args) throws SQLException {
      try (Connection conn = DriverManager.getConnection(
         "jdbc:postgresql://localhost:5432/ocp-book",
         "username",
         "Password20182")) {
         System.out.println(conn);
      } } }   
```

Обратите внимание на три параметра, которые передаются в getConnection(). Первый — это URL-адрес JDBC, о котором вы 
узнали в предыдущем разделе. Второе — это имя пользователя для доступа к базе данных, а третье — пароль для доступа к 
базе данных. Само собой разумеется, что наш пароль — не Password20182. Кроме того, не вводите свой пароль в реальный 
код. Это ужасная практика. Всегда загружайте его из какой-либо конфигурации, в идеале из той, которая сохраняет 
сохраненное значение в зашифрованном виде.

Если бы вы запустили это с JAR-файлом драйвера Postgres, он бы напечатал что-то вроде этого:

```
org.postgresql.jdbc4.Jdbc4Connection@eed1f14
```

Опять же, обратите внимание, что это класс реализации, специфичный для драйвера. Это можно понять по названию пакета. 
Поскольку пакет называется org.postgresql.jdbc4, он является частью драйвера PostgreSQL.

Если в экзамене не указана командная строка, вы можете предположить, что правильный JAR-файл драйвера JDBC находится в 
пути к классам. Создатели экзамена прямо спрашивают о JAR-файле драйвера, хотят ли они, чтобы вы об этом подумали.

Преимущество шаблона фабрики заключается в том, что он берет на себя логику создания класса за вас. Вам не нужно знать 
имя класса, реализующего Connection, и вам не нужно знать, как он создается. Хотя вам, вероятно, немного любопытно.

DriverManager просматривает все найденные драйверы, чтобы определить, могут ли они обрабатывать URL-адрес JDBC. Если 
это так, он создает Connection с использованием этого Driver. Если нет, он сдается и выдает исключение SQLException.

_Вы можете увидеть Class.forName() в коде. Это требовалось для старых драйверов (которые были разработаны для более 
старых версий JDBC) перед получением Connection._

## Работа с PreparedStatement

В Java у вас есть выбор: работать с Statement, ReadableStatement или CallableStatement. Последние два являются 
подинтерфейсами Statement, как показано на рисунке 15.4.

#### Рис. 15.4 - Типы утверждений



Далее в этой главе вы узнаете об использовании CallableStatement для запросов, находящихся внутри базы данных. В этом 
разделе мы рассмотрим ReadedStatement.

А как насчет Statement, спросите вы? Это интерфейс, который расширяется как PreparedStatement , так и CallableStatement. 
Statement и PreparedStatement похожи друг на друга, за исключением того, что PreparedStatement принимает параметры, а 
Statement — нет. Statement просто выполняет любой SQL-запрос, который вы ему даете.

Хотя можно запускать SQL напрямую с помощью Statement, не следует этого делать. PreparedStatement намного превосходит 
его по следующим причинам:

+ **Производительность:** В большинстве программ одни и те же запросы выполняются несколько раз. Когда вы используете 
PreparedStatement, программное обеспечение базы данных часто разрабатывает план правильного выполнения запроса и запоминает его.
+ **Безопасность:** Вы защищены от атаки, называемой SQL-инъекцией, при правильном использовании PreparedStatement.
+ **Читабельность:** Приятно не иметь дело с конкатенацией строк при построении строки запроса с большим количеством параметров.
+ **Использование в будущем:** Даже если ваш запрос выполняется только один раз или не имеет параметров, вам все равно следует использовать PreparedStatement. Таким образом, будущие редакторы кода не будут добавлять переменную, и им придется не забыть потом перейти на PreparedStatement.

---

**Маленькие столики Бобби**

SQL-инъекция часто вызвана отсутствием должным образом обработанного пользовательского ввода. Автор популярного 
веб-комикса xkcd.com однажды задал вопрос, что произойдет, если чье-то имя будет содержать оператор SQL?

«Подвиги мамы» воспроизведено с разрешения xkcd.com/327/

**вставить картинку**

Упс! Предполагаю, что школе следовало использовать PreparedStatement и привязать имя каждого ученика к переменной. 
Если бы это было так, вся строка была бы правильно экранирована и сохранена в базе данных.

---

Непосредственное использование интерфейса Statement не входит в задачу экзамена JDBC, поэтому мы не рассматриваем его в 
этой книге. В следующих разделах мы рассмотрим получение PreparedStatement, его выполнение, работу с параметрами
и запуск нескольких обновлений.

### Получение PreparedStatement

Чтобы запустить SQL, вам нужно сообщить об этом PreparedStatement. Получить подготовленный оператор из Connection легко.

```
try (PreparedStatement ps = conn.prepareStatement(
   "SELECT * FROM exhibits")) {
   // work with ps
}
```

Экземпляр PreparedStatement представляет собой инструкцию SQL, которую вы хотите запустить с помощью Connection. Он еще 
не выполняет запрос! Мы доберемся до этого в ближайшее время.

Передача оператора SQL при создании объекта является обязательной. На экзамене вы можете увидеть подвох.

```
try (var ps = conn.prepareStatement()) { // НЕ КОМПИЛИРУЕТСЯ
}
```

Предыдущий пример не компилируется, поскольку SQL не предоставляется во время запроса PreparedStatement. В этом примере 
мы также использовали var. Мы пишем код JDBC, используя как var, так и фактические имена классов, чтобы вы привыкли к 
обоим подходам.

Существуют перегруженные сигнатуры, позволяющие указать тип ResultSet и режим параллелизма. На экзамене вам нужно только 
знать, как использовать параметры по умолчанию, которые обрабатывают результаты по порядку.

### Выполнение PreparedStatement

Теперь, когда у нас есть подготовленный оператор, мы можем запустить оператор SQL. Метод запуска SQL варьируется в 
зависимости от типа оператора SQL. Помните, что от вас не требуется умения читать SQL, но вам необходимо знать, что 
означает первое ключевое слово.

### Изменение данных с помощью executeUpdate()

Начнем с операторов, которые изменяют данные в таблице. Это операторы SQL, начинающиеся с DELETE, INSERT или UPDATE. 
Обычно они используют метод executeUpdate(). Название немного сложное, поскольку инструкция SQL UPDATE — не единственная 
инструкция, использующая этот метод.

Метод принимает оператор SQL для запуска в качестве параметра. Он возвращает количество строк, которые были вставлены, 
удалены или изменены. Вот пример всех трех типов обновлений:

```
10: var insertSql = "INSERT INTO exhibits VALUES(10, 'Deer', 3)"; 
11: var updateSql = "UPDATE exhibits SET name = '' " + 
12:    "WHERE name = 'None'"; 
13: var deleteSql = "DELETE FROM exhibits WHERE id = 10"; 
14:
15: try (var ps = conn.prepareStatement(insertSql)) { 
16:    int result = ps.executeUpdate(); 
17:    System.out.println(result); // 1 
18: }
19:
20: try (var ps = conn.prepareStatement(updateSql)) { 
21:    int result = ps.executeUpdate(); 
22:    System.out.println(result); // 0 
23: }
24:
25: try (var ps = conn.prepareStatement(deleteSql)) { 
26:    int result = ps.executeUpdate(); 
27:    System.out.println(result); // 1 
28: }
```

Для экзамена вам не нужно читать SQL. Если вам нужно знать, вопрос скажет вам, сколько строк затронуто. Обратите 
внимание, что каждому отдельному оператору SQL требуется собственный вызов метода prepareStatement().

Строка 15 создает оператор вставки, а строка 16 запускает этот оператор для вставки одной строки. Результат равен 1, 
поскольку была затронута одна строка. В строке 20 создается оператор обновления, а в строке 21 проверяется вся таблица 
на наличие соответствующих записей для обновления. Поскольку совпадений нет, результат равен 0. В строке 25 создается 
оператор удаления, а в строке 26 удаляется строка, созданная в строке 16. Опять же, затрагивается одна строка, поэтому 
результат равен 1.

### Чтение данных с помощью executeQuery()

Далее давайте посмотрим на оператор SQL, который начинается с SELECT. На этот раз мы используем метод executeQuery().

```
30: var sql = "SELECT * FROM exhibits"; 
31: try (var ps = conn.prepareStatement(sql); 
32:    ResultSet rs = ps.executeQuery() ) { 
33:
34:    // work with rs 
35: }
```

В строке 31 мы создаем PreparedStatement для нашего запроса SELECT. В строке 32 мы запускаем его. Поскольку мы 
выполняем запрос для получения результата, тип возвращаемого значения — ResultSet. В следующем разделе мы покажем вам, 
как обрабатывать ResultSet.

### Обработка данных с помощью execute()

Существует третий метод, называемый execute(), который может выполнять либо запрос, либо обновление. Он возвращает 
логическое значение, чтобы мы знали, существует ли ResultSet. Таким образом, мы можем вызвать правильный метод, чтобы 
получить более подробную информацию. Шаблон выглядит следующим образом:

```
boolean isResultSet = ps.execute();
if (isResultSet) {
   try (ResultSet rs = ps.getResultSet()) {
      System.out.println("ran a query");
   }
} else {
   int result = ps.getUpdateCount();
   System.out.println("ran an update");
}
```

Если PreparedStatement ссылается на sql, который является SELECT, логическое значение равно true, и мы можем получить
ResultSet. Если это не SELECT, мы можем получить количество обновленных строк.

### Использование правильного метода

Как вы думаете, что произойдет, если мы используем неправильный метод для оператора SQL? Давайте взглянем:

```
var sql = "SELECT * FROM names";
try (var ps = conn.prepareStatement(sql)) {

   var result = ps.executeUpdate();
}
```

Это вызывает исключение SQLException, подобное следующему:

```
Exception in thread "main" java.sql.SQLException: 
statement does not generate a row count
```

Мы не можем получить ошибку компилятора, поскольку SQL является String. Однако мы можем получить исключение, и мы это 
делаем. Мы также получаем исключение SQLException при использовании метода executeQuery() с SQL, который изменяет базу 
данных.

```
Exception in thread "main" java.sql.SQLException: 
statement does not generate a result set
```

И снова мы получаем исключение, поскольку драйвер не может преобразовать запрос в ожидаемый тип возвращаемого значения.

### Обзор методов PreparedStatement

Перед повторением убедитесь, что вы хорошо знаете Таблицу 15.3 и Таблицу 15.4. В Таблице 15.3 показано, какие операторы 
SQL могут выполняться каждым из трех ключевых методов PreparedStatement. В таблице 15.4 показано, что возвращает каждый метод.

#### Таблица 15.3 - SQL, запускаемый методом execute

|        Метод        | DELETE | INSERT | SELECT | UPDATE |  
|:-------------------:|:------:|:------:|:------:|:------:|
|    ps.execute()     |   Да   |   Да   |   Да   |   Да   |
|  ps.executeQuery()  |  Нет   |  Нет   |   Да   |  Нет   |
| ps.executeUpdate()  |   Да   |   Да   |  Нет   |   Да   |

#### Таблица 15.4 - Возвращаемые типы методов execute

|        Метод        | Возвращаемый тип |  Что возвращается для SELECT  |     Что возвращается при DELETE/INSERT/UPDATE     |  
|:-------------------:|:----------------:|:-----------------------------:|:-------------------------------------------------:|
|    ps.execute()     |     boolean      |             true              |                       false                       |
|  ps.executeQuery()  |    ResultSet     | Возвращаемые строки и столбцы |                        n/a                        |
| ps.executeUpdate()  |       int        |              n/a              | Количество добавленных/измененных/удаленных строк |

### Работа с Parameters

Предположим, в нашем зоопарке появился новый слон, и мы хотим зарегистрировать его в нашей таблице имен. Мы уже узнали 
достаточно, чтобы сделать это.

```
public static void register(Connection conn) throws SQLException {
   var sql = "INSERT INTO names VALUES(6, 1, 'Edith')";
   
   try (var ps = conn.prepareStatement(sql)) {
      ps.executeUpdate();
   }
}
```

Однако все жестко запрограммировано. Мы хотим иметь возможность передавать значения в качестве параметров. К счастью, 
PreparedStatement позволяет нам устанавливать параметры. Вместо указания трех значений в SQL мы можем использовать 
вопросительный знак (?). Переменная привязки — это заполнитель, который позволяет указывать фактические значения во 
время выполнения. Переменная привязки аналогична параметру, и вы увидите, что переменные привязки упоминаются и как 
переменные, и как параметры. Мы можем переписать наш оператор SQL, используя переменные связывания.

```
String sql = "INSERT INTO names VALUES(?, ?, ?)";
```

Переменные привязки облегчают чтение SQL, поскольку вам больше не нужно использовать кавычки вокруг строковых значений в 
SQL. Теперь мы можем передать параметры самому методу.

```
14: public static void register(Connection conn, int key, 
15:    int type, String name) throws SQLException { 
16:
17:    String sql = "INSERT INTO names VALUES(?, ?, ?)"; 
18:
19:    try (PreparedStatement ps = conn.prepareStatement(sql)) { 
20:       ps.setInt(1, key);
21:       ps.setString(3, name); 
22:       ps.setInt(2, type); 
23:       ps.executeUpdate(); 
24:    }
25: }
```

В строке 19 создается PreparedStatement с использованием нашего SQL, который содержит три переменные привязки. Строки 
20–22 устанавливают эти переменные. Вы можете думать о переменных привязки как о списке параметров, каждый из которых 
задается по очереди. Обратите внимание, что переменные связывания могут быть установлены в любом порядке. Строка 23 
выполняет запрос и запускает обновление.

Обратите внимание, что переменные связывания считаются начиная с 1, а не с 0. Это действительно важно, поэтому мы 
повторим это.

_Помните, что JDBC начинает подсчет столбцов с 1, а не с 0. Обычный экзаменационный вопрос проверяет, что вы это знаете!_

В предыдущем примере мы установили параметры не по порядку. Это совершенно нормально. Правило заключается только в том, 
что каждый из них устанавливается до выполнения запроса. Давайте посмотрим, что произойдет, если вы не установите все 
переменные привязки.

```
var sql = "INSERT INTO names VALUES(?, ?, ?)";
try (var ps = conn.prepareStatement(sql)) {
   ps.setInt(1, key);
   ps.setInt(2, type);
   // // отсутствует значение, заданное для параметра номер 3
   ps.executeUpdate();
}
```

Код компилируется, и вы получаете исключение SQLException. Сообщение может отличаться в зависимости от вашего драйвера 
базы данных.

```
Exception in thread "main" java.sql.SQLException: Parameter not set
```

Что будет, если вы попытаетесь установить больше значений, чем у вас есть в качестве переменных привязки?

```
var sql = "INSERT INTO names VALUES(?, ?)";
try (var ps = conn.prepareStatement(sql)) {
   ps.setInt(1, key);
   ps.setInt(2, type);
   ps.setString(3, name);
   ps.executeUpdate();
}
```

И снова вы получаете исключение SQLException, на этот раз с другим сообщением. В HyperSQL это сообщение было следующим:

```
Exception in thread "main" java.sql.SQLException:
row column count mismatch in statement [INSERT INTO names VALUES(?, ?)]
```

В Таблице 15.5 показаны методы, которые необходимо знать на экзамене для установки переменных привязки. Те, которые вам 
нужно знать для экзамена, легко запомнить, поскольку они называются set, за которым следует имя типа, который вы 
устанавливаете. Есть много других, например свиданий, которые выходят за рамки экзамена.

#### Таблица 15.5 - Методы PreparedStatement 

|   Метод    | Тип параметра | Пример типа базы данных |  
|:----------:|:-------------:|:-----------------------:|
| setBoolean |    boolean    |         BOOLEAN         |
| setDouble  |    double     |         DOUBLE          |
|   setInt   |      int      |         INTEGER         |
|  setLong   |     long      |         BIGINT          |
|  setNull   |      int      |        Любой тип        |
| setObject  |    Object     |        Любой тип        |
| setString  |    String     |      CHAR, VARCHAR      |

В первом столбце показано имя метода, а во втором — тип, который использует Java. В третьем столбце показано имя типа, 
который может находиться в базе данных. В зависимости от базы данных существуют некоторые различия, поэтому проверьте 
документацию по конкретной базе данных. Для экзамена вам необходимо знать только первые две колонки.

Метод setNull() принимает параметр int, представляющий тип столбца в базе данных. Вам не обязательно знать эти типы. 
Обратите внимание, что метод setObject() работает с любым типом Java. Если вы передадите примитив, он будет 
автоматически упакован в тип-оболочку. Это означает, что мы можем переписать наш пример следующим образом:

```
String sql = "INSERT INTO names VALUES(?, ?, ?)";
try (PreparedStatement ps = conn.prepareStatement(sql)) {
   ps.setObject(1, key);
   ps.setObject(2, type);
   ps.setObject(3, name);
   ps.executeUpdate();
}
```

Java выполнит преобразование типов за вас. Все же лучше вызвать более конкретные методы установки, поскольку это приведет 
к ошибке времени компиляции, если вы передадите неправильный тип вместо ошибки времени выполнения.

### Обновление нескольких записей

Предположим, мы получили двух новых слонов и хотим добавить обоих. Мы можем использовать тот же объект PreparedStatement.

```
var sql = "INSERT INTO names VALUES(?, ?, ?)";

try (var ps = conn.prepareStatement(sql)) {

   ps.setInt(1, 20);
   ps.setInt(2, 1);
   ps.setString(3, "Ester");
   ps.executeUpdate();
   
   ps.setInt(1, 21);
   ps.setString(3, "Elias");
   ps.executeUpdate();
}
```

Обратите внимание, что при добавлении Ester мы задаем все три параметра, а для Elias — только два. PreparedStatement 
достаточно умен, чтобы запомнить уже установленные параметры и сохранить их. Вам нужно только установить те, 
которые отличаются.

---

Сценарий реального мира

**Пакетные операторы**

JDBC поддерживает пакетную обработку, поэтому вы можете запускать несколько операторов за меньшее количество обращений 
к базе данных. Часто база данных находится на другом компьютере, на котором выполняется код Java. Сохранение поездок в 
базе данных экономит время, поскольку сетевые вызовы могут быть дорогостоящими. Например, если вам нужно вставить в базу 
данных 1000 записей, вставка их как один сетевой вызов (а не 1000 сетевых вызовов) обычно выполняется намного быстрее.

Для экзамена вам не обязательно знать методы addBatch() и executeBatch(), но они пригодятся на практике.

```
public static void register(Connection conn, int firstKey,
   int type, String... names) throws SQLException {
   
   var sql = "INSERT INTO names VALUES(?, ?, ?)";
   var nextIndex = firstKey;
   
   try (var ps = conn.prepareStatement(sql)) {
      ps.setInt(2, type);
      
      for(var name: names) {
         ps.setInt(1, nextIndex);
         ps.setString(3, name);
         ps.addBatch();
         
         nextIndex++;
      }
      int[] result = ps.executeBatch();
      System.out.println(Arrays.toString(result));
   }
}
```

Теперь мы называем этот метод двумя именами:

```
register(conn, 100, 1,  "Elias", "Ester");
```

Вывод показывает, что массив состоит из двух элементов, поскольку в пакете есть два разных элемента. Каждый добавил по 
одной строке в базу данных.

```
[1, 1]
```

Вы можете использовать пакетную обработку для разделения больших операций, например вставки 10 миллионов записей в 
группы по 100. На практике требуется некоторая работа, чтобы определить подходящий размер пакета, но производительность 
при использовании пакета обычно намного выше, чем при вставке одной записи. построчно (или все десять миллионов сразу).

---

## Получение данных из ResultSet

База данных бесполезна, если вы не можете получить свои данные. Мы начнем с того, что покажем вам, как работать с 
ResultSet. Затем мы используем различные методы для получения столбцов по типу.

### Чтение ResultSet

При работе с ResultSet в большинстве случаев вы пишете цикл для просмотра каждой строки. Код выглядит следующим образом:

```
20: String sql = "SELECT id, name FROM exhibits"; 
21: var idToNameMap = new HashMap<Integer, String>(); 
22:
23: try (var ps = conn.prepareStatement(sql); 
24:    ResultSet rs = ps.executeQuery()) { 
25:
26:    while (rs.next()) { 
27:       int id = rs.getInt("id"); 
28:       String name = rs.getString("name"); 
29:       idToNameMap.put(id, name); 
30:    }
31:    System.out.println(idToNameMap); 
32: }
```

Выводит следующее: 

```
{1=African Elephant, 2=Zebra}
```

Здесь следует обратить внимание на несколько вещей. Сначала мы используем метод executeQuery() в строке 24, так как мы 
хотим вернуть ResultSet. В строке 26 мы просматриваем результаты. Каждый раз при выполнении цикла представляет одну 
строку в ResultSet. Строки 27 и 28 показывают лучший способ получить столбцы для данной строки.

ResultSet имеет курсор, который указывает на текущее местоположение в данных. На рисунке 15.5 показано положение при 
прохождении цикла.

#### Рис. 15.5 - Курсор ResultSet


В строке 24 курсор начинается с указания позиции перед первой строкой в ResultSet. На первой итерации цикла rs.next() 
возвращает true, и курсор перемещается, указывая на первую строку данных. На второй итерации цикла rs.next() снова 
возвращает true, и курсор перемещается, указывая на вторую строку данных. Следующий вызов rs.next() возвращает false. 
Курсор перемещается за конец данных. Значение false означает, что данных для получения больше нет.

Мы говорили, что «лучший способ» получить данные — это использовать имена столбцов. Есть еще один способ доступа к 
столбцам. Вместо имени столбца вы можете использовать индекс, считая от 1.

```
27:       int id = rs.getInt(1); 
28:       String name = rs.getString(2);
```

Теперь вы можете видеть позиции столбцов. Обратите внимание, что подсчет столбцов начинается с 1, а не с 0. Как и в 
случае с PreparedStatement, JDBC начинает отсчет с 1 в ResultSet.

Имя столбца лучше, потому что оно понятнее, что происходит при чтении кода. Это также позволяет вам изменить SQL, чтобы 
изменить порядок столбцов.

_На экзамене вам либо назовут названия столбцов таблицы, либо вы сможете предположить, что они правильные. Точно так же 
вы можете предположить, что весь SQL верен._

Иногда требуется получить только одну строку из таблицы. Возможно, вам нужен только один фрагмент данных. Или, может 
быть, SQL просто возвращает количество строк в таблице. Если вам нужна только одна строка, вы используете оператор if, 
а не цикл while.

```
var sql = "SELECT count(*) FROM exhibits";

try (var ps = conn.prepareStatement(sql);
   var rs = ps.executeQuery()) {
   
   if (rs.next()) {
      int count = rs.getInt(1);
      System.out.println(count);
   }
}
```

Важно убедиться, что rs.next() возвращает true, прежде чем пытаться вызвать геттер в ResultSet. Если запрос не вернул ни 
одной строки, он выдаст исключение SQLException, поэтому оператор if проверяет безопасность вызова. Альтернативно вы 
можете использовать имя столбца.

```
var count = rs.getInt("count");
```

Попробуем прочитать несуществующий столбец.

```
var sql = "SELECT count(*) AS count FROM exhibits";

try (var ps = conn.prepareStatement(sql);
   var rs = ps.executeQuery()) {
   
   if (rs.next()) {
      var count = rs.getInt("total");
      System.out.println(count);
   }
}
```

Это вызывает исключение SQLException с таким сообщением:

```
Exception in thread "main" java.sql.SQLException: Column not found: total
```

Попытка получить доступ к несуществующему имени столбца или индексу вызывает исключение SQLException, как и получение 
данных из ResultSet, когда они не указывают на допустимую строку. Вы должны уметь распознавать такой код. Вот несколько 
примеров, на которые следует обратить внимание. Вы видите, что не так, когда ни одна строка не совпадает?

```
var sql = "SELECT * FROM exhibits where name='Not in table'";

try (var ps = conn.prepareStatement(sql);
   var rs = ps.executeQuery()) {
   
   rs.next();
   rs.getInt(1); // SQLException
}
```

Вызов rs.next() работает. Он возвращает false. Однако последующий вызов метода получения вызывает исключение 
SQLException, поскольку курсор набора результатов не указывает на допустимую позицию. Если бы было возвращено совпадение, 
этот код сработал бы. Вы видите, что не так в следующем?

```
var sql = "SELECT count(*) FROM exhibits";

try (var ps = conn.prepareStatement(sql);
   var rs = ps.executeQuery()) {
   
   rs.getInt(1); // SQLException
}
```

Отсутствие вызова rs.next() вообще является проблемой. Курсор набора результатов по-прежнему указывает на место перед 
первой строкой, поэтому геттеру не на что указывать.

Подводя итог этому разделу, важно помнить следующее:

+ Всегда используйте оператор if или цикл while при вызове rs.next().
+ Индексы столбцов начинаются с 1.

### Получение данных из столбца

В интерфейсе ResultSet имеется множество методов get. В Таблице 15.6 показаны методы get, которые вам необходимо знать. 
Это геттерные эквиваленты сеттеров из таблицы 15.5.

#### Таблица 15.6 - Методы PreparedStatement

|   Метод    | Возращаемый тип |  
|:----------:|:---------------:|
| getBoolean |     boolean     |
| getDouble  |     double      |
|   getInt   |       int       |
|  getLong   |      long       |
| getObject  |     Object      |
| getString  |     String      |


Вы можете заметить, что не все примитивные типы представлены в Таблице 15.6. Есть методы getByte() и getFloat(), но для 
экзамена о них знать не обязательно. Метода getChar() нет. К счастью, вам не нужно об этом помнить. Экзамен не будет 
пытаться обмануть вас, используя имя метода get, которого не существует для JDBC. Разве это не мило со стороны 
создателей экзамена?

Метод getObject() может возвращать любой тип. Для примитива он использует класс-оболочку. Давайте посмотрим на следующий 
пример:

```
16: var sql = "SELECT id, name FROM exhibits"; 
17: try (var ps = conn.prepareStatement(sql); 
18:    var rs = ps.executeQuery()) { 
19:
20:    while (rs.next()) { 
21:       Object idField = rs.getObject("id"); 
22:       Object nameField = rs.getObject("name"); 
23:       if (idField instanceof Integer id) 
24:          System.out.println(id); 
25:       if (nameField instanceof String name) 
26:          System.out.println(name); 
27:    }
28: }
```

В строках 21 и 22 столбец получает Object любого наиболее подходящего типа. Строки 23–26 используют сопоставление с 
образцом для получения фактических типов. Вероятно, вы не будете использовать getObject() при написании кода для задания, 
но к экзамену полезно узнать об этом.

### Использование переменных привязки

Мы создавали PreparedStatement и ResultSet в одном и том же операторе try-withresources. Это не работает, если у вас 
есть переменные привязки, потому что их нужно установить между ними. К счастью, для решения этой проблемы мы можем 
вложить try-with-resources. Этот код распечатывает идентификатор всех экспонатов, соответствующих заданному имени:

```
30: var sql = "SELECT id FROM exhibits WHERE name = ?"; 
31:
32: try (var ps = conn.prepareStatement(sql)) { 
33:    ps.setString(1, "Zebra"); 
34:
35:    try (var rs = ps.executeQuery()) { 
36:       while (rs.next()) { 
37:          int id = rs.getInt("id"); 
38:          System.out.println(id); 
39:       }
40:    }
41: }
```

Обратите внимание на поток здесь. Сначала мы создаем PreparedStatement в строке 32. Затем мы устанавливаем переменную 
связывания в строке 33. Только после того, как оба этих шага выполнены, у нас есть вложенная попытка с ресурсами в 
строке 35 для создания ResultSet.

## Вызов CallableStatement

В некоторых ситуациях полезно хранить SQL-запросы в базе данных вместо того, чтобы упаковывать их в код Java. Это 
особенно полезно, когда имеется много сложных запросов. Хранимая процедура — это код, который заранее компилируется и 
сохраняется в базе данных. Хранимые процедуры обычно пишутся на специальном варианте SQL, который варьируется в 
зависимости от поставщика программного обеспечения баз данных.

Использование хранимой процедуры сокращает количество обращений по сети. Это также позволяет экспертам по базам данных 
владеть этой частью кода. Однако хранимые процедуры зависят от базы данных и усложняют обслуживание вашего приложения. 
На экзамене вам нужно знать, как вызывать хранимую процедуру, но не решать, когда ее использовать.

Для экзамена вам не нужно знать, как читать или писать хранимую процедуру. Поэтому мы не включили их в книгу. Если вам 
интересно, они находятся в коде настройки примера базы данных.

_Для экзамена вам не нужно изучать что-либо, связанное с базой данных. Поскольку изучение хранимых процедур может быть 
довольно сложным, мы рекомендуем ограничить изучение CallableStatement тем, что описано в этой книге._

В этом разделе мы будем использовать четыре хранимые процедуры. В таблице 15.7 обобщено все, что вам нужно о них знать. 
В реальном мире ни одна из этих реализаций не будет хорошей, поскольку они недостаточно сложны, чтобы служить хранимыми 
процедурами. Как видно из таблицы, хранимые процедуры позволяют параметрам быть только для ввода, только для вывода или 
для того и другого.

#### Таблица 15.7 - Примеры хранимых процедур

|           Имя            | Имя параметра | Тип параметра |                                                  Опсиание                                                   |  
|:------------------------:|---------------|---------------|:-----------------------------------------------------------------------------------------------------------:|
|      read_e_names()      | n/a           | n/a           |                  Возвращает все строки в таблице имен, имена которых начинаются с e или E.                  |
| read_ names_by_ letter() | prefix        | IN            | Возвращает все строки в таблице имен, имена которых начинаются с указанного параметра (без учета регистра). |
|     magic_ number()      | num           | OUT           |                                             Возвращает число 42                                             |
|    double_ number()      | num           | INOUT         |                              Умножает параметр на два и возвращает это число                                |

В следующих четырех разделах мы рассмотрим, как вызывать каждую из этих хранимых процедур.

### Вызов процедуры без параметров

Наша хранимая процедура read_e_names() не принимает никаких параметров. Он возвращает ResultSet. Поскольку мы работали с 
ResultSet в разделе PreparedStatement, здесь мы можем сосредоточиться на том, как вызывается хранимая процедура.

```
12: String sql = "{call read_e_names()}"; 
13: try (CallableStatement cs = conn.prepareCall(sql); 
14:    ResultSet rs = cs.executeQuery()) { 
15:
16:    while (rs.next()) { 
17:       System.out.println(rs.getString(3)); 
18:    }
19: }
```

Строка 12 вводит новый синтаксис. Хранимая процедура вызывается путем помещения слова call и имени процедуры в фигурные 
скобки ({}). Строка 13 создает объект CallableStatement. Когда мы создавали PreparedStatement, мы использовали метод
prepareStatement(). Здесь мы вместо этого используем метод prepareCall().

Строки 14–18 должны выглядеть знакомыми. Это стандартная логика, которую мы использовали для получения ResultSet и его 
обработки. Эта хранимая процедура возвращает базовую таблицу, поэтому столбцы одинаковы.

### Передача параметра IN

Хранимая процедура, которая всегда возвращает одно и то же, полезна лишь отчасти. Мы создали новую версию этой хранимой 
процедуры, более общую. Хранимая процедура read_names_by_letter() принимает в качестве параметра префикс или первую 
букву хранимой процедуры. Для ввода используется параметр IN.

Есть два различия в ее вызове по сравнению с нашей предыдущей хранимой процедурой.

```
25: var sql = "{call read_names_by_letter(?)}"; 
26: try (var cs = conn.prepareCall(sql)) { 
27:    cs.setString("prefix", "Z"); 
28:
29:    try (var rs = cs.executeQuery()) { 
30:       while (rs.next()) { 
31:          System.out.println(rs.getString(3)); 
32:       }
33:    }
34: }
```

В строке 25 мы должны передать ? чтобы показать, что у нас есть параметр. Это должно быть знакомо по привязке переменных 
с помощью PreparedStatement.

В строке 27 мы устанавливаем значение этого параметра. В отличие от PreparedStatement, мы можем использовать либо номер 
параметра (начиная с 1), либо имя параметра. Это означает, что эти два утверждения эквивалентны:

```
cs.setString(1, "Z");
cs.setString("prefix", "Z");
```

### Returning an OUT Parameter 

