# Операторы (Operators)

---
### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Обработка даты, времени, текста, числовых и логических значений

+ Используйте примитивы и классы-оболочки, включая Math API, круглые скобки, продвижение (возможно приведение) типов 
и приведение типов для вычисления арифметических и логических выражений.
---

В предыдущей главе много говорилось об определении переменных, но что вы можете сделать с переменной после её создания?
В этой главе представлены операторы и показано, как вы можете использовать их для объединения существующих переменных 
и создания новых значений. Он показывает вам, как применять операторы к различным примитивным типам данных, в том 
числе знакомит вас с операторами, которые могут быть применены к объектам.

## Понимание операторов Java (Understanding Java Operators)

Прежде чем мы перейдем к самому интересному, давайте немного разберемся с терминологией. Оператор Java — это 
специальный символ, который может быть применен к набору переменных, значений или литералов, называемых операндами, 
и который возвращает результат. Термин "операнд", который мы используем на протяжении всей этой главы, относится к 
значению или переменной, к которой применяется оператор. На рис. 2.1 показана структура операции Java.

#### Рис. 2.1 - Операция Java

Результат операции называется просто результатом. Рисунок 2.1 фактически содержит вторую операцию, в которой оператор 
присваивания (=) используется для сохранения результата в переменной c.

Мы уверены, что вы использовали операторы сложения (+) и вычитания (-) с самого детства. Java поддерживает многие 
другие операторы, которые вам необходимо знать для сдачи экзамена. Хотя многие из них вам следует изучить, некоторые 
(например, составные операторы присваивания) могут быть для вас новыми.

### Типы операторов (Types of Operators) 

Java поддерживает три разновидности операторов: унарные, бинарные и троичные (быть может тернарные?). Эти типы 
операторов могут применяться к одному, двум или трем операндам соответственно. Для сдачи экзамена вам необходимо знать 
определенное подмножество операторов Java, как их применять и в каком порядке они должны применяться.

Операторы Java не обязательно вычисляются слева направо. В этом следующем примере второе выражение фактически 
вычисляется справа налево, учитывая конкретные задействованные операторы:

```
int cookies = 4;
double reward = 3 + 2 * --cookies;
System.out.print("Zoo animal receives: " + reward + " reward points");
```

В этом примере вы сначала уменьшаете количество файлов cookie до 3, затем умножаете полученное значение на 2 и, наконец,
добавляете 3. Затем значение автоматически повышается с 9 до 9,0 и присваивается reward. Окончательные значения 
reward и cookie равны 9,0 и 3 соответственно, при этом напечатано следующее:

```
Zoo animal receives: 9.0 reward points
```

Если вы не следовали этой оценке, не волнуйтесь. К концу этой главы решение подобных задач должно стать вашей второй 
натурой.

### Приоритет оператора (Operator Precedence)

При чтении книги или газеты некоторые письменные языки оцениваются слева направо, а некоторые — справа налево. В 
математике некоторые операторы могут переопределять другие операторы и выполняться в первую очередь. Определение того, 
какие операторы оцениваются в каком порядке, называется приоритетом оператора. Таким образом, Java более точно следует 
правилам математики. Рассмотрим следующее выражение:

```
var perimeter = 2 * height + 2 * length;
```

Давайте применим некоторые необязательные круглые скобки, чтобы продемонстрировать, как компилятор оценивает этот 
оператор:

```
var perimeter = ((2 * height) + (2 * length));
```

Оператор умножения (*) имеет более высокий приоритет, чем оператор сложения (+), поэтому перед сложением height и 
length умножаются на 2. Оператор присваивания (=) имеет самый низкий приоритет, поэтому присваивание переменной 
perimeter выполняется последним.

Если не указано иное с помощью круглых скобок, операторы Java следуют порядку операций, указанному в таблице 2.1, в 
порядке убывания приоритета операторов. Если два оператора имеют одинаковый уровень приоритета, то Java гарантирует 
вычисление слева направо для большинства операторов, кроме отмеченных в таблице.

#### Таблица 2.1. - Порядок приоритета оператора


Мы рекомендуем держать таблицу 2.1 под рукой на протяжении всей этой главы. Для экзамена вам нужно запомнить порядок 
очередности в этой таблице. Обратите внимание, что вы не будете протестированы на некоторых операторах, таких как 
операторы сдвига, хотя мы рекомендуем вам знать об их существовании.

---
Стрелочный оператор (->), иногда называемый стрелочной функцией или лямбда-оператором, представляет собой бинарный 
оператор, представляющий отношение между двумя операндами. Хотя мы не будем рассматривать оператор стрелки в этой 
главе, вы увидите его использование в выражениях переключения в главе 3 «Принятие решений» и в лямбда-выражениях, 
начиная с главы 8 «Лямбда-выражения и функциональные интерфейсы».
---

## Применение унарных операторов (Applying Unary Operators)

По определению унарный оператор — это оператор, для работы которого требуется ровно один операнд или переменная.
Как показано в таблице 2.2, они часто выполняют простые задачи, такие как увеличение числовой переменной на единицу или 
отрицание логического значения.

#### Таблица 2.2. - Унарные операторы

Несмотря на то, что в таблице 2.2 есть оператор приведения, мы откладываем обсуждение приведения до раздела 
«Присвоение значений» далее в этой главе, поскольку именно там он обычно используется.

### Операторы дополнения и отрицания (Complement and Negation Operators)

Поскольку в этой главе мы будем работать со многими числовыми операторами, давайте сначала избавимся от логического 
оператора. Оператор логического дополнения (!) инвертирует значение логического выражения. Например, если значение 
равно true, оно будет преобразовано в false, и наоборот. Чтобы проиллюстрировать это, сравните выходные данные 
следующих операторов:

```
boolean isAnimalAsleep = false;
System.out.print(isAnimalAsleep); // false
isAnimalAsleep = !isAnimalAsleep;
System.out.print(isAnimalAsleep); // true
```

Для экзамена вам также необходимо знать об операторе побитового дополнения (~), который переворачивает все 0 и 1 в 
числе. Его можно применять только к целочисленным числовым типам, таким как byte, short, char, int и long.
Давайте попробуем пример. Для простоты мы показываем только последние четыре бита (вместо всех 32 бит).

```
int value = 3;                   // Stored as 0011
int complement = ~value;         // Stored as 1100
System.out.println(value);      // 3
System.out.println(complement); // -4
```

Расслабьтесь! Вам не нужно знать, как выполнять сложную битовую арифметику на экзамене, если вы помните это правило: 
чтобы найти побитовое дополнение числа, умножьте его на отрицательную единицу, а затем вычтите единицу.

```
System.out.println(-1*value - 1);       // -4
System.out.println(-1*complement - 1);  // 3
```

Переходя к более распространенным операторам, оператор отрицания/negation operator (-) меняет знак числового выражения, 
как показано в следующих утверждениях:

```
double zooTemperature = 1.21;
System.out.println(zooTemperature);   // 1.21
zooTemperature = -zooTemperature;
System.out.println(zooTemperature);   // -1.21
zooTemperature = -(-zooTemperature);
System.out.println(zooTemperature);   // -1.21
```

Обратите внимание, что в последнем примере мы использовали круглые скобки () для оператора отрицания -, чтобы применить 
отрицание дважды. Если бы вместо этого мы написали --, то это было бы интерпретировано как оператор декремента и 
напечатано -2,21. Вскоре вы увидите больше этого оператора декремента.

На основании описания может быть очевидно, что некоторые операторы требуют, чтобы переменная или выражение, с которыми 
они работают, имели определенный тип. Например, вы не можете применить оператор отрицания (-) к логическому выражению, 
а также вы не можете применить оператор логического дополнения (!) к числовому выражению. Будьте осторожны с вопросами 
на экзамене, которые пытаются сделать это, так как они приводят к тому, что код не компилируется. Например, ни одна из 
следующих строк кода не скомпилируется:

```
int pelican = !5;          // DOES NOT COMPILE
boolean penguin = -true;   // DOES NOT COMPILE
boolean peacock = !0;      // DOES NOT COMPILE
```

Первый оператор не будет компилироваться, потому что в Java вы не можете выполнить логическую инверсию числового 
значения. Второй оператор не компилируется, потому что вы не можете численно инвертировать логическое значение; вам 
нужно использовать логический обратный оператор. Наконец, последний оператор не компилируется, потому что вы не можете 
взять логическое дополнение числового значения или присвоить целое число логической переменной.

---
Обращайте внимание на вопросы экзамена, в которых используются числовые значения (например, 0 или 1) с логическими 
выражениями. В отличие от некоторых других языков программирования, в Java 1 и true никак не связаны, как не связаны 
0 и false.
--- 

### Операторы увеличения и уменьшения (Increment and Decrement Operators)

Операторы инкремента и декремента, ++ и -- соответственно, могут применяться к числовым переменным и имеют более 
высокий порядок приоритета по сравнению с бинарными операторами. Другими словами, они часто применяются первыми в 
выражении.

Операторы инкремента и декремента требуют особой осторожности, потому что порядок, в котором они присоединяются к 
связанной с ними переменной, может повлиять на то, как обрабатывается выражение. В Таблице 2.3 перечислены все эти 
операторы.

#### Таблица 2.3. - Операторы инкремента и декремента


Следующий фрагмент кода иллюстрирует это различие:

```
int parkAttendance = 0;
System.out.println(parkAttendance);    // 0
System.out.println(++parkAttendance);  // 1
System.out.println(parkAttendance);    // 1
System.out.println(parkAttendance--);  // 1
System.out.println(parkAttendance);    // 0
```

Первый оператор предварительного приращения обновляет значение для parkAttendance и выводит новое значение 1.
Следующий оператор постдекремента также обновляет значение parkAttendance, но выводит значение до того, как произойдет 
декремент.

---
Для экзамена очень важно, чтобы вы знали разницу между такими выражениями, как parkAttendance++ и ++parkAttendance.
Операторы инкремента и декремента будут в нескольких вопросах, и путаница в том, какое значение возвращается, может 
привести к потере большого количества баллов на экзамене.
---

## Работа с двоичными арифметическими операторами (Working with Binary Arithmetic Operators)

Далее мы переходим к операторам, которые принимают два операнда, называемым бинарными операторами. Бинарные операторы 
на сегодняшний день являются наиболее распространенными операторами в языке Java. Их можно использовать для выполнения 
математических операций над переменными, создания логических выражений и выполнения основных назначений переменных. 
Бинарные операторы часто объединяются в сложные выражения с другими бинарными операторами; поэтому приоритет операций 
очень важен при вычислении выражений, содержащих бинарные операторы. В этом разделе мы начнем с бинарных арифметических 
операторов; мы расширимся до других бинарных операторов в последующих разделах.

### Арифметические операторы (Arithmetic Operators) 

Арифметические операторы — это те, которые работают с числовыми значениями. Они показаны в таблице 2.4.

#### Таблица 2.4. - Двоичные арифметические операторы


Вы должны знать все, кроме модуля, из ранней математики. Однако, если вы не знаете, что такое модуль, не 
волнуйтесь — мы вскоре расскажем об этом. К арифметическим операторам также относятся унарные операторы ++ и --, 
которые мы уже рассмотрели. Как вы могли заметить в таблице 2.1, мультипликативные операторы (*, /, %) имеют более 
высокий порядок старшинства, чем аддитивные операторы (+, -). Взгляните на следующее выражение:

```
int price = 2 * 5 + 3 * 4 - 8;
```

Сначала вы оцениваете 2 * 5 и 3 * 4, что приводит к следующему выражению: 

```
int price = 10 + 12 - 8;
```

Затем вы оцениваете оставшиеся термины в порядке слева направо, в результате чего значение price равно 14.
Убедитесь, что вы понимаете, почему результат равен 14, потому что вы, скорее всего, встретите такой вопрос о 
приоритете операторов на экзамене.

---
Все арифметические операторы могут применяться к любым примитивам Java, за исключением логических.
Кроме того, к значениям String можно применять только операторы сложения + и +=, что приводит к конкатенации строк.
Вы узнаете больше об этих операторах и о том, как они применяются к строковым значениям, в главе 4, «Основные API».
---

### Добавление круглых скобок (Adding Parentheses)

Возможно, вы заметили, что мы сказали “Если не переопределено скобками” перед представлением таблицы 2.1 о приоритете 
операторов. Это потому, что вы можете явно изменить порядок выполнения операций, заключив в круглые скобки разделы, 
которые вы хотите оценить в первую очередь.

#### Изменение порядка работы (Changing the Order of Operation)

Вернемся к предыдущему примеру с price. Следующий фрагмент кода содержит те же значения и операторы в том же порядке, 
но с двумя добавленными скобками:

```
int price = 2 * ((5 + 3) * 4 -8);
```

На этот раз вы должны вычислить оператор сложения 5 + 3, который уменьшает выражение до следующего: 

```
int price = 2 * (8 * 4 -8);
```

Вы можете уменьшить это выражение, умножив первые два значения в скобках:

```
int price = 2 * (32 -8);
```

Затем вы вычитаете значения в круглых скобках, прежде чем применять термины за пределами круглых скобок:

```
int price = 2 * 24;
```

Наконец, вы должны умножить результат на 2, в результате чего price будет равен 48.

Круглые скобки могут появляться практически в любом вопросе экзамена, включающем числовые значения, поэтому убедитесь, 
что вы понимаете, как они меняют порядок действий, когда вы их видите.

---
Когда вы сталкиваетесь с кодом в своей профессиональной карьере, в котором вы не уверены в порядке работы, не 
стесняйтесь добавлять необязательные круглые скобки. Хотя часто они не требуются, они могут улучшить читаемость, 
особенно в том, что вы увидите с тернарными операторами.
---

#### Проверка синтаксиса скобок (Verifying Parentheses Syntax)

При работе со скобками необходимо убедиться, что они всегда корректны и сбалансированы. Рассмотрим следующие примеры:

```
long pigeon = 1 + ((3 * 5) / 3;        // DOES NOT COMPILE
int blueJay = (9 + 2) + 3) / (2 * 4;   // DOES NOT COMPILE
```

Первый пример не компилируется, потому что скобки не сбалансированы. Существует левая скобка без соответствующей 
правой скобки. Во втором примере одинаковое количество левых и правых скобок, но они не сбалансированы должным образом. 
При чтении слева направо новая правая скобка должна совпадать с предыдущей левой скобкой. Аналогично, все левые круглые 
скобки должны быть закрыты правыми скобками до конца выражения.

Давайте попробуем другой пример: 

```
short robin = 3 + [(4 * 2) + 4];   // DOES NOT COMPILE
```

Этот пример не компилируется, потому что Java, в отличие от некоторых других языков программирования, не позволяет 
использовать квадратные скобки [] вместо скобок. Если вы замените квадратные скобки скобками, последний пример будет 
скомпилирован очень хорошо.

### Операторы деления и модуля (Division and Modulus Operators)

Как мы уже говорили ранее, оператор модуля % может быть для вас новым. Оператор модуля, иногда называемый оператором 
остатка, представляет собой просто остаток от деления двух чисел. Например, 9, разделенное на 3, делится без остатка и 
не имеет остатка; следовательно, результат 9 % 3 равен 0. С другой стороны, 11, деленное на 3, не делится поровну; 
следовательно, результатом 11 % 3 будет 2.

Следующие примеры иллюстрируют это различие:

```
System.out.println(9 / 3);  // 3
System.out.println(9 % 3);  // 0

System.out.println(10 / 3);  // 3
System.out.println(10 % 3);  // 1

System.out.println(11 / 3);  // 3
System.out.println(11 % 3);  // 2

System.out.println(12 / 3);  // 4
System.out.println(12 % 3);  // 0
```

Как видите, результаты деления увеличиваются только тогда, когда значение в левой части изменяется от 11 до 12, тогда 
как значение остатка модуля увеличивается на 1 каждый раз, когда левая часть увеличивается, пока не достигнет нуля.
Для данного делителя y операция по модулю приводит к значению от 0 до (y -1) для положительных дивидендов или 0, 1, 2 в 
этом примере.

Обязательно поймите разницу между арифметическим делением и модулем. Для целочисленных значений результатом деления 
является минимальное значение ближайшего целого числа, которое выполняет операцию, тогда как модуль является 
остаточным значением. Если вы слышите словосочетание «минимальное значение», это просто означает значение без 
каких-либо знаков после запятой. Например, минимальное значение равно 4 для каждого из значений 4,0, 4,5 и 4,9999999. 
В отличие от округления, которое мы рассмотрим в главе 4, вы просто берете значение до запятой, независимо от того, 
что находится после запятой.

---
Операция модуля не ограничена положительными целыми значениями в Java; его также можно применять к отрицательным целым 
числам и числам с плавающей запятой. Например, если делитель равен 5, то значение модуля отрицательного числа находится
в диапазоне от -4 до 0. Однако для экзамена от вас не требуется уметь вычислять модуль отрицательного целого числа или 
числа с плавающей запятой.
---

###  Числовое продвижение (Numeric Promotion)

Теперь, когда вы понимаете основы арифметических операций, очень важно поговорить о примитивном преобразовании чисел, 
поскольку Java может делать вещи, которые поначалу кажутся вам необычными. Как мы показали в главе 1, «Строительные 
блоки», каждый примитивный числовой тип имеет битовую длину. Вам не нужно знать точный размер этих типов для экзамена, 
но вы должны знать, какие из них больше, чем другие. Например, вы должны знать, что тип long занимает больше места, 
чем int, который, в свою очередь, занимает больше места, чем тип short, и так далее.

Вам нужно запомнить определенные правила, которым будет следовать Java при применении операторов к типам данных:

Числовые правила продвижения(приведения)

1. Если два значения имеют разные типы данных, Java автоматически продвинет одно из значений к большему из двух 
типов данных.
2. Если одно из значений является целым числом, а другое — числом с плавающей запятой, Java автоматически преобразует 
целочисленное значение в тип данных значения с плавающей запятой.
3. Меньшие типы данных, а именно byte, short и char, сначала преобразуются в int всякий раз, когда они используются с 
бинарным арифметическим оператором Java с переменной (в отличие от значения), даже если ни один из операндов не 
является int.
4. После выполнения всех преобразований и операндов с одинаковым типом данных результирующее значение будет иметь тот 
же тип данных, что и его операнды.

Последние два правила вызывают затруднения у большинства людей и могут поставить вас в тупик на экзамене. Что касается 
третьего правила, обратите внимание, что унарные операторы исключены из этого правила. Например, применение ++ к 
short значению приводит к short значению.

Давайте рассмотрим несколько примеров в иллюстративных целях:

+ Каков тип данных x * y ?

```
int x = 1;
long y = 33;
var z = x * y;
```

В этом случае мы следуем первому правилу. Поскольку одно из значений — int, а другое — long, а long больше, чем int, 
значение int x сначала повышается до long. Результат z - это long значение.

+ Каков тип данных x + y ?

```
double x = 39.21;
float y = 2.1;
var z = x + y;
```

На самом деле это вопрос с подвохом, так как вторая строка не компилируется! Как вы, возможно, помните из главы 1, 
литералы с плавающей запятой считаются double, если после них не ставится f, как в 2.1f. Если бы значение y было 
правильно установлено равным 2.1f, то преобразование было бы аналогично предыдущему примеру, с преобразованием 
обоих операндов в double значение, и результатом z было бы double значение.

+ Каков тип данных x * y ?

```
short x = 10;
short y = 3;
var z = x * y;
```

В последней строке мы должны применить третье правило: x и y будут преобразованы в int перед операцией двоичного 
умножения, что приведет к выводу типа int. Если бы вы попытались присвоить значение short переменной z без 
приведения, то код не скомпилировался бы. Обратите особое внимание на тот факт, что результирующий вывод не является 
short, так как мы вернемся к этому примеру в следующем разделе «Присвоение значений».

+ Каков тип данных w * x / y ?

```
short w = 14;
float x = 13;
double y = 30;
var z = w * x / y;
```

В этом случае мы должны применить все правила. Во-первых, w будет автоматически повышен до int исключительно потому, 
что он является short и используется в арифметической двоичной операции. Затем повышенное значение w будет 
автоматически преобразовано в float (число с плавающей запятой), чтобы его можно было умножить на x.
Затем результат w * x будет автоматически повышен до double, чтобы его можно было разделить на y, в результате чего 
получится double значение.

При работе с арифметическими операторами в Java всегда следует помнить о типе данных переменных, промежуточных 
значениях и результирующих значениях. Вы должны применять приоритет операторов и круглые скобки и работать вовне, 
продвигая типы данных по пути. В следующем разделе мы обсудим тонкости присвоения этих значений переменным 
определенного типа.

## Присвоение значений (Assigning Values)

Ошибки компиляции от операторов присваивания часто упускаются из виду на экзамене, отчасти из-за того, насколько 
незаметными могут быть эти ошибки. Чтобы успешно работать с операторами присваивания, вы должны свободно понимать, 
как компилятор обрабатывает числовое преобразование и когда требуется приведение типов. Возможность обнаружить эти 
проблемы имеет решающее значение для сдачи экзамена, поскольку операторы присваивания появляются почти в каждом 
вопросе с фрагментом кода.

### Оператор присваивания (Assignment Operator)

Оператор присваивания — это бинарный оператор, который изменяет или присваивает переменной в левой части оператора 
результат, равный значению в правой части уравнения. В отличие от большинства других операторов Java, оператор 
присваивания вычисляется справа налево.

Простейшим оператором присваивания является присваивание =, которое вы уже видели: 

```
int herd = 1;
```
Этот оператор присваивает переменной herd значение 1. Java будет автоматически переходить от меньших типов данных к 
более крупным, как вы видели в предыдущем разделе об арифметических операторах, но она выдаст исключение компилятора, 
если обнаружит, что вы пытаетесь преобразовать большие типы данных в меньшие без приведения типов. В табл. 2.5 
перечислены первые операторы присваивания, которые вам необходимо знать для экзамена. Мы представим дополнительные 
операторы присваивания позже в этом разделе.

#### Таблица 2.5. - Простой оператор присваивания


### Приведение значений (Casting Values)

Кажется, пока все просто, верно? Что ж, мы не можем подробно говорить об операторе присваивания, пока не рассмотрим 
приведение типов. Приведение типов — это унарная операция, в которой один тип данных явно интерпретируется как 
другой тип данных. Приведение является необязательным и ненужным при преобразовании в более крупный или расширяющий тип 
данных, но требуется при преобразовании в меньший или сужающий тип данных. Без приведения компилятор выдаст ошибку 
при попытке поместить больший тип данных в меньший.

Приведение выполняется путем размещения типа данных, заключенного в круглые скобки, слева от значения, которое вы 
хотите преобразовать. Вот несколько примеров кастинга:

```
int fur = (int)5;
int hair = (short) 2;
String type = (String) "Bird";
short tail = (short)(4 + 10);
long feathers = 10(long); // DOES NOT COMPILE
```

Пробелы между приведением и значением необязательны. Как показано в предпоследнем примере, правая сторона обычно также 
заключена в круглые скобки. Поскольку приведение — это унарная операция, она будет применяться только к 4, если мы не 
будем заключать 4 + 10 в круглые скобки. Последний пример не компилируется, потому что тип находится не на той стороне 
значения.

С одной стороны удобно, что компилятор автоматически приводит меньшие типы данных к большим. С другой стороны, это 
отличные экзаменационные вопросы, когда они делают противоположное, чтобы увидеть, обращаете ли вы внимание. 
Посмотрите, сможете ли вы понять, почему ни одна из следующих строк кода не компилируется:

```
float egg = 2.0 / 9;        // DOES NOT COMPILE
int tadpole = (int)5 * 2L;  // DOES NOT COMPILE
short frog = 3 - 2.0;       // DOES NOT COMPILE
```

Во всех этих примерах большее значение помещается в меньший тип данных. Не волнуйтесь, если вы еще не следуете этому; 
мы рассмотрим больше подобных примеров в ближайшее время.

В этой главе приведение в первую очередь связано с преобразованием числовых типов данных в другие типы данных. Как вы 
увидите в следующих главах, приведение может также применяться к объектам и ссылкам. Однако в этих случаях 
преобразование не выполняется. Проще говоря, приведение числового значения может изменить тип данных, в то время как 
приведение объекта изменяет только ссылку на объект, а не сам объект.

### Просмотр назначений примитивов (Reviewing Primitive Assignments)

Посмотрите, сможете ли вы понять, почему каждая из следующих строк не компилируется:

```
int fish = 1.0;       // DOES NOT COMPILE
short bird = 1921222; // DOES NOT COMPILE
int mammal = 9f;      // DOES NOT COMPILE
long reptile = 192_301_398_193_810_323;  // DOES NOT COMPILE
```

Первый оператор не компилируется, потому что вы пытаетесь присвоить двойное значение 1.0 целочисленному значению. 
Несмотря на то, что значение представляет собой математическое целое число, добавляя .0, вы даете компилятору 
указание рассматривать его как двойное. Второй оператор не компилируется, потому что литеральное значение 1921222 
выходит за пределы диапазона short, и компилятор это обнаруживает. Третий оператор не компилируется, потому что f, 
добавленное в конце числа, указывает компилятору обрабатывать число как значение с плавающей запятой, но присваивается 
значение int. Наконец, последний оператор не компилируется, потому что Java интерпретирует литерал как int и замечает, 
что значение больше, чем позволяет int. Литералу потребуется постфикс L или l, чтобы он считался long.

### Applying Casting (перевод потом сделать)

Мы можем исправить три предыдущих примера, приведя результаты к меньшему типу данных. Помните, что приведение 
примитивов требуется всякий раз, когда вы переходите от большего числового типа данных к меньшему числовому типу 
данных или конвертируете число с плавающей запятой в целочисленное значение.

```
int fish = (int)1.0;
short bird = (short)1921222; // Stored as 20678
int mammal = (int)9f;
```

Как насчет применения приведения к последнему примеру?

```
long reptile = (long)192301398193810323; // DOES NOT COMPILE
```

Это по-прежнему не компилируется, потому что значение сначала интерпретируется компилятором как int и выходит за 
пределы допустимого диапазона. Следующий код исправляет этот код без приведения:

```
long reptile = 192301398193810323L;
```

---
##### Сценарий реального мира

#### Переполнение и недополнение (Overflow and Underflow)

Выражения в предыдущем примере теперь компилируются, хотя и за это приходится платить. Второе значение, 1 921 222, 
слишком велико, чтобы его можно было сохранить как короткое, поэтому возникает числовое переполнение, и оно становится 
равным 20 678. Переполнение — это когда число настолько велико, что больше не помещается в тип данных, поэтому система 
«переходит» к наименьшему отрицательному значению и начинает считать оттуда, подобно тому, как работает модульная 
арифметика. Существует также аналогичный потеря значимости, когда число слишком мало, чтобы поместиться в тип данных, 
например, сохранение -200 в байтовом поле.

Это выходит за рамки экзамена, но с этим следует быть осторожным в собственном коде. Например, следующий оператор 
выводит отрицательное число:

```
System.out.print(2147483647+1); // -2147483648
```

Поскольку 2147483647 является максимальным значением int, добавление к нему любого строго положительного значения 
приведет к переносу его на наименьшее отрицательное число.
---

Вернемся к аналогичному примеру из раздела «Числовое продвижение» ранее в этой главе.

```
short mouse = 10;
short hamster = 3;
short capybara = mouse * hamster; // DOES NOT COMPILE
```

Основываясь на всем, что вы узнали до сих пор о числовом преобразовании и преобразовании, вы понимаете, почему 
последняя строка этого утверждения не будет компилироваться? Как вы, возможно, помните, короткие значения 
автоматически преобразуются в int при применении любого арифметического оператора, при этом результирующее значение 
имеет тип int. Попытка присвоить короткой переменной значение int приводит к ошибке компилятора, поскольку Java 
считает, что вы пытаетесь неявно преобразовать больший тип данных в меньший.

Мы можем исправить это выражение путем приведения, так как иногда вам может понадобиться переопределить поведение 
компилятора по умолчанию. В этом примере мы знаем, что результат 10 * 3 равен 30, что может легко поместиться в 
переменную типа short, поэтому мы можем применить кастинг, чтобы преобразовать результат обратно в тип short:

```
short mouse = 10;
short hamster = 3;
short capybara = (short)(mouse * hamster);
```

Преобразуя большее значение в меньший тип данных, вы указываете компилятору игнорировать его поведение по умолчанию. 
Другими словами, вы сообщаете компилятору, что предприняли дополнительные шаги для предотвращения переполнения или 
потери значимости. Также возможно, что в вашем конкретном приложении и сценарии переполнение или потеря значимости 
приведет к приемлемым значениям.

И последнее, но не менее важное: приведение типов может появляться в любом месте выражения, а не только в присваивании. 
Например, давайте взглянем на модифицированную форму предыдущего примера:

```
short mouse = 10;
short hamster = 3;
short capybara = (short)mouse * hamster; // DOES NOT COMPILE
```

Итак, что происходит в последней строке? Помните, мы говорили, что приведение типов — это унарная операция? Это 
означает, что приведение в последней строке применяется к мыши и только к мыши. После завершения приведения оба 
операнда повышаются до int, поскольку они используются с оператором двоичного умножения (*), что делает результат 
int и вызывает ошибку компилятора.

Что, если мы изменим последнюю строку на следующую? 

```
short capybara = 1 + (short)(mouse * hamster); // DOES NOT COMPILE
```

В этом примере приведение выполняется успешно, но результирующее значение автоматически повышается до int, поскольку 
оно используется с бинарным арифметическим оператором (+).

### Casting Values vs. Variables

Возвращаясь к нашему третьему числовому рекламному правилу, компилятор не требует приведения типов при работе с 
литеральными значениями, которые соответствуют типу данных. Рассмотрим эти примеры:

```
byte hat = 1;
byte gloves = 7 * 10;
short scarf = 5;
short boots = 2 + 1;
```

Все эти операторы компилируются без проблем. С другой стороны, ни одно из этих утверждений не компилируется:

```
short boots = 2 + hat; // DOES NOT COMPILE
byte gloves = 7 * 100; // DOES NOT COMPILE
```

Первый оператор не компилируется, потому что шляпа — это переменная, а не значение, и оба операнда автоматически 
преобразуются в int. При работе со значениями у компилятора было достаточно информации, чтобы определить намерение 
автора. Однако при работе с переменными возникает неясность в отношении дальнейших действий, поэтому компилятор 
сообщает об ошибке. Второе выражение не компилируется, так как 700 вызывает переполнение для байта, максимальное 
значение которого равно 127.

## Compound Assignment Operators