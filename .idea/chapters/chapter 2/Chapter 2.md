# Операторы

---
### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Обработка даты, времени, текста, числовых и логических значений

+ Используйте примитивы и классы-оболочки, включая математический API, круглые скобки, расширение и приведение типов 
для вычисления арифметических и логических выражений
---

В предыдущей главе много говорилось об определении переменных, но что вы можете сделать с переменной после её создания?
В этой главе представлены операторы и показано, как вы можете использовать их для объединения существующих переменных 
и создания новых значений. Он показывает вам, как применять операторы к различным примитивным типам данных, в том 
числе знакомит вас с операторами, которые могут быть применены к объектам.

## Понимание операторов Java

Прежде чем мы перейдем к самому интересному, давайте немного разберемся с терминологией. Оператор Java — это 
специальный символ, который может быть применен к набору переменных, значений или литералов, называемых операндами, 
и который возвращает результат. Термин "операнд", который мы используем на протяжении всей этой главы, относится к 
значению или переменной, к которой применяется оператор. На рис. 2.1 показана структура операции Java.

#### Рис. 2.1 - Операция Java
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/chapter%202/image2/figure%202.1%20.JPG)

Результат операции называется просто результатом. Рисунок 2.1 фактически содержит вторую операцию, в которой оператор 
присваивания (=) используется для сохранения результата в переменной c.

Мы уверены, что вы использовали операторы сложения (+) и вычитания (-) с самого детства. Java поддерживает многие 
другие операторы, которые вам необходимо знать для сдачи экзамена. Хотя многие из них вам следует изучить, некоторые 
(например, составные операторы присваивания) могут быть для вас новыми.

### Типы операторов

Java поддерживает три разновидности операторов: унарные, бинарные и тернарные. Эти типы 
операторов могут применяться к одному, двум или трем операндам соответственно. Для сдачи экзамена вам необходимо знать 
определенное подмножество операторов Java, как их применять и в каком порядке они должны применяться.

Операторы Java не обязательно вычисляются слева направо. В этом следующем примере второе выражение фактически 
вычисляется справа налево, учитывая конкретные задействованные операторы:

```
int cookies = 4;
double reward = 3 + 2 * --cookies;
System.out.print("Zoo animal receives: " + reward + " reward points");
```

В этом примере вы сначала уменьшаете количество файлов cookie до 3, затем умножаете полученное значение на 2 и, наконец,
добавляете 3. Затем значение автоматически повышается с 9 до 9,0 и присваивается reward. Окончательные значения 
reward и cookie равны 9,0 и 3 соответственно, при этом напечатано следующее:

```
Zoo animal receives: 9.0 reward points
```

Если вы не следовали этой оценке, не волнуйтесь. К концу этой главы решение подобных задач должно стать вашей второй 
натурой.

### Приоритет оператора

При чтении книги или газеты некоторые письменные языки оцениваются слева направо, а некоторые — справа налево. В 
математике некоторые операторы могут переопределять другие операторы и выполняться в первую очередь. Определение того, 
какие операторы оцениваются в каком порядке, называется приоритетом оператора. Таким образом, Java более точно следует 
правилам математики. Рассмотрим следующее выражение:

```
var perimeter = 2 * height + 2 * length;
```

Давайте применим некоторые необязательные круглые скобки, чтобы продемонстрировать, как компилятор оценивает этот 
оператор:

```
var perimeter = ((2 * height) + (2 * length));
```

Оператор умножения (*) имеет более высокий приоритет, чем оператор сложения (+), поэтому перед сложением height и 
length умножаются на 2. Оператор присваивания (=) имеет самый низкий приоритет, поэтому присваивание переменной 
perimeter выполняется последним.

Если не указано иное с помощью круглых скобок, операторы Java следуют порядку операций, указанному в таблице 2.1, в 
порядке убывания приоритета операторов. Если два оператора имеют одинаковый уровень приоритета, то Java гарантирует 
вычисление слева направо для большинства операторов, кроме отмеченных в таблице.

#### Таблица 2.1. - Порядок приоритета оператора
| Оператор                   |                   Символы и примеры                    |    Оценка     |
|:---------------------------|:------------------------------------------------------:|:-------------:|
| Пост-унарные операторы     |               expression++, expression--               | Слева направо |
| Пре-унарные операторы      |               ++expression, --expression               | Слева направо |
| Другие унарные операторы   |                   -, !, ~, +, (type)                   | Справа налево |
| Приведение типов           |                    (Type)reference                     | Справа налево |
| Умножение/деление/модуль   |                        *, /, %                         | Слева направо |
| Сложение/вычитание         |                          +, -                          | Слева направо |
| Операторы сдвига           |                      <<, >>, >>>                       | Слева направо |
| Реляционные операторы      |                <, >, <=, >=, instanceof                | Слева направо |
| Равно/не равно             |                         ==, !=                         | Слева направо |
| Логическое И               |                           &                            | Слева направо |
| Логическое исключающее ИЛИ |                           ^                            | Слева направо |
| Логическое включающее ИЛИ  |                         &#124;                         | Слева направо |
| Условное И                 |                           &&                           | Слева направо |
| Условное ИЛИ               |                      &#124;&#124;                      | Слева направо |
| Тернарный оператор         |     boolean expression ? expression1 :expression2      | Справа налево |
| Операторы присваивания     | =, +=, -=, *=, /=, %=, &=, ^=, &#124;=, <<=, >>=, >>>= | Справа налево |
| Оператор стрелки           |                           ->                           | Справа налево |

Мы рекомендуем держать таблицу 2.1 под рукой на протяжении всей этой главы. Для экзамена вам нужно запомнить порядок 
очередности в этой таблице. Обратите внимание, что вы не будете протестированы на некоторых операторах, таких как 
операторы сдвига, хотя мы рекомендуем вам знать об их существовании.

---

Стрелочный оператор (->), иногда называемый стрелочной функцией или лямбда-оператором, представляет собой бинарный 
оператор, представляющий отношение между двумя операндами. Хотя мы не будем рассматривать оператор стрелки в этой 
главе, вы увидите его использование в выражениях переключения в главе 3 «Принятие решений» и в лямбда-выражениях, 
начиная с главы 8 «Лямбда-выражения и функциональные интерфейсы».

---

## Применение унарных операторов

По определению унарный оператор — это оператор, для работы которого требуется ровно один операнд или переменная.
Как показано в таблице 2.2, они часто выполняют простые задачи, такие как увеличение числовой переменной на единицу или 
отрицание логического значения.

#### Таблица 2.2. - Унарные операторы
| Оператор              |   Примеры   |                                                                     Описание                                                                      |
|:----------------------|:-----------:|:-------------------------------------------------------------------------------------------------------------------------------------------------:|
| Логическое дополнение |     !a      |                                                   Инвертировать логическое логическое значение                                                    |
| Побитовое дополнение  |     ~b      |                                                           Инвертирует все 0 и 1 в числе                                                           |
| Плюс                  |     +c      | Указывает, что число положительное, хотя в Java<br/> числа считаются положительными, если они не сопровождаются отрицательным унарным оператором. |
| Отрицание или минус   |     -d      |                                   Указывает, что буквальное число является отрицательным или отрицает выражение                                   |
| Инкремент             | ++e<br/>f++ |                                                             Увеличивает значение на 1                                                             |
| Декремент             | --f<br/>h-- |                                                              Уменьшает значение на 1                                                              |
| Приведение типов      |  (String)i  |                                                      Приводит значение к определенному типу                                                       |

Несмотря на то, что в таблице 2.2 есть оператор приведения, мы откладываем обсуждение приведения до раздела 
«Присвоение значений» далее в этой главе, поскольку именно там он обычно используется.

### Операторы дополнения и отрицания

Поскольку в этой главе мы будем работать со многими числовыми операторами, давайте сначала разберемся с логическим 
оператором. Оператор логического дополнения (!) инвертирует значение логического выражения. Например, если значение 
равно true, оно будет преобразовано в false, и наоборот. Чтобы проиллюстрировать это, сравните выходные данные 
следующих операторов:

```
boolean isAnimalAsleep = false;
System.out.print(isAnimalAsleep); // false
isAnimalAsleep = !isAnimalAsleep;
System.out.print(isAnimalAsleep); // true
```

Для экзамена вам также необходимо знать об операторе побитового дополнения (~), который переворачивает все 0 и 1 в 
числе. Его можно применять только к целочисленным числовым типам, таким как byte, short, char, int и long.
Давайте попробуем пример. Для простоты мы показываем только последние четыре бита (вместо всех 32 бит).

```
int value = 3;                   // Stored as 0011
int complement = ~value;         // Stored as 1100
System.out.println(value);      // 3
System.out.println(complement); // -4
```

Расслабьтесь! Вам не нужно знать, как выполнять сложную битовую арифметику на экзамене, если вы помните это правило: 
чтобы найти побитовое дополнение числа, умножьте его на отрицательную единицу, а затем вычтите единицу.

```
System.out.println(-1*value - 1);       // -4
System.out.println(-1*complement - 1);  // 3
```

Переходя к более распространенным операторам, оператор отрицания (-) меняет знак числового выражения, 
как показано в следующих утверждениях:

```
double zooTemperature = 1.21;
System.out.println(zooTemperature);   // 1.21
zooTemperature = -zooTemperature;
System.out.println(zooTemperature);   // -1.21
zooTemperature = -(-zooTemperature);
System.out.println(zooTemperature);   // -1.21
```

Обратите внимание, что в последнем примере мы использовали круглые скобки () для оператора отрицания -, чтобы применить 
отрицание дважды. Если бы вместо этого мы написали --, то это было бы интерпретировано как оператор декремента и 
напечатано -2,21. Вскоре вы увидите больше этого оператора декремента.

На основании описания может быть очевидно, что некоторые операторы требуют, чтобы переменная или выражение, с которыми 
они работают, имели определенный тип. Например, вы не можете применить оператор отрицания (-) к логическому выражению, 
а также вы не можете применить оператор логического дополнения (!) к числовому выражению. Будьте осторожны с вопросами 
на экзамене, которые пытаются сделать это, так как они приводят к тому, что код не компилируется. Например, ни одна из 
следующих строк кода не скомпилируется:

```
int pelican = !5;          // НЕ КОМПИЛИРУЕТСЯ
boolean penguin = -true;   // НЕ КОМПИЛИРУЕТСЯ
boolean peacock = !0;      // НЕ КОМПИЛИРУЕТСЯ
```

Первый оператор не будет компилироваться, потому что в Java вы не можете выполнить логическую инверсию числового 
значения. Второй оператор не компилируется, потому что вы не можете численно инвертировать логическое значение; вам 
нужно использовать логический обратный оператор. Наконец, последний оператор не компилируется, потому что вы не можете 
взять логическое дополнение числового значения или присвоить целое число логической переменной.

---

Обращайте внимание на вопросы экзамена, в которых используются числовые значения (например, 0 или 1) с логическими 
выражениями. В отличие от некоторых других языков программирования, в Java 1 и true никак не связаны, как не связаны 
0 и false.

--- 

### Операторы увеличения и уменьшения

Операторы инкремента и декремента, ++ и -- соответственно, могут применяться к числовым переменным и имеют более 
высокий порядок приоритета по сравнению с бинарными операторами. Другими словами, они часто применяются первыми в 
выражении.

Операторы инкремента и декремента требуют особой осторожности, потому что порядок, в котором они присоединяются к 
связанной с ними переменной, может повлиять на то, как обрабатывается выражение. В Таблице 2.3 перечислены все эти 
операторы.

#### Таблица 2.3. - Операторы инкремента и декремента
| Оператор        | Пример |                         Описание                         |
|:----------------|:------:|:--------------------------------------------------------:|
| Пре-инкремент   |  ++w   |  Увеличивает значение на 1 и возвращает новое значение   |
| Пре-декремент   |  --x   |   Уменьшает значение на 1 и возвращает новое значение    |
| Пост-инкремент  |  y++   | Увеличивает значение на 1 и возвращает исходное значение |
| Пост-декремент  |  z--   | Уменьшает значение на 1 и возвращает исходное значение   |

Следующий фрагмент кода иллюстрирует это различие:

```
int parkAttendance = 0;
System.out.println(parkAttendance);    // 0
System.out.println(++parkAttendance);  // 1
System.out.println(parkAttendance);    // 1
System.out.println(parkAttendance--);  // 1
System.out.println(parkAttendance);    // 0
```

Первый оператор предварительного приращения обновляет значение для parkAttendance и выводит новое значение 1.
Следующий оператор постдекремента также обновляет значение parkAttendance, но выводит значение до того, как произойдет 
декремент.

---

Для экзамена очень важно, чтобы вы знали разницу между такими выражениями, как parkAttendance++ и ++parkAttendance.
Операторы инкремента и декремента будут в нескольких вопросах, и путаница в том, какое значение возвращается, может 
привести к потере большого количества баллов на экзамене.

---

## Работа с двоичными арифметическими операторами

Далее мы переходим к операторам, которые принимают два операнда, называемым бинарными операторами. Бинарные операторы 
на сегодняшний день являются наиболее распространенными операторами в языке Java. Их можно использовать для выполнения 
математических операций над переменными, создания логических выражений и выполнения основных назначений переменных. 
Бинарные операторы часто объединяются в сложные выражения с другими бинарными операторами; поэтому приоритет операций 
очень важен при вычислении выражений, содержащих бинарные операторы. В этом разделе мы начнем с бинарных арифметических 
операторов; мы расширимся до других бинарных операторов в последующих разделах.

### Арифметические операторы

Арифметические операторы — это те, которые работают с числовыми значениями. Они показаны в таблице 2.4.

#### Таблица 2.4. - Двоичные арифметические операторы
| Оператор  | Пример |                               Описание                                |
|:----------|:------:|:---------------------------------------------------------------------:|
| Сложение  | a + b  |                    Добавляет два числовых значения                    |
| Вычитание | c - d  |                    Вычитает два числовых значения                     |
| Умножение | e * f  |                    Умножает два числовых значения                     |
| Деление   | g / h  |                Делит одно числовое значение на другое                 |
| Модуль    | i % j  | Возвращает остаток после деления одного числового значения на другое  |

Вы должны знать все, кроме модуля, из ранней математики. Однако, если вы не знаете, что такое модуль, не 
волнуйтесь — мы вскоре расскажем об этом. К арифметическим операторам также относятся унарные операторы ++ и --, 
которые мы уже рассмотрели. Как вы могли заметить в таблице 2.1, мультипликативные операторы (*, /, %) имеют более 
высокий порядок старшинства, чем аддитивные операторы (+, -). Взгляните на следующее выражение:

```
int price = 2 * 5 + 3 * 4 - 8;
```

Сначала вы оцениваете 2 * 5 и 3 * 4, что приводит к следующему выражению: 

```
int price = 10 + 12 - 8;
```

Затем вы оцениваете оставшиеся термины в порядке слева направо, в результате чего значение price равно 14.
Убедитесь, что вы понимаете, почему результат равен 14, потому что вы, скорее всего, встретите такой вопрос о 
приоритете операторов на экзамене.

---

Все арифметические операторы могут применяться к любым примитивам Java, за исключением логических.
Кроме того, к значениям String можно применять только операторы сложения + и +=, что приводит к конкатенации строк.
Вы узнаете больше об этих операторах и о том, как они применяются к строковым значениям, в главе 4, «Основные API».

---

### Добавление круглых скобок

Возможно, вы заметили, что мы сказали “Если не переопределено скобками” перед представлением таблицы 2.1 о приоритете 
операторов. Это потому, что вы можете явно изменить порядок выполнения операций, заключив в круглые скобки разделы, 
которые вы хотите оценить в первую очередь.

#### Изменение порядка работы

Вернемся к предыдущему примеру с price. Следующий фрагмент кода содержит те же значения и операторы в том же порядке, 
но с двумя добавленными скобками:

```
int price = 2 * ((5 + 3) * 4 -8);
```

На этот раз вы должны вычислить оператор сложения 5 + 3, который уменьшает выражение до следующего: 

```
int price = 2 * (8 * 4 -8);
```

Вы можете уменьшить это выражение, умножив первые два значения в скобках:

```
int price = 2 * (32 -8);
```

Затем вы вычитаете значения в круглых скобках, прежде чем применять термины за пределами круглых скобок:

```
int price = 2 * 24;
```

Наконец, вы должны умножить результат на 2, в результате чего price будет равен 48.

Круглые скобки могут появляться практически в любом вопросе экзамена, включающем числовые значения, поэтому убедитесь, 
что вы понимаете, как они меняют порядок действий, когда вы их видите.

---

Когда вы сталкиваетесь с кодом в своей профессиональной карьере, в котором вы не уверены в порядке работы, не 
стесняйтесь добавлять необязательные круглые скобки. Хотя часто они не требуются, они могут улучшить читаемость, 
особенно в том, что вы увидите с тернарными операторами.

---

#### Проверка синтаксиса скобок

При работе со скобками необходимо убедиться, что они всегда корректны и сбалансированы. Рассмотрим следующие примеры:

```
long pigeon = 1 + ((3 * 5) / 3;        // НЕ КОМПИЛИРУЕТСЯ
int blueJay = (9 + 2) + 3) / (2 * 4;   // НЕ КОМПИЛИРУЕТСЯ
```

Первый пример не компилируется, потому что скобки не сбалансированы. Существует левая скобка без соответствующей 
правой скобки. Во втором примере одинаковое количество левых и правых скобок, но они не сбалансированы должным образом. 
При чтении слева направо новая правая скобка должна совпадать с предыдущей левой скобкой. Аналогично, все левые круглые 
скобки должны быть закрыты правыми скобками до конца выражения.

Давайте попробуем другой пример: 

```
short robin = 3 + [(4 * 2) + 4];   // НЕ КОМПИЛИРУЕТСЯ
```

Этот пример не компилируется, потому что Java, в отличие от некоторых других языков программирования, не позволяет 
использовать квадратные скобки [] вместо скобок. Если вы замените квадратные скобки скобками, последний пример будет 
скомпилирован очень хорошо.

### Операторы деления и модуля

Как мы уже говорили ранее, оператор модуля % может быть для вас новым. Оператор модуля, иногда называемый оператором 
остатка, представляет собой просто остаток от деления двух чисел. Например, 9, разделенное на 3, делится без остатка и 
не имеет остатка; следовательно, результат 9 % 3 равен 0. С другой стороны, 11, деленное на 3, не делится поровну; 
следовательно, результатом 11 % 3 будет 2.

Следующие примеры иллюстрируют это различие:

```
System.out.println(9 / 3);  // 3
System.out.println(9 % 3);  // 0

System.out.println(10 / 3);  // 3
System.out.println(10 % 3);  // 1

System.out.println(11 / 3);  // 3
System.out.println(11 % 3);  // 2

System.out.println(12 / 3);  // 4
System.out.println(12 % 3);  // 0
```

Как видите, результаты деления увеличиваются только тогда, когда значение в левой части изменяется от 11 до 12, тогда 
как значение остатка модуля увеличивается на 1 каждый раз, когда левая часть увеличивается, пока не достигнет нуля.
Для данного делителя y операция по модулю приводит к значению от 0 до (y -1) для положительных дивидендов или 0, 1, 2 в 
этом примере.

Обязательно поймите разницу между арифметическим делением и модулем. Для целочисленных значений результатом деления 
является минимальное значение ближайшего целого числа, которое выполняет операцию, тогда как модуль является 
остаточным значением. Если вы слышите словосочетание «минимальное значение», это просто означает значение без 
каких-либо знаков после запятой. Например, минимальное значение равно 4 для каждого из значений 4,0, 4,5 и 4,9999999. 
В отличие от округления, которое мы рассмотрим в главе 4, вы просто берете значение до запятой, независимо от того, 
что находится после запятой.

---

Операция модуля не ограничена положительными целыми значениями в Java; его также можно применять к отрицательным целым 
числам и числам с плавающей запятой. Например, если делитель равен 5, то значение модуля отрицательного числа находится
в диапазоне от -4 до 0. Однако для экзамена от вас не требуется уметь вычислять модуль отрицательного целого числа или 
числа с плавающей запятой.

---

###  Числовое продвижение

Теперь, когда вы понимаете основы арифметических операций, очень важно поговорить о примитивном преобразовании чисел, 
поскольку Java может делать вещи, которые поначалу кажутся вам необычными. Как мы показали в главе 1, «Строительные 
блоки», каждый примитивный числовой тип имеет битовую длину. Вам не нужно знать точный размер этих типов для экзамена, 
но вы должны знать, какие из них больше, чем другие. Например, вы должны знать, что тип long занимает больше места, 
чем int, который, в свою очередь, занимает больше места, чем тип short, и так далее.

Вам нужно запомнить определенные правила, которым будет следовать Java при применении операторов к типам данных:

Правила числового продвижения

1. Если два значения имеют разные типы данных, Java автоматически продвинет одно из значений к большему из двух 
типов данных.
2. Если одно из значений является целым числом, а другое — числом с плавающей точкой, Java автоматически преобразует 
целочисленное значение в тип данных значения с плавающей точкой.
3. Меньшие типы данных, а именно byte, short и char, сначала преобразуются в int всякий раз, когда они используются с 
бинарным арифметическим оператором Java с переменной (в отличие от значения), даже если ни один из операндов не 
является int.
4. После выполнения всех преобразований и операндов с одинаковым типом данных результирующее значение будет иметь тот 
же тип данных, что и его операнды.

Последние два правила вызывают затруднения у большинства людей и могут поставить вас в тупик на экзамене. Что касается 
третьего правила, обратите внимание, что унарные операторы исключены из этого правила. Например, применение ++ к 
short значению приводит к short значению.

Давайте рассмотрим несколько примеров в иллюстративных целях:

+ Каков тип данных x * y ?

```
int x = 1;
long y = 33;
var z = x * y;
```

В этом случае мы следуем первому правилу. Поскольку одно из значений — int, а другое — long, а long больше, чем int, 
значение int x сначала повышается до long. Результат z - это long значение.

+ Каков тип данных x + y ?

```
double x = 39.21;
float y = 2.1;
var z = x + y;
```

На самом деле это вопрос с подвохом, так как вторая строка не компилируется! Как вы, возможно, помните из главы 1, 
литералы с плавающей точкой считаются double, если после них не ставится f, как в 2.1f. Если бы значение y было 
правильно установлено равным 2.1f, то преобразование было бы аналогично предыдущему примеру, с преобразованием 
обоих операндов в double значение, и результатом z было бы double значение.

+ Каков тип данных x * y ?

```
short x = 10;
short y = 3;
var z = x * y;
```

В последней строке мы должны применить третье правило: x и y будут преобразованы в int перед операцией двоичного 
умножения, что приведет к выводу типа int. Если бы вы попытались присвоить значение short переменной z без 
приведения, то код не скомпилировался бы. Обратите особое внимание на тот факт, что результирующий вывод не является 
short, так как мы вернемся к этому примеру в следующем разделе «Присвоение значений».

+ Каков тип данных w * x / y ?

```
short w = 14;
float x = 13;
double y = 30;
var z = w * x / y;
```

В этом случае мы должны применить все правила. Во-первых, w будет автоматически повышен до int исключительно потому, 
что он является short и используется в арифметической двоичной операции. Затем повышенное значение w будет 
автоматически преобразовано в float (число с плавающей точкой), чтобы его можно было умножить на x.
Затем результат w * x будет автоматически повышен до double, чтобы его можно было разделить на y, в результате чего 
получится double значение.

При работе с арифметическими операторами в Java всегда следует помнить о типе данных переменных, промежуточных 
значениях и результирующих значениях. Вы должны применять приоритет операторов и круглые скобки и работать дальше, 
продвигая типы данных по пути. В следующем разделе мы обсудим тонкости присвоения этих значений переменным 
определенного типа.

## Присвоение значений

Ошибки компиляции от операторов присваивания часто упускаются из виду на экзамене, отчасти из-за того, насколько 
незаметными могут быть эти ошибки. Чтобы успешно работать с операторами присваивания, вы должны свободно понимать, 
как компилятор обрабатывает числовое преобразование и когда требуется приведение типов. Возможность обнаружить эти 
проблемы имеет решающее значение для сдачи экзамена, поскольку операторы присваивания появляются почти в каждом 
вопросе с фрагментом кода.

### Оператор присваивания

Оператор присваивания — это бинарный оператор, который изменяет или присваивает переменной в левой части оператора 
результат, равный значению в правой части уравнения. В отличие от большинства других операторов Java, оператор 
присваивания вычисляется справа налево.

Простейшим оператором присваивания является присваивание =, которое вы уже видели: 

```
int herd = 1;
```
Этот оператор присваивает переменной herd значение 1. Java будет автоматически переходить от меньших типов данных к 
более крупным, как вы видели в предыдущем разделе об арифметических операторах, но она выдаст исключение компилятора, 
если обнаружит, что вы пытаетесь преобразовать большие типы данных в меньшие без приведения типов. В табл. 2.5 
перечислены первые операторы присваивания, которые вам необходимо знать для экзамена. Мы представим дополнительные 
операторы присваивания позже в этом разделе.

#### Таблица 2.5. - Простой оператор присваивания
| Оператор         |    Пример    |                   Описание                    |
|:-----------------|:------------:|:---------------------------------------------:|
| Назначение       | int a = 50;  | Присваивает значение справа переменной слева  |

### Приведение значений

Кажется, пока все просто, верно? Что ж, мы не можем подробно говорить об операторе присваивания, пока не рассмотрим 
приведение типов. Приведение типов — это унарная операция, в которой один тип данных явно интерпретируется как 
другой тип данных. Приведение является необязательным и ненужным при преобразовании в более крупный или расширяющий тип 
данных, но требуется при преобразовании в меньший или сужающий тип данных. Без приведения компилятор выдаст ошибку 
при попытке поместить больший тип данных в меньший.

Приведение выполняется путем размещения типа данных, заключенного в круглые скобки, слева от значения, которое вы 
хотите преобразовать. Вот несколько примеров кастинга:

```
int fur = (int)5;
int hair = (short) 2;
String type = (String) "Bird";
short tail = (short)(4 + 10);
long feathers = 10(long); // НЕ КОМПИЛИРУЕТСЯ
```

Пробелы между приведением и значением необязательны. Как показано в предпоследнем примере, правая сторона обычно также 
заключена в круглые скобки. Поскольку приведение — это унарная операция, она будет применяться только к 4, если мы не 
будем заключать 4 + 10 в круглые скобки. Последний пример не компилируется, потому что тип находится не на той стороне 
значения.

С одной стороны удобно, что компилятор автоматически приводит меньшие типы данных к большим. С другой стороны, это 
отличные экзаменационные вопросы, когда они делают противоположное, чтобы увидеть, обращаете ли вы внимание. 
Посмотрите, сможете ли вы понять, почему ни одна из следующих строк кода не компилируется:

```
float egg = 2.0 / 9;        // НЕ КОМПИЛИРУЕТСЯ
int tadpole = (int)5 * 2L;  // НЕ КОМПИЛИРУЕТСЯ
short frog = 3 - 2.0;       // НЕ КОМПИЛИРУЕТСЯ
```

Во всех этих примерах большее значение помещается в меньший тип данных. Не волнуйтесь, если вы еще не следуете этому; 
мы рассмотрим больше подобных примеров в ближайшее время.

В этой главе приведение в первую очередь связано с преобразованием числовых типов данных в другие типы данных. Как вы 
увидите в следующих главах, приведение может также применяться к объектам и ссылкам. Однако в этих случаях 
преобразование не выполняется. Проще говоря, приведение числового значения может изменить тип данных, в то время как 
приведение объекта изменяет только ссылку на объект, а не сам объект.

### Просмотр назначений примитивов

Посмотрите, сможете ли вы понять, почему каждая из следующих строк не компилируется:

```
int fish = 1.0;       // НЕ КОМПИЛИРУЕТСЯ
short bird = 1921222; // НЕ КОМПИЛИРУЕТСЯ
int mammal = 9f;      // НЕ КОМПИЛИРУЕТСЯ
long reptile = 192_301_398_193_810_323;  // НЕ КОМПИЛИРУЕТСЯ
```

Первый оператор не компилируется, потому что вы пытаетесь присвоить двойное значение 1.0 целочисленному значению. 
Несмотря на то, что значение представляет собой математическое целое число, добавляя .0, вы даете компилятору 
указание рассматривать его как двойное. Второй оператор не компилируется, потому что литеральное значение 1921222 
выходит за пределы диапазона short, и компилятор это обнаруживает. Третий оператор не компилируется, потому что f, 
добавленное в конце числа, указывает компилятору обрабатывать число как значение с плавающей точкой, но присваивается значение int. 
Наконец, последний оператор не компилируется, потому что Java интерпретирует литерал как int и замечает, что значение больше, чем позволяет int. 
Литералу потребуется постфикс L или l, чтобы он считался long.

### Применение кастинга

Мы можем исправить три предыдущих примера, приведя результаты к меньшему типу данных. Помните, что приведение 
примитивов требуется всякий раз, когда вы переходите от большего числового типа данных к меньшему числовому типу 
данных или конвертируете число с плавающей запятой в целочисленное значение.

```
int fish = (int)1.0;
short bird = (short)1921222; // Сохранено как 20678
int mammal = (int)9f;
```

Как насчет применения приведения к последнему примеру?

```
long reptile = (long)192301398193810323; // НЕ КОМПИЛИРУЕТСЯ
```

Это по-прежнему не компилируется, потому что значение сначала интерпретируется компилятором как int и выходит за 
пределы допустимого диапазона. Следующий код исправляет этот код без приведения:

```
long reptile = 192301398193810323L;
```

---

##### Сценарий реального мира

#### Переполнение и недополнение

Выражения в предыдущем примере теперь компилируются, хотя и за это приходится платить. Второе значение, 1 921 222, 
слишком велико, чтобы его можно было сохранить как короткое, поэтому возникает числовое переполнение, и оно становится 
равным 20 678. Переполнение — это когда число настолько велико, что больше не помещается в тип данных, поэтому система 
«переходит» к наименьшему отрицательному значению и начинает считать оттуда, подобно тому, как работает модульная 
арифметика. Существует также аналогичный потеря значимости, когда число слишком мало, чтобы поместиться в тип данных, 
например, сохранение -200 в байтовом поле.

Это выходит за рамки экзамена, но с этим следует быть осторожным в собственном коде. Например, следующий оператор 
выводит отрицательное число:

```
System.out.print(2147483647+1); // -2147483648
```

Поскольку 2147483647 является максимальным значением int, добавление к нему любого строго положительного значения 
приведет к переносу его на наименьшее отрицательное число.

---

Вернемся к аналогичному примеру из раздела «Числовое продвижение» ранее в этой главе.

```
short mouse = 10;
short hamster = 3;
short capybara = mouse * hamster; // НЕ КОМПИЛИРУЕТСЯ
```

Основываясь на всем, что вы узнали до сих пор о числовом преобразовании и преобразовании, вы понимаете, почему 
последняя строка этого утверждения не будет компилироваться? Как вы, возможно, помните, короткие значения 
автоматически преобразуются в int при применении любого арифметического оператора, при этом результирующее значение 
имеет тип int. Попытка присвоить короткой переменной значение int приводит к ошибке компилятора, поскольку Java 
считает, что вы пытаетесь неявно преобразовать больший тип данных в меньший.

Мы можем исправить это выражение путем приведения, так как иногда вам может понадобиться переопределить поведение 
компилятора по умолчанию. В этом примере мы знаем, что результат 10 * 3 равен 30, что может легко поместиться в 
переменную типа short, поэтому мы можем применить кастинг, чтобы преобразовать результат обратно в тип short:

```
short mouse = 10;
short hamster = 3;
short capybara = (short)(mouse * hamster);
```

Преобразуя большее значение в меньший тип данных, вы указываете компилятору игнорировать его поведение по умолчанию. 
Другими словами, вы сообщаете компилятору, что предприняли дополнительные шаги для предотвращения переполнения или 
потери значимости. Также возможно, что в вашем конкретном приложении и сценарии переполнение или потеря значимости 
приведет к приемлемым значениям.

И последнее, но не менее важное: приведение типов может появляться в любом месте выражения, а не только в присваивании. 
Например, давайте взглянем на модифицированную форму предыдущего примера:

```
short mouse = 10;
short hamster = 3;
short capybara = (short)mouse * hamster; // DOES NOT COMPILE
```

Итак, что происходит в последней строке? Помните, мы говорили, что приведение типов — это унарная операция? Это 
означает, что приведение в последней строке применяется к мыши и только к мыши. После завершения приведения оба 
операнда повышаются до int, поскольку они используются с оператором двоичного умножения (*), что делает результат 
int и вызывает ошибку компилятора.

Что, если мы изменим последнюю строку на следующую? 

```
short capybara = 1 + (short)(mouse * hamster); // DOES NOT COMPILE
```

В этом примере приведение выполняется успешно, но результирующее значение автоматически повышается до int, поскольку 
оно используется с бинарным арифметическим оператором (+).

### Casting Values vs. Variables

Возвращаясь к нашему третьему числовому рекламному правилу, компилятор не требует приведения типов при работе с 
литеральными значениями, которые соответствуют типу данных. Рассмотрим эти примеры:

```
byte hat = 1;
byte gloves = 7 * 10;
short scarf = 5;
short boots = 2 + 1;
```

Все эти операторы компилируются без проблем. С другой стороны, ни одно из этих утверждений не компилируется:

```
short boots = 2 + hat; // DOES NOT COMPILE
byte gloves = 7 * 100; // DOES NOT COMPILE
```

Первый оператор не компилируется, потому что шляпа — это переменная, а не значение, и оба операнда автоматически 
преобразуются в int. При работе со значениями у компилятора было достаточно информации, чтобы определить намерение 
автора. Однако при работе с переменными возникает неясность в отношении дальнейших действий, поэтому компилятор 
сообщает об ошибке. Второе выражение не компилируется, так как 700 вызывает переполнение для байта, максимальное 
значение которого равно 127.

## Составные операторы присваивания (Compound Assignment Operators)

Помимо простого оператора присваивания (=), Java поддерживает множество составных операторов присваивания. Для 
экзамена вы должны быть знакомы с составными операторами в таблице 2.6.

#### Таблица 2.6. - Составные операторы присваивания
| Оператор             |  Пример  |                                      Описание                                      |
|:---------------------|:--------:|:----------------------------------------------------------------------------------:|
| Назначение сложения  |  a += 5  |    Добавляет значение справа к переменной слева и присваивает сумму переменной     |
| Назначение вычитания | b -= 0.2 |   Вычитает значение справа от переменной слева и присваивает разницу переменной    |
| Назначение умножения | c *= 100 | Умножает значение справа на переменную слева и присваивает произведение переменной |
| Назначение деления   | d /= 4   |    Делит переменную слева на значение справа и присваивает переменной частное      |

Составные операторы на самом деле являются просто прославленными формами простого оператора присваивания со встроенной 
арифметической или логической операцией, которая применяет левую и правую части оператора и сохраняет результирующее 
значение в переменной в левой части оператора. Например, следующие два оператора после объявления camel и giraffe 
эквивалентны при независимом выполнении:

```
int camel = 2, giraffe = 3;
camel = camel * giraffe;     // Simple assignment operator
camel *= giraffe;            // Compound assignment operator
```

Левая часть составного оператора может применяться только к уже определенной переменной и не может использоваться для 
объявления новой переменной. В этом примере, если бы camel еще не был определен, выражение camel *= giraffe 
не скомпилировалось бы.

Составные операторы полезны не только для сокращения — они также могут избавить вас от необходимости явного приведения 
значения. Например, рассмотрим следующее. Можете ли вы понять, почему последняя строка не компилируется?

```
long goat = 10;
int sheep = 5;
sheep = sheep * goat;  // DOES NOT COMPILE
```

Из предыдущего раздела вы должны определить проблему в последней строке. Мы пытаемся присвоить длинное значение 
переменной int. Эту последнюю строку можно было бы исправить с помощью явного приведения к (int), но есть лучший 
способ использовать составной оператор присваивания:

```
long goat = 10;
int sheep = 5;
sheep *= goat;
```

Составной оператор сначала приведёт sheep к типу long, применит умножение двух значений типа long, а затем приведёт 
результат к типу int. В отличие от предыдущего примера, в котором компилятор сообщил об ошибке, компилятор 
автоматически приведет результирующее значение к типу данных значения в левой части составного оператора.

### Возвращаемое значение операторов присваивания (Return Value of Assignment Operators)

Последнее, что нужно знать об операторах присваивания, это то, что результатом присваивания является выражение, само 
по себе равное значению присваивания. Например, следующий фрагмент кода вполне корректен, хотя и выглядит немного 
странно:

```
long wolf = 5;
long coyote = (wolf=3);
System.out.println(wolf);    // 3
System.out.println(coyote);  // 3
```

Суть здесь в том, что (wolf=3) делает две вещи. Во-первых, он устанавливает значение переменной wolf равным 3. 
Во-вторых, он возвращает значение присваивания, которое также равно 3.

Создатели экзамена любят вставлять оператор присваивания (=) в середине выражения и использовать значение присваивания 
как часть более сложного выражения. Например, не удивляйтесь, если увидите на экзамене оператор if, подобный 
следующему:

```
boolean healthy = false;
if(healthy = true)
    System.out.print("Good!");
```

Хотя это может выглядеть как проверка, верно ли значение «healthy», на самом деле это присваивает healthy
значение «истина». Результатом присваивания является значение присваивания, которое равно true, в результате чего этот 
фрагмент печатает Good!. Мы рассмотрим это более подробно в следующем разделе «Операторы равенства».

## Сравнение значений (Comparing Values)

Последний набор бинарных операторов вращается вокруг сравнения значений. Их можно использовать для проверки совпадения 
двух значений, проверки того, является ли одно числовое значение меньше или больше другого, и выполнения логических 
арифметических операций. Скорее всего, вы использовали многие операторы из этого раздела в своем опыте разработки.

### Операторы равенства (Equality Operators)

Определение равенства в Java может быть нетривиальной задачей, поскольку существует семантическая разница между 
«два объекта одинаковы» и «два объекта эквивалентны». Это еще более усложняется тем фактом, что для числовых и 
логических примитивов такого различия нет.

В табл. 2.7 перечислены операторы равенства. Оператор равенства (==) и оператор не равно (!=) сравнивают два операнда 
и возвращают логическое значение, определяющее, равны или не равны выражения или значения соответственно.

#### Таблица 2.7. - Операторы равенства
| Оператор    |  Пример   |                        Применить к примитивам                         |                           Применить к объектам                            |
|:------------|:---------:|:---------------------------------------------------------------------:|:-------------------------------------------------------------------------:|
| Равенство   |  a == 10  | Возвращает true, если два значения представляют одно и то же значение |   Возвращает true, если два значения ссылаются на один и тот же объект    |
| Неравенство | b != 3.14 |   Возвращает true, если два значения представляют разные значения     | Возвращает true, если два значения не ссылаются на один и тот же объект.  |

Оператор равенства можно применять к числовым значениям, логическим значениям и объектам (включая String и null).
При применении оператора равенства нельзя смешивать эти типы. Каждое из следующих действий приводит к ошибке 
компилятора:

```
boolean monkey = true == 3;       // DOES NOT COMPILE
boolean ape = false != "Grape";   // DOES NOT COMPILE
boolean gorilla = 10.2 == "Koko"; // DOES NOT COMPILE
```

Обратите особое внимание на типы данных, когда увидите на экзамене оператор равенства. Как упоминалось в предыдущем 
разделе, создатели экзамена также имеют привычку смешивать операторы присваивания и операторы равенства.

```
boolean bear = false;
boolean polar = (bear = true);
System.out.println(polar);     // true
```

На первый взгляд может показаться, что вывод должен быть ложным, и если бы выражение было (bear == true), то вы были бы 
правы. Однако в этом примере выражение присваивает Bear значение true, и, как вы видели в разделе об операторах 
присваивания, само присваивание имеет значение присваивания. Следовательно, полярному также присваивается значение 
true, и на выходе получается true.

Для сравнения объектов оператор равенства применяется к ссылкам на объекты, а не к объектам, на которые они указывают. 
Две ссылки равны тогда и только тогда, когда они указывают на один и тот же объект или обе указывают на null. 
Давайте рассмотрим несколько примеров:

```
var monday = new File("schedule.txt");
var tuesday = new File("schedule.txt");
var wednesday = tuesday;
System.out.println(monday == tuesday);     // false
System.out.println(tuesday == wednesday);  // true
```

Несмотря на то, что все переменные указывают на одну и ту же информацию о файле, только две ссылки, вторник и среда, 
равны с точки зрения ==, поскольку они указывают на один и тот же объект.

---
Подождите, что такое класс File?
В этом примере, а также во время экзамена вам могут быть представлены незнакомые имена классов, например File. Много 
раз вы можете отвечать на вопросы об этих классах, не зная конкретных деталей этих классов. В предыдущем примере вы 
должны быть в состоянии ответить на вопросы, указывающие на то, что понедельник и вторник — это два отдельных объекта, 
поскольку используется ключевое слово new, даже если вы не знакомы с типами данных этих объектов.
---

В некоторых языках сравнение null с любым другим значением всегда ложно, хотя в Java это не так. 

```
System.out.print(null == null); // true
```

В главе 4 мы продолжим обсуждение равенства объектов, представив, что означает эквивалентность двух разных объектов. 
Мы также рассмотрим равенство строк и покажем, насколько это может быть нетривиальной темой.

### Реляционные операторы (Relational Operators) 

Теперь перейдем к операторам отношения, которые сравнивают два выражения и возвращают логическое значение. В табл. 2.8 
описаны реляционные операторы, которые вам необходимо знать для сдачи экзамена.

#### Таблица 2.8. - Реляционные операторы
| Оператор         |        Пример        |                                                         Описание                                                         |
|:-----------------|:--------------------:|:------------------------------------------------------------------------------------------------------------------------:|
| Меньше, чем      |        a < 5         |                            Возвращает true, если значение слева строго меньше значения справа                            |
| Меньше или равно |        b <= 6        |                          Возвращает true, если значение слева меньше или равно значению справа                           |
| Больше, чем      |        c > 9         |                            Возвращает true, если значение слева строго больше значения справа                            |
| Больше или равно |        3 >= d        |                          Возвращает true, если значение слева больше или равно значению справа                           |
| Сравнение типов  | e instanceof String  | Возвращает true, если ссылка слева является экземпляром типа справа (класс, интерфейс, запись, перечисление, аннотация)  |

### Операторы числового сравнения

Первые четыре реляционных оператора в таблице 2.8 применяются только к числовым значениям. Если два числовых операнда 
имеют разные типы данных, меньший из них продвигается вперед, как обсуждалось ранее.

Давайте посмотрим на примеры этих операторов в действии:

```
int gibbonNumFeet = 2, wolfNumFeet = 4, ostrichNumFeet = 2;
System.out.println(gibbonNumFeet < wolfNumFeet);       // true
System.out.println(gibbonNumFeet <= wolfNumFeet);      // true
System.out.println(gibbonNumFeet >= ostrichNumFeet);   // true
System.out.println(gibbonNumFeet > ostrichNumFeet);    // false
```

Обратите внимание, что в последнем примере выводится false, потому что хотя gibbonNumFeet и ostrichNumFeet имеют 
одинаковое значение, gibbonNumFeet строго не больше, чем ostrichNumFeet.

###  оператор instanceof (instanceof Operator)

Последний реляционный оператор, который вам нужно знать для экзамена, — это оператор instanceof, показанный в 
таблице 2.8. Это полезно для определения того, является ли произвольный объект членом определенного класса или 
интерфейса во время выполнения. Например, все классы наследуются от java.lang.Object. Это означает, что любой экземпляр 
может быть назначен ссылке на объект. Например, сколько объектов создается и используется в следующем фрагменте кода?

```
Integer zooTime = Integer.valueOf(9);
Number num = zooTime;
Object obj = zooTime;
```

В этом примере в памяти создается только один объект, но есть три разных ссылки на него, поскольку Integer наследует 
как Number, так и Object. Это означает, что вы можете вызвать instanceof для любой из этих ссылок с тремя разными 
типами данных, и он вернет true для каждого из них. 

Полиморфизм часто вступает в игру, когда вы создаете метод, который принимает тип данных со многими возможными 
подклассами. Например, представьте, что у нас есть функция, которая открывает зоопарк (zoo) и печатает время. В 
качестве входных данных он принимает число (Number) в качестве входного параметра.

```
public void openZoo(Number time) {}
```

Теперь мы хотим, чтобы функция добавляла часы в конец вывода, если значение представляет собой целое число, например 
Integer; в противном случае он просто печатает значение.

```
public void openZoo(Number time) {
    if (time instanceof Integer)
        System.out.print((Integer)time + " O'clock");
    else
        System.out.print(time);
}
```

Теперь у нас есть метод, который может разумно обрабатывать как целочисленные, так и другие значения. Хорошим 
упражнением для читателя является добавление проверок для других числовых типов данных, таких как Short, Long, Double 
и так далее.

Обратите внимание, что в этом примере мы приводим значение Integer. Распространено использование приведения с 
instanceof при работе с объектами, которые могут быть разных типов, поскольку приведение дает вам доступ к полям, 
доступным только в более конкретных классах. Считается хорошей практикой кодирования использовать оператор instanceof 
перед приведением от одного объекта к более узкому типу.

---
Для экзамена вам нужно сосредоточиться только на том, когда instanceof используется с классами и интерфейсами. Хотя 
его можно использовать с другими высокоуровневыми типами, такими как записи, перечисления и аннотации, это не является 
распространенным явлением.
---

### Неверный экземпляр (Invalid instanceof)

Одна из областей, в которой экзамен может вас запутать, — это использование instanceof с несовместимыми типами. 
Например, Number не может содержать строковое значение, поэтому следующее вызовет ошибку компиляции:

```
public void openZoo(Number time) {
    if(time instanceof String) // DOES NOT COMPILE
       System.out.print(time);
}
```

Если компилятор может определить, что переменная не может быть приведена к определенному классу, он сообщает об ошибке.

### null и оператор instanceof (null and the instanceof operator)

Что произойдет, если вы вызовете instanceof для нулевой (null) переменной? Для экзамена вы должны знать, что вызов 
instanceof для нулевого (null) литерала или нулевой (null) ссылки всегда возвращает false.

```
System.out.print(null instanceof Object); // false

Object noObjectHere = null;
System.out.print(noObjectHere instanceof String); // false
```

Оба предыдущих примера выводят false. Почти не имеет значения, какая правая часть выражения. Мы говорим «почти», потому 
что есть исключения. Этот пример не компилируется, поскольку null используется в правой части оператора instanceof:

```
System.out.print(null instanceof null); // DOES NOT COMPILE
```

---
Хотя может показаться, что вы узнали все, что есть об операторе instanceof, впереди еще много интересного! В главе 3 мы 
вводим сопоставление с шаблоном с помощью оператора instanceof, который был официально добавлен в Java 16. В главе 7 
“За пределами классов” мы гораздо подробнее рассмотрим полиморфизм и покажем, как применять эти правила к интерфейсам.
---

## Логические операторы (Logical Operators) 

Если вы изучали информатику, возможно, вы уже сталкивались с логическими операторами раньше. Если нет, не нужно 
паниковать — мы подробно расскажем о них в этом разделе.

Логические операторы (&), (|) и (^) могут применяться как к числовым, так и к логическим типам данных; они перечислены 
в таблице 2.9. Когда они применяются к логическим типам данных, их называют логическими операторами. В качестве 
альтернативы, когда они применяются к числовым типам данных, их называют побитовыми операторами, поскольку они 
выполняют побитовое сравнение битов, составляющих число. Однако для экзамена вам не нужно ничего знать о числовых 
побитовых сравнениях, поэтому мы оставим этот образовательный аспект другим книгам.

#### Таблица 2.9. - Логические операторы
| Оператор                    |   Пример   |                               Описание                                |
|:----------------------------|:----------:|:---------------------------------------------------------------------:|
| Логическое И                |   a & b    |          Значение истинно, только если оба значения истинны.          |
| Логическое включающее ИЛИ   | c &#124; d |       Значение истинно, если хотя бы одно из значений истинно.        |
| Логическое исключающее ИЛИ  |   e ^ f    | Значение истинно, только если одно значение истинно, а другое ложно.  |

Вам следует ознакомиться с таблицами истинности на рис. 2.2, где x и y предполагаются логическими типами данных.

#### Рис. 2.2 - Логические таблицы истинности для &, | и ^
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/chapter%202/image2/figure%202.2%20.JPG)

Вот несколько советов, которые помогут вам запомнить эту таблицу:

+ AND истинен только в том случае, если оба операнда истинны.
+ Включающее ИЛИ ложно только в том случае, если оба операнда ложны.
+ Исключающее ИЛИ верно только в том случае, если операнды разные.

Давайте рассмотрим несколько примеров:

```
boolean eyesClosed = true;
boolean breathingSlowly = true;

boolean resting = eyesClosed | breathingSlowly;
boolean asleep = eyesClosed & breathingSlowly;
boolean awake = eyesClosed ^ breathingSlowly;
System.out.println(resting);    // true
System.out.println(asleep);    // true
System.out.println(awake);    // false
```

Вы должны попробовать это сами, изменив значения параметров eyesClosed и breathSlowly и изучив результаты.

## Условные операторы (Conditional Operators)

Далее мы представляем условные операторы && и || в таблице 2.10.

#### Таблица 2.10. - Условные операторы
| Оператор     |      Пример      |                                                          Описание                                                           |
|:-------------|:----------------:|:---------------------------------------------------------------------------------------------------------------------------:|
| Условное И   |      a && b      |    Значение истинно, только если оба значения истинны. Если левая сторона ложна, то правая сторона не будет оцениваться.    |
| Условное ИЛИ | c &#124;&#124; d | Значение истинно, если хотя бы одно из значений истинно. Если левая часть истинна, то правая сторона не будет оцениваться.  |

Условные операторы, часто называемые операторами короткого замыкания, почти идентичны логическим операторам & и |, за 
исключением того, что правая часть выражения никогда не может быть вычислена, если конечный результат может быть 
определен левой частью выражения. Например, рассмотрим следующее утверждение:

```
int hour = 10;
boolean zooOpen = true || (hour < 4);
System.out.println(zooOpen);   // true
```

Ссылаясь на таблицы истинности, значение zooOpen может быть false только в том случае, если обе части выражения false. 
Поскольку мы знаем, что левая часть true, нет необходимости оценивать правую часть, так как никакое значение hour 
никогда не заставит этот код вывести false. Другими словами, hour мог быть -10 или 892; выход был бы таким же. 
Попробуйте сами с разными значениями часа!

### Избегание исключения NullPointerException (Avoiding a NullPointerException)

Более распространенным примером использования условных операторов является проверка нулевых (null) объектов перед 
выполнением операции. В следующем примере, если duck имеет значение null, программа выдаст исключение 
NullPointerException во время выполнения:

```
if(duck!=null & duck.getAge()<5) { // Could throw a NullPointerException
// Do something
}
```

Проблема в том, что логический оператор И (&) оценивает обе части выражения. Мы могли бы добавить второй оператор if, 
но это может стать громоздким, если у нас будет много переменных для проверки. Легко читаемое решение — использовать 
условный оператор И (&&):

```
if(duck!=null && duck.getAge()<5) {
// Do something
}
```

В этом примере, если duck имеет значение null, условие предотвращает создание исключения NullPointerException, так как 
оценка duck.getAge() < 5 никогда не достигается.

### Проверка на отсутствие побочных эффектов (Checking for Unperformed Side Effects)

Остерегайтесь короткого замыкания на экзамене, поскольку известно, что вопросы изменяют переменную в правой части 
выражения, которая может никогда не быть достигнута. Это называется невыполненным побочным эффектом (unperformed
side effect). Например, каков результат следующего кода?

```
int rabbit = 6;
boolean bunny = (rabbit >= 6) || (++rabbit <= 7);
System.out.println(rabbit);
```

Поскольку rabbit >= 6 true, оператор приращения в правой части выражения никогда не вычисляется, поэтому на выходе 
будет 6.

## Принятие решений с тернарным оператором (Making Decisions with the Ternary Operator)

Последний оператор, с которым вы должны быть знакомы на экзамене, — это условный оператор ? :, также известный как 
тернарный оператор. Он примечателен тем, что это единственный оператор, который принимает три операнда. Тернарный 
оператор имеет следующий вид:

```
booleanExpression ? expression1 : expression2
```

Первый операнд должен быть логическим выражением, а второй и третий операнды могут быть любыми выражениями, 
возвращающими значение. Тернарная операция на самом деле представляет собой сжатую форму комбинированного оператора 
if и else, который возвращает значение. Мы более подробно рассмотрим операторы if/else в главе 3, поэтому сейчас мы 
просто используем простые примеры. Например, рассмотрим следующий фрагмент кода, который вычисляет количество еды (food)
для совы (owl):

```
int owl = 5;
int food;
if(owl < 2) {
    food = 3;
} else {
    food = 4;
}
System.out.println(food); // 4
```

Сравните предыдущий фрагмент кода со следующим фрагментом кода тернарного оператора:

```
int owl = 5;
int food = owl < 2 ? 3 : 4;
System.out.println(food);   // 4
```

Эти два фрагмента кода эквивалентны. Обратите внимание, что для удобочитаемости часто полезно добавлять круглые скобки 
вокруг выражений в тернарных операциях, хотя это, конечно, не требуется. Однако это особенно полезно, когда несколько 
тернарных операторов используются вместе. Рассмотрим следующие два эквивалентных выражения:

``` 
int food1 = owl < 4 ? owl > 2 ? 3 : 4 : 5;
int food2 = (owl < 4 ? ((owl > 2) ? 3 : 4) : 5);
```

Хотя они эквивалентны, мы находим второе утверждение гораздо более читабельным. Тем не менее, возможно, экзамен может 
использовать несколько тернарных операторов в одной строке.

Для экзамена вы должны знать, что нет требования, чтобы второе и третье выражения в тернарных операциях имели 
одинаковые типы данных, хотя это играет роль в сочетании с оператором присваивания. Сравните два оператора после 
объявления переменной:

```
int stripes = 7;

System.out.print((stripes > 5) ? 21 : "Zebra");

int animal = (stripes < 9) ? 3 : "Horse"; // DOES NOT COMPILE
```

Оба выражения оценивают схожие логические значения и возвращают int и String, хотя компилируется только первое. 
System.out.print() не заботится о том, чтобы выражения были совершенно разных типов, потому что он может 
преобразовывать как значения Object, так и вызывать для них toString(). С другой стороны, компилятор знает, что 
"Horse" имеет неправильный тип данных и не может быть присвоено типу int; поэтому он не позволяет компилировать код.

---
#### Тернарное выражение и невыполненные побочные эффекты (Ternary Expression and Unperformed Side Effects)

Как мы видели с условными операторами, тернарное выражение может содержать невыполненный побочный эффект, поскольку 
только одно из выражений в правой части будет оцениваться во время выполнения. Проиллюстрируем этот принцип на 
следующем примере:

```
int sheep = 1;
int zzz = 1;
int sleep = zzz<10 ? sheep++ : zzz++;
System.out.print(sheep + "," + zzz); // 2,1
```

Обратите внимание, что, поскольку левое логическое (boolean) выражение было истинным (true), увеличивалась только овца
(sheep). Сравните предыдущий пример со следующей модификацией:

```
int sheep = 1;
int zzz = 1;
int sleep = sheep>=10 ? sheep++ : zzz++;
System.out.print(sheep + "," + zzz); // 1,2
```

Теперь, когда левое логическое выражение оценивается как false, увеличивается только zzz. Таким образом, мы видим, как 
изменения в тернарном операторе могут не применяться, если конкретное выражение не используется.

На экзамене будьте осторожны с любым вопросом, который включает троичное выражение, в котором переменная изменяется 
в одном из выражений в правой части.
---

## Резюме (Summary)

В этой главе рассмотрен широкий спектр тем, связанных с операторами Java для унарных, бинарных и тернарных операторов. 
Надеемся, что большинство из этих операторов были рассмотрены для вас. Если нет, то вам необходимо изучить их подробно. 
Важно, чтобы вы понимали, как использовать все необходимые операторы Java, описанные в этой главе, и знали, как 
приоритет операций и круглые скобки влияют на способ интерпретации конкретного выражения.

Скорее всего, на экзамене будет множество вопросов, которые, по-видимому, проверяют что-то одно, например, NIO.2 или 
обработку исключений, хотя на самом деле ответ связан с неправильным использованием определенного оператора, который 
приводит к сбою компиляции приложения. Когда вы видите на экзамене оператор, использующий числа, всегда проверяйте, 
используются ли соответствующие типы данных и совпадают ли они друг с другом, где это применимо.

Операторы используются на протяжении всего экзамена, почти в каждом примере кода, поэтому чем лучше вы поймете эту 
главу, тем лучше вы подготовитесь к экзамену.

## Основы экзамена (Exam Essentials)

Уметь писать код, использующий операторы Java. В этой главе рассмотрен широкий спектр символов операторов. Вернитесь и 
просмотрите их несколько раз, чтобы вы были знакомы с ними на протяжении всей оставшейся части книги.

Уметь распознавать, какие операторы связаны с какими типами данных. Некоторые операторы могут применяться только к 
числовым примитивам, некоторые только к логическим значениям, а некоторые только к объектам. Важно, чтобы вы замечали, 
когда оператор и операнд(ы) не совпадают, так как эта проблема, скорее всего, возникнет в паре экзаменационных 
вопросов.

Поймите, когда требуется кастинг или происходит числовое продвижение. Всякий раз, когда вы смешиваете операнды двух 
разных типов данных, компилятор должен решить, как обрабатывать результирующий тип данных. При преобразовании меньшего 
типа данных в больший автоматически применяется числовое продвижение. Когда вы конвертируете из большего типа данных в 
меньший, требуется приведение типов.

Понимать приоритет операторов Java. Большинство операторов Java, с которыми вы будете работать, являются бинарными, но 
количество выражений часто превышает два. Поэтому вы должны понимать порядок, в котором Java будет оценивать каждый 
символ оператора.

Уметь писать код, который использует круглые скобки для переопределения приоритета оператора. Вы можете использовать 
круглые скобки в своем коде, чтобы вручную изменить порядок приоритета.
