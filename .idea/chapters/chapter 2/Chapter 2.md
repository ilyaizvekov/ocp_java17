# Операторы (Operators)

---
### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Обработка даты, времени, текста, числовых и логических значений

+ Используйте примитивы и классы-оболочки, включая Math API, круглые скобки, продвижение (возможно приведение) типов 
и приведение типов для вычисления арифметических и логических выражений.
---

В предыдущей главе много говорилось об определении переменных, но что вы можете сделать с переменной после её создания?
В этой главе представлены операторы и показано, как вы можете использовать их для объединения существующих переменных 
и создания новых значений. Он показывает вам, как применять операторы к различным примитивным типам данных, в том 
числе знакомит вас с операторами, которые могут быть применены к объектам.

## Понимание операторов Java (Understanding Java Operators)

Прежде чем мы перейдем к самому интересному, давайте немного разберемся с терминологией. Оператор Java — это 
специальный символ, который может быть применен к набору переменных, значений или литералов, называемых операндами, 
и который возвращает результат. Термин "операнд", который мы используем на протяжении всей этой главы, относится к 
значению или переменной, к которой применяется оператор. На рис. 2.1 показана структура операции Java.

#### Рис. 2.1 - Операция Java

Результат операции называется просто результатом. Рисунок 2.1 фактически содержит вторую операцию, в которой оператор 
присваивания (=) используется для сохранения результата в переменной c.

Мы уверены, что вы использовали операторы сложения (+) и вычитания (-) с самого детства. Java поддерживает многие 
другие операторы, которые вам необходимо знать для сдачи экзамена. Хотя многие из них вам следует изучить, некоторые 
(например, составные операторы присваивания) могут быть для вас новыми.

### Типы операторов (Types of Operators) 

Java поддерживает три разновидности операторов: унарные, бинарные и троичные (быть может тернарные?). Эти типы 
операторов могут применяться к одному, двум или трем операндам соответственно. Для сдачи экзамена вам необходимо знать 
определенное подмножество операторов Java, как их применять и в каком порядке они должны применяться.

Операторы Java не обязательно вычисляются слева направо. В этом следующем примере второе выражение фактически 
вычисляется справа налево, учитывая конкретные задействованные операторы:

```
int cookies = 4;
double reward = 3 + 2 * --cookies;
System.out.print("Zoo animal receives: " + reward + " reward points");
```

В этом примере вы сначала уменьшаете количество файлов cookie до 3, затем умножаете полученное значение на 2 и, наконец,
добавляете 3. Затем значение автоматически повышается с 9 до 9,0 и присваивается reward. Окончательные значения 
reward и cookie равны 9,0 и 3 соответственно, при этом напечатано следующее:

```
Zoo animal receives: 9.0 reward points
```

Если вы не следовали этой оценке, не волнуйтесь. К концу этой главы решение подобных задач должно стать вашей второй 
натурой.

### Приоритет оператора (Operator Precedence)

При чтении книги или газеты некоторые письменные языки оцениваются слева направо, а некоторые — справа налево. В 
математике некоторые операторы могут переопределять другие операторы и выполняться в первую очередь. Определение того, 
какие операторы оцениваются в каком порядке, называется приоритетом оператора. Таким образом, Java более точно следует 
правилам математики. Рассмотрим следующее выражение:

```
var perimeter = 2 * height + 2 * length;
```

Давайте применим некоторые необязательные круглые скобки, чтобы продемонстрировать, как компилятор оценивает этот 
оператор:

```
var perimeter = ((2 * height) + (2 * length));
```

Оператор умножения (*) имеет более высокий приоритет, чем оператор сложения (+), поэтому перед сложением height и 
length умножаются на 2. Оператор присваивания (=) имеет самый низкий приоритет, поэтому присваивание переменной 
perimeter выполняется последним.

Если не указано иное с помощью круглых скобок, операторы Java следуют порядку операций, указанному в таблице 2.1, в 
порядке убывания приоритета операторов. Если два оператора имеют одинаковый уровень приоритета, то Java гарантирует 
вычисление слева направо для большинства операторов, кроме отмеченных в таблице.

#### Таблица 2.1. - Порядок приоритета оператора


Мы рекомендуем держать таблицу 2.1 под рукой на протяжении всей этой главы. Для экзамена вам нужно запомнить порядок 
очередности в этой таблице. Обратите внимание, что вы не будете протестированы на некоторых операторах, таких как 
операторы сдвига, хотя мы рекомендуем вам знать об их существовании.

---
Стрелочный оператор (->), иногда называемый стрелочной функцией или лямбда-оператором, представляет собой бинарный 
оператор, представляющий отношение между двумя операндами. Хотя мы не будем рассматривать оператор стрелки в этой 
главе, вы увидите его использование в выражениях переключения в главе 3 «Принятие решений» и в лямбда-выражениях, 
начиная с главы 8 «Лямбда-выражения и функциональные интерфейсы».
---

## Применение унарных операторов (Applying Unary Operators)

По определению унарный оператор — это оператор, для работы которого требуется ровно один операнд или переменная.
Как показано в таблице 2.2, они часто выполняют простые задачи, такие как увеличение числовой переменной на единицу или 
отрицание логического значения.

#### Таблица 2.2. - Унарные операторы

Несмотря на то, что в таблице 2.2 есть оператор приведения, мы откладываем обсуждение приведения до раздела 
«Присвоение значений» далее в этой главе, поскольку именно там он обычно используется.

### Операторы дополнения и отрицания (Complement and Negation Operators)

Поскольку в этой главе мы будем работать со многими числовыми операторами, давайте сначала избавимся от логического 
оператора. Оператор логического дополнения (!) инвертирует значение логического выражения. Например, если значение 
равно true, оно будет преобразовано в false, и наоборот. Чтобы проиллюстрировать это, сравните выходные данные 
следующих операторов:

```
boolean isAnimalAsleep = false;
System.out.print(isAnimalAsleep); // false
isAnimalAsleep = !isAnimalAsleep;
System.out.print(isAnimalAsleep); // true
```

Для экзамена вам также необходимо знать об операторе побитового дополнения (~), который переворачивает все 0 и 1 в 
числе. Его можно применять только к целочисленным числовым типам, таким как byte, short, char, int и long.
Давайте попробуем пример. Для простоты мы показываем только последние четыре бита (вместо всех 32 бит).

```
int value = 3;                   // Stored as 0011
int complement = ~value;         // Stored as 1100
System.out.println(value);      // 3
System.out.println(complement); // -4
```

Расслабьтесь! Вам не нужно знать, как выполнять сложную битовую арифметику на экзамене, если вы помните это правило: 
чтобы найти побитовое дополнение числа, умножьте его на отрицательную единицу, а затем вычтите единицу.

```
System.out.println(-1*value - 1);       // -4
System.out.println(-1*complement - 1);  // 3
```

Переходя к более распространенным операторам, оператор отрицания/negation operator (-) меняет знак числового выражения, 
как показано в следующих утверждениях:

```
double zooTemperature = 1.21;
System.out.println(zooTemperature);   // 1.21
zooTemperature = -zooTemperature;
System.out.println(zooTemperature);   // -1.21
zooTemperature = -(-zooTemperature);
System.out.println(zooTemperature);   // -1.21
```

Обратите внимание, что в последнем примере мы использовали круглые скобки () для оператора отрицания -, чтобы применить 
отрицание дважды. Если бы вместо этого мы написали --, то это было бы интерпретировано как оператор декремента и 
напечатано -2,21. Вскоре вы увидите больше этого оператора декремента.

На основании описания может быть очевидно, что некоторые операторы требуют, чтобы переменная или выражение, с которыми 
они работают, имели определенный тип. Например, вы не можете применить оператор отрицания (-) к логическому выражению, 
а также вы не можете применить оператор логического дополнения (!) к числовому выражению. Будьте осторожны с вопросами 
на экзамене, которые пытаются сделать это, так как они приводят к тому, что код не компилируется. Например, ни одна из 
следующих строк кода не скомпилируется:

```
int pelican = !5;          // DOES NOT COMPILE
boolean penguin = -true;   // DOES NOT COMPILE
boolean peacock = !0;      // DOES NOT COMPILE
```

Первый оператор не будет компилироваться, потому что в Java вы не можете выполнить логическую инверсию числового 
значения. Второй оператор не компилируется, потому что вы не можете численно инвертировать логическое значение; вам 
нужно использовать логический обратный оператор. Наконец, последний оператор не компилируется, потому что вы не можете 
взять логическое дополнение числового значения или присвоить целое число логической переменной.

---
Обращайте внимание на вопросы экзамена, в которых используются числовые значения (например, 0 или 1) с логическими 
выражениями. В отличие от некоторых других языков программирования, в Java 1 и true никак не связаны, как не связаны 
0 и false.
--- 

### Операторы увеличения и уменьшения (Increment and Decrement Operators)

Операторы инкремента и декремента, ++ и -- соответственно, могут применяться к числовым переменным и имеют более 
высокий порядок приоритета по сравнению с бинарными операторами. Другими словами, они часто применяются первыми в 
выражении.

Операторы инкремента и декремента требуют особой осторожности, потому что порядок, в котором они присоединяются к 
связанной с ними переменной, может повлиять на то, как обрабатывается выражение. В Таблице 2.3 перечислены все эти 
операторы.

#### Таблица 2.3. - Операторы инкремента и декремента


Следующий фрагмент кода иллюстрирует это различие:

```
int parkAttendance = 0;
System.out.println(parkAttendance);    // 0
System.out.println(++parkAttendance);  // 1
System.out.println(parkAttendance);    // 1
System.out.println(parkAttendance--);  // 1
System.out.println(parkAttendance);    // 0
```

Первый оператор предварительного приращения обновляет значение для parkAttendance и выводит новое значение 1.
Следующий оператор постдекремента также обновляет значение parkAttendance, но выводит значение до того, как произойдет 
декремент.

---
Для экзамена очень важно, чтобы вы знали разницу между такими выражениями, как parkAttendance++ и ++parkAttendance.
Операторы инкремента и декремента будут в нескольких вопросах, и путаница в том, какое значение возвращается, может 
привести к потере большого количества баллов на экзамене.
---

## Работа с двоичными арифметическими операторами (Working with Binary Arithmetic Operators)

Далее мы переходим к операторам, которые принимают два операнда, называемым бинарными операторами. Бинарные операторы 
на сегодняшний день являются наиболее распространенными операторами в языке Java. Их можно использовать для выполнения 
математических операций над переменными, создания логических выражений и выполнения основных назначений переменных. 
Бинарные операторы часто объединяются в сложные выражения с другими бинарными операторами; поэтому приоритет операций 
очень важен при вычислении выражений, содержащих бинарные операторы. В этом разделе мы начнем с бинарных арифметических 
операторов; мы расширимся до других бинарных операторов в последующих разделах.

### Арифметические операторы (Arithmetic Operators) 

Арифметические операторы — это те, которые работают с числовыми значениями. Они показаны в таблице 2.4.

#### Таблица 2.4. - Двоичные арифметические операторы


Вы должны знать все, кроме модуля, из ранней математики. Однако, если вы не знаете, что такое модуль, не 
волнуйтесь — мы вскоре расскажем об этом. К арифметическим операторам также относятся унарные операторы ++ и --, 
которые мы уже рассмотрели. Как вы могли заметить в таблице 2.1, мультипликативные операторы (*, /, %) имеют более 
высокий порядок старшинства, чем аддитивные операторы (+, -). Взгляните на следующее выражение:

```
int price = 2 * 5 + 3 * 4 - 8;
```

Сначала вы оцениваете 2 * 5 и 3 * 4, что приводит к следующему выражению: 

```
int price = 10 + 12 - 8;
```

Затем вы оцениваете оставшиеся термины в порядке слева направо, в результате чего значение price равно 14.
Убедитесь, что вы понимаете, почему результат равен 14, потому что вы, скорее всего, встретите такой вопрос о 
приоритете операторов на экзамене.

---
Все арифметические операторы могут применяться к любым примитивам Java, за исключением логических.
Кроме того, к значениям String можно применять только операторы сложения + и +=, что приводит к конкатенации строк.
Вы узнаете больше об этих операторах и о том, как они применяются к строковым значениям, в главе 4, «Основные API».
---

### Добавление круглых скобок (Adding Parentheses)

Возможно, вы заметили, что мы сказали “Если не переопределено скобками” перед представлением таблицы 2.1 о приоритете 
операторов. Это потому, что вы можете явно изменить порядок выполнения операций, заключив в круглые скобки разделы, 
которые вы хотите оценить в первую очередь.

#### Изменение порядка работы (Changing the Order of Operation)

Вернемся к предыдущему примеру с price. Следующий фрагмент кода содержит те же значения и операторы в том же порядке, 
но с двумя добавленными скобками:

```
int price = 2 * ((5 + 3) * 4 -8);
```

На этот раз вы должны вычислить оператор сложения 5 + 3, который уменьшает выражение до следующего: 

```
int price = 2 * (8 * 4 -8);
```

Вы можете уменьшить это выражение, умножив первые два значения в скобках:

```
int price = 2 * (32 -8);
```

Затем вы вычитаете значения в круглых скобках, прежде чем применять термины за пределами круглых скобок:

```
int price = 2 * 24;
```

Наконец, вы должны умножить результат на 2, в результате чего price будет равен 48.

Круглые скобки могут появляться практически в любом вопросе экзамена, включающем числовые значения, поэтому убедитесь, 
что вы понимаете, как они меняют порядок действий, когда вы их видите.

---
Когда вы сталкиваетесь с кодом в своей профессиональной карьере, в котором вы не уверены в порядке работы, не 
стесняйтесь добавлять необязательные круглые скобки. Хотя часто они не требуются, они могут улучшить читаемость, 
особенно в том, что вы увидите с тернарными операторами.
---

#### Проверка синтаксиса скобок (Verifying Parentheses Syntax)

При работе со скобками необходимо убедиться, что они всегда корректны и сбалансированы. Рассмотрим следующие примеры:

```
long pigeon = 1 + ((3 * 5) / 3;        // DOES NOT COMPILE
int blueJay = (9 + 2) + 3) / (2 * 4;   // DOES NOT COMPILE
```

Первый пример не компилируется, потому что скобки не сбалансированы. Существует левая скобка без соответствующей 
правой скобки. Во втором примере одинаковое количество левых и правых скобок, но они не сбалансированы должным образом. 
При чтении слева направо новая правая скобка должна совпадать с предыдущей левой скобкой. Аналогично, все левые круглые 
скобки должны быть закрыты правыми скобками до конца выражения.

Давайте попробуем другой пример: 

```
short robin = 3 + [(4 * 2) + 4];   // DOES NOT COMPILE
```

Этот пример не компилируется, потому что Java, в отличие от некоторых других языков программирования, не позволяет 
использовать квадратные скобки [] вместо скобок. Если вы замените квадратные скобки скобками, последний пример будет 
скомпилирован очень хорошо.

### Операторы деления и модуля (Division and Modulus Operators)

Как мы уже говорили ранее, оператор модуля % может быть для вас новым. Оператор модуля, иногда называемый оператором 
остатка, представляет собой просто остаток от деления двух чисел. Например, 9, разделенное на 3, делится без остатка и 
не имеет остатка; следовательно, результат 9 % 3 равен 0. С другой стороны, 11, деленное на 3, не делится поровну; 
следовательно, результатом 11 % 3 будет 2.

Следующие примеры иллюстрируют это различие:

```
System.out.println(9 / 3);  // 3
System.out.println(9 % 3);  // 0

System.out.println(10 / 3);  // 3
System.out.println(10 % 3);  // 1

System.out.println(11 / 3);  // 3
System.out.println(11 % 3);  // 2

System.out.println(12 / 3);  // 4
System.out.println(12 % 3);  // 0
```

Как видите, результаты деления увеличиваются только тогда, когда значение в левой части изменяется от 11 до 12, тогда 
как значение остатка модуля увеличивается на 1 каждый раз, когда левая часть увеличивается, пока не достигнет нуля.
Для данного делителя y операция по модулю приводит к значению от 0 до (y -1) для положительных дивидендов или 0, 1, 2 в 
этом примере.

Обязательно поймите разницу между арифметическим делением и модулем. Для целочисленных значений результатом деления 
является минимальное значение ближайшего целого числа, которое выполняет операцию, тогда как модуль является 
остаточным значением. Если вы слышите словосочетание «минимальное значение», это просто означает значение без 
каких-либо знаков после запятой. Например, минимальное значение равно 4 для каждого из значений 4,0, 4,5 и 4,9999999. 
В отличие от округления, которое мы рассмотрим в главе 4, вы просто берете значение до запятой, независимо от того, 
что находится после запятой.

---
Операция модуля не ограничена положительными целыми значениями в Java; его также можно применять к отрицательным целым 
числам и числам с плавающей запятой. Например, если делитель равен 5, то значение модуля отрицательного числа находится
в диапазоне от -4 до 0. Однако для экзамена от вас не требуется уметь вычислять модуль отрицательного целого числа или 
числа с плавающей запятой.
---

### Numeric Promotion
