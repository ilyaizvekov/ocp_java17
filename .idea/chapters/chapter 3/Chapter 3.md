# Принятие решений

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Управление потоком программы

+ Создание конструкций управления потоком программы, включая операторы if/else, операторы и выражения switch, циклы, а 
также операторы break и continue.

#### Использование объектно-ориентированного подхода Java

+ Реализуйте полиморфизм и различайте тип объекта и ссылочный тип. Выполните приведение типов, определите типы объектов 
с помощью оператора instanceof и сопоставления с образцом.

---

Как и многие языки программирования, Java состоит в основном из переменных, операторов и инструкций, собранных в определенном логическом порядке. 
В прошлой главе мы рассмотрели, как создавать переменные и управлять ими. 
Однако написание программного обеспечения - это нечто большее, чем управление переменными; речь идет о создании приложений, 
способных принимать разумные решения. В этой главе мы представляем различные инструкции по принятию решений, доступные 
вам в рамках данного языка. Эти знания позволят вам создавать сложные функции и структуры классов, которые вы увидите 
на протяжении всей этой книги.

## Создание заявлений для принятия решений

Операторы Java позволяют создавать множество сложных выражений, но они ограничены в том, как они могут управлять ходом 
выполнения программы. Представьте, что вы хотите, чтобы метод выполнялся только при определенных условиях, которые 
нельзя оценить до времени выполнения. Например, в дождливые дни зоопарк должен напоминать посетителям о необходимости 
взять с собой зонтик, а в снежный день зоопарку, возможно, придется закрыться. Программное обеспечение не меняется, но 
поведение программного обеспечения должно меняться в зависимости от входных данных, поступающих в данный момент. В этом 
разделе мы обсудим операторы принятия решений, включая if и else, а также новую функцию сопоставления с образцом.

### Инструкции и блоки

Как вы, возможно, помните из главы 1 «Строительные блоки», оператор Java — это завершенная единица выполнения в Java, 
заканчивающаяся точкой с запятой (;). В этой главе мы познакомим вас с различными операторами потока управления Java. 
Операторы потока управления разбивают поток выполнения с помощью принятия решений, циклов и ветвлений, позволяя 
приложению выборочно выполнять определенные сегменты кода.

Эти операторы могут применяться как к отдельным выражениям, так и к блоку кода Java. Как описано в главе 1, блок кода в 
Java представляет собой группу из нуля или более операторов между сбалансированными фигурными скобками ({}) и может 
использоваться везде, где разрешен один оператор. Например, следующие два фрагмента эквивалентны: первый представляет 
собой отдельное выражение, а второй — блок, содержащий один и тот же оператор:

```
// Один оператор
patrons++;

// Оператор внутри блока
{
patrons++;
}
```

Оператор или блок часто служат целью заявления о принятии решения. Например, мы можем добавить оператор if для принятия 
решения к этим двум примерам:

```
// Один оператор
if(ticketsTaken > 1)
patrons++;

// Оператор внутри блока
if(ticketsTaken > 1)
{
patrons++;
}
```

Опять же, оба этих фрагмента кода эквивалентны. Просто помните, что целью заявления о принятии решения может быть одно 
заявление или блок заявлений. В остальной части главы мы используем обе формы, чтобы лучше подготовить вас к тому, что 
вы увидите на экзамене.

---

Хотя оба предыдущих примера эквивалентны, стилистически использование блоков часто предпочтительнее, даже если блок 
содержит только одно утверждение. Вторая форма имеет то преимущество, что вы можете быстро вставлять новые строки кода 
в блок, не изменяя окружающую структуру.

---

### Оператор if

Часто мы хотим выполнить блок только при определенных обстоятельствах. Оператор if, как показано на рисунке 3.1, 
выполняет это, позволяя нашему приложению выполнять определенный блок кода тогда и только тогда, когда логическое 
выражение принимает значение true во время выполнения.

#### Рис. 3.1 - Структура оператора if
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/chapter%202/image2/figure%202.1%20.JPG) 

Например, представьте, что у нас есть функция, которая использует час дня, целочисленное значение от 0 до 23, для 
отображения сообщения пользователю:

```
if(hourOfDay < 11)
    System.out.println("Good Morning");
```

Если время суток меньше 11, то будет выведено соответствующее сообщение. Теперь предположим, что мы также хотели 
увеличивать некоторое значение, morningGreetingCount, каждый раз, когда печатается приветствие. Мы могли бы написать 
оператор if дважды, но, к счастью, Java предлагает нам более естественный подход с использованием блока:

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
    morningGreetingCount++;
}
```

---
#### Следите за отступами и фигурными скобками

Одна из областей, в которой составители экзамена попытаются сбить вас с толку, — это операторы if без фигурных 
скобок ({}). Например, взгляните на эту слегка измененную форму нашего примера:

```
if(hourOfDay < 11)
    System.out.println("Good Morning");
    morningGreetingCount++;
```

Основываясь на отступе, вы можете быть склонны думать, что переменная morningGreetingCount будет увеличена только в том 
случае, если hourOfDay меньше 11, но это не то, что делает этот код. Он выполнит инструкцию печати только в том случае, 
если условие выполнено, но он всегда будет выполнять операцию увеличения.

Помните, что в Java, в отличие от некоторых других языков программирования, вкладки являются просто пробелами и не 
оцениваются как часть выполнения. Когда вы видите инструкцию потока управления в вопросе, обязательно проследите за 
открытыми и закрывающими фигурными скобками блока, игнорируя любые отступы, с которыми вы можете столкнуться.

---

### Оператор else

Давайте немного расширим наш пример. Что, если мы хотим отобразить другое сообщение, если сейчас 11 часов утра или 
позже? Можем ли мы сделать это, используя только те инструменты, которые у нас есть? Конечно, мы можем!

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
}
if(hourOfDay >= 11) {
    System.out.println("Good Afternoon");
}
```

Однако это кажется немного избыточным, поскольку мы дважды выполняем оценку в hourOfDay. К счастью, Java предлагает 
более полезный подход в виде оператора else, как показано на рис. 3.2.

#### Рис. 3.2 - Структура оператора else

Вернемся к этому примеру:

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
} else System.out.println("Good Afternoon");
```

Теперь наш код действительно разветвляется между одним из двух возможных вариантов, причем логическое вычисление 
выполняется только один раз. Оператор else принимает оператор или блок операторов таким же образом, как оператор if. 
Аналогично, мы можем добавить дополнительные операторы if к блоку else, чтобы получить более совершенный пример:

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
} else if(hourOfDay < 15) {
    System.out.println("Good Afternoon");
} else {
    System.out.println("Good Evening");
}
```

В этом примере процесс Java продолжит выполнение до тех пор, пока не встретит оператор if, значение которого равно 
true. Если ни одно из первых двух выражений не является истинным, будет выполнен последний код блока else.

---

#### Проверка того, что оператор if оценивается как логическое выражение

Другой распространенный способ, которым экзамен может попытаться ввести вас в заблуждение, - это предоставление кода, 
в котором логическое выражение внутри оператора if на самом деле не является логическим выражением. Например, 
взгляните на следующие строки кода:

```
int hourOfDay = 1;
if(hourOfDay) { // НЕ КОМПИЛИРУЕТСЯ
    ...
}
```

Это утверждение может быть допустимо в некоторых других языках программирования и написания сценариев, но не в Java, 
где 0 и 1 не считаются логическими значениями.

---

### Сокращение кода с помощью сопоставления с образцом

В Java 16 официально представлено сопоставление шаблонов с операторами if и оператором instanceof.
Сопоставление с образцом - это метод управления потоком программы, который выполняет только ту часть кода, которая 
соответствует определенным критериям. Он используется в сочетании с операторами if для большего контроля над программой.

_Если сопоставление с образцом для вас новое, будьте осторожны, чтобы не спутать его с классом Java Pattern или 
регулярными выражениями. Хотя сопоставление с образцом может включать использование 
регулярных выражений для фильтрации, это не связанные понятия._

Сопоставление с образцом — это новый доступный вам инструмент, позволяющий уменьшить количество шаблонов в вашем коде. 
Стандартный код — это код, который имеет тенденцию повторяться в одном и том же разделе кода снова и снова одним и 
тем же образом. Многие новые усовершенствования языка Java сосредоточены на сокращении шаблонного кода.

Чтобы понять, почему был добавлен этот инструмент, рассмотрим следующий код, который принимает экземпляр Number и 
сравнивает его со значением 5. Если вы еще не видели Number или Integer, вам просто нужно знать, что Integer 
наследуется от Number на данный момент. Вы часто увидите их в этой книге!

```
void compareIntegers(Number number) {
   if(number instanceof Integer) {
      Integer data = (Integer)number;
      System.out.print(data.compareTo(5));
   }
}
```

Приведение необходимо, так как метод compareTo() определен для Integer, но не для Number.

Код, который сначала проверяет, относится ли переменная к определенному типу, а затем немедленно приводит ее к этому 
типу, чрезвычайно распространен в мире Java. Это настолько распространено, что авторы Java решили реализовать для него 
более короткий синтаксис:

```
void compareIntegers(Number number) {
   if(number instanceof Integer data) {
      System.out.print(data.compareTo(5));
   }
}
```

Переменная data в этом примере называется переменной шаблона. Обратите внимание, что этот код также позволяет 
избежать любого потенциального исключения ClassCastException, поскольку операция приведения выполняется только в том 
случае, если неявный оператор instanceof возвращает true.

---
#### Переназначение переменных шаблона

Хотя это возможно, переназначать переменную шаблона - плохая практика, поскольку это может привести к двусмысленности 
в отношении того, что входит в область видимости, а что нет.

```
if(number instanceof Integer data) {
   data = 10;
}
```

Переназначение можно предотвратить с помощью модификатора final, но лучше вообще не переназначать переменную.

```
if(number instanceof final Integer data) {
   data = 10;  // НЕ КОМПИЛИРУЕТСЯ
}
```
---

### Переменные шаблона и выражения

Сопоставление с образцом включает выражения, которые можно использовать для фильтрации данных, например, в следующем 
примере:

```
void printIntegersGreaterThan5(Number number) {
   if(number instanceof Integer data && data.compareTo(5)>0)
      System.out.print(data);
}
```

Мы можем применить ряд фильтров или шаблонов, чтобы оператор if выполнялся только в определенных обстоятельствах. 
Обратите внимание, что мы используем переменную шаблона в выражении в той же строке, в которой она объявлена.

### Подтипы

Тип переменной шаблона должен быть подтипом переменной в левой части выражения. Он также не может быть одного типа. 
Однако этого правила не существует для традиционных выражений оператора instanceof. Рассмотрим следующие два варианта 
использования оператора instanceof:

```
Integer value = 123;
if(value instanceof Integer) {}
if(value instanceof Integer data) {} // НЕ КОМПИЛИРУЕТСЯ
```

В то время как вторая строка компилируется, последняя строка не компилируется, поскольку сопоставление шаблонов 
требует, чтобы тип переменной шаблона Integer был строгим подтипом Integer.

---
#### Ограничения применения подтипа

У компилятора есть некоторые ограничения на применение типов сопоставления с образцом, когда мы смешиваем классы и 
интерфейсы, что станет более понятным после того, как вы прочитаете главу 7 «Помимо классов». Например, учитывая 
неконечный класс Number и список интерфейсов, это компилируется, даже если они не связаны:

```
Number value = 123;
if(value instanceof List) {}
if(value instanceof List data) {}
```

### Анализ потока

Компилятор применяет определение области потока при работе с сопоставлением шаблонов. Определение области потока 
означает, что переменная находится в области видимости только тогда, когда компилятор может окончательно определить 
ее тип. Определение области потока отличается от любого другого типа определения области тем, что оно не является 
строго иерархическим, как определение экземпляра, класса или локальной области. Он определяется компилятором на 
основе ветвления и потока выполнения программы.

Учитывая эту информацию, можете ли вы понять, почему следующее не компилируется?

```
void printIntegersOrNumbersGreaterThan5(Number number) {
   if(number instanceof Integer data || data.compareTo(5)>0)
      System.out.print(data);
}
```

Если вход не наследует Integer, переменная data не определена. Поскольку компилятор не может гарантировать, что data 
являются экземпляром Integer, data не входит в область действия, и код не компилируется.

Как насчет этого примера?

```
void printIntegerTwice(Number number) {
  if (number instanceof Integer data)
     System.out.print(data.intValue());
  System.out.print(data.intValue()); // НЕ КОМПИЛИРУЕТСЯ
}
```

Поскольку входные данные могли не унаследоваться от Integer, данные больше не находятся в области видимости после 
оператора if. О, так вы могли подумать, что переменная шаблона находится в области видимости только внутри 
оператора if, верно? Ну, не совсем! Рассмотрим следующий пример, который компилируется:

```
void printOnlyIntegers(Number number) {
   if (!(number instanceof Integer data))
      return;
   System.out.print(data.intValue());
}
```

Вы можете удивиться, узнав, что этот код компилируется. Эй! Что здесь происходит? Метод возвращает значение, если ввод 
не наследует Integer. Это означает, что при достижении последней строки метода входные данные должны наследовать 
Integer, и поэтому данные остаются в области действия даже после завершения оператора if.

---
#### Определение области действия потока и другие ветви

Если последний пример кода вас смущает, не беспокойтесь: вы не одиноки! Другой способ подумать об этом — переписать 
логику на что-то эквивалентное, использующее оператор else:

```
void printOnlyIntegers(Number number) {
   if (!(number instanceof Integer data))
      return;
   else
      System.out.print(data.intValue());
 }
```

Теперь мы можем сделать еще один шаг и поменять местами ветви if и else, инвертировав логическое выражение:

```
void printOnlyIntegers(Number number) {
   if (number instanceof Integer data)
      System.out.print(data.intValue());
   else
      return;
 }
```

Наш новый код эквивалентен нашему исходному и лучше демонстрирует, как компилятор смог определить, что data находится 
в области видимости, только когда number является целым числом.

---

Убедитесь, что вы понимаете, как работает обзор потока. В частности, можно использовать переменную шаблона вне 
оператора if, но только тогда, когда компилятор может окончательно определить ее тип.

## Применение операторов switch

Что, если у нас есть много возможных ветвей или путей для одного значения? Например, мы могли бы захотеть напечатать
разные сообщения в зависимости от дня недели. Мы, конечно, могли бы достичь этого с помощью комбинации из семи 
операторов if или else, но это приводит к созданию длинного кода, который трудно читать и часто неинтересен в 
обслуживании:

```
public void printDayOfWeek(int day) {
    if(day == 0)
       System.out.print("Sunday");
    else if(day == 1)
       System.out.print("Monday");
    else if(day == 2)
       System.out.print("Tuesday");
    else if(day == 3)
       System.out.print("Wednesday");
    ...
}
```

К счастью, Java, наряду со многими другими языками, обеспечивает более чистый подход. В этом разделе мы представляем 
оператор switch вместе с более новым выражением switch для управления потоком программы.

### Оператор switch

Оператор switch, как показано на рис. 3.3, представляет собой сложную структуру принятия решений, в которой вычисляется 
одно значение и поток перенаправляется в первую соответствующую ветвь, известную как оператор case. Если не найдено 
такого оператора case, который соответствовал бы значению, будет вызван необязательный оператор default. Если такой 
параметр по умолчанию недоступен, вся инструкция switch будет пропущена. Обратите внимание на рис. 3.3, что значения 
регистра могут быть объединены в один оператор регистра с помощью запятых.

#### Рис. 3.3 - Структура оператора switch

Поскольку инструкции switch могут быть длиннее, чем большинство инструкций для принятия решений, на экзамене может быть 
представлен недопустимый синтаксис switch, чтобы проверить, обращаете ли вы внимание.

---

#### Объединение значений case

Заметили что-то новое на рисунке 3.3? Начиная с Java 14, значения регистра теперь можно комбинировать:

```
switch(animal) {
   case 1,2: System.out.print("Lion");
   case 3: System.out.print("Tiger");
}
```

До Java 14 эквивалентный код был бы следующим:

```
switch(animal) {
   case 1: case 2: System.out.print("Lion");
   case 3: System.out.print("Tiger");
}
```

Как вы вскоре увидите, выражения switch могут еще больше сократить количество шаблонного кода!

---

Посмотрите, сможете ли вы выяснить, почему каждый из следующих операторов switch не компилируется:

```
int month = 5;

switch month {   // НЕ КОМПИЛИРУЕТСЯ
   case 1: System.out.print("January");
}

switch(month)   // НЕ КОМПИЛИРУЕТСЯ
   case 1: System.out.print("January");
   
switch(month) {
   case 1: 2: System.out.print("January"); // НЕ КОМПИЛИРУЕТСЯ
}
```

Первый оператор switch не компилируется, поскольку в нем отсутствуют круглые скобки вокруг переменной switch. 
Вторая инструкция не компилируется, потому что в ней отсутствуют фигурные скобки вокруг тела переключателя. 
Третий оператор не компилируется, потому что для разделения операторов комбинированного регистра следует использовать 
запятую (,), а не двоеточие (:).

Последнее замечание, о котором вам следует знать на экзамене: оператор switch не обязательно должен содержать 
какие-либо операторы case. Например, это утверждение совершенно справедливо:

```
switch(month) {}
```

Возвращаясь к нашему методу printDayOfWeek(), мы можем переписать его, чтобы использовать оператор switch вместо 
операторов if/else:

```
public void printDayOfWeek(int day) {
   switch(day) {
      case 0:
         System.out.print("Sunday");
         break;
      case 1:
         System.out.print("Monday");
         break;
      case 2:
         System.out.print("Tuesday");
         break;
      case 3:
         System.out.print("Wednesday");
         break;
      case 4:
         System.out.print("Thursday");
         break;
      case 5:
         System.out.print("Friday");
         break;
      case 6:
         System.out.print("Saturday");
         break;
      default:
         System.out.print("Invalid value");
         break;
 } }
```

Для простоты мы просто печатаем сообщение, если значение недопустимо. Если вы знаете об исключениях или уже прочитали 
главу 11 “Исключения и локализация”, возможно, имеет смысл создать исключение в ветке по умолчанию, если совпадение 
не найдено.

### Выход с операторами break

Взглянув на нашу предыдущую реализацию printDayOfWeek(), вы увидите оператор break в конце каждого раздела case и 
default. Оператор break завершает оператор switch и возвращает управление потоком окружающему процессу. Проще говоря, 
он немедленно завершает оператор switch.

Операторы break необязательны, но без них код будет выполнять каждую ветвь, следующую за соответствующим оператором 
case, включая все найденные операторы по умолчанию. Без операторов break в каждой ветви порядок операторов 
case и default теперь чрезвычайно важен. Как вы думаете, что будет напечатано при вызове printSeason(2)?

```
public void printSeason(int month) {
   switch(month) {
      case 1, 2, 3: System.out.print("Winter");
      case 4, 5, 6: System.out.print("Spring");
      default: System.out.print("Unknown");
      case 7, 8, 9: System.out.print("Summer");
      case 10, 11, 12: System.out.print("Fall");
} }
```

Он печатает все!

```
WinterSpringUnknownSummerFall
```

Он соответствует первому оператору case и выполняет все ветви в том порядке, в котором они найдены, включая оператор 
по умолчанию. Обычно, хотя, конечно, и не обязательно, использовать оператор break после каждого оператора case.

---

_Создателям экзамена нравятся примеры переключения, в которых отсутствуют операторы break! При оценке операторов switch 
на экзамене всегда учитывайте, что за одно выполнение можно посетить несколько ветвей._

---

### Выбор типов данных переключателя

Как показано на рисунке 3.3, оператор switch имеет целевую переменную, которая не вычисляется до выполнения. Тип этого 
целевого объекта может включать выбранные примитивные типы данных (int, byte, short, char) и связанные с ними 
классы-оболочки (Integer, Byte, Short, Character). Ниже приведен список всех типов данных, поддерживаемых операторами 
switch:

+ int и Integer
+ byte и Byte
+ short и Short
+ char и Character
+ String
+ enum values
+ var (если тип преобразуется в один из предыдущих типов)

Для этой главы вам просто нужно знать, что перечисление, или enum, представляет собой фиксированный набор констант, 
таких как дни недели, месяцы года и так далее. Мы рассмотрим перечисления более подробно в главе 7, включая 
демонстрацию того, как они могут определять переменные, методы и конструкторы.

---

_Обратите внимание, что boolean, long, float и double исключены из операторов switch, как и связанные с ними классы 
Boolean, Long, Float и Double. Причины разнообразны, например, boolean значение, имеющее слишком малый диапазон 
значений, и числа с плавающей запятой, имеющие довольно широкий диапазон значений. Однако для экзамена вам просто нужно 
знать, что они не разрешены в операторах switch._

---

### Определение допустимых значений регистра

В операторе case можно использовать не любую переменную или значение. Во-первых, значения в каждом операторе case 
должны быть постоянными значениями времени компиляции того же типа данных, что и значение переключателя. Это означает, 
что вы можете использовать только литералы, константы перечисления или окончательные постоянные переменные одного и 
того же типа данных. Под финальной константой мы подразумеваем, что переменная должна быть помечена модификатором final 
и инициализирована литеральным значением в том же выражении, в котором она объявлена. Например, у вас не может быть 
значения оператора case, требующего выполнения метода во время выполнения, даже если этот метод всегда возвращает одно 
и то же значение. По этим причинам компилируются только первый и последний операторы case в следующем примере:

```
final int getCookies() { return 4; }
void feedAnimals() {
   final int bananas = 1;
   int apples = 2;
   int numberOfAnimals = 3;
   final int cookies = getCookies();
   switch(numberOfAnimals) {
      case bananas:
      case apples:        // НЕ КОМПИЛИРУЕТСЯ
      case getCookies():  // НЕ КОМПИЛИРУЕТСЯ
      case cookies :      // НЕ КОМПИЛИРУЕТСЯ
      case 3 * 5 :
} }
```

Переменная bananas помечена как final, и ее значение известно во время компиляции, поэтому оно допустимо. 
Переменная apples не помечена как final, даже если ее значение известно, поэтому она не разрешена. Следующие два 
оператора case со значениями getCookies() и cookies не компилируются, поскольку методы не вычисляются до выполнения, 
поэтому их нельзя использовать в качестве значения оператора case, даже если одно из значений хранится в конечной 
переменной. Последний оператор case со значением 3 * 5 действительно компилируется, поскольку выражения разрешены в 
качестве значений регистра, при условии, что значение может быть разрешено во время компиляции. Они также должны быть в 
состоянии вписаться в тип данных switch без явного приведения. Вскоре мы рассмотрим это более подробно.

Далее, тип данных для операторов case должен совпадать с типом данных переменной-переключателя. Например, у вас не 
может быть оператора case типа String, если переменная оператора switch имеет тип int, поскольку эти типы несравнимы.

### Выражение оператора switch

Наша вторая реализация printDayOfWeek() была улучшена, но все еще довольно длинная. Обратите внимание, что там было 
много шаблонного кода, а также многочисленные инструкции break. Можем ли мы сделать лучше? Да, благодаря новым 
выражениям switch, которые были официально добавлены в Java 14.

Выражение switch — это гораздо более компактная форма оператора switch, способная возвращать значение. 
Взгляните на новый синтаксис на рис. 3.4.

Поскольку выражение switch представляет собой компактную форму, на рис. 3.4 происходит многое! Во-первых, теперь мы 
можем присвоить результат выражения переключения переменной result. Чтобы это работало, все ветви case и default должны 
возвращать тип данных, совместимый с назначением. Выражение switch поддерживает два типа ветвей: выражение и блок. 
Каждый из них имеет различные синтаксические правила о том, как он должен быть создан. Подробнее об этих темах в 
ближайшее время.

#### Рис. 3.4 - Структура выражения переключения

Подобно традиционному оператору switch, выражение switch поддерживает ноль или множество ветвей case и необязательную 
ветвь по умолчанию. Оба также поддерживают новую функцию, позволяющую объединять значения case с одним оператором case 
с помощью запятых. Однако, в отличие от традиционного оператора switch, выражения switch имеют специальные правила, 
когда требуется ветвь по умолчанию.

---

_Напомним из главы 2, “Операторы”, что -> - это оператор стрелки. Хотя оператор стрелки обычно используется в 
лямбда-выражениях, когда он используется в выражении switch, ветви регистра не являются лямбдами._

---

Мы можем переписать наш предыдущий метод printDayOfWeek() гораздо более лаконичным образом, используя выражения case:

```
public void printDayOfWeek(int day) {
   var result = switch(day) {
      case 0 -> "Sunday";
      case 1 -> "Monday";
      case 2 -> "Tuesday";
      case 3 -> "Wednesday";
      case 4 -> "Thursday";
      case 5 -> "Friday";
      case 6 -> "Saturday";
      default -> "Invalid value";
   };
   System.out.print(result);
}
```

Сравните этот код с оператором switch, который мы написали ранее. Оба выполняют одну и ту же задачу, но большая часть 
шаблонного кода была удалена, оставив то поведение, которое нас больше всего волнует.

Обратите внимание, что после каждого выражения switch требуется точка с запятой. Например, следующий код не 
компилируется. Сколько точек с запятой не хватает?

```
var result = switch(bear) {
   case 30 -> "Grizzly"
   default -> "Panda"
}
```

Ответ - три. Для каждого case или default требуется точка с запятой, а также само присвоение. 
Следующее исправляет код:

```
var result = switch(bear) {
   case 30 -> "Grizzly";
   default -> "Panda";
};
```

Как показано на рисунке 3.4, операторы case могут принимать несколько значений, разделенных запятыми.
Давайте перепишем наш метод printSeason() из предыдущего, используя выражение switch:

```
public void printSeason(int month) {
   switch(month) {
      case 1, 2, 3 -> System.out.print("Winter");
      case 4, 5, 6 -> System.out.print("Spring");
      case 7, 8, 9 -> System.out.print("Summer");
      case 10, 11, 12 -> System.out.print("Fall");
} }
```

Вызов printSeason(2) выводит единственное значение Winter. На этот раз нам не нужно беспокоиться об операторах break, 
так как выполняется только одна ветвь.

---

_В большинстве случаев выражение switch возвращает значение, хотя метод printSeason() демонстрирует значение, в котором 
возвращаемый тип является void. Поскольку тип является void, он не может быть присвоен переменной. На экзамене вы, 
скорее всего, увидите выражение switch, которое возвращает значение, но вы должны знать, что это возможно._

---

Все предыдущие правила, касающиеся switch типов данных и значений case, по-прежнему применяются, хотя у нас есть 
несколько новых правил. Не волнуйтесь, если эти правила для вас новы или вы никогда раньше не встречали ключевое 
слово yield; мы обсудим их в следующих разделах.

1. Все ветви выражения switch, которые не генерируют исключение, должны возвращать согласованный тип данных 
(если выражение switch возвращает значение).
2. Если выражение switch возвращает значение, то каждая ветвь, которая не является выражением, должна выдавать значение.
3. Ветвь default требуется, если не охвачены все случаи или не возвращается значение.

Мы кратко рассмотрим последнее правило, но обратите внимание, что наш пример printSeason() не содержит ветки default. 
Поскольку выражение switch не возвращает значение и не присваивает его переменной, оно совершенно необязательно.

---

_Java 17 также поддерживает сопоставление шаблонов в выражениях switch, но поскольку это функция предварительного 
просмотра, она не рассматривается в рамках экзамена._

---

### Возврат совместимых типов данных

Первое правило использования выражения switch, вероятно, самое простое. Вы не можете возвращать несовместимые или 
случайные типы данных. Например, можете ли вы понять, почему три строки следующего кода не компилируются?

```
int measurement = 10;
int size = switch (measurement) {
   case 5 -> 1;
   case 10 -> (short) 2;
   default -> 5;
   case 20 -> "3";   // НЕ КОМПИЛИРУЕТСЯ
   case 40 -> 4L;    // НЕ КОМПИЛИРУЕТСЯ
   case 50 -> null;  // НЕ КОМПИЛИРУЕТСЯ
};
```

Обратите внимание, что второе case-выражение возвращает short, но его можно неявно привести к типу int. 
Таким образом, значения должны соответствовать size, но не обязательно все они должны быть одного типа данных. 
Последние три case-выражения не компилируются, поскольку каждое из них возвращает тип, который нельзя присвоить 
переменной int.

### Применение блока case

Выражение switch поддерживает как выражение, так и блок в ветвях case и default. Как и обычный блок, 
case блок - это блок, заключенный в фигурные скобки ({}). Он также включает в себя оператор yield, если выражение 
switch возвращает значение. Например, в приведенном ниже примере используется сочетание case выражений и блоков:

```
int fish = 5;
int length = 12;
var name = switch (fish) {
   case 1 -> "Goldfish";
   case 2 -> {yield "Trout";}
   case 3 -> {
      if (length > 10) yield "Blobfish";
      else yield "Green";
   }
   default -> "Swordfish";
};
```

Ключевое слово yield эквивалентно оператору return в выражении switch и используется, чтобы избежать двусмысленности в 
отношении того, имели ли вы в виду выход из блока или метода вокруг выражения switch.

Ссылаясь на наше второе правило для выражений switch, операторы yield являются обязательными, если оператор 
switch возвращает значение. Можете ли вы понять, почему следующие строки не компилируются?

```
10: int fish = 5;
11: int length = 12;
12: var name = switch (fish) {
13:    case 1 -> "Goldfish";
14:    case 2 -> {} // НЕ КОМПИЛИРУЕТСЯ
15:    case 3 -> {
16:       if (length > 10) yield "Blobfish";
17:    }  // НЕ КОМПИЛИРУЕТСЯ
18:    default -> "Swordfish";
19: };
```

Строка 14 не компилируется, так как не возвращает значение с помощью yield. Строка 17 тоже не компилируется. 
Хотя код возвращает значение для length больше 10, он не возвращает значение, если length меньше или равна 10. 
Не имеет значения, что length установлена равной 12; все ветви должны возвращать значение в блоке case.

---

#### Следите за точками с запятой в выражениях switch

В отличие от обычного оператора switch, выражение switch может использоваться с оператором присваивания, и при этом 
требуется точка с запятой. Кроме того, точки с запятой обязательны для выражений регистра, но не могут использоваться 
с блоками регистра.

```
var name = switch (fish) {
   case 1 -> "Goldfish" // НЕ КОМПИЛИРУЕТСЯ (отсутствует точка с запятой)
   case 2 -> {yield "Trout";}; // НЕ КОМПИЛИРУЕТСЯ (лишняя точка с запятой)
   ...
} // НЕ КОМПИЛИРУЕТСЯ (отсутствует точка с запятой)
```

Немного запутанно, правда? Это всего лишь одна из тех вещей, которые вы должны приучить себя замечать на экзамене.

---

### Покрытие всех возможных значений

Последнее правило, касающееся выражений переключения, вероятно, является тем, на котором экзамен, скорее всего, 
попытается вас обмануть: выражение переключения, возвращающее значение, должно обрабатывать все возможные входные 
значения. И, как вы видели ранее, когда он не возвращает значение, это необязательно.

Давайте попробуем это сделать. Учитывая следующий код, каково значение type, если canis равно 5?

```
String type = switch (canis) { // НЕ КОМПИЛИРУЕТСЯ
   case 1 -> "dog";
   case 2 -> "wolf";
   case 3 -> "coyote";
};
```

Нет ветки case для 5 (или 4, -1, 0 и т. д.), поэтому должно ли выражение switch возвращать null, пустую строку, 
undefined или какое-то другое значение? При добавлении выражений switch в язык Java авторы решили, что такое 
поведение не будет поддерживаться. Каждое выражение switch должно обрабатывать все возможные значения переменной 
switch. У разработчика есть два способа решить эту проблему:

+ Добавить ветку default.
+ Если выражение switch принимает значение enum, добавьте ветвь case для каждого возможного значения enum.

На практике чаще всего используется первое решение. Второе решение применимо только к выражениям switch, которые 
принимают перечисление. Вы можете попробовать написать операторы case для всех возможных значений int, но мы обещаем, 
что это не сработает! Даже меньшие типы, такие как byte, не разрешены компилятором, несмотря на то, что существует 
только 256 возможных значений.

Для перечислений второе решение хорошо работает, когда число значений перечисления относительно невелико. Например, 
рассмотрим следующее определение перечисления и метод:

```
enum Season {WINTER, SPRING, SUMMER, FALL}

String getWeather(Season value) {
   return switch (value) {
      case WINTER -> "Cold";
      case SPRING -> "Rainy";
      case SUMMER -> "Hot";
      case FALL -> "Warm";
   };
}
```

Поскольку охватываются все возможные перестановки Season, в этом выражении switch не требуется ветвь default. 
Однако вы можете включить необязательную ветвь default, даже если вы охватываете все известные значения.

---

Что произойдет, если вы используете перечисление с тремя значениями, а позже кто-то добавит четвертое значение? Любые 
выражения switch, использующие перечисление без ветви по умолчанию, внезапно не смогут скомпилироваться. Если бы это 
делалось часто, вам, возможно, пришлось бы исправлять много кода! По этой причине рассмотрите возможность включения 
ветви по умолчанию в каждое выражение switch, даже в те, которые включают значения enum.

---

## Написание цикла while

Обычной практикой при написании программного обеспечения является выполнение одной и той же задачи несколько раз.
Вы можете использовать структуры решений, которые мы представили до сих пор, чтобы добиться этого, но это будет 
довольно длинная цепочка операторов if или else, особенно если вам нужно выполнить одно и то же 100 или более раз.

Вводите циклы! Цикл - это повторяющаяся структура управления, которая может выполнять инструкцию кода несколько раз 
подряд. При использовании переменных, которым могут быть присвоены новые значения, каждое повторение инструкции может 
отличаться. Следующий цикл выполняется ровно 10 раз:

```
int counter = 0;
while (counter < 10) {
   double price = counter * 10;
   System.out.println(price);
   counter++;
}
```

Если вы не следуете этому коду, не паникуйте — мы скоро расскажем об этом. В этом разделе мы обсудим цикл while и две 
его формы. В следующем разделе мы перейдем к циклам for, корнями которых являются циклы while.

### Оператор while

Простейшей повторяющейся структурой управления в Java является оператор while, описанный на рис. 3.5. Как и все 
структуры управления повторением, он имеет условие завершения, реализованное в виде логического выражения, которое 
будет продолжаться до тех пор, пока выражение принимает значение true.

#### Рис. 3.5 - Структура оператора while

Как показано на рис. 3.5, цикл while похож на оператор if в том смысле, что он состоит из логического выражения и 
оператора или блока операторов. Во время выполнения логическое выражение 
оценивается перед каждой итерацией цикла и завершается, если оценка возвращает false.

Давайте посмотрим, как можно использовать цикл для моделирования мыши, которая ест:

```
int roomInBelly = 5;
public void eatCheese(int bitesOfCheese) {
   while (bitesOfCheese > 0 && roomInBelly > 0) {
      bitesOfCheese--;
      roomInBelly--;
   }
   System.out.println(bitesOfCheese+" pieces of cheese left");
}
```

Этот метод требует некоторого количества пищи — в данном случае сыра — и продолжается до тех пор, пока у мыши не 
останется места в животе или не останется еды. С каждой итерацией цикла мышь «съедает» один кусочек пищи и теряет одно 
место в животе. Используя составной логический оператор, вы гарантируете, что цикл while может завершиться для любого 
из условий.

Следует помнить, что цикл while может завершиться после первого вычисления логического выражения. Например, 
сколько раз Not null! напечатано в следующем примере?

```
int full = 5;
while (full < 5) {
   System.out.println("Not full!");
   full++;
}
```

Ответ? Нуль! На первой итерации цикла условие достигается и цикл завершается. Вот почему циклы while часто используются 
там, где вы ожидаете ноль или более циклов. Проще говоря, тело цикла может вообще не выполняться или выполняться много 
раз.

### Оператор do/while 

Вторая форма, которую может принимать цикл while, называется циклом do/while, который, как и цикл while, представляет 
собой структуру управления повторением с условием завершения и оператором или блоком операторов, как показано 
на рис. 3.6.

#### Рис. 3.6 - Структура оператора do/while

Однако, в отличие от цикла while, цикл do/while гарантирует, что оператор или блок будут выполнены хотя бы один раз. 
Например, каков результат следующих утверждений?

```
int lizard = 0;
do {
    lizard++;
} while(false);
System.out.println(lizard); // 1
```

Java сначала выполнит блок операторов, а затем проверит условие цикла. Несмотря на то, что цикл завершается сразу же, 
блок операторов все равно выполняется один раз, и программа выводит 1.

### Бесконечные циклы

Самая важная вещь, о которой вы должны знать, когда используете любые структуры управления повторением, это убедиться, 
что они всегда заканчиваются! Невыполнение цикла может привести к многочисленным проблемам на практике, включая 
исключения переполнения, утечки памяти, низкую производительность и даже неверные данные. Давайте посмотрим на пример:

```
int pen = 2;
int pigs = 5;
while (pen < 10)
   pigs++;
```

Вы можете заметить одну вопиющую проблему с этим утверждением: это никогда не закончится. Переменная pen никогда не 
изменяется, поэтому выражение (pen < 10) всегда будет иметь значение true. В результате цикл никогда не закончится, 
создавая то, что обычно называют бесконечным циклом. Бесконечный цикл - это цикл, условие завершения которого никогда 
не достигается во время выполнения.

Каждый раз, когда вы пишете цикл, вы должны проверять его, чтобы определить, всегда ли условие завершения в конечном 
итоге выполняется при каком-либо условии. Например, цикл, в котором никакие переменные не изменяются между двумя 
исполнениями, предполагает, что условие завершения может не выполняться. Переменные цикла всегда должны двигаться в 
определенном направлении.

Другими словами, убедитесь, что условие цикла или переменные, от которых зависит условие, меняются между выполнением. 
Затем убедитесь, что условие прекращения будет в конечном итоге достигнуто при любых обстоятельствах. Как вы узнаете из 
последнего раздела этой главы, цикл может существовать и при других условиях, таких как оператор break.

## Построение циклов for

Несмотря на то, что операторы while и do/while довольно мощные, некоторые задачи настолько распространены при написании 
программного обеспечения, что были созданы специальные типы циклов — например, повторение инструкции ровно 10 раз или 
перебор списка имен. Вы могли бы легко выполнить эти задачи с помощью различных циклов while, которые вы видели до сих 
пор, но они обычно требуют большого количества шаблонного кода. Разве не было бы здорово, если бы существовала 
циклическая структура, которая могла бы делать то же самое в одной строке кода?

При этом мы представляем наиболее удобную структуру управления повторением для циклов. Существует два типа циклов for, 
хотя оба используют одно и то же ключевое слово for. Первый называется базовым циклом for, а второй часто называют 
расширенным циклом for. Для ясности мы называем их циклом for и циклом for-each соответственно на протяжении всей книги.

### Цикл for

Базовый цикл for имеет то же условное логическое выражение и оператор или блок операторов, что и циклы while, а также 
два новых раздела: блок инициализации и оператор обновления. На рис. 3.7 показано, как расположены эти компоненты.

Хотя на первый взгляд рисунок 3.7 может показаться немного запутанным и почти произвольным, организация компонентов и 
потока позволяет нам создавать чрезвычайно мощные операторы в одной строке, которые в противном случае заняли бы 
несколько строк с циклом while. Каждый из трех разделов отделяется точкой с запятой. Кроме того, разделы инициализации 
и обновления могут содержать несколько операторов, разделенных запятыми.

Переменные, объявленные в блоке инициализации цикла for, имеют ограниченную область действия и доступны только внутри 
цикла for. Будьте осторожны с любыми экзаменационными вопросами, в которых переменная объявляется в блоке инициализации 
цикла for, а затем считывается вне цикла. Например, этот код не компилируется, потому что ссылка на переменную цикла i 
находится вне цикла:

#### Рис. 3.7 - Структура базового цикла for


```
for (int i = 0; i < 10; i++)
  System.out.println("Value is: " + i);
System.out.println(i); // НЕ КОМПИЛИРУЕТСЯ
```

В качестве альтернативы, переменные, объявленные перед циклом for и которым присвоено значение в блоке инициализации, могут 
использоваться вне цикла for, поскольку их область действия предшествует созданию цикла for.

```
int i;
for (i = 0; i < 10; i++)
 System.out.println("Value is: " + i);
System.out.println(i);
```

Давайте посмотрим на пример, который выводит первые пять чисел, начиная с нуля:

```
for (int i = 0; i < 5; i++) {
 System.out.print(i + " ");
}
```

Локальная переменная i сначала инициализируется значением 0. Переменная i находится в области видимости только на время 
цикла и недоступна вне цикла после его завершения. Подобно циклу while, логическое условие оценивается на каждой 
итерации цикла перед его выполнением. Поскольку он возвращает true, цикл выполняется и выводит 0, за которым следует 
пробел. Затем цикл выполняет раздел обновления, который в данном случае увеличивает значение i до 1. Затем цикл 
оценивает логическое выражение во второй раз, и процесс повторяется несколько раз, выводя следующее:

```
0 1 2 3 4
```

На пятой итерации цикла значение i достигает 4 и увеличивается на 1, чтобы достичь 5. На шестой итерации цикла 
вычисляется логическое выражение, и поскольку (5 < 5) возвращает false, цикл завершается без выполнения тела цикла 
операторов.

---

### _Сценарий реального мира_

#### Почему i в цикле for?

Вы можете заметить, что обычной практикой является присвоение переменной цикла for имени i. Задолго до появления Java 
программисты начали использовать i как сокращение от переменной инкремента, и эта практика существует сегодня, хотя 
многие из этих языков программирования больше этого не делают! Для двойных или тройных циклов, где i уже используется, 
часто используются следующие буквы в алфавите, j и k.

---

### Печать элементов в обратном порядке

Допустим, вы хотите вывести те же первые пять чисел от нуля, что и в предыдущем разделе, но на этот раз в обратном 
порядке. Тогда цель состоит в том, чтобы напечатать 4 3 2 1 0.

Как бы вы это сделали? Первоначальная реализация может выглядеть следующим образом:

```
for (var counter = 5; counter > 0; counter--) {
   System.out.print(counter + " ");
}
```

Хотя этот фрагмент действительно выводит пять различных значений и напоминает наш первый пример цикла for, он не 
выводит те же пять значений. Вместо этого это результат:

```
5 4 3 2 1
```

Подождите, это не то, что мы хотели! Мы хотели 4 3 2 1 0. Он начинается с 5, потому что это первое присвоенное ему 
значение. Давайте исправим это, начав с 4:

```
for (var counter = 4; counter > 0; counter--) {
 System.out.print(counter + " ");
}
```

Что теперь печатает? Он печатает следующее:

```
4 3 2 1
```

Так близко! Проблема в том, что он заканчивается на 1, а не на 0, потому что мы сказали ему завершить работу, как 
только значение не будет строго больше 0. Если мы хотим напечатать те же значения от 0 до 4, что и в нашем первом 
примере, нам нужно обновить условие завершения, например:

```
for (var counter = 4; counter >= 0; counter--) {
   System.out.print(counter + " ");
}
```

Наконец-то! У нас есть код, который теперь выводит 4 3 2 1 0 и соответствует обратному примеру цикла for из предыдущего 
раздела. Вместо этого мы могли бы использовать counter > -1 в качестве условия завершения цикла в этом примере, хотя 
counter >= 0 имеет тенденцию быть более читаемым.

---

_Для экзамена вам нужно знать, как читать циклы вперед и назад. Когда вы увидите на экзамене цикл for, обратите особое 
внимание на переменную цикла и операции, если используется оператор декремента --. В то время как увеличение от 0 в 
цикле for часто бывает простым, уменьшение имеет тенденцию быть менее интуитивным. На самом деле, если вы видите на 
экзамене цикл for с оператором декремента, вы должны предположить, что они пытаются проверить ваши знания операций с 
циклами._

---

### Работа с циклами for

Хотя большинство циклов for, с которыми вы, вероятно, столкнетесь в своем профессиональном опыте разработки, будут 
четко определены и аналогичны предыдущим примерам, существует ряд вариантов и пограничных случаев, которые вы можете 
увидеть на экзамене. Вам следует ознакомиться со следующими пятью примерами; варианты их, вероятно, будут замечены на 
экзамене.

Давайте рассмотрим несколько примеров в иллюстративных целях:

1. Создание бесконечного цикла (Creating an Infinite Loop)

```
for ( ; ; )
 System.out.println("Hello World");
```

Хотя этот цикл for может выглядеть так, как будто он не компилируется, на самом деле он будет компилироваться и 
выполняться без проблем. На самом деле это бесконечный цикл, который будет печатать одно и то же утверждение повторно. 
Этот пример подтверждает тот факт, что каждый компонент цикла for является необязательным. Обратите внимание, что точки 
с запятой, разделяющие три раздела, обязательны, так как for( ) без каких-либо точек с запятой не будет компилироваться.

2. Добавление нескольких терминов в оператор for (Adding Multiple Terms to the for Statement)

```
int x = 0;
for (long y = 0, z = 4; x < 5 && y < 10; x++, y++) {
 System.out.print(y + " "); }
System.out.print(x + " ");
```

Этот код демонстрирует три варианта цикла for, которые вы, возможно, не видели. Во-первых, вы можете объявить 
переменную, такую как x в этом примере, до начала цикла и использовать ее после его завершения. Во-вторых, ваш блок 
инициализации, логическое выражение и операторы обновления могут включать в себя дополнительные переменные, которые 
могут ссылаться или не ссылаться друг на друга. Например, z определяется в блоке инициализации и никогда не 
используется. Наконец, оператор обновления может изменять несколько переменных. Этот код напечатает следующее при 
выполнении:

```
0 1 2 3 4 5
```

3. Повторное объявление переменной в блоке инициализации (Redeclaring a Variable in the Initialization Block)

```
int x = 0;
for (int x = 4; x < 5; x++) // DOES NOT COMPILE
 System.out.print(x + " ");
```

Этот пример похож на предыдущий, но не компилируется из-за блока инициализации. Разница в том, что x повторяется в 
блоке инициализации после того, как уже было объявлено перед циклом, что приводит к остановке компилятора из-за 
двойного объявления переменной. Мы можем исправить этот цикл, удалив объявление x из цикла for следующим образом:

```
int x = 0;
for (x = 0; x < 5; x++)
 System.out.print(x + " ");
```

Обратите внимание, что этот вариант теперь будет компилироваться, потому что блок инициализации просто присваивает 
значение x и не объявляет его.

4. Использование несовместимых типов данных в блоке инициализации (Using Incompatible Data Types in the Initialization 
Block)

```
int x = 0;
for (long y = 0, int z = 4; x < 5; x++) // DOES NOT COMPILE
 System.out.print(y + " ");
```

Как и в третьем примере, этот код не скомпилируется, хотя на этот раз по другой причине. Все переменные в блоке 
инициализации должны быть одного типа. В примере с несколькими терминами y и z были длинными, поэтому код 
скомпилировался без проблем; но в этом примере они имеют разные типы, поэтому код не скомпилируется.

5. Использование переменных цикла вне цикла (Using Loop Variables Outside the Loop)

```
for (long y = 0, x = 4; x < 5 && y < 10; x++, y++)
 System.out.print(y + " ");
System.out.print(x); // DOES NOT COMPILE
```

Мы уже говорили об этом в начале этого раздела, но это настолько важно для сдачи экзамена, что мы снова обсудим это 
здесь. Если вы заметили, x определяется в блоке инициализации цикла и затем используется после завершения цикла. 
Поскольку область x была ограничена только циклом, использование его вне цикла вызовет ошибку компилятора.

---

#### Изменение переменных цикла (Modifying Loop Variables)

Как правило, считается плохой практикой кодирования изменять переменные цикла из-за непредсказуемости результата, 
например, в следующих примерах:

```
for (int i = 0; i < 10; i++)
 i = 0;
 
for (int j = 1; j < 10; j++)
 j++;
```

Это также делает код трудным для понимания другими людьми.

---

### Цикл for-each

Цикл for-each представляет собой специализированную структуру, предназначенную для перебора массивов и различных 
классов Collections Framework, как показано на рис. 3.8.

#### Рис. 3.8 - Структура расширенного цикла for-each

Объявление цикла for-each состоит из раздела инициализации и объекта, по которому нужно выполнить итерацию. Правая 
сторона цикла for-each должна быть одной из следующих:

+ Встроенный массив Java
+ Объект, тип которого реализует java.lang.Iterable

Мы рассмотрим, что означает implements в главе 7, но сейчас вам просто нужно знать, что правая сторона должна быть 
массивом или коллекцией элементов, таких как List или Set. Для экзамена вы должны знать, что сюда входят не все 
классы или интерфейсы Collections Framework, а только те, которые реализуют или расширяют этот интерфейс Collection. 
Например, Map не поддерживается в цикле for-each, хотя Map включает методы, возвращающие экземпляры Collection.

Левая часть цикла for-each должна включать объявление экземпляра переменной, тип которой совместим с типом массива или 
коллекции в правой части инструкции. На каждой итерации цикла именованной переменной в левой части инструкции 
присваивается новое значение из массива или коллекции в правой части инструкции.

Сравните эти два метода, которые печатают значения массива, один из которых использует традиционный цикл for, а 
другой — цикл for-each:

```
public void printNames(String[] names) {
   for (int counter = 0; counter < names.length; counter++)
       System.out.println(names[counter]);
}

public void printNames(String[] names) {
   for (var name : names)
       System.out.println(names);
}
```

Цикл for-each намного короче, не так ли? У нас больше нет переменной цикла счетчика, которую нам нужно создавать, 
увеличивать и отслеживать. Подобно использованию цикла for вместо цикла while, циклы for-each предназначены для 
сокращения шаблонного кода, облегчая чтение / запись кода и позволяя вам сосредоточиться на тех частях вашего кода, 
которые действительно важны.

Мы также можем использовать цикл for-each в List, так как он реализует Iterable.

```
public void printNames(List<String> names) {
   for (var name : names)
       System.out.println(name);
}
```

Мы подробно рассмотрим дженерики в главе 9 “Коллекции и дженерики”. Для этой главы вам просто нужно знать, что на 
каждой итерации цикл for-each присваивает переменной тот же тип, что и общий аргумент. В этом случае имя имеет 
тип String.

Пока все идет хорошо. Как насчет следующих примеров?

```
String birds = "Jay";
for (String bird : birds) // DOES NOT COMPILE
   System.out.print(bird + " ");
 
String[] sloths = new String[3];
for (int sloth : sloths) // DOES NOT COMPILE
   System.out.print(sloth + " ");
```

Первый цикл for-each не компилируется, так как String нельзя использовать в правой части оператора. 
Хотя String может представлять собой список символов, на самом деле он должен быть массивом или реализовывать Iterable. 
Второй пример не компилируется, потому что тип цикла в левой части инструкции — int и не соответствует ожидаемому 
типу String.

## Управление потоком с помощью ветвления (Controlling Flow with Branching)

Последними типами структур потока управления, которые мы рассмотрим в этой главе, являются операторы ветвления.
До сих пор мы имели дело с одиночными циклами, которые заканчивались только тогда, когда их логическое выражение 
оценивалось как ложное. Теперь мы покажем вам другие способы завершения или ветвления циклов, и вы увидите, что путь, 
выбранный во время выполнения, может быть не таким простым, как в предыдущих примерах.

### Вложенные циклы

Прежде чем мы перейдем к операторам ветвления, нам нужно ввести понятие вложенных циклов. Вложенный цикл — это цикл, 
который содержит другой цикл, включая циклы while, do/while, for и for-each. Например, рассмотрим следующий код, 
выполняющий итерацию по двумерному массиву, который содержит другие массивы в качестве элементов. Мы подробно 
рассмотрели многомерные массивы в Главе 4, «Основные API», но сейчас предположим, что вы должны объявить двумерный 
массив следующим образом:

```
int[][] myComplexArray = {{5, 2, 1, 3},{3, 9, 8, 9},{5, 7, 12, 7}};

for (int[] mySimpleArray : myComplexArray) {
  for (int i = 0; i < mySimpleArray.length; i++) {
     System.out.print(mySimpleArray[i]+"\t");
  }
  System.out.println();
}
```

Обратите внимание, что в этом примере мы намеренно смешиваем цикл for и цикл for-each. Внешний цикл будет выполнен в 
общей сложности три раза. Каждый раз, когда выполняется внешний цикл, внутренний цикл выполняется четыре раза. Когда мы 
выполняем этот код, мы видим следующий вывод:

```
5  2  1  3
3  9  8  9
5  7  12 7
```

Вложенные циклы могут включать в себя while и do/while, как показано в этом примере. Посмотрите, сможете ли вы 
определить, что выведет этот код:

```
int hungryHippopotamus = 8;
while(hungryHippopotamus > 0) {
   do {
       hungryHippopotamus -= 2;
   } while (hungryHippopotamus > 5);
   hungryHippopotamus--;
   System.out.print(hungryHippopotamus + ", ");
}
```

При первом выполнении этого цикла внутренний цикл повторяется до тех пор, пока значение hungryHippopotamus не станет 
равным 4. Затем значение будет уменьшено до 3, и это будет результат в конце первой итерации внешнего цикла.

На второй итерации внешнего цикла внутренний do/while будет выполнен один раз, даже несмотря на то, что 
hungryHippopotamus уже не превышает 5. Как вы, возможно, помните, операторы do/while всегда выполняют тело по 
крайней мере один раз. Это уменьшит значение до 1, которое будет дополнительно уменьшено оператором декремента во 
внешнем цикле до 0. Как только значение достигнет 0, внешний цикл завершится. В результате код выведет следующее: 3, 0,

Примеры в оставшейся части этого раздела включают множество вложенных циклов. На экзамене вы также столкнетесь с 
вложенными циклами, поэтому чем больше вы будете с ними практиковаться, тем лучше вы будете подготовлены.

### Добавление дополнительных меток (Adding Optional Labels)

Одна вещь, которую мы намеренно пропустили, когда представляли операторы if, switch и циклы, заключается в том, что 
все они могут иметь необязательные метки. Метка - это необязательный указатель на заголовок инструкции, который 
позволяет потоку приложения переходить к нему или прерывать его. Это единственный идентификатор, за которым следует 
двоеточие (:). Например, мы можем добавить необязательные метки к одному из предыдущих примеров:

```
int[][] myComplexArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}};

OUTER_LOOP: for (int[] mySimpleArray : myComplexArray) {
  INNER_LOOP: for (int i = 0; i < mySimpleArray.length; i++) {
 System.out.print(mySimpleArray[i]+"\t");
 }
 System.out.println();
}
```

Метки подчиняются тем же правилам форматирования, что и идентификаторы. Для удобства чтения они обычно выражаются 
заглавными буквами в snake_case с подчеркиванием между словами. При работе только с одним циклом метки не добавляют 
никакого значения, но, как вы узнаете из следующего раздела, они чрезвычайно полезны во вложенных структурах.

---

_Хотя эта тема не включена в экзамен, можно добавить необязательные метки к управляющим и блокирующим операторам. 
Например, компилятор разрешает следующее, хотя и крайне редко:_

---

```
 int frog = 15;
 BAD_IDEA: if (frog > 10)
 EVEN_WORSE_IDEA: {
    frog++;
 }
```

### Оператор break

Как вы видели при работе с операторами switch, оператор break передает поток управления заключающему(-окружающему)
оператору. То же самое справедливо для инструкции break, которая появляется внутри цикла while, do/while или for, 
поскольку она завершит цикл раньше, как показано на рисунке 3.9.

#### Рис. 3.9 - Структура оператора break

Обратите внимание на рис. 3.9, что оператор break может принимать необязательный параметр label. Без параметра метки 
оператор break завершит ближайший внутренний цикл, который в данный момент находится в процессе выполнения. 
Необязательный параметр label позволяет выйти из внешнего цикла более высокого уровня. В следующем примере мы ищем 
первую (x,y) позицию индекса массива числа в несортированном двумерном массиве:

```
public class FindInMatrix {
   public static void main(String[] args) {
      int[][] list = {{1, 13},{5, 2},{2, 2}};
      int searchValue = 2;
      int positionX = -1;
      int positionY = -1;
      PARENT_LOOP: for (int i = 0; i < list.length; i++) {
         for (int j = 0; j < list[i].length; j++) {
             if (list[i][j] == searchValue) {
                positionX = i;
                positionY = j;
                break PARENT_LOOP;
             }
         }
      }
      if (positionX == -1 || positionY == -1) {
         System.out.println("Value " + searchValue + " not found");
      } else {
         System.out.println("Value " + searchValue + " found at: " + "(" + positionX + "," + positionY +")");
           
      }
   }
}
```

При выполнении этот код выведет следующее:

```
Value 2 found at: (1,1)
```

В частности, взгляните на оператор break PARENT_LOOP. Этот оператор вырвется из всей структуры цикла, как только будет 
найдено первое совпадающее значение. Теперь представьте, что произойдет, если мы заменим тело внутреннего цикла 
следующим:

```
if (list[i][j] == searchValue) {
   positionX = i;
   positionY = j;
   break;
}
```

Как это изменит наш поток и изменится ли результат? Вместо выхода при обнаружении первого совпадающего значения 
программа теперь будет выходить из внутреннего цикла только при выполнении условия. Другими словами, структура найдет 
первое совпадающее значение последнего внутреннего цикла, содержащее это значение, что приведет к следующему результату:

```
Value 2 found at: (2,0)
```

Наконец, что, если мы вообще удалим break?

```
if (list[i][j]==searchValue) {
 positionX = i;
 positionY = j;
}
```

В этом случае код будет искать последнее значение во всей структуре, имеющее совпадающее значение. Вывод будет 
выглядеть следующим образом:

```
Value 2 found at: (2,1)
```

Из этого примера видно, что использование метки в операторе break во вложенном цикле или полное отсутствие оператора 
break может привести к тому, что структура цикла будет вести себя совершенно по-другому.

### Оператор continue

Теперь давайте расширим наше обсуждение расширенного управления циклом оператором continue, оператором, который 
заставляет поток завершать выполнение текущей итерации цикла, как показано на рис. 3.10.

#### Рис. 3.10 - Структура оператора continue

Вы можете заметить, что синтаксис оператора continue аналогичен синтаксису оператора break. На самом деле операторы 
идентичны в том, как они используются, но с разными результатами. В то время как оператор break передает управление 
закрывающему оператору, оператор continue передает управление логическому выражению, которое определяет, должен ли цикл 
продолжаться. Другими словами, он завершает текущую итерацию цикла. Кроме того, как и оператор break, оператор continue 
применяется к ближайшему выполняемому внутреннему циклу, используя необязательные операторы меток(label) для 
переопределения этого поведения.

Давайте посмотрим на пример. Представьте, что у нас есть смотритель зоопарка, который должен почистить первого леопарда 
в каждой из четырех конюшен, но полностью пропустить конюшню b.

```
1: public class CleaningSchedule {
2:    public static void main(String[] args) {
3:       CLEANING: for(char stables = 'a'; stables<='d'; stables++) {
4:          for (int leopard = 1; leopard<4; leopard++) {
5:             if (stables == 'b' || leopard==2) {
6:                  continue CLEANING;
7:             }
8:             System.out.println("Cleaning: "+stables+","+leopard);
9: } } } }
```

С определенной структурой цикл будет возвращать управление родительскому циклу каждый раз, когда первое значение равно 
b или второе значение равно 2. При первом, третьем и четвертом выполнении внешнего цикла внутренний цикл печатает 
оператор ровно один раз, а затем завершает следующий внутренний цикл, когда leopard равен 2. При втором выполнении 
внешнего цикла внутренний цикл немедленно завершается, ничего не печатая, поскольку b встречается сразу. 
Печатается следующее:

```
Cleaning: a,1
Cleaning: c,1
Cleaning: d,1
```

Теперь представьте, что мы удаляем метку CLEANING в операторе continue, чтобы управление возвращалось во внутренний 
цикл, а не во внешний. Строка 6 становится следующей:

```
6:               continue;
```

Это соответствует тому, что смотритель зоопарка чистит всех леопардов, кроме тех, которые помечены как 2 или находятся 
в стойле в. Тогда результат будет следующим:

```
Cleaning: a,1
Cleaning: a,3
Cleaning: c,1
Cleaning: c,3
Cleaning: d,1
Cleaning: d,3
```

Наконец, если мы полностью удалим оператор continue и связанный с ним оператор if, удалив строки 5–7, мы придем к 
структуре, которая выводит все значения, например:

```
Cleaning: a,1
Cleaning: a,2
Cleaning: a,3
Cleaning: b,1
Cleaning: b,2
Cleaning: b,3
Cleaning: c,1
Cleaning: c,2
Cleaning: c,3
Cleaning: d,1
Cleaning: d,2
Cleaning: d,3
```

### Оператор return

Учитывая, что эта книга не должна быть вашим первым знакомством с программированием, мы надеемся, что вы познакомились 
с методами, содержащими операторы возврата. Несмотря на это, мы подробно расскажем, как проектировать и создавать 
методы, которые их используют, в главе 5 «Методы».

Однако сейчас вы должны быть знакомы с идеей о том, что создание методов и использование операторов return можно 
использовать в качестве альтернативы использованию меток и операторов break. Например, взгляните на эту переписанную 
версию нашего предыдущего класса FindInMatrix:

```
public class FindInMatrixUsingReturn {
   private static int[] searchForValue(int[][] list, int v) {
      for (int i = 0; i < list.length; i++) {
        for (int j = 0; j < list[i].length; j++) {
           if (list[i][j] == v) {
              return new int[] {i,j};
           }
        }
      }
      return null;
   }
   
   public static void main(String[] args) {
      int[][] list = { { 1, 13 }, { 5, 2 }, { 2, 2 } };
      int searchValue = 2;
      int[] results = searchForValue(list,searchValue);
      
      if (results == null) {
         System.out.println("Value " + searchValue + " not found");
      } else {
         System.out.println("Value " + searchValue + " found at: " +
            "(" + results[0] + "," + results[1] + ")");
      }
   }
}
```

Этот класс функционально такой же, как и первый класс FindInMatrix, который мы видели ранее с использованием break. 
Если вам нужен более детальный контроль цикла с несколькими операторами break и continue, первый класс, вероятно, лучше. 
Тем не менее, мы находим, что код без меток и инструкций break намного проще читать и отлаживать. Кроме того, 
превращение логики поиска в независимую функцию делает код более многоразовым, а вызывающий метод main() намного проще 
для чтения.

Для экзамена вам нужно будет знать обе формы. Просто помните, что операторы return могут использоваться для быстрого 
выхода из циклов и на практике могут привести к более читаемому коду, особенно при использовании с вложенными циклами.

### Недоступный код (Unreachable Code)

Один из аспектов break, continue и return, о котором вы должны знать, заключается в том, что любой код, размещенный 
сразу после них в том же блоке, считается недоступным и не будет компилироваться. Например, следующий фрагмент кода не 
компилируется:

```
int checkDate = 0;
while (checkDate < 10) {
   checkDate++;
   if (checkDate > 100) {
       break;
       checkDate++;      // DOES NOT COMPILE
   }
}
```

Несмотря на то, что логически невозможно, чтобы оператор if оценивался как true в этом примере кода, компилятор 
замечает, что у вас есть инструкции сразу после break, и не сможет скомпилировать с “недоступным кодом” в качестве 
причины. То же самое верно для операторов continue и return, как показано в следующих двух примерах:

```
int minute = 1;
WATCH: while(minute > 2) {
   if (minute++ > 2) {
       continue WATCH;
       System.out.print(minute);  // НЕ КОМПИЛИРУЕТСЯ
   }
}

int hour = 2;
switch(hour) {
   case 1: return; hour++;  // НЕ КОМПИЛИРУЕТСЯ
   case 2:
}
```

Одна вещь, которую следует помнить, заключается в том, что не имеет значения, действительно ли цикл или структура 
принятия решений посещают строку кода. Например, цикл может выполняться ноль или бесконечное количество раз во время 
выполнения. Независимо от выполнения компилятор сообщит об ошибке, если обнаружит какой-либо код, который он сочтет 
недоступным, в данном случае любые инструкции, следующие сразу за инструкцией break, continue или return.

### Обзор ветвлений (Reviewing Branching)

Мы завершаем этот раздел таблицей 3.1, которая поможет напомнить вам, когда в Java разрешены операторы меток (labels) , 
break и continue. Хотя в иллюстративных целях в наших примерах эти операторы используются во вложенных циклах, их можно 
использовать и внутри одиночных циклов.

#### Таблица 3.1. - Использование оператора управления

|          | Вспомогательные метки | Поддержка break | Поддержка continue | Поддержка yield |
|:---------|:---------------------:|:---------------:|:------------------:|:---------------:|
| while    |          Да           |       Да        |         Да         |       Нет       |
| do/while |          Да           |       Да        |         Да         |       Нет       |
| for      |          Да           |       Да        |         Да         |       Нет       |
| switch   |          Да           |       Да        |        Нет         |       Да        |

И последнее, но не менее важное: во всех центрах тестирования должны быть предложены листы бумаги или доска с сухой 
пергаментной краской для использования во время экзамена. Мы настоятельно рекомендуем вам воспользоваться этими 
вспомогательными средствами тестирования, если вам встретятся сложные вопросы, связанными с вложенными циклами и 
операторами ветвления.

---

_Некоторые из наиболее трудоемких вопросов, которые вы можете встретить на экзамене, могут включать в себя вложенные 
циклы с большим количеством ветвлений. Если вы не обнаружили очевидную ошибку компилятора, мы рекомендуем пропустить 
эти вопросы и вернуться к ним в конце. Помните, что все вопросы на экзамене имеют равный вес!_

---

## Резюме

В этой главе показано, как принимать разумные решения в Java. Мы рассмотрели основные конструкции принятия решений, 
такие как операторы if, else и switch, и показали, как их использовать для изменения пути процесса во время выполнения. 
Мы также представили новые функции языка Java, в том числе сопоставление с образцом и выражения переключения, 
предназначенные для сокращения шаблонного кода.

Затем мы перенесли наше обсуждение на структуры управления повторением, начав с циклов while и do/while. Мы показали, 
как использовать их для создания процессов, которые повторяются несколько раз, а также показали, как важно убедиться, 
что они в конечном итоге завершатся. Помните, что для большинства этих структур требуется вычисление конкретного 
логического выражения.

Далее мы рассмотрели чрезвычайно удобные структуры управления повторением: циклы for и for-each. Хотя их синтаксис более
сложен, чем у традиционных циклов while или do/while, они чрезвычайно полезны в повседневном программировании и 
позволяют создавать сложные выражения в одной строке кода. С циклом for-each вам не нужно явно писать логическое 
выражение, так как компилятор строит его за вас. Для ясности мы назвали расширенный цикл for циклом for-each, но 
синтаксически оба они записываются с использованием ключевого слова for.

Мы завершили эту главу обсуждением дополнительных параметров управления и того, как можно улучшить поток с помощью 
вложенных циклов в сочетании с операторами break, continue и return. Будьте осторожны с вопросами на экзамене, в 
которых используются вложенные циклы, особенно с метками, и убедитесь, что они используются правильно.

Эта глава особенно важна, потому что по крайней мере один компонент этой главы, скорее всего, будет присутствовать в 
каждом экзаменационном вопросе с образцом кода. Многие вопросы на экзамене сосредоточены на правильном синтаксическом 
использовании структур, поскольку они будут большим источником вопросов, которые заканчиваются на “Не компилируется”. 
Вы должны быть в состоянии правильно ответить на все _контрольные вопросы_ или полностью понять те, на которые вы 
ответили неправильно, прежде чем переходить к последующим главам.

## Основы экзамена

**Понимать операторы управления решениями if и else.** Операторы if и else часто встречаются на экзамене в вопросах, не 
связанных с контролем принятия решений, поэтому убедитесь, что вы полностью понимаете эти основные строительные блоки 
Java.

**Применяйте сопоставление с образцом и определение области потока.** Сопоставление с образцом может быть использовано 
для сокращения шаблонного кода, включающего оператор if, оператор instanceof и операцию приведения с использованием 
переменной шаблона. Он также может включать шаблон или фильтр после объявления переменной шаблона. Сопоставление с 
образцом использует определение области потока, в котором переменная шаблона находится в области видимости до тех пор, 
пока компилятор может окончательно определить ее тип.

**Изучите операторы switch и их правильное использование.** Обратите внимание на различия между выражениями switch и 
операторами switch. Поймите, как правильно писать выражения switch, включая правильное использование точек с запятой, 
написание выражений case и блоков, которые дают согласованное значение, и убедитесь, что все возможные значения 
переменной switch обрабатываются выражением switch.

**Пишите циклы while.** Знайте синтаксическую структуру всех циклов while и do/while. В частности, знайте, когда 
использовать одно по сравнению с другим.

**Уметь использовать циклы for.** Вы должны быть знакомы с циклами for и for-each и знать, как их писать и вычислять.
Каждый цикл имеет свои собственные особые свойства и структуры. Вы должны знать, как использовать циклы for-each для 
перебора списков и массивов.

**Поймите, как break, continue и return могут изменить управление потоком.** Знайте, как изменить управление потоком 
внутри оператора, применяя операторы break, continue или return. Также узнайте, какие управляющие операторы могут 
принимать операторы break, а какие могут принимать операторы continue. Наконец, вы должны понимать, как эти операторы 
работают внутри встроенных циклов или операторов switch.

