# Принятие решений (Making Decisions)

---
### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Управление потоком программы

+ Создание конструкций управления потоком программы, включая операторы if/else, операторы и выражения switch, циклы, а 
также операторы break и continue.

#### Использование объектно-ориентированного подхода Java

+ Реализуйте полиморфизм и различайте тип объекта и ссылочный тип. Выполните приведение типов, определите типы объектов 
с помощью оператора instanceof и сопоставления с образцом.
---

Как и многие языки программирования, Java состоит в основном из переменных, операторов и утверждений(или выражений), расположенных в 
определенном логическом порядке. В прошлой главе мы рассмотрели, как создавать переменные и управлять ими. Однако 
написание программного обеспечения - это нечто большее, чем управление переменными; речь идет о создании приложений, 
способных принимать разумные решения. В этой главе мы представляем различные инструкции по принятию решений, доступные 
вам в рамках данного языка. Эти знания позволят вам создавать сложные функции и структуры классов, которые вы увидите 
на протяжении всей этой книги.

## Создание заявлений для принятия решений (Creating Decision-Making Statements)

Операторы Java позволяют создавать множество сложных выражений, но они ограничены в том, как они могут управлять ходом 
выполнения программы. Представьте, что вы хотите, чтобы метод выполнялся только при определенных условиях, которые 
нельзя оценить до времени выполнения. Например, в дождливые дни зоопарк должен напоминать посетителям о необходимости 
взять с собой зонтик, а в снежный день зоопарку, возможно, придется закрыться. Программное обеспечение не меняется, но 
поведение программного обеспечения должно меняться в зависимости от входных данных, поступающих в данный момент. В этом 
разделе мы обсудим операторы принятия решений, включая if и else, а также новую функцию сопоставления с образцом.

### Инструкции и блоки (Statements and Blocks) 

Как вы, возможно, помните из главы 1 «Строительные блоки», оператор Java — это завершенная единица выполнения в Java, 
заканчивающаяся точкой с запятой (;). В этой главе мы познакомим вас с различными операторами потока управления Java. 
Операторы потока управления разбивают поток выполнения с помощью принятия решений, циклов и ветвлений, позволяя 
приложению выборочно выполнять определенные сегменты кода.

Эти операторы могут применяться как к отдельным выражениям, так и к блоку кода Java. Как описано в главе 1, блок кода в 
Java представляет собой группу из нуля или более операторов между сбалансированными фигурными скобками ({}) и может 
использоваться везде, где разрешен один оператор. Например, следующие два фрагмента эквивалентны: первый представляет 
собой отдельное выражение, а второй — блок, содержащий один и тот же оператор:

```
// Один оператор
patrons++;

// Оператор внутри блока
{
patrons++;
}
```

Оператор или блок часто служат целью заявления о принятии решения. Например, мы можем добавить оператор if для принятия 
решения к этим двум примерам:

```
// Один оператор
if(ticketsTaken > 1)
patrons++;

// Оператор внутри блока
if(ticketsTaken > 1)
{
patrons++;
}
```

Опять же, оба этих фрагмента кода эквивалентны. Просто помните, что целью заявления о принятии решения может быть одно 
заявление или блок заявлений. В остальной части главы мы используем обе формы, чтобы лучше подготовить вас к тому, что 
вы увидите на экзамене.

---
Хотя оба предыдущих примера эквивалентны, стилистически использование блоков часто предпочтительнее, даже если блок 
содержит только одно утверждение. Вторая форма имеет то преимущество, что вы можете быстро вставлять новые строки кода 
в блок, не изменяя окружающую структуру.
---

### Оператор if

Часто мы хотим выполнить блок только при определенных обстоятельствах. Оператор if, как показано на рисунке 3.1, 
выполняет это, позволяя нашему приложению выполнять определенный блок кода тогда и только тогда, когда логическое 
выражение принимает значение true во время выполнения.

#### Рис. 3.1 - Структура оператора if
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/chapter%202/image2/figure%202.1%20.JPG) - для примера 

Например, представьте, что у нас есть функция, которая использует час дня, целочисленное значение от 0 до 23, для 
отображения сообщения пользователю:

```
if(hourOfDay < 11)
    System.out.println("Good Morning");
```

Если время суток меньше 11, то будет выведено соответствующее сообщение. Теперь предположим, что мы также хотели 
увеличивать некоторое значение, morningGreetingCount, каждый раз, когда печатается приветствие. Мы могли бы написать 
оператор if дважды, но, к счастью, Java предлагает нам более естественный подход с использованием блока:

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
    morningGreetingCount++;
}
```

---
#### Следите за отступами и фигурными скобками

Одна из областей, в которой составители экзамена попытаются сбить вас с толку, — это операторы if без фигурных 
скобок ({}). Например, взгляните на эту слегка измененную форму нашего примера:

```
if(hourOfDay < 11)
    System.out.println("Good Morning");
    morningGreetingCount++;
```

Основываясь на отступе, вы можете быть склонны думать, что переменная morningGreetingCount будет увеличена только в том 
случае, если hourOfDay меньше 11, но это не то, что делает этот код. Он выполнит инструкцию печати только в том случае, 
если условие выполнено, но он всегда будет выполнять операцию увеличения.

Помните, что в Java, в отличие от некоторых других языков программирования, вкладки являются просто пробелами и не 
оцениваются как часть выполнения. Когда вы видите инструкцию потока управления в вопросе, обязательно проследите за 
открытыми и закрывающими фигурными скобками блока, игнорируя любые отступы, с которыми вы можете столкнуться.
---

### Оператор else

Давайте немного расширим наш пример. Что, если мы хотим отобразить другое сообщение, если сейчас 11 часов утра или 
позже? Можем ли мы сделать это, используя только те инструменты, которые у нас есть? Конечно, мы можем!

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
}
if(hourOfDay >= 11) {
    System.out.println("Good Afternoon");
}
```

Однако это кажется немного избыточным, поскольку мы дважды выполняем оценку в hourOfDay. К счастью, Java предлагает 
более полезный подход в виде оператора else, как показано на рис. 3.2.

#### Рис. 3.2 - Структура оператора else

Вернемся к этому примеру:

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
} else System.out.println("Good Afternoon");
```

Теперь наш код действительно разветвляется между одним из двух возможных вариантов, причем логическое вычисление 
выполняется только один раз. Оператор else принимает оператор или блок операторов таким же образом, как оператор if. 
Аналогично, мы можем добавить дополнительные операторы if к блоку else, чтобы получить более совершенный пример:

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
} else if(hourOfDay < 15) {
    System.out.println("Good Afternoon");
} else {
    System.out.println("Good Evening");
}
```

В этом примере процесс Java продолжит выполнение до тех пор, пока не встретит оператор if, значение которого равно 
true. Если ни одно из первых двух выражений не является истинным, будет выполнен последний код блока else.

---
#### Проверка того, что оператор if оценивается как логическое выражение

Другой распространенный способ, которым экзамен может попытаться ввести вас в заблуждение, - это предоставление кода, 
в котором логическое выражение внутри оператора if на самом деле не является логическим (boolean) выражением. Например, 
взгляните на следующие строки кода:

```
int hourOfDay = 1;
if(hourOfDay) { // DOES NOT COMPILE
    ...
}
```

Это утверждение может быть допустимо в некоторых других языках программирования и написания сценариев, но не в Java, 
где 0 и 1 не считаются логическими значениями.
---

### Сокращение кода с помощью сопоставления с образцом (Shortening Code with Pattern Matching)

В Java 16 официально представлено сопоставление шаблонов с операторами if и оператором instanceof.
Сопоставление с образцом - это метод управления потоком программы, который выполняет только ту часть кода, которая 
соответствует определенным критериям. Он используется в сочетании с операторами if для большего контроля над программой.

_Если сопоставление с образцом для вас новое, будьте осторожны, чтобы не спутать его с классом Java Pattern или 
регулярными выражениями (регулярными выражениями). Хотя сопоставление с образцом может включать использование 
регулярных выражений для фильтрации, это не связанные понятия._

Сопоставление с образцом — это новый доступный вам инструмент, позволяющий уменьшить количество шаблонов в вашем коде. 
Стандартный код — это код, который имеет тенденцию повторяться в одном и том же разделе кода снова и снова одним и 
тем же образом. Многие новые усовершенствования языка Java сосредоточены на сокращении шаблонного кода.

Чтобы понять, почему был добавлен этот инструмент, рассмотрим следующий код, который принимает экземпляр Number и 
сравнивает его со значением 5. Если вы еще не видели Number или Integer, вам просто нужно знать, что Integer 
наследуется от Number на данный момент. Вы часто увидите их в этой книге!

```
void compareIntegers(Number number) {
   if(number instanceof Integer) {
      Integer data = (Integer)number;
      System.out.print(data.compareTo(5));
   }
}
```

Приведение необходимо, так как метод compareTo() определен для Integer, но не для Number.

Код, который сначала проверяет, относится ли переменная к определенному типу, а затем немедленно приводит ее к этому 
типу, чрезвычайно распространен в мире Java. Это настолько распространено, что авторы Java решили реализовать для него 
более короткий синтаксис:

```
void compareIntegers(Number number) {
   if(number instanceof Integer data) {
      System.out.print(data.compareTo(5));
   }
}
```

Переменные данные в этом примере называются переменной шаблона. Обратите внимание, что этот код также позволяет 
избежать любого потенциального исключения ClassCastException, поскольку операция приведения выполняется только в том 
случае, если неявный оператор instanceof возвращает true.

---
#### Переназначение переменных шаблона

Хотя это возможно, переназначать переменную шаблона - плохая практика, поскольку это может привести к двусмысленности 
в отношении того, что входит в область видимости, а что нет.

```
if(number instanceof Integer data) {
   data = 10;
}
```

Переназначение можно предотвратить с помощью модификатора final, но лучше вообще не переназначать переменную.

```
if(number instanceof final Integer data) {
   data = 10;  // DOES NOT COMPILE
}
```
---

### Переменные шаблона и выражения

Сопоставление с образцом включает выражения, которые можно использовать для фильтрации данных, например, в следующем 
примере:

```
void printIntegersGreaterThan5(Number number) {
   if(number instanceof Integer data && data.compareTo(5)>0)
      System.out.print(data);
}
```

Мы можем применить ряд фильтров или шаблонов, чтобы оператор if выполнялся только в определенных обстоятельствах. 
Обратите внимание, что мы используем переменную pattern в выражении в той же строке, в которой она объявлена.
(Обратите внимание, что мы используем переменную шаблона в выражении в той же строке, в которой она объявлена.)

### Подтипы

Тип переменной шаблона должен быть подтипом переменной в левой части выражения. Он также не может быть одного типа. 
Однако этого правила не существует для традиционных выражений оператора instanceof. Рассмотрим следующие два варианта 
использования оператора instanceof:

```
Integer value = 123;
if(value instanceof Integer) {}
if(value instanceof Integer data) {} // DOES NOT COMPILE
```

В то время как вторая строка компилируется, последняя строка не компилируется, поскольку сопоставление шаблонов 
требует, чтобы тип переменной шаблона Integer был строгим подтипом Integer.

---
#### Ограничения применения подтипа

У компилятора есть некоторые ограничения на применение типов сопоставления с образцом, когда мы смешиваем классы и 
интерфейсы, что станет более понятным после того, как вы прочитаете главу 7 «Помимо классов». Например, учитывая 
неконечный класс Number и список интерфейсов, это компилируется, даже если они не связаны:

```
Number value = 123;
if(value instanceof List) {}
if(value instanceof List data) {}
```

### Анализ потока (Flow Scoping)