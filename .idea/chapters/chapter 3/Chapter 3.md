# Принятие решений (Making Decisions)

---
### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Управление потоком программы

+ Создание конструкций управления потоком программы, включая операторы if/else, операторы и выражения switch, циклы, а 
также операторы break и continue.

#### Использование объектно-ориентированного подхода Java

+ Реализуйте полиморфизм и различайте тип объекта и ссылочный тип. Выполните приведение типов, определите типы объектов 
с помощью оператора instanceof и сопоставления с образцом.
---

Как и многие языки программирования, Java состоит в основном из переменных, операторов и утверждений(или выражений), расположенных в 
определенном логическом порядке. В прошлой главе мы рассмотрели, как создавать переменные и управлять ими. Однако 
написание программного обеспечения - это нечто большее, чем управление переменными; речь идет о создании приложений, 
способных принимать разумные решения. В этой главе мы представляем различные инструкции по принятию решений, доступные 
вам в рамках данного языка. Эти знания позволят вам создавать сложные функции и структуры классов, которые вы увидите 
на протяжении всей этой книги.

## Создание заявлений для принятия решений (Creating Decision-Making Statements)

Операторы Java позволяют создавать множество сложных выражений, но они ограничены в том, как они могут управлять ходом 
выполнения программы. Представьте, что вы хотите, чтобы метод выполнялся только при определенных условиях, которые 
нельзя оценить до времени выполнения. Например, в дождливые дни зоопарк должен напоминать посетителям о необходимости 
взять с собой зонтик, а в снежный день зоопарку, возможно, придется закрыться. Программное обеспечение не меняется, но 
поведение программного обеспечения должно меняться в зависимости от входных данных, поступающих в данный момент. В этом 
разделе мы обсудим операторы принятия решений, включая if и else, а также новую функцию сопоставления с образцом.

### Инструкции и блоки (Statements and Blocks) 

Как вы, возможно, помните из главы 1 «Строительные блоки», оператор Java — это завершенная единица выполнения в Java, 
заканчивающаяся точкой с запятой (;). В этой главе мы познакомим вас с различными операторами потока управления Java. 
Операторы потока управления разбивают поток выполнения с помощью принятия решений, циклов и ветвлений, позволяя 
приложению выборочно выполнять определенные сегменты кода.

Эти операторы могут применяться как к отдельным выражениям, так и к блоку кода Java. Как описано в главе 1, блок кода в 
Java представляет собой группу из нуля или более операторов между сбалансированными фигурными скобками ({}) и может 
использоваться везде, где разрешен один оператор. Например, следующие два фрагмента эквивалентны: первый представляет 
собой отдельное выражение, а второй — блок, содержащий один и тот же оператор:

```
// Один оператор
patrons++;

// Оператор внутри блока
{
patrons++;
}
```

Оператор или блок часто служат целью заявления о принятии решения. Например, мы можем добавить оператор if для принятия 
решения к этим двум примерам:

```
// Один оператор
if(ticketsTaken > 1)
patrons++;

// Оператор внутри блока
if(ticketsTaken > 1)
{
patrons++;
}
```

Опять же, оба этих фрагмента кода эквивалентны. Просто помните, что целью заявления о принятии решения может быть одно 
заявление или блок заявлений. В остальной части главы мы используем обе формы, чтобы лучше подготовить вас к тому, что 
вы увидите на экзамене.

---
Хотя оба предыдущих примера эквивалентны, стилистически использование блоков часто предпочтительнее, даже если блок 
содержит только одно утверждение. Вторая форма имеет то преимущество, что вы можете быстро вставлять новые строки кода 
в блок, не изменяя окружающую структуру.
---

### Оператор if

Часто мы хотим выполнить блок только при определенных обстоятельствах. Оператор if, как показано на рисунке 3.1, 
выполняет это, позволяя нашему приложению выполнять определенный блок кода тогда и только тогда, когда логическое 
выражение принимает значение true во время выполнения.

#### Рис. 3.1 - Структура оператора if
![img.png](https://github.com/ilyaizvekov/ocp_java17/blob/main/.idea/chapters/chapter%202/image2/figure%202.1%20.JPG) - для примера 

Например, представьте, что у нас есть функция, которая использует час дня, целочисленное значение от 0 до 23, для 
отображения сообщения пользователю:

```
if(hourOfDay < 11)
    System.out.println("Good Morning");
```

Если время суток меньше 11, то будет выведено соответствующее сообщение. Теперь предположим, что мы также хотели 
увеличивать некоторое значение, morningGreetingCount, каждый раз, когда печатается приветствие. Мы могли бы написать 
оператор if дважды, но, к счастью, Java предлагает нам более естественный подход с использованием блока:

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
    morningGreetingCount++;
}
```

---
#### Следите за отступами и фигурными скобками

Одна из областей, в которой составители экзамена попытаются сбить вас с толку, — это операторы if без фигурных 
скобок ({}). Например, взгляните на эту слегка измененную форму нашего примера:

```
if(hourOfDay < 11)
    System.out.println("Good Morning");
    morningGreetingCount++;
```

Основываясь на отступе, вы можете быть склонны думать, что переменная morningGreetingCount будет увеличена только в том 
случае, если hourOfDay меньше 11, но это не то, что делает этот код. Он выполнит инструкцию печати только в том случае, 
если условие выполнено, но он всегда будет выполнять операцию увеличения.

Помните, что в Java, в отличие от некоторых других языков программирования, вкладки являются просто пробелами и не 
оцениваются как часть выполнения. Когда вы видите инструкцию потока управления в вопросе, обязательно проследите за 
открытыми и закрывающими фигурными скобками блока, игнорируя любые отступы, с которыми вы можете столкнуться.
---

### Оператор else

Давайте немного расширим наш пример. Что, если мы хотим отобразить другое сообщение, если сейчас 11 часов утра или 
позже? Можем ли мы сделать это, используя только те инструменты, которые у нас есть? Конечно, мы можем!

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
}
if(hourOfDay >= 11) {
    System.out.println("Good Afternoon");
}
```

Однако это кажется немного избыточным, поскольку мы дважды выполняем оценку в hourOfDay. К счастью, Java предлагает 
более полезный подход в виде оператора else, как показано на рис. 3.2.

#### Рис. 3.2 - Структура оператора else

Вернемся к этому примеру:

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
} else System.out.println("Good Afternoon");
```

Теперь наш код действительно разветвляется между одним из двух возможных вариантов, причем логическое вычисление 
выполняется только один раз. Оператор else принимает оператор или блок операторов таким же образом, как оператор if. 
Аналогично, мы можем добавить дополнительные операторы if к блоку else, чтобы получить более совершенный пример:

```
if(hourOfDay < 11) {
    System.out.println("Good Morning");
} else if(hourOfDay < 15) {
    System.out.println("Good Afternoon");
} else {
    System.out.println("Good Evening");
}
```

В этом примере процесс Java продолжит выполнение до тех пор, пока не встретит оператор if, значение которого равно 
true. Если ни одно из первых двух выражений не является истинным, будет выполнен последний код блока else.

---
#### Проверка того, что оператор if оценивается как логическое выражение

Другой распространенный способ, которым экзамен может попытаться ввести вас в заблуждение, - это предоставление кода, 
в котором логическое выражение внутри оператора if на самом деле не является логическим (boolean) выражением. Например, 
взгляните на следующие строки кода:

```
int hourOfDay = 1;
if(hourOfDay) { // DOES NOT COMPILE
    ...
}
```

Это утверждение может быть допустимо в некоторых других языках программирования и написания сценариев, но не в Java, 
где 0 и 1 не считаются логическими значениями.
---

### Сокращение кода с помощью сопоставления с образцом (Shortening Code with Pattern Matching)

В Java 16 официально представлено сопоставление шаблонов с операторами if и оператором instanceof.
Сопоставление с образцом - это метод управления потоком программы, который выполняет только ту часть кода, которая 
соответствует определенным критериям. Он используется в сочетании с операторами if для большего контроля над программой.

_Если сопоставление с образцом для вас новое, будьте осторожны, чтобы не спутать его с классом Java Pattern или 
регулярными выражениями (регулярными выражениями). Хотя сопоставление с образцом может включать использование 
регулярных выражений для фильтрации, это не связанные понятия._

Сопоставление с образцом — это новый доступный вам инструмент, позволяющий уменьшить количество шаблонов в вашем коде. 
Стандартный код — это код, который имеет тенденцию повторяться в одном и том же разделе кода снова и снова одним и 
тем же образом. Многие новые усовершенствования языка Java сосредоточены на сокращении шаблонного кода.

Чтобы понять, почему был добавлен этот инструмент, рассмотрим следующий код, который принимает экземпляр Number и 
сравнивает его со значением 5. Если вы еще не видели Number или Integer, вам просто нужно знать, что Integer 
наследуется от Number на данный момент. Вы часто увидите их в этой книге!

```
void compareIntegers(Number number) {
   if(number instanceof Integer) {
      Integer data = (Integer)number;
      System.out.print(data.compareTo(5));
   }
}
```

Приведение необходимо, так как метод compareTo() определен для Integer, но не для Number.

Код, который сначала проверяет, относится ли переменная к определенному типу, а затем немедленно приводит ее к этому 
типу, чрезвычайно распространен в мире Java. Это настолько распространено, что авторы Java решили реализовать для него 
более короткий синтаксис:

```
void compareIntegers(Number number) {
   if(number instanceof Integer data) {
      System.out.print(data.compareTo(5));
   }
}
```

Переменные данные в этом примере называются переменной шаблона. Обратите внимание, что этот код также позволяет 
избежать любого потенциального исключения ClassCastException, поскольку операция приведения выполняется только в том 
случае, если неявный оператор instanceof возвращает true.

---
#### Переназначение переменных шаблона

Хотя это возможно, переназначать переменную шаблона - плохая практика, поскольку это может привести к двусмысленности 
в отношении того, что входит в область видимости, а что нет.

```
if(number instanceof Integer data) {
   data = 10;
}
```

Переназначение можно предотвратить с помощью модификатора final, но лучше вообще не переназначать переменную.

```
if(number instanceof final Integer data) {
   data = 10;  // DOES NOT COMPILE
}
```
---

### Переменные шаблона и выражения

Сопоставление с образцом включает выражения, которые можно использовать для фильтрации данных, например, в следующем 
примере:

```
void printIntegersGreaterThan5(Number number) {
   if(number instanceof Integer data && data.compareTo(5)>0)
      System.out.print(data);
}
```

Мы можем применить ряд фильтров или шаблонов, чтобы оператор if выполнялся только в определенных обстоятельствах. 
Обратите внимание, что мы используем переменную pattern в выражении в той же строке, в которой она объявлена.
(Обратите внимание, что мы используем переменную шаблона в выражении в той же строке, в которой она объявлена.)

### Подтипы

Тип переменной шаблона должен быть подтипом переменной в левой части выражения. Он также не может быть одного типа. 
Однако этого правила не существует для традиционных выражений оператора instanceof. Рассмотрим следующие два варианта 
использования оператора instanceof:

```
Integer value = 123;
if(value instanceof Integer) {}
if(value instanceof Integer data) {} // DOES NOT COMPILE
```

В то время как вторая строка компилируется, последняя строка не компилируется, поскольку сопоставление шаблонов 
требует, чтобы тип переменной шаблона Integer был строгим подтипом Integer.

---
#### Ограничения применения подтипа

У компилятора есть некоторые ограничения на применение типов сопоставления с образцом, когда мы смешиваем классы и 
интерфейсы, что станет более понятным после того, как вы прочитаете главу 7 «Помимо классов». Например, учитывая 
неконечный класс Number и список интерфейсов, это компилируется, даже если они не связаны:

```
Number value = 123;
if(value instanceof List) {}
if(value instanceof List data) {}
```

### Анализ потока (Flow Scoping)

Компилятор применяет определение области потока при работе с сопоставлением шаблонов. Определение области потока 
означает, что переменная находится в области видимости только тогда, когда компилятор может окончательно определить 
ее тип. Определение области потока отличается от любого другого типа определения области тем, что оно не является 
строго иерархическим, как определение экземпляра, класса или локальной области. Он определяется компилятором на 
основе ветвления и потока выполнения программы.

Учитывая эту информацию, можете ли вы понять, почему следующее не компилируется?

```
void printIntegersOrNumbersGreaterThan5(Number number) {
   if(number instanceof Integer data || data.compareTo(5)>0)
      System.out.print(data);
}
```

Если вход не наследует Integer, переменная data не определена. Поскольку компилятор не может гарантировать, что data 
являются экземпляром Integer, data не входят в область действия, и код не компилируется. (поправить)

Как насчет этого примера?

```
void printIntegerTwice(Number number) {
  if (number instanceof Integer data)
     System.out.print(data.intValue());
  System.out.print(data.intValue()); // DOES NOT COMPILE
}
```

Поскольку входные данные могли не унаследоваться от Integer, данные больше не находятся в области видимости после 
оператора if. О, так вы могли подумать, что переменная шаблона находится в области видимости только внутри 
оператора if, верно? Ну не совсем так! Рассмотрим следующий пример, который компилирует: (поправить)

```
void printOnlyIntegers(Number number) {
   if (!(number instanceof Integer data))
      return;
   System.out.print(data.intValue());
}
```

Вы можете удивиться, узнав, что этот код компилируется. Эй! Что здесь происходит? Метод возвращает значение, если ввод 
не наследует Integer. Это означает, что при достижении последней строки метода входные данные должны наследовать 
Integer, и поэтому данные остаются в области действия даже после завершения оператора if.

---
#### Определение области действия потока и другие ветви (Flow Scoping and else Branches)

Если последний пример кода вас смущает, не беспокойтесь: вы не одиноки! Другой способ подумать об этом — переписать 
логику на что-то эквивалентное, использующее оператор else:

```
void printOnlyIntegers(Number number) {
   if (!(number instanceof Integer data))
      return;
   else
      System.out.print(data.intValue());
 }
```

Теперь мы можем сделать еще один шаг и поменять местами ветви if и else, инвертировав логическое выражение:

```
void printOnlyIntegers(Number number) {
   if (number instanceof Integer data)
      System.out.print(data.intValue());
   else
      return;
 }
```

Наш новый код эквивалентен нашему исходному и лучше демонстрирует, как компилятор смог определить, что data находятся 
в области видимости, только когда number является целым числом.
---

Убедитесь, что вы понимаете, как работает обзор потока. В частности, можно использовать переменную шаблона вне 
оператора if, но только тогда, когда компилятор может окончательно определить ее тип.

## Применение операторов switch (Applying switch Statements)

Что, если у нас есть много возможных ветвей или путей для одного значения? Например, мы могли бы захотеть напечатать
разные сообщения в зависимости от дня недели. Мы, конечно, могли бы достичь этого с помощью комбинации из семи 
операторов if или else, но это приводит к созданию длинного кода, который трудно читать и часто неинтересен в 
обслуживании:

```
public void printDayOfWeek(int day) {
    if(day == 0)
       System.out.print("Sunday");
    else if(day == 1)
       System.out.print("Monday");
    else if(day == 2)
       System.out.print("Tuesday");
    else if(day == 3)
       System.out.print("Wednesday");
    ...
}
```

К счастью, Java, наряду со многими другими языками, обеспечивает более чистый подход. В этом разделе мы представляем 
оператор switch вместе с более новым выражением switch для управления потоком программы.

### Оператор switch

Оператор switch, как показано на рис. 3.3, представляет собой сложную структуру принятия решений, в которой вычисляется 
одно значение и поток перенаправляется в первую соответствующую ветвь, известную как оператор case. Если не найдено 
такого оператора case, который соответствовал бы значению, будет вызван необязательный оператор default. Если такой 
параметр по умолчанию недоступен, вся инструкция switch будет пропущена. Обратите внимание на рис. 3.3, что значения 
регистра могут быть объединены в один оператор регистра с помощью запятых.

#### Рис. 3.3 - Структура оператора switch

Поскольку инструкции switch могут быть длиннее, чем большинство инструкций для принятия решений, на экзамене может быть 
представлен недопустимый синтаксис switch, чтобы проверить, обращаете ли вы внимание.

---

#### Объединение значений case (Combining case Values)

Заметили что-то новое на рисунке 3.3? Начиная с Java 14, значения регистра теперь можно комбинировать:

```
switch(animal) {
   case 1,2: System.out.print("Lion");
   case 3: System.out.print("Tiger");
}
```

До Java 14 эквивалентный код был бы следующим:

```
switch(animal) {
   case 1: case 2: System.out.print("Lion");
   case 3: System.out.print("Tiger");
}
```

Как вы вскоре увидите, выражения switch могут еще больше сократить количество шаблонного кода!

---

Посмотрите, сможете ли вы выяснить, почему каждый из следующих операторов switch не компилируется:

```
int month = 5;

switch month {   // DOES NOT COMPILE
   case 1: System.out.print("January");
}

switch(month)   // DOES NOT COMPILE
   case 1: System.out.print("January");
   
switch(month) {
   case 1: 2: System.out.print("January"); // DOES NOT COMPILE
}
```

Первый оператор switch не компилируется, поскольку в нем отсутствуют круглые скобки вокруг переменной switch. 
Вторая инструкция не компилируется, потому что в ней отсутствуют фигурные скобки вокруг тела переключателя. 
Третий оператор не компилируется, потому что для разделения операторов комбинированного регистра следует использовать 
запятую (,), а не двоеточие (:).

Последнее замечание, о котором вам следует знать на экзамене: оператор switch не обязательно должен содержать 
какие-либо операторы case. Например, это утверждение совершенно справедливо:

```
switch(month) {}
```

Возвращаясь к нашему методу printDayOfWeek(), мы можем переписать его, чтобы использовать оператор switch вместо 
операторов if/else:

```
public void printDayOfWeek(int day) {
   switch(day) {
      case 0:
         System.out.print("Sunday");
         break;
      case 1:
         System.out.print("Monday");
         break;
      case 2:
         System.out.print("Tuesday");
         break;
      case 3:
         System.out.print("Wednesday");
         break;
      case 4:
         System.out.print("Thursday");
         break;
      case 5:
         System.out.print("Friday");
         break;
      case 6:
         System.out.print("Saturday");
         break;
      default:
         System.out.print("Invalid value");
         break;
 } }
```

Для простоты мы просто печатаем сообщение, если значение недопустимо. Если вы знаете об исключениях или уже прочитали 
главу 11 “Исключения и локализация”, возможно, имеет смысл создать исключение в ветке по умолчанию, если совпадение 
не найдено.

### Выход с операторами break (Exiting with break Statements)

Взглянув на нашу предыдущую реализацию printDayOfWeek(), вы увидите оператор break в конце каждого раздела case и 
default. Оператор break завершает оператор switch и возвращает управление потоком окружающему процессу. Проще говоря, 
он немедленно завершает оператор switch.

Операторы break необязательны, но без них код будет выполнять каждую ветвь, следующую за соответствующим оператором 
case, включая все найденные операторы по умолчанию. Без операторов break в каждой ветви порядок операторов 
case и default теперь чрезвычайно важен. Как вы думаете, что будет напечатано при вызове printSeason(2)?

```
public void printSeason(int month) {
   switch(month) {
      case 1, 2, 3: System.out.print("Winter");
      case 4, 5, 6: System.out.print("Spring");
      default: System.out.print("Unknown");
      case 7, 8, 9: System.out.print("Summer");
      case 10, 11, 12: System.out.print("Fall");
} }
```

Он печатает все!

```
WinterSpringUnknownSummerFall
```

Он соответствует первому оператору case и выполняет все ветви в том порядке, в котором они найдены, включая оператор 
по умолчанию. Обычно, хотя, конечно, и не обязательно, использовать оператор break после каждого оператора case.

---

_Создателям экзамена нравятся примеры переключения, в которых отсутствуют операторы break! При оценке операторов switch 
на экзамене всегда учитывайте, что за одно выполнение можно посетить несколько ветвей._

---

### Выбор типов данных переключателя (Selecting switch Data Types)

Как показано на рисунке 3.3, оператор switch имеет целевую переменную, которая не вычисляется до выполнения. Тип этого 
целевого объекта может включать выбранные примитивные типы данных (int, byte, short, char) и связанные с ними 
классы-оболочки (Integer, Byte, Short, Character). Ниже приведен список всех типов данных, поддерживаемых операторами 
switch:

+ int и Integer
+ byte и Byte
+ short и Short
+ char и Character
+ String
+ enum values
+ var (если тип преобразуется в один из предыдущих типов)

Для этой главы вам просто нужно знать, что перечисление, или enum, представляет собой фиксированный набор констант, 
таких как дни недели, месяцы года и так далее. Мы рассмотрим перечисления более подробно в главе 7, включая 
демонстрацию того, как они могут определять переменные, методы и конструкторы.

---

_Обратите внимание, что boolean, long, float и double исключены из операторов switch, как и связанные с ними классы 
Boolean, Long, Float и Double. Причины разнообразны, например, boolean значение, имеющее слишком малый диапазон 
значений, и числа с плавающей запятой, имеющие довольно широкий диапазон значений. Однако для экзамена вам просто нужно 
знать, что они не разрешены в операторах switch._

---

### Определение допустимых значений регистра (Determining Acceptable Case Values)

В операторе case можно использовать не любую переменную или значение. Во-первых, значения в каждом операторе case 
должны быть постоянными значениями времени компиляции того же типа данных, что и значение переключателя. Это означает, 
что вы можете использовать только литералы, константы перечисления или окончательные постоянные переменные одного и 
того же типа данных. Под финальной константой мы подразумеваем, что переменная должна быть помечена модификатором final 
и инициализирована литеральным значением в том же выражении, в котором она объявлена. Например, у вас не может быть 
значения оператора case, требующего выполнения метода во время выполнения, даже если этот метод всегда возвращает одно 
и то же значение. По этим причинам компилируются только первый и последний операторы case в следующем примере:

_В операторе case может быть использована не только любая переменная или значение. Во-первых, значения в каждом 
операторе case должны быть постоянными значениями времени компиляции того же типа данных, что и значение switch. Это 
означает, что вы можете использовать только литералы, константы перечисления или конечные постоянные переменные того же 
типа данных. Под конечной константой мы подразумеваем, что переменная должна быть помечена модификатором final и 
инициализирована буквальным значением в том же выражении, в котором она объявлена. Например, у вас не может быть 
значения инструкции case, которое требует выполнения метода во время выполнения, даже если этот метод всегда возвращает 
одно и то же значение. По этим причинам в следующем примере компилируются только первый и последний операторы case:_

```
final int getCookies() { return 4; }
void feedAnimals() {
   final int bananas = 1;
   int apples = 2;
   int numberOfAnimals = 3;
   final int cookies = getCookies();
   switch(numberOfAnimals) {
      case bananas:
      case apples:        // DOES NOT COMPILE
      case getCookies():  // DOES NOT COMPILE
      case cookies :      // DOES NOT COMPILE
      case 3 * 5 :
} }
```

Переменная bananas помечена как final, и ее значение известно во время компиляции, поэтому оно допустимо. 
Переменная apples не помечена как final, даже если ее значение известно, поэтому она не разрешена. Следующие два 
оператора case со значениями getCookies() и cookies не компилируются, поскольку методы не вычисляются до выполнения, 
поэтому их нельзя использовать в качестве значения оператора case, даже если одно из значений хранится в конечной 
переменной. Последний оператор case со значением 3 * 5 действительно компилируется, поскольку выражения разрешены в 
качестве значений регистра, при условии, что значение может быть разрешено во время компиляции. Они также должны быть в 
состоянии вписаться в тип данных switch без явного приведения. Вскоре мы рассмотрим это более подробно.

Далее, тип данных для операторов case должен совпадать с типом данных переменной-переключателя. Например, у вас не 
может быть оператора case типа String, если переменная оператора switch имеет тип int, поскольку эти типы несравнимы.

### Выражение переключателя (или Выражение оператора switch) (The switch Expression)

Наша вторая реализация printDayOfWeek() была улучшена, но все еще довольно длинная. Обратите внимание, что там было 
много шаблонного кода, а также многочисленные инструкции break. Можем ли мы сделать лучше? Да, благодаря новым 
выражениям switch, которые были официально добавлены в Java 14.

Выражение switch — это гораздо более компактная форма оператора switch, способная возвращать значение. 
Взгляните на новый синтаксис на рис. 3.4.

Поскольку выражение switch представляет собой компактную форму, на рис. 3.4 происходит многое! Во-первых, теперь мы 
можем присвоить результат выражения переключения переменной result. Чтобы это работало, все ветви case и default должны 
возвращать тип данных, совместимый с назначением. Выражение switch поддерживает два типа ветвей: выражение и блок. 
Каждый из них имеет различные синтаксические правила о том, как он должен быть создан. Подробнее об этих темах в 
ближайшее время.

#### Рис. 3.4 - Структура выражения переключения

Подобно традиционному оператору switch, выражение switch поддерживает ноль или множество ветвей case и необязательную 
ветвь по умолчанию. Оба также поддерживают новую функцию, позволяющую объединять значения case с одним оператором case 
с помощью запятых. Однако, в отличие от традиционного оператора switch, выражения switch имеют специальные правила, 
когда требуется ветвь по умолчанию.

---

_Напомним из главы 2, “Операторы”, что -> - это оператор стрелки. Хотя оператор стрелки обычно используется в 
лямбда-выражениях, когда он используется в выражении switch, ветви регистра не являются лямбдами._

---

Мы можем переписать наш предыдущий метод printDayOfWeek() гораздо более лаконичным образом, используя выражения case:

```
public void printDayOfWeek(int day) {
   var result = switch(day) {
      case 0 -> "Sunday";
      case 1 -> "Monday";
      case 2 -> "Tuesday";
      case 3 -> "Wednesday";
      case 4 -> "Thursday";
      case 5 -> "Friday";
      case 6 -> "Saturday";
      default -> "Invalid value";
   };
   System.out.print(result);
}
```

Сравните этот код с оператором switch, который мы написали ранее. Оба выполняют одну и ту же задачу, но большая часть 
шаблонного кода была удалена, оставив то поведение, которое нас больше всего волнует.

Обратите внимание, что после каждого выражения switch требуется точка с запятой. Например, следующий код не 
компилируется. Сколько точек с запятой не хватает?

```
var result = switch(bear) {
   case 30 -> "Grizzly"
   default -> "Panda"
}
```

Ответ - три. Для каждого case или default требуется точка с запятой, а также само присвоение. 
Следующее исправляет код:

```
var result = switch(bear) {
   case 30 -> "Grizzly";
   default -> "Panda";
};
```

Как показано на рисунке 3.4, операторы case могут принимать несколько значений, разделенных запятыми.
Давайте перепишем наш метод printSeason() из предыдущего, используя выражение switch:

```
public void printSeason(int month) {
   switch(month) {
      case 1, 2, 3 -> System.out.print("Winter");
      case 4, 5, 6 -> System.out.print("Spring");
      case 7, 8, 9 -> System.out.print("Summer");
      case 10, 11, 12 -> System.out.print("Fall");
} }
```

Вызов printSeason(2) выводит единственное значение Winter. На этот раз нам не нужно беспокоиться об операторах break, 
так как выполняется только одна ветвь.

---

_В большинстве случаев выражение switch возвращает значение, хотя метод printSeason() демонстрирует значение, в котором 
возвращаемый тип является void. Поскольку тип является void, он не может быть присвоен переменной. На экзамене вы, 
скорее всего, увидите выражение switch, которое возвращает значение, но вы должны знать, что это возможно._

---

Все предыдущие правила, касающиеся switch типов данных и значений case, по-прежнему применяются, хотя у нас есть 
несколько новых правил. Не волнуйтесь, если эти правила для вас новы или вы никогда раньше не встречали ключевое 
слово yield; мы обсудим их в следующих разделах.

1. Все ветви выражения switch, которые не генерируют исключение, должны возвращать согласованный тип данных 
(если выражение switch возвращает значение).
2. Если выражение switch возвращает значение, то каждая ветвь, которая не является выражением, должна выдавать значение.
3. Ветвь default требуется, если не охвачены все случаи или не возвращается значение.

Мы кратко рассмотрим последнее правило, но обратите внимание, что наш пример printSeason() не содержит ветки default. 
Поскольку выражение switch не возвращает значение и не присваивает его переменной, оно совершенно необязательно.

---

_Java 17 также поддерживает сопоставление шаблонов в выражениях switch, но поскольку это функция предварительного 
просмотра, она не рассматривается в рамках экзамена._

---

### Возврат согласованных (или совместимых) типов данных (Returning Consistent Data Types)

Первое правило использования выражения switch, вероятно, самое простое. Вы не можете возвращать несовместимые или 
случайные типы данных. Например, можете ли вы понять, почему три строки следующего кода не компилируются?

```
int measurement = 10;
int size = switch (measurement) {
   case 5 -> 1;
   case 10 -> (short) 2;
   default -> 5;
   case 20 -> "3";   // DOES NOT COMPILE
   case 40 -> 4L;    // DOES NOT COMPILE
   case 50 -> null;  // DOES NOT COMPILE
};
```

Обратите внимание, что второе case-выражение возвращает short, но его можно неявно привести к типу int. 
Таким образом, значения должны соответствовать size, но не обязательно все они должны быть одного типа данных. 
Последние три case-выражения не компилируются, поскольку каждое из них возвращает тип, который нельзя присвоить 
переменной int.

### Применение блока case (Applying a case Block)

Выражение switch поддерживает как выражение, так и блок в ветвях case и default. Как и обычный блок, 
case блок - это блок, заключенный в фигурные скобки ({}). Он также включает в себя оператор yield, если выражение 
switch возвращает значение. Например, в приведенном ниже примере используется сочетание case выражений и блоков:

```
int fish = 5;
int length = 12;
var name = switch (fish) {
   case 1 -> "Goldfish";
   case 2 -> {yield "Trout";}
   case 3 -> {
      if (length > 10) yield "Blobfish";
      else yield "Green";
   }
   default -> "Swordfish";
};
```

Ключевое слово yield эквивалентно оператору return в выражении switch и используется, чтобы избежать двусмысленности в 
отношении того, имели ли вы в виду выход из блока или метода вокруг выражения switch.

Ссылаясь на наше второе правило для выражений switch, операторы yield не являются необязательными, если оператор 
switch возвращает значение. Можете ли вы понять, почему следующие строки не компилируются?

```
10: int fish = 5;
11: int length = 12;
12: var name = switch (fish) {
13:    case 1 -> "Goldfish";
14:    case 2 -> {} // DOES NOT COMPILE
15:    case 3 -> {
16:       if (length > 10) yield "Blobfish";
17:    }  // DOES NOT COMPILE
18:    default -> "Swordfish";
19: };
```

Строка 14 не компилируется, так как не возвращает значение с помощью yield. Строка 17 тоже не компилируется. 
Хотя код возвращает значение для length больше 10, он не возвращает значение, если length меньше или равна 10. 
Не имеет значения, что length установлена равной 12; все ветви должны возвращать значение в блоке case.

---

#### Следите за точками с запятой в выражениях switch (Watch Semicolons in switch Expressions) 

В отличие от обычного оператора switch, выражение switch может использоваться с оператором присваивания, и при этом 
требуется точка с запятой. Кроме того, точки с запятой обязательны для выражений регистра, но не могут использоваться 
с блоками регистра.

```
var name = switch (fish) {
   case 1 -> "Goldfish" // DOES NOT COMPILE (missing semicolon)
   case 2 -> {yield "Trout";}; // DOES NOT COMPILE (extra semicolon)
   ...
} // DOES NOT COMPILE (missing semicolon)
```

Немного запутанно, правда? Это всего лишь одна из тех вещей, которые вы должны приучить себя замечать на экзамене.

---

### Покрытие всех возможных значений (Covering All Possible Values)

Последнее правило, касающееся выражений переключения, вероятно, является тем, на котором экзамен, скорее всего, 
попытается вас обмануть: выражение переключения, возвращающее значение, должно обрабатывать все возможные входные 
значения. И, как вы видели ранее, когда он не возвращает значение, это необязательно.

Давайте попробуем это сделать. Учитывая следующий код, каково значение type, если canis равно 5?

```
String type = switch (canis) { // DOES NOT COMPILE
   case 1 -> "dog";
   case 2 -> "wolf";
   case 3 -> "coyote";
};
```

Нет ветки case для 5 (или 4, -1, 0 и т. д.), поэтому должно ли выражение switch возвращать null, пустую строку, 
undefined или какое-то другое значение? При добавлении выражений switch в язык Java авторы решили, что такое 
поведение не будет поддерживаться. Каждое выражение switch должно обрабатывать все возможные значения переменной 
switch. У разработчика есть два способа решить эту проблему:

+ Добавить ветку default.
+ Если выражение switch принимает значение enum, добавьте ветвь case для каждого возможного значения enum.

На практике чаще всего используется первое решение. Второе решение применимо только к выражениям switch, которые 
принимают перечисление. Вы можете попробовать написать операторы case для всех возможных значений int, но мы обещаем, 
что это не сработает! Даже меньшие типы, такие как byte, не разрешены компилятором, несмотря на то, что существует 
только 256 возможных значений.

Для перечислений второе решение хорошо работает, когда число значений перечисления относительно невелико. Например, 
рассмотрим следующее определение перечисления и метод:

```
enum Season {WINTER, SPRING, SUMMER, FALL}

String getWeather(Season value) {
   return switch (value) {
      case WINTER -> "Cold";
      case SPRING -> "Rainy";
      case SUMMER -> "Hot";
      case FALL -> "Warm";
   };
}
```

Поскольку охватываются все возможные перестановки Season, в этом выражении switch не требуется ветвь default. 
Однако вы можете включить необязательную ветвь default, даже если вы охватываете все известные значения.

---

What happens if you use an enum with three values and later someone adds a fourth value? Any switch expressions that use the enum without a default branch will suddenly fail to compile. If this was done frequently, you might have a lot of code to fix! For this reason, consider including a default branch in every switch expression, even those that involve enum values.

**Что произойдет, если вы используете перечисление с тремя значениями, а позже кто-то добавит четвертое значение? Любые выражения switch, использующие перечисление без ветви по умолчанию, внезапно не смогут скомпилироваться. Если бы это делалось часто, вам, возможно, пришлось бы исправлять много кода! По этой причине рассмотрите возможность включения ветви по умолчанию в каждое выражение switch, даже в те, которые включают значения enum.**

_Что произойдет, если вы используете перечисление с тремя значениями, а позже кто-то добавит четвертое значение? Любые выражения переключения, использующие перечисление без ветки по умолчанию, внезапно не смогут скомпилироваться. Если это делалось часто, у вас может быть много кода для исправления! По этой причине рассмотрите возможность включения ветки по умолчанию в каждое выражение переключателя, даже в те, которые включают значения перечисления._

---

## Написание циклов (или цикла) while

Обычной практикой при написании программного обеспечения является выполнение одной и той же задачи несколько раз.
Вы можете использовать структуры решений, которые мы представили до сих пор, чтобы добиться этого, но это будет 
довольно длинная цепочка операторов if или else, особенно если вам нужно выполнить одно и то же 100 или более раз.

Вводите циклы! Цикл - это повторяющаяся структура управления, которая может выполнять инструкцию кода несколько раз 
подряд. При использовании переменных, которым могут быть присвоены новые значения, каждое повторение инструкции может 
отличаться. Следующий цикл выполняется ровно 10 раз:

```
int counter = 0;
while (counter < 10) {
   double price = counter * 10;
   System.out.println(price);
   counter++;
}
```

Если вы не следуете этому коду, не паникуйте — мы скоро расскажем об этом. В этом разделе мы обсудим цикл while и две 
его формы. В следующем разделе мы перейдем к циклам for, корнями которых являются циклы while.

### Оператор while

Простейшей повторяющейся структурой управления в Java является оператор while, описанный на рис. 3.5. Как и все 
структуры управления повторением, он имеет условие завершения, реализованное в виде логического выражения, которое 
будет продолжаться до тех пор, пока выражение принимает значение true.

#### Рис. 3.5 - Структура оператора while

Как показано на рис. 3.5, цикл while похож на оператор if в том смысле, что он состоит из логического выражения и 
оператора или блока операторов (или 'и инструкции или блока инструкций.'). Во время выполнения логическое выражение 
оценивается перед каждой итерацией цикла и завершается, если оценка возвращает false.

Давайте посмотрим, как можно использовать цикл для моделирования мыши, которая ест:

```
int roomInBelly = 5;
public void eatCheese(int bitesOfCheese) {
   while (bitesOfCheese > 0 && roomInBelly > 0) {
      bitesOfCheese--;
      roomInBelly--;
   }
   System.out.println(bitesOfCheese+" pieces of cheese left");
}
```

Этот метод требует некоторого количества пищи — в данном случае сыра — и продолжается до тех пор, пока у мыши не 
останется места в животе или не останется еды. С каждой итерацией цикла мышь «съедает» один кусочек пищи и теряет одно 
место в животе. Используя составной логический оператор, вы гарантируете, что цикл while может завершиться для любого 
из условий.

Следует помнить, что цикл while может завершиться после первого вычисления логического(boolean) выражения. Например, 
сколько раз Not null! напечатано в следующем примере?

```
int full = 5;
while (full < 5) {
   System.out.println("Not full!");
   full++;
}
```

Ответ? Нуль! На первой итерации цикла условие достигается и цикл завершается. Вот почему циклы while часто используются 
там, где вы ожидаете ноль или более циклов. Проще говоря, тело цикла может вообще не выполняться или выполняться много 
раз.

### Оператор do/while 

Вторая форма, которую может принимать цикл while, называется циклом do/while, который, как и цикл while, представляет 
собой структуру управления повторением с условием завершения и оператором или блоком операторов, как показано 
на рис. 3.6.

#### Рис. 3.6 - Структура оператора do/while

Однако, в отличие от цикла while, цикл do/while гарантирует, что оператор или блок будут выполнены хотя бы один раз. 
Например, каков результат следующих утверждений?

```
int lizard = 0;
do {
    lizard++;
} while(false);
System.out.println(lizard); // 1
```

Java сначала выполнит блок операторов, а затем проверит условие цикла. Несмотря на то, что цикл завершается сразу же, 
блок операторов все равно выполняется один раз, и программа выводит 1.

### Бесконечные(-й) циклы (Infinite Loops)

Самая важная вещь, о которой вы должны знать, когда используете любые структуры управления повторением, это убедиться, 
что они всегда заканчиваются! Невыполнение цикла может привести к многочисленным проблемам на практике, включая 
исключения переполнения, утечки памяти, низкую производительность и даже неверные данные. Давайте посмотрим на пример:

```
int pen = 2;
int pigs = 5;
while (pen < 10)
   pigs++;
```

Вы можете заметить одну вопиющую проблему с этим утверждением: это никогда не закончится. Переменная pen никогда не 
изменяется, поэтому выражение (pen < 10) всегда будет иметь значение true. В результате цикл никогда не закончится, 
создавая то, что обычно называют бесконечным циклом. Бесконечный цикл - это цикл, условие завершения которого никогда 
не достигается во время выполнения.

Каждый раз, когда вы пишете цикл, вы должны проверять его, чтобы определить, всегда ли условие завершения в конечном 
итоге выполняется при каком-либо условии. Например, цикл, в котором никакие переменные не изменяются между двумя 
исполнениями, предполагает, что условие завершения может не выполняться. Переменные цикла всегда должны двигаться в 
определенном направлении.

Другими словами, убедитесь, что условие цикла или переменные, от которых зависит условие, меняются между выполнением. 
Затем убедитесь, что условие прекращения будет в конечном итоге достигнуто при любых обстоятельствах. Как вы узнаете из 
последнего раздела этой главы, цикл может существовать и при других условиях, таких как оператор break.

## Построение циклов for

1/1 Несмотря на то, что операторы while и do/while весьма эффективны, некоторые задачи настолько распространены при написании программного обеспечения, что были созданы специальные типы циклов — например, итерация по оператору ровно 10 раз или по списку имен. Вы могли бы легко выполнить эти задачи с помощью различных циклов while, которые вы видели до сих пор, но они обычно требуют большого количества шаблонного кода. Разве не было бы здорово, если бы существовала циклическая структура, которая могла бы делать то же самое в одной строке кода?

1/2 Несмотря на то, что операторы while и do/while довольно мощные, некоторые задачи настолько распространены при написании программного обеспечения, что были созданы специальные типы циклов — например, повторение инструкции ровно 10 раз или перебор списка имен. Вы могли бы легко выполнить эти задачи с помощью различных циклов while, которые вы видели до сих пор, но они обычно требуют большого количества шаблонного кода. Разве не было бы здорово, если бы существовала циклическая структура, которая могла бы делать то же самое в одной строке кода?

1/3 При этом мы представляем наиболее удобную структуру управления повторением для циклов. Существует два типа циклов for, хотя оба используют одно и то же ключевое слово for. Первый называется базовым циклом for, а второй часто называют расширенным циклом for. Для ясности мы называем их циклом for и циклом for-each соответственно на протяжении всей книги.

1/4 При этом мы представляем наиболее удобную структуру управления повторением для циклов. Существует два типа циклов for, хотя в обоих используется одно и то же ключевое слово for. Первый называется базовым циклом for, а второй часто называют расширенным циклом for. Для наглядности на протяжении всей книги мы называем их циклом for и циклом for-each соответственно.

### Цикл for










