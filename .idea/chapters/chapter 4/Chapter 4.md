# Основные API

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Обработка даты, времени, текста, числовых и логических значений

+ Используйте примитивы и классы-оболочки, включая Math API, круглые скобки, продвижение(или повышение) и 
приведение типов для вычисления арифметических и логических выражений
+ Манипулируйте текстом, включая текстовые блоки, используя классы String и StringBuilder
+ Манипулируйте датой, временем, продолжительностью, периодом, мгновенными объектами и объектами часового пояса с 
помощью Date-Time API

#### Работа с массивами и коллекциями

+ Создавайте массивы Java, коллекции List, Set, Map и Deque, а также добавляйте, удаляйте, обновляйте, извлекайте и 
сортируйте их элементы

---

В контексте интерфейса прикладного программирования (API) интерфейс относится к группе классов или определений 
интерфейса Java, предоставляющих вам доступ к функциональности.

В этой главе вы узнаете о многих основных структурах данных в Java, а также о наиболее распространенных API для доступа 
к ним. Например, String и StringBuilder вместе со связанными с ними API используются для создания текстовых данных и 
управления ими. Затем мы покрываем массивы. Наконец, мы изучаем математические API и API даты/времени.

## Создание и манипулирование строками

Класс String - это настолько фундаментальный класс, что вам было бы трудно писать код без него. В конце концов, вы даже 
не можете написать метод main() без использования класса String. Строка - это, по сути, последовательность символов; 
вот пример:

```
String name = "Fluffy";
```

Как вы узнали из главы 1 “Строительные блоки”, это пример ссылочного типа. Вы также узнали, что ссылочные типы создаются
с использованием ключевого слова new. Подождите минуту. В предыдущем примере чего-то не хватает: в нем нет new! В Java 
эти два фрагмента создают строку:

```
String name = "Fluffy";
String name = new String("Fluffy");
```

Оба дают вам ссылочную переменную с именем name, указывающую на объект String "Fluffy". Как вы увидите далее в этой 
главе, они немного отличаются. А пока просто помните, что класс String особенный и его не нужно создавать с помощью new.

Кроме того, текстовые блоки — это ещё один способ создания String. Для обзора этот текстовый блок такой же, как и 
предыдущие переменные:

```
String name = """
              Fluffy""";
```

Поскольку String - это последовательность символов, вы, вероятно, не удивитесь, услышав, что она реализует интерфейс 
CharSequence. Этот интерфейс представляет собой общий способ представления нескольких классов, включая String и 
StringBuilder. Вы узнаете больше об интерфейсах в главе 7 “За пределами классов”.

В этом разделе мы рассмотрим конкатенацию, общие методы и цепочку методов.

### Конкатенация

В главе 2 «Операторы» вы узнали, как складывать числа. 1 + 2 — это явно 3. Но что такое «1» + «2»? Это «12», потому что 
Java объединяет два объекта String. Размещение одной строки перед другой строкой и их объединение называется 
конкатенацией строк. Создателям экзамена нравится конкатенация строк, потому что оператор + можно использовать двумя 
способами в одной строке кода. Для этого не так много правил, но вы должны их хорошо знать:

1. Если оба операнда являются числовыми, + означает числовое сложение.
2. Если любой из операндов является строкой, + означает конкатенацию.
3. Выражение оценивается слева направо.

Теперь давайте рассмотрим несколько примеров:

```
System.out.println(1 + 2);             // 3
System.out.println("a" + "b");         // ab
System.out.println("a" + "b" + 3);     // ab3
System.out.println(1 + 2 + "c");       // 3c
System.out.println("c" + 1 + 2);       // c12
System.out.println("c" + null);        // cnull
```

В первом примере используется первое правило. Оба операнда являются числами, поэтому мы используем обычное сложение. 
Второй пример — простая конкатенация строк, описанная во втором правиле. Кавычки для строки используются только в коде; 
они не получают выход.

Третий пример объединяет второе и третье правила. Поскольку мы начинаем слева, Java выясняет, чему соответствует 
"a" + "b". Вы уже знаете это: это «ab». Затем Java просматривает оставшееся выражение «ab» + 3. Второе правило говорит 
нам о конкатенации, поскольку один из операндов является строкой.

В четвертом примере мы начинаем с третьего правила, которое говорит нам рассмотреть 1 + 2. Оба операнда являются 
числовыми, поэтому первое правило говорит нам, что ответ равен 3. Затем у нас есть 3 + «с», которое использует второе 
правило, чтобы дать нам "3c". Заметили, что все три правила используются в одной строке?

Пятый пример показывает важность третьего правила. Сначала у нас есть "c" + 1, который использует второе правило, чтобы 
дать нам "c1". Затем у нас есть «c1» + 2, который снова использует второе правило, чтобы дать нам «c12».

Наконец, последний пример показывает, как null представляется в виде строки при объединении или печати, что дает нам 
«cnull».

Экзамен делает ещё один шаг вперед и попытается одурачить вас чем-то вроде этого:

```
int three = 3;
String four = "4";
System.out.println(1 + 2 + three + four);
```

Когда вы увидите это, просто не торопитесь, запомните три правила и обязательно проверьте типы переменных. В этом 
примере мы начинаем с третьего правила, которое говорит нам рассмотреть 1 + 2.

Первое правило дает нам 3. Далее у нас есть 3 + three. Поскольку число three имеет тип int, мы по-прежнему используем 
первое правило, что дает нам число 6. Тогда у нас есть 6 + four. Так как четыре имеет тип String, мы переключаемся на 
второе правило и получаем окончательный ответ «64». Когда вы видите такие вопросы, просто не торопитесь и проверьте 
типы. Методичность окупается.

Есть еще одна вещь, которую нужно знать о конкатенации, но это несложно. В этом примере вам просто нужно помнить, что 
делает +=. Имейте в виду, что s += "2" означает то же самое, что и s = s + "2".

```
4: var s = "1";                // s currently holds "1"
5: s += "2";                   // s currently holds "12"
6: s += 3;                     // s currently holds "123"
7: System.out.println(s);      // 123
```

В строке 5 мы «добавляем» две строки, что означает их конкатенацию. Строка 6 пытается обмануть вас, добавляя число, но 
это точно так же, как мы написали s = s + 3. Мы знаем, что строка «плюс» что-либо еще означает использование 
конкатенации.

Чтобы просмотреть правила еще раз: используйте числовое сложение, если участвуют два числа, используйте конкатенацию в 
противном случае и оценивайте слева направо. Вы уже выучили эти три правила? Обязательно сделайте это перед экзаменом!


## Важные методы String

Класс String имеет десятки методов. К счастью, для экзамена вам нужно знать лишь несколько. Создатели экзамена выбирают 
большинство методов, которые разработчики используют в реальном мире.

Для всех этих методов вам нужно помнить, что строка представляет собой последовательность символов, а Java отсчитывает 
от 0 при индексации. На рис. 4.1 показано, как индексируется каждый символ в строке «animals».

#### Рис. 4.1 - Индексация для строки

Вам также необходимо знать, что String является неизменяемым или неизменным. Это означает, что вызов метода для 
String вернет другой объект String, а не изменит значение ссылки. В этой главе вы используете неизменяемые объекты. 
В главе 6 “Проектирование классов” вы узнаете, как создавать собственные неизменяемые объекты.

Давайте рассмотрим несколько методов класса String. Многие из них просты, поэтому мы не будем подробно их обсуждать. 
Вы должны знать, как использовать эти методы.

### Определение длины

Метод length() возвращает количество символов в строке. Сигнатура метода выглядит следующим образом:

```
public int length()
```

Следующий код показывает, как использовать length():

```
var name = "animals";
System.out.println(name.length());  // 7
```

Ждать. Выдает 7? Разве мы только что не говорили вам, что Java считает с 0? Разница в том, что нулевой подсчет 
происходит только тогда, когда вы используете индексы или позиции в списке. При определении общего размера или длины 
Java снова использует обычный подсчет.

### Получение одного символа

Метод charAt() позволяет вам запросить строку, чтобы узнать, какой символ находится в определенном индексе. 
Сигнатура метода выглядит следующим образом:

```
public char charAt(int index)
```

Следующий код показывает, как использовать charAt():

```
var name = "animals";
System.out.println(name.charAt(0));  // a
System.out.println(name.charAt(6));  // s
System.out.println(name.charAt(7));  // exception
```

Поскольку индексы начинают считать с 0, charAt(0) возвращает «первый» символ в последовательности. Точно так же 
charAt(6) возвращает «седьмой» символ в последовательности. Однако проблема с charAt(7). Он запрашивает «восьмой» 
символ в последовательности, но присутствует только семь символов. Когда что-то идет не так, с чем Java не знает, что 
делать, она генерирует исключение, как показано здесь. Вы узнаете больше об исключениях в главе 11, «Исключения и 
локализация».

```
java.lang.StringIndexOutOfBoundsException: String index out of range: 7
```

### Поиск индекса

Метод indexOf() просматривает символы в строке и находит первый индекс, соответствующий нужному значению. Метод indexOf 
может работать с отдельным символом или целой строкой в качестве входных данных. Он также может начинаться с 
запрошенной позиции. Помните, что char может быть передан в тип параметра int. На экзамене вы увидите только символ, 
переданный в параметры с именем ch. Сигнатуры методов следующие:

```
public int indexOf(int ch)

public int indexOf(int ch, int fromIndex)
public int indexOf(String str)
public int indexOf(String str, int fromIndex)
```

Следующий код показывает, как использовать indexOf():

```
var name = "animals";
System.out.println(name.indexOf('a'));       // 0
System.out.println(name.indexOf("al"));      // 4
System.out.println(name.indexOf('a', 4));    // 4
System.out.println(name.indexOf("al", 5));   // -1
```

Поскольку индексы начинаются с 0, первая буква «а» соответствует этой позиции. Второй оператор ищет более конкретную 
строку, поэтому она соответствует позже. Третий оператор говорит, что Java не должен смотреть на символы, пока не 
доберется до индекса 4. Последний оператор ничего не находит, потому что он начинает искать после совпадения. В отличие 
от charAt(), метод indexOf() не генерирует исключение, если не может найти совпадение, вместо этого возвращает -1. 
Поскольку индексы начинаются с 0, вызывающая сторона знает, что -1 не может быть допустимым индексом. Это делает 
обычным значением для метода указание вызывающей стороне, что совпадение не найдено.

### Получение подстроки

Метод substring() также ищет символы в строке. Он возвращает части строки. Первый параметр — это индекс, с которого 
начинается возвращаемая строка. Как обычно, это индекс с отсчетом от нуля. Существует необязательный второй параметр, 
который является конечным индексом, на котором вы хотите остановиться.

Обратите внимание, мы сказали “остановиться на”, а не “включить”. Это означает, что параметру endIndex разрешено быть 
на единицу больше конца последовательности, если вы хотите остановиться в конце последовательности. Однако это было бы 
излишним, поскольку в этом случае вы могли бы полностью опустить второй параметр. В вашем собственном коде вы хотите 
избежать этой избыточности. Однако не удивляйтесь, если на экзамене он будет использоваться. Сигнатуры метода следующие:

```
public String substring(int beginIndex)
public String substring(int beginIndex, int endIndex)
```

Это помогает немного по-другому относиться к индексам для методов подстроки. Представьте, что индексы находятся прямо перед символом, на который они будут указывать. Рисунок 4.2 помогает визуализировать это. Обратите внимание, как стрелка с 0 указывает на символ, который будет иметь индекс 0. Стрелка с цифрой 1 указывает между символами с индексами 0 и 1. В строке семь символов. Поскольку Java использует индексы на основе нуля, это означает, что последний символ имеет индекс 6. Стрелка с 7 точками сразу после этого последнего символа. Это поможет вам помнить, что endIndex не выдает исключение, выходящее за пределы, когда оно находится на единицу дальше конца строки.

Это помогает думать об индексах немного по-другому для методов подстроки. Представьте, что индексы находятся прямо перед символом, на который они указывают. Рисунок 4.2 помогает визуализировать это. Обратите внимание, как стрелка с 0 указывает на символ, который должен иметь индекс 0. Стрелка с 1 указывает между символами с индексами 0 и 1. В строке семь символов. Так как Java использует индексы, начинающиеся с нуля, это означает, что последний символ имеет индекс 6. Стрелка с 7 указывает сразу после этого последнего символа. Это поможет вам помнить, что endIndex не выдает исключения за пределами диапазона, когда он находится за концом строки на единицу.

#### Рис. 4.2 - Индексы для подстроки


Следующий код показывает, как использовать substring():

```
var name = "animals";
System.out.println(name.substring(3));                   // mals
System.out.println(name.substring(name.indexOf('m')));   // mals
System.out.println(name.substring(3, 4));                // m
System.out.println(name.substring(3, 7));                // mals
```

Метод substring() - самый сложный строковый метод на экзамене. В первом примере говорится, что нужно брать символы, 
начиная с индекса 3 и заканчивая концом, что дает нам "mals". Во втором примере делается то же самое, но он вызывает 
indexOf() для получения индекса, а не жестко задает его. Это обычная практика при кодировании, потому что вы можете не 
знать индекс заранее.

В третьем примере говорится, что нужно брать символы, начинающиеся с индекса 3, до символа с индексом 4, но не включая 
его. Это сложный способ сказать, что нам нужна строка с одним символом: с индексом 3. В результате получается "m".
В последнем примере говорится, что нужно брать символы, начинающиеся с индекса 3, пока мы не дойдем до индекса 7. 
Поскольку индекс 7 совпадает с концом строки, это эквивалентно первому примеру.

Мы надеемся, что это не слишком сбило с толку. Следующие примеры менее очевидны:

```
System.out.println(name.substring(3, 3));  // empty string (пустая строка)
System.out.println(name.substring(3, 2));  // exception
System.out.println(name.substring(3, 8));  // exception
```

Первый пример в этом наборе печатает пустую строку. Запрос касается символов, начинающихся с индекса 3, пока мы не 
доберемся до индекса 3. Поскольку мы начинаем и заканчиваем с одним и тем же индексом, между ними нет символов. Второй 
пример в этом наборе вызывает исключение, потому что индексы не могут быть обратными. Java прекрасно знает, что она 
никогда не доберется до индекса 2, если начнет с индекса 3. В третьем примере предлагается продолжать до восьмого 
символа. Восьмой позиции нет, поэтому Java выдает исключение. Конечно, седьмого символа тоже нет, но зато есть 
невидимая позиция «конец строки».

Давайте рассмотрим это еще раз, так как функция substring() сложная. Метод возвращает строку, начинающуюся с 
запрошенного индекса. Если запрашивается конечный индекс, он останавливается прямо перед этим индексом. В противном 
случае он переходит в конец строки.

### Настройка регистра

После этого умственного упражнения приятно иметь методы, которые действуют именно так, как звучат! 
Эти методы упрощают преобразование ваших данных. Сигнатуры методов следующие:

```
public String toLowerCase()
public String toUpperCase()
```

В следующем коде показано, как использовать эти методы:

```
var name = "animals";
System.out.println(name.toUpperCase());      // ANIMALS
System.out.println("Abc123".toLowerCase());  // abc123
```

Эти методы делают то, что говорят. Метод toUpperCase() преобразует все символы нижнего регистра в верхний регистр в 
возвращаемой строке. Метод toLowerCase() преобразует любые символы верхнего регистра в нижний регистр в возвращаемой 
строке. Эти методы оставляют в покое любые символы, кроме букв. Кроме того, помните, что строки неизменяемы, поэтому 
исходная строка остается неизменной.

### Проверка на равенство

Метод equals() проверяет, содержат ли два объекта String одни и те же символы в одном и том же порядке. Метод 
equalsIgnoreCase() проверяет, содержат ли два объекта String одинаковые символы, за исключением того, что он игнорирует 
регистр символов. Сигнатуры методов следующие:

```
public boolean equals(Object obj)
public boolean equalsIgnoreCase(String str)
```

Возможно, вы заметили, что equals() принимает объект, а не строку. Это связано с тем, что метод одинаков для всех 
объектов. Если вы передадите что-то, что не является строкой, это просто вернет значение false. В отличие от этого, 
метод equalsIgnoreCase() применяется только к строковым объектам, поэтому он может принимать более конкретный тип в 
качестве параметра.

В Java значения String чувствительны к регистру. Это означает, что «abc» и «ABC» считаются разными значениями. 
Имея это в виду, следующий код показывает, как использовать эти методы:

```
System.out.println("abc".equals("ABC"));            // false
System.out.println("ABC".equals("ABC"));            // true
System.out.println("abc".equalsIgnoreCase("ABC"));  // true
```

Этот пример должен быть достаточно интуитивным. В первом примере значения не совсем совпадают. Во втором они точно 
такие же. В третьем они отличаются только регистром, но ничего страшного, потому что мы вызвали метод, который 
игнорирует различия в регистре.

---

#### Переопределение (Overriding) toString(), equals(Object), and hashCode()

Знание того, как правильно переопределять toString(), equals(Object) и hashCode(), в прошлом было частью 
сертификационных экзаменов Java. Как профессиональному разработчику Java, вам по-прежнему важно знать, по крайней мере, 
основные правила переопределения каждого из этих методов:

+ toString(): Метод toString() вызывается, когда вы пытаетесь напечатать объект или объединить объект со строкой. 
Обычно он переопределяется версией, которая печатает уникальное описание экземпляра, используя его поля экземпляра.
+ equals(Object): Метод equals(Object) используется для сравнения объектов, а реализация по умолчанию использует только 
оператор ==. Вы должны переопределять метод equals(Object) каждый раз, когда хотите удобно сравнить элементы на 
равенство, особенно если это требует проверки множества полей.
+ hashCode(): Каждый раз, когда вы переопределяете equals(Object), вы должны переопределить hashCode(), чтобы быть 
согласованным. Это означает, что для любых двух объектов, если значение a.equals(b) равно true, то значение 
a.hashCode()==b.hashCode() также должно быть true. Если они не согласованы, это может привести к неверным данным и 
побочным эффектам в коллекциях на основе хэша, таких как HashMap и HashSet.

Все эти методы обеспечивают реализацию по умолчанию в Object, но если вы хотите использовать их с умом, вы должны 
переопределить их.

---

### Поиск подстроки

Часто вам нужно выполнить поиск в строке большего размера, чтобы определить, содержится ли в ней подстрока. Методы 
startsWith() и endsWith() проверяют, соответствует ли предоставленное значение части строки. Метод contains() не столь 
специфичен; он ищет совпадения в любом месте строки. Сигнатуры метода следующие:

```
public boolean startsWith(String prefix)
public boolean endsWith(String suffix)
public boolean contains(CharSequence charSeq)
```

В следующем коде показано, как использовать эти методы:

```
System.out.println("abc".startsWith("a")); // true
System.out.println("abc".startsWith("A")); // false

System.out.println("abc".endsWith("c")); // true
System.out.println("abc".endsWith("a")); // false

System.out.println("abc".contains("b")); // true
System.out.println("abc".contains("B")); // false
```

Опять же, здесь нет ничего удивительного. Java выполняет проверку предоставленных значений с учетом регистра. Обратите 
внимание, что метод contains() является удобным методом, поэтому вам не нужно писать str.indexOf(otherString) != -1.

### Замена значений

Метод replace() выполняет простой поиск и замену в строке. Есть версия, которая принимает параметры char, а также 
версия, которая принимает параметры CharSequence. Сигнатуры методов следующие:

```
public String replace(char oldChar, char newChar)
public String replace(CharSequence target, CharSequence replacement)
```

В следующем коде показано, как использовать эти методы:

```
System.out.println("abcabc".replace('a', 'A'));   // AbcAbc
System.out.println("abcabc".replace("a", "A"));   // AbcAbc
```

В первом примере используется сигнатура первого метода, передающая параметры char. Во втором примере используется 
сигнатура второго метода, передающая String параметры.

### Удаление пробелов

Эти методы удаляют пустое пространство в начале и/или конце строки. Методы strip() и trim() удаляют пробелы в начале и 
в конце строки. С точки зрения экзамена пробел состоит из пробелов, а также символов \t (табуляция) и \n (новая строка). 
Другие символы, такие как \r (возврат каретки), также включаются в то, что обрезается. Метод strip() делает все то же, 
что и trim(), но поддерживает Unicode.

_Вам не нужно знать о Unicode для экзамена. Но если вы хотите проверить разницу, один из пробельных символов Unicode 
выглядит следующим образом:_

```
char ch = '\u2000';
```

Кроме того, метод stripLeading() удаляет пробелы в начале строки и оставляет их в конце. Метод stripTrailing() делает 
обратное. Он удаляет пробелы с конца строки и оставляет их в начале. Сигнатуры методов следующие:

```
public String strip()
public String stripLeading()
public String stripTrailing()
public String trim()
```

В следующем коде показано, как использовать эти методы:

```
System.out.println("abc".strip());          // abc
System.out.println("\t a b c\n".strip());   // a b c

String text = " abc\t ";
System.out.println(text.trim().length());            // 3
System.out.println(text.strip().length());           // 3
System.out.println(text.stripLeading().length());    // 5
System.out.println(text.stripTrailing().length());   // 4
```

Во-первых, помните, что \t — это одиночный символ. Обратная косая черта экранирует t для обозначения табуляции. 
В первом примере печатается исходная строка, поскольку в начале и в конце нет пробельных символов. Второй пример 
избавляется от ведущей табуляции, последующих пробелов и завершающей новой строки. Он оставляет пробелы в середине 
строки.

Остальные примеры просто печатают количество оставшихся символов. Вы можете видеть, что функции trim() и strip() 
оставляют одни и те же три символа «abc», потому что они удаляют как начальные, так и конечные пробелы. Метод 
stripLeading() удаляет только один пробел в начале строки. Он оставляет вкладку и пробел в конце. Метод stripTrailing() 
удаляет эти два символа в конце, но оставляет символ в начале строки.

### Работа с отступом

Теперь, когда Java поддерживает текстовые блоки, полезно иметь методы для работы с отступами. Оба они немного сложны, 
так что читайте внимательно!

```
public String indent(int numberSpaces)
public String stripIndent()
```

Метод indent() добавляет одинаковое количество пробелов в начало каждой строки, если вы передаете положительное число. 
Если вы передаете отрицательное число, он пытается удалить это количество пробельных символов с начала строки. Если вы 
передадите ноль, отступ не изменится.

_Если вы вызовете indent() с отрицательным числом и попытаетесь удалить больше пробелов, чем присутствует в начале 
строки, Java удалит все, что сможет найти._

Это кажется достаточно простым. Однако функция indent() также нормализует символы пробела. Что означает нормализация пробелов, спросите вы? Во-первых, в конец строки добавляется разрыв строки, если его там еще нет. Во-вторых, любые разрывы строк преобразуются в формат \n. Независимо от того, использует ли ваша операционная система \ r \ n (Windows) или \ n (Mac / Unix), Java будет стандартизировать \ n для вас.
or
Это кажется достаточно простым. Однако indent() также нормализует символы пробела. Вы спросите, что означает нормализация пробелов? Во-первых, в конец строки добавляется разрыв строки, если его еще нет. Во-вторых, любые разрывы строк преобразуются в формат \n. Независимо от того, использует ли ваша операционная система \r\n (Windows) или\n (Mac/Unix), Java стандартизирует \n для вас.

Метод stripIndent() полезен, когда String был построен с конкатенацией, а не с использованием текстового блока. Он избавляется от всех случайных пробелов. Это означает, что все непустые строки сдвигаются влево, поэтому из каждой строки удаляется одинаковое количество пробелов, а первый оставшийся символ не является пустым. Как и indent(), \r\n превращается в \n. Однако метод stripIndent() не добавляет разрыв строки в конце, если он отсутствует.
or
Метод stripIndent() полезен, когда строка была создана с помощью конкатенации, а не с использованием текстового блока. Это избавляет от всех случайных пробелов. Это означает, что все непустые строки сдвигаются влево, поэтому из каждой строки удаляется одинаковое количество пробелов, а первый оставшийся символ не является пустым. Как и indent(), \r\n превращается в \n. Однако метод stripIndent() не добавляет завершающий разрыв строки, если он отсутствует.

Что ж, это было очень много правил. В таблице 4.1 приведены ссылки, облегчающие их запоминание.

#### Таблица 4.1. - Правила для indent() и stripIndent()

|         Метод          |                                                     Изменение отступа                                                     | Нормализует существующие<br/>  разрывы строк | Добавляет разрыв строки<br/>  в конце, если он отсутствует |  
|:----------------------:|:-------------------------------------------------------------------------------------------------------------------------:|:--------------------------------------------:|:----------------------------------------------------------:|
| indent(n) where n > 0  |                                     Добавляет n пробелов<br/> в начало каждой строки                                      |                      Да                      |                             Да                             |
| indent(n) where n == 0 |                                                       Без изменений                                                       |                      Да                      |                             Да                             |
| indent(n) where n < 0  | Удаляет до n пробелов из каждой строки, при этом одинаковое<br/> количество символов удаляется из каждой непустой строки. |                      Да                      |                             Да                             |
|     stripIndent()      |                                          Удаляет все ведущие случайные пробелы                                            |                      Да                      |                            Нет                             |

Следующий код показывает, как использовать эти методы. Не волнуйтесь, если результаты окажутся не такими, как вы 
ожидаете. Мы объясняем каждый из них.

```
10: var block = """
11:             a
12:              b
13:             c""";
14: var concat = " a\n"
15:            + " b\n"
16:            + " c";
17: System.out.println(block.length());                  // 6
18: System.out.println(concat.length());                 // 9
19: System.out.println(block.indent(1).length());        // 10
20: System.out.println(concat.indent(-1).length());      // 7
21: System.out.println(concat.indent(-4).length());      // 6
22: System.out.println(concat.stripIndent().length());   // 6
```

Строки 10-16 создают аналогичные строки, используя текстовый блок и обычную строку соответственно. Мы говорим “похожий”,
потому что concat имеет пробельный символ в начале каждой строки, в то время как block - нет.

Строка 17 подсчитывает шесть символов в блоке: три буквы, пробел перед b и \n после a и b. Строка 18 подсчитывает девять символов в concat, которые представляют собой три буквы, один пробел перед a, два пробела перед b, один пробел перед c и \n после a и b. Считайте их сами. Если вы не понимаете, какие символы учитываются, это только еще больше запутает.
or
Строка 17 подсчитывает шесть символов в блоке, которые представляют собой три буквы, пробел перед b и \ n после a и b. Строка 18 подсчитывает девять символов в concat, которые представляют собой три буквы, один пробел перед a, два пробела перед b, один пробел перед c и \ n после a и b. Подсчитайте их сами. Если вы не понимаете, какие символы подсчитываются, это только еще больше запутает.

В строке 19 мы просим Java добавить один пробел к каждой из трех строк блока. Однако вывод говорит, что мы добавили 4 символа, а не 3, поскольку длина увеличилась с 6 до 10. Этот загадочный дополнительный символ появился благодаря нормализации конца строки. Поскольку текстовый блок не имеет разрыва строки в конце, indent() добавляет его!
or
В строке 19 мы просим Java добавить по одному пробелу к каждой из трех строк в блоке. Однако в выходных данных говорится, что мы добавили 4 символа, а не 3, поскольку длина увеличилась с 6 до 10. Этот таинственный дополнительный символ появился благодаря нормализации окончания строки. Поскольку текстовый блок не имеет разрыва строки в конце, функция indent() добавляет его!

В строке 20 мы удаляем по одному символу пробела из каждой из трех строк concat. Это дает длину семь. Мы начали с девяти, избавились от трех символов и добавили конечную нормализованную новую строку.
or
В строке 20 мы удаляем по одному пробелу из каждой из трех строк concat. Это дает длину семь. Мы начали с девяти, избавились от трех символов и добавили завершающую нормализованную новую строку.

В строке 21 мы просим Java удалить четыре пробела из тех же трех строк. Поскольку четырех пробельных символов нет, Java делает все возможное. Одиночный пробел удаляется перед a и c. Оба пробела удаляются перед b. Длина шесть должна иметь смысл здесь; мы удалили здесь на один символ больше, чем в строке 20.
or
В строке 21 мы просим Java удалить четыре пробельных символа из тех же трех строк. Поскольку в нем нет четырех пробельных символов, Java делает все возможное. Единственный пробел удаляется перед a и c. Оба пробела удаляются перед b. Длина в шесть должна иметь смысл здесь; мы удалили здесь на один символ больше, чем в строке 20.

Наконец, в строке 22 используется метод stripIndent(). Во всех строках есть хотя бы один пробельный символ. Поскольку не все они содержат два пробельных символа, метод избавляется только от одного символа в строке. Так как stripIndent() не добавляет новую строку, длина равна шести, что на три меньше исходных девяти.
or
Наконец, в строке 22 используется метод stripIndent(). Все строки содержат по крайней мере один пробел. Поскольку не все они содержат два пробельных символа, метод избавляется только от одного символа в строке. Поскольку stripIndent() не добавляет новую строку, длина равна шести, что на три меньше, чем исходные девять.

### Перевод побегов (Translating Escapes)

Когда мы экранируем символы, мы используем одну обратную косую черту. Например, \t — это табуляция. Если мы не хотим 
такого поведения, мы добавляем ещё одну обратную косую черту, чтобы избежать обратной косой черты, поэтому 
\\t — буквальная строка \t. Метод translateEscapes() берет эти литералы и превращает их в эквивалентные экранированные 
символы. Сигнатура метода выглядит следующим образом:

```
public String translateEscapes()
```

В следующем коде показано, как использовать эти методы:

```
var str = "1\\t2";
System.out.println(str);                     // 1\t2
System.out.println(str.translateEscapes());  // 1 2
```

Первая строка выводит литеральную строку \t, потому что обратная косая черта экранирована. Вторая строка выводит 
фактическую вкладку, так как мы перевели escape. Этот метод можно использовать для управляющих последовательностей, 
таких как \t (табуляция), \n (новая строка), \s (пробел), \" (двойная кавычка) и \' (одинарная кавычка).

### Проверка пустых или незаполненных строк

Java предоставляет удобные методы для определения того, имеет ли строка нулевую длину или содержит только символы 
пробела. Сигнатуры методов следующие:

```
public boolean isEmpty()
public boolean isBlank()
```

В следующем коде показано, как использовать эти методы:

```
System.out.println(" ".isEmpty());  // false
System.out.println("".isEmpty());   // true
System.out.println(" ".isBlank());  // true
System.out.println("".isBlank());   // true
```

Первая строка выводит false, потому что строка не пуста; в нем есть пустое место. Вторая строка выводит true, потому 
что на этот раз в строке нет символов. Последние две строки выводят true, потому что нет никаких символов, кроме 
пробелов.

### Форматирование значений

Существуют методы форматирования строковых значений с использованием флагов форматирования. Два метода принимают строку формата в качестве параметра, а другой использует экземпляр для этого значения. Один из методов использует Locale, о котором вы узнаете в главе 11.

Параметры метода используются для создания форматированной строки в одном вызове метода, а не с помощью множества 
операций форматирования и конкатенации. Они возвращают ссылку на экземпляр, для которого они вызываются, чтобы операции 
можно было связать вместе. Сигнатуры методов следующие:

```
public static String format(String format, Object args...)
public static String format(Locale loc, String format, Object args...)
public String formatted(Object args...)
```

В следующем коде показано, как использовать эти методы:

```
var name = "Kate";
var orderId = 5;

// All print: Hello Kate, order 5 is ready
System.out.println("Hello " + name + ", order " + orderId + " is ready");
System.out.println(String.format("Hello %s, order %d is ready",
   name, orderId));
System.out.println("Hello %s, order %d is ready"
   .formatted(name, orderId));
```

В операциях format() и formatted() параметры вставляются и форматируются с помощью символов в том порядке, в котором 
они указаны в vararg. В таблице 4.2 перечислены те, которые вы должны знать для сдачи экзамена.

#### Таблица 4.2. - Распространенные символы форматирования

| Условное обозначение |                                   Описание                                   |  
|:--------------------:|:----------------------------------------------------------------------------:|
|          %s          |           Применяется к любому типу, обычно к строковым значениям            |                                     
|          %d          |         Применяется к целочисленным значениям, таким как int и long          |                                        
|          %f          |    Применяется к значениям с плавающей запятой, таким как float и double     |                                   
|          %n          | Вставляет разрыв строки, используя разделитель строк, зависящий от системы.  |

В следующем примере используются все четыре символа из таблицы 4.2:

```
var name = "James";
var score = 90.25;
var total = 100;
System.out.println("%s:%n Score: %f out of %d"
   .formatted(name, score, total));
```

При этом выводится следующее:

```
James:
   Score: 90.250000 out of 100
```

Смешивание типов данных может вызвать исключения во время выполнения. Например, следующее выдает исключение, поскольку 
число с плавающей запятой используется, когда ожидается целочисленное значение:

```
var str = "Food: %d tons".formatted(2.0);     // IllegalFormatConversionException
```

---

#### Использование format() с флагами

Помимо поддержки символов, Java также поддерживает необязательные флаги между % и символом. В предыдущем примере число 
с плавающей запятой было напечатано как 90,250000. По умолчанию %f отображает ровно шесть цифр после запятой.
Если вы хотите отображать только одну цифру после запятой, вы можете использовать %.1f вместо %f. Метод format() 
основан на округлении, а не на усечении при сокращении чисел. Например, 90.250000 будет отображаться как 90.3 
(а не 90.2) при передаче в format() с %.1f.

Метод format() также поддерживает две дополнительные функции. Вы можете указать общую длину выходных данных, используя 
число перед десятичным символом. По умолчанию метод заполнит пустое пространство пробелами. Вы также можете заполнить 
пустое пространство нулями, поместив один ноль перед десятичным символом. В следующих примерах используются квадратные 
скобки [], чтобы показать начало/конец форматированного значения:

```
var pi = 3.14159265359;
System.out.format("[%f]",pi);        // [3.141593]
System.out.format("[%12.8f]",pi);    // [ 3.14159265]
System.out.format("[%012f]",pi);     // [00003.141593]
System.out.format("[%12.2f]",pi);    // [ 3.14]
System.out.format("[%.3f]",pi);      // [3.142]
```

Метод format() поддерживает множество других символов и флагов. Вам не нужно знать ни одного из них для экзамена, кроме 
того(тех), что мы уже обсуждали.

---

### Цепочка методов

Готовы собрать воедино все, о чем вы только что узнали? Обычно вызывается несколько методов, как показано здесь:

```
var start = "AniMaL ";
var trimmed = start.trim();                    // "AniMaL"
var lowercase = trimmed.toLowerCase();         // "animal"
var result = lowercase.replace('a', 'A');      // "AnimAl"
System.out.println(result);
```

Это всего лишь серия строковых методов. Каждый раз, когда вызывается один из них, возвращаемое значение помещается в 
новую переменную. На этом пути есть четыре строковых значения, и выводится AnimAl.

Однако на экзамене существует тенденция впихивать как можно больше кода в небольшое пространство. Вы увидите код, 
использующий технику, называемую цепочкой методов. Вот пример:

```
String result = "AniMaL ".trim().toLowerCase().replace('a', 'A');
System.out.println(result);
```

Этот код эквивалентен предыдущему примеру. Он также создает четыре строковых объекта и выводит AnimAl. Чтобы прочитать 
код, использующий цепочку методов, начните слева и оцените первый метод. Затем вызовите следующий метод на основе 
возвращаемого значения первого метода. Продолжайте, пока не дойдете до точки с запятой.

Как вы думаете, каков результат этого кода?

```
5: String a = "abc";
6: String b = a.toUpperCase();
7: b = b.replace("B", "2").replace('C', '3');
8: System.out.println("a=" + a);
9: System.out.println("b=" + b);
```

В строке 5 мы установили 'a' так, чтобы оно указывало на "abc", и никогда не указывали 'a' ни на что другое. Поскольку 
ни один код в строках 6 и 7 не изменяет 'a', значение остается "abc".

Однако 'b' немного сложнее. В строке 6 буква 'b' указывает на «ABC», что несложно. В строке 7 у нас есть цепочка 
методов. Сначала вызывается "ABC".replace("B", "2"). Это возвращает "A2C". Затем вызывается "A2C".replace('C', '3'). 
Это возвращает "A23". Наконец, b изменяется, чтобы указать на эту возвращенную строку. Когда строка 9 выполняется, 
b равно "A23".

## Использование класса StringBuilder

Небольшая программа может очень быстро создать множество объектов String. Например, как вы думаете, сколько объектов 
создает этот фрагмент кода?

```
10: String alpha = "";
11: for (char current = 'a'; current <= 'z'; current++)
12:      alpha += current;
13: System.out.println(alpha);
```

Создается экземпляр пустой строки в строке 10, а затем в строке 12 добавляется буква "а". Однако, поскольку объект String является неизменяемым, новый объект String присваивается alpha, и объект "" становится пригодным для сборки мусора. При следующем прохождении цикла alpha присваивается новый строковый объект "ab", и объект "a" становится пригодным для сборки мусора. Следующая итерация присваивает alpha "abc", и объект "ab" становится пригодным для сборки мусора, и так далее.

Эта последовательность событий продолжается, и после 26 итераций цикла создается в общей сложности 27 объектов, большинство из которых немедленно подлежат сборке мусора.

Это очень неэффективно. К счастью, у Java есть решение. Класс StringBuilder создает String без сохранения всех этих промежуточных значений String. В отличие от класса String, StringBuilder не является неизменным.

```
15: StringBuilder alpha = new StringBuilder();
16: for(char current = 'a'; current <= 'z'; current++)
17:    alpha.append(current);
18: System.out.println(alpha);
```

В строке 15 создается экземпляр нового объекта StringBuilder. Вызов append() в строке 17 добавляет символ к объекту StringBuilder каждый раз через цикл for, добавляя значение current к концу alpha. Этот код повторно использует один и тот же StringBuilder без создания промежуточной строки каждый раз.

В старом коде вы можете увидеть ссылки на StringBuffer. Он работает так же, за исключением того, что поддерживает потоки, о которых вы узнаете в главе 13 «Параллелизм». StringBuffer не на экзамене. Он работает медленнее, чем StringBuilder, поэтому просто используйте StringBuilder.

В этом разделе мы рассмотрим создание StringBuilder и использование его общих методов.

### Изменчивость и цепочка

Мы уверены, что вы заметили это из предыдущего примера, но StringBuilder не является неизменяемым. Фактически, мы дали ему 27 различных значений в примере (пробел плюс добавление каждой буквы в алфавите). Экзамен, скорее всего, попытается обмануть вас в отношении того, что String и StringBuilder являются изменяемыми.

Цепочка делает это еще более интересным. Когда мы связали вызовы методов String, результатом стала новая String с ответом. Цепочка методов StringBuilder так не работает. Вместо этого StringBuilder изменяет свое собственное состояние и возвращает ссылку на себя. Давайте рассмотрим пример, чтобы было понятнее:

```
4: StringBuilder sb = new StringBuilder("start");
5: sb.append("+middle");                            // sb = "start+middle"
6: StringBuilder same = sb.append("+end");          // "start+middle+end"
```

Строка 5 добавляет текст в конец sb. Он также возвращает ссылку на sb, которая игнорируется. Строка 6 также добавляет текст в конец sb и возвращает ссылку на sb. На этот раз ссылка сохраняется в файле same. Это означает, что sb и same указывают на один и тот же объект и выводят одно и то же значение.

Экзамен не всегда сделает код легко читаемым, если в каждой строке будет только один метод. Как вы думаете, что печатает этот пример?

```
4: StringBuilder a = new StringBuilder("abc");
5: StringBuilder b = a.append("de");
6: b = b.append("f").append("g");
7: System.out.println("a=" + a);
8: System.out.println("b=" + b);
```

Вы сказали, что оба печатают "abcdefg"? Хорошо. Здесь есть только один объект StringBuilder. Мы знаем это, потому что new StringBuilder() вызывается только один раз. В строке 5 есть две переменные, ссылающиеся на этот объект, который имеет значение "abcde". В строке 6 эти две переменные по-прежнему ссылаются на тот же объект, который теперь имеет значение "abcdefg". Кстати, присвоение обратно b абсолютно ничего не делает. b уже указывает на этот StringBuilder.

### Создание StringBuilder 

Существует три способа создания StringBuilder:

```
StringBuilder sb1 = new StringBuilder();
StringBuilder sb2 = new StringBuilder("animal");
StringBuilder sb3 = new StringBuilder(10);
```

В первом предлагается создать StringBuilder, содержащий пустую последовательность символов, и назначить sb1 для указания 
на нее. Второй предлагает создать StringBuilder, содержащий определенное значение, и назначить sb2 для указания на него. 
Первые два примера говорят Java управлять деталями реализации. Последний пример говорит Java, что у нас есть некоторое 
представление о том, насколько большим будет конечное значение, и мы хотели бы, чтобы StringBuilder зарезервировал 
определенную емкость или количество слотов для символов.

## Важные методы StringBuilder

Как и в случае со String, мы не собираемся рассматривать каждый метод класса StringBuilder. Это те, которые вы можете 
увидеть на экзамене.

### Использование общих методов

Эти четыре метода работают точно так же, как и в классе String. Убедитесь, что вы можете идентифицировать вывод этого примера:

```
var sb = new StringBuilder("animals");
String sub = sb.substring(sb.indexOf("a"), sb.indexOf("al"));
int len = sb.length();
char ch = sb.charAt(6);
System.out.println(sub + " " + len + " " + ch);
```

Правильный ответ - anim 7 s. Вызовы метода indexOf() возвращают 0 и 4 соответственно. Метод substring() возвращает 
строку, начинающуюся с индекса 0 и заканчивающуюся непосредственно перед индексом 4.

Метод length() возвращает 7, потому что это количество символов в StringBuilder, а не индекс. Наконец, charAt() 
возвращает символ с индексом 6. Здесь мы начинаем с 0, потому что имеем в виду индексы. Если это не кажется вам 
знакомым, вернитесь и снова прочитайте раздел о String.

Обратите внимание, что substring() возвращает String, а не StringBuilder. Вот почему sb не меняется. Метод substring() на самом деле просто метод, который запрашивает состояние StringBuilder.

### Добавление значений

Метод append() на сегодняшний день является наиболее часто используемым методом в StringBuilder. На самом деле, он настолько часто используется, что мы просто начали использовать его без комментариев. К счастью, этот метод делает именно то, на что он похож: он добавляет параметр в StringBuilder и возвращает ссылку на текущий StringBuilder. Одна из сигнатур метода выглядит следующим образом:

```
public StringBuilder append(String str)
```

Обратите внимание, что мы упомянули одну из сигнатур метода. Существует более 10 сигнатур методов, которые выглядят 
одинаково, но принимают в качестве параметров разные типы данных, такие как int, char и т.д. Все эти методы представлены
для того, чтобы вы могли написать код, подобный этому:

```
var sb = new StringBuilder().append(1).append('c');
sb.append("-").append(true);
System.out.println(sb);      // 1c-true
```

Хорошая цепочка методов, не так ли? Метод append() вызывается непосредственно после конструктора. Имея все эти сигнатуры 
методов, вы можете просто вызвать append() без необходимости сначала преобразовывать свой параметр в строку.

### Вставка данных

Метод insert() добавляет символы в StringBuilder по запрошенному индексу и возвращает ссылку на текущий StringBuilder. 
Так же, как и append(), существует множество сигнатур методов для разных типов. Вот один:

```
public StringBuilder insert(int offset, String str)
```

Обратите внимание на смещение в этих примерах. Это индекс, в который мы хотим вставить запрошенный параметр.

```
3: var sb = new StringBuilder("animals");
4: sb.insert(7, "-");                    // sb = animals
5: sb.insert(0, "-");                    // sb = -animals
6: sb.insert(4, "-");                    // sb = -ani-mals
7: System.out.println(sb);
```

В строке 4 предлагается вставить тире в индексе 7, который является концом последовательности символов. В строке 5 
предлагается вставить тире в индексе 0, что оказывается самым началом. Наконец, в строке 6 предлагается вставить тире 
прямо перед индексом 4. Создатели экзамена попытаются сбить вас с толку. Когда мы добавляем и удаляем символы, их 
индексы меняются. Когда вы видите вопрос, связанный с такими операциями, нарисуйте, что происходит, используя доступные 
письменные принадлежности, чтобы не запутаться.

### Удаление содержимого

Метод delete() противоположен методу insert(). Он удаляет символы из последовательности и возвращает ссылку на текущий 
StringBuilder. Метод deleteCharAt() удобен, когда вы хотите удалить только один символ. Сигнатуры метода следующие:

```
public StringBuilder delete(int startIndex, int endIndex)
public StringBuilder deleteCharAt(int index)
```

Следующий код показывает, как использовать эти методы

```
var sb = new StringBuilder("abcdef");
sb.delete(1, 3);                    // sb = adef
sb.deleteCharAt(5);                 // exception
```

Сначала мы удаляем символы, начинающиеся с индекса 1 и заканчивающиеся непосредственно перед индексом 3. Это дает 
нам adef. Далее мы просим Java удалить символ в позиции 5. Однако оставшееся значение имеет длину всего четыре символа, 
поэтому оно вызывает исключение StringIndexOutOfBoundsException.

Метод delete() является более гибким, чем некоторые другие, когда дело доходит до индексов массива. Если вы укажете 
второй параметр, который находится после конца StringBuilder, Java просто предположит, что вы имели в виду конец. 
Это означает, что этот код является законным:

```
var sb = new StringBuilder("abcdef");
sb.delete(1, 100);                   // sb = a
```

### Замена частей (Replacing Portions)

Метод replace() работает для StringBuilder иначе, чем для String. Сигнатура метода выглядит следующим образом:

```
public StringBuilder replace(int startIndex, int endIndex, String newString)
```

Следующий код показывает, как использовать эти методы:

```
var builder = new StringBuilder("pigeon dirty");
builder.replace(3, 6, "sty");
System.out.println(builder);   // pigsty dirty
```

Во-первых, Java удаляет символы, начинающиеся с индекса 3 и заканчивающиеся непосредственно перед индексом 6. Это дает 
нам pig dirty. Затем Java вставляет значение "sty" в эту позицию.

В этом примере количество удаленных и вставленных символов одинаковое. Однако нет никаких причин, по которым они должны 
быть такими. Как вы думаете, что это делает?

```
var builder = new StringBuilder("pigeon dirty");
builder.replace(3, 100, "");
System.out.println(builder);
```

Печатает "pig". Помните, метод сначала выполняет логическое удаление. Метод replace() позволяет указать второй параметр, 
который находится за концом StringBuilder. Это означает, что остаются только первые три символа.

### Реверсирование (Reversing)

После всего этого пришло время для хорошего, простого метода. Метод reverse() делает именно то, на что он похож: он 
меняет местами символы в последовательностях и возвращает ссылку на текущий StringBuilder. 
Сигнатура метода выглядит следующим образом:

```
public StringBuilder reverse()
```

Следующий код показывает, как использовать эти методы:

```
var sb = new StringBuilder("ABC");
sb.reverse();
System.out.println(sb);
```

Как и ожидалось, это выводит CBA. Этот метод не так уж интересен. Возможно, создатели экзамена хотели бы включить его, 
чтобы побудить вас записать значение, а не полагаться на память для индексов.

---

#### Работа с toString()

Класс Object содержит метод toString(), который многие классы предоставляют пользовательские реализации. Класс 
StringBuilder является одним из них.

Следующий код показывает, как использовать этот метод:

```
var sb = new StringBuilder("ABC");
String s = sb.toString();
```

Часто StringBuilder используется внутри для повышения производительности, но конечным результатом должен быть String. 
Например, возможно, его нужно передать другому методу, который ожидает String.

---

## Понимание равенства

В главе 2 вы узнали, как использовать == для сравнения чисел и что ссылки на объекты относятся к одному и тому же 
объекту. В этом разделе мы рассмотрим, что означает, когда два объекта эквивалентны или одинаковы. Мы также рассмотрим 
влияние пула строк на равенство.

### Сравнение equals() и ==

Рассмотрим следующий код, который использует == с объектами:

```
var one = new StringBuilder();
var two = new StringBuilder();
var three = one.append("a");
System.out.println(one == two); // false
System.out.println(one == three); // true
```

Поскольку этот пример не имеет дело с примитивами, мы знаем, что нужно искать, относятся ли ссылки к одному и тому же 
объекту. Переменные one и two являются полностью отдельными объектами StringBuilder, что дает нам два объекта.
Следовательно, первый оператор печати дает нам false. Переменная three интереснее. Помните, как методы StringBuilder 
возвращают текущую ссылку для цепочки? Это означает, что one и three указывают на один и тот же объект, а второй 
оператор печати возвращает нам значение true.

Ранее вы видели, что equals() использует логическое равенство, а не равенство объектов для объектов String:

```
var x = "Hello World";
var z = " Hello World".trim();
System.out.println(x.equals(z));  // true
```

Это работает, потому что авторы класса String реализовали стандартный метод equals() для проверки значений внутри 
String, а не самой ссылки на строку. Если в классе нет метода equals(), Java определяет, указывают ли ссылки на один и 
тот же объект, что и делает ==.

Если вам интересно, авторы StringBuilder не реализовали функцию equals(). Если вы вызовете equals() для двух 
экземпляров StringBuilder, он проверит равенство ссылок. Вы можете вызвать toString() в StringBuilder, чтобы получить 
String для проверки на равенство.

Наконец, экзамен может попытаться обмануть вас таким вопросом. Можете ли вы догадаться, почему код не компилируется?

```
var name = "a";
var builder = new StringBuilder("a");
System.out.println(name == builder); // DOES NOT COMPILE
```

Помните, что == проверяет равенство ссылок на объекты. Компилятор достаточно умен, чтобы понять, что две ссылки не 
могут указывать на один и тот же объект, если они совершенно разных типов.

### Пул строк

Поскольку строки в Java повсюду, они занимают много памяти. В некоторых производственных приложениях они могут 
использовать большой объем памяти во всей программе. Java понимает, что многие строки повторяются в программе, и решает 
эту проблему, повторно используя общие. Пул строк, также известный как внутренний пул, представляет собой место в 
виртуальной машине Java (JVM), в котором собираются все эти строки.

Пул строк содержит литеральные значения и константы, которые отображаются в вашей программе. Например, "name" является 
литералом и, следовательно, попадает в пул строк. Метод MyObject.toString() возвращает строку, но не литерал, поэтому 
он не попадает в пул строк.

Теперь давайте перейдем к более сложному и запутанному сценарию, равенству строк, отчасти благодаря тому, как JVM 
повторно использует строковые литералы.

```
var x = "Hello World";
var y = "Hello World";
System.out.println(x == y);   // true
```

Помните, что строка неизменяема, а литералы объединены в пул. JVM создала только один литерал в памяти. Переменные x и y
указывают на одно и то же местоположение в памяти; следовательно, оператор выводит значение true. Это становится ещё 
сложнее. Рассмотрим этот код:

```
var x = "Hello World";
var z = " Hello World".trim();
System.out.println(x == z);    // false
```

В этом примере у нас нет двух одинаковых строковых литералов. Хотя x и z вычисляются в одной и той же строке, одна из 
них вычисляется во время выполнения. Поскольку во время компиляции это не одно и то же, создается новый объект String. 
Давайте попробуем еще один. Как вы думаете, что здесь выводится?

```
var singleString = "hello world";
var concat = "hello ";
concat += "world";
System.out.println(singleString == concat); // false
```

Это выводит значение false. Вызов += аналогичен вызову метода и приводит к созданию новой строки. Вы даже можете 
принудительно устранить проблему, создав новую строку:

```
var x = "Hello World";
var y = new String("Hello World");
System.out.println(x == y);        // false
```

Первый говорит об обычном использовании пула строк. Второй говорит: «Нет, JVM, я действительно не хочу, чтобы вы 
использовали пул строк. Пожалуйста, создайте для меня новый объект, даже если он менее эффективен».

Вы также можете сделать обратное и указать Java использовать пул строк. Метод intern() будет использовать объект в пуле 
строк, если он присутствует.

```
public String intern()
```

Если литерала еще нет в пуле строк, Java добавит его в это время.

```
var name = "Hello World";
var name2 = new String("Hello World").intern();
System.out.println(name == name2);     // true
```

Сначала мы сообщаем Java, что для name обычно используется пул строк. Затем для name2 мы сообщаем Java создать новый 
объект с помощью конструктора, но интернировать его и в любом случае использовать пул строк. Поскольку обе переменные 
указывают на одну и ту же ссылку в пуле строк, мы можем использовать оператор ==.

Давайте попробуем еще один. Как вы думаете, что это выводит на печать? Будь осторожен. Это сложно.

```
15: var first = "rat" + 1;
16: var second = "r" + "a" + "t" + "1";
17: var third = "r" + "a" + "t" + new String("1");
18: System.out.println(first == second);
19: System.out.println(first == second.intern());
20: System.out.println(first == third);
21: System.out.println(first == third.intern());
```

В строке 15 у нас есть константа времени компиляции, которая автоматически помещается в пул строк как «rat1». 
В строке 16 у нас есть более сложное выражение, которое также является константой времени компиляции. Следовательно, 
first и second используют одну и ту же ссылку на пул строк. Это делает строки 18 и 19 true.

В строке 17 у нас есть конструктор String. Это означает, что у нас больше нет константы времени компиляции, и third не
указывает на ссылку в пуле строк. Следовательно, строка 20 выводит значение false. В строке 21 вызов intern()
просматривает пул строк. Java замечает, что сначала указывает на ту же строку и выводит true.

Когда вы пишете программы, вам не хотелось бы создавать строку из строки или использовать метод intern(). Для сдачи 
экзамена вам нужно знать, что и то, и другое разрешено и как они себя ведут.

_Помните, что никогда не используйте intern() или == для сравнения строковых объектов в вашем коде. Единственный раз, 
когда вам следует иметь с этим дело, - это на экзамене._

## Понимание массивов

До сих пор мы называли классы String и StringBuilder «последовательностью символов». Это правда. Они реализованы с 
использованием массива символов. Массив — это область памяти в куче с местом для определенного количества элементов. 
Строка реализована как массив с некоторыми методами, которые вы можете захотеть использовать при работе с конкретными 
символами. StringBuilder реализован как массив, в котором объект массива заменяется новым, более крупным объектом 
массива, когда в нем заканчивается место для хранения всех символов. Большая разница в том, что массив может быть любого
другого типа Java. Если бы мы по какой-то причине не хотели использовать String, мы могли бы напрямую использовать 
массив примитивов char:

```
char[] letters;
```

Это было бы не очень удобно, потому что мы потеряли бы все специальные свойства, которые дает нам String, такие как 
запись «Java». Имейте в виду, что letters — это ссылочная переменная, а не примитив. Тип char является примитивным. 
Но char — это то, что входит в массив, а не тип самого массива. Сам массив имеет тип char[]. Вы можете мысленно 
прочитать скобки ([]) как «массив».

Другими словами, массив — это упорядоченный список. Он может содержать дубликаты. В этом разделе мы рассмотрим создание 
массива примитивов и объектов, сортировку, поиск, varargs и многомерные массивы.

### Создание массива примитивов

Наиболее распространенный способ создания массива показан на рис. 4.3. Он указывает тип массива (int) и размер (3). 
Квадратные скобки говорят вам, что это массив.

#### Рис. 4.3 - Базовая структура массива


Когда вы используете эту форму для создания экземпляра массива, всем элементам присваивается значение по умолчанию для 
этого типа. Как вы узнали из главы 1, значение int по умолчанию равно 0. Поскольку numbers является ссылочной 
переменной, она указывает на объект array, как показано на рис. 4.4. Как вы можете видеть, значение по умолчанию для 
всех элементов равно 0. Кроме того, индексы начинаются с 0 и подсчитываются, как и для строки.

#### Рис. 4.4 - Пустой массив


Другой способ создать массив - указать все элементы, с которых он должен начинаться:

```
int[] moreNumbers = new int[] {42, 55, 99};
```

В этом примере мы также создаем массив int размера 3. На этот раз мы указываем начальные значения этих трех элементов 
вместо использования значений по умолчанию. На рис. 4.5 показано, как выглядит этот массив.

#### Рис. 4.5 - Инициализированный массив


Java распознает, что это выражение является избыточным. Поскольку вы указываете тип массива слева от знака равенства, 
Java уже знает этот тип. И поскольку вы указываете начальные значения, он уже знает размер. В качестве ярлыка Java 
позволяет написать следующее:

```
int[] moreNumbers = {42, 55, 99};
```

Такой подход называется _анонимным массивом_. Это анонимно, потому что вы не указываете тип и размер.

Наконец, вы можете ввести [] до или после имени, а добавление пробела необязательно. Это означает, что все пять из этих 
утверждений делают одно и то же:

```
int[] numAnimals;
int [] numAnimals2;
int []numAnimals3;
int numAnimals4[];
int numAnimals5 [];
```

Большинство людей используют первый вариант. Однако вы можете увидеть любой из них на экзамене, так что привыкайте 
видеть скобки в разных местах.

---

#### Несколько "массивов" в объявлении

Как вы думаете, какие типы ссылочных переменных создает следующий код?

```
int[] ids, types;
```

Правильный ответ — две переменные типа int[]. Это выглядит достаточно логично. Ведь int a, b; создал две переменные 
типа int. А как насчет этого примера?

```
int ids[], types;
```

Все, что мы сделали, это передвинули скобки, но это изменило поведение. На этот раз мы получаем один массив типа int[] 
и переменную типа int. Java видит эту строчку кода и думает примерно так: «Они хотят две переменные типа int. 
Первый называется ids[]. Это  int[] под названием ids. Второй просто называется types. Без скобок, так что это обычное 
целое число».

Разумеется, вы не должны писать код, который выглядит так. Но вам нужно понять это для экзамена.

---

### Создание массива со ссылочными переменными

Вы можете выбрать любой тип Java в качестве типа массива. Сюда входят классы, которые вы создаете самостоятельно. 
Давайте посмотрим на встроенный тип со String:

```
String[] bugs = { "cricket", "beetle", "ladybug" };
String[] alias = bugs;
System.out.println(bugs.equals(alias));   // true
System.out.println(bugs.toString());      // [Ljava.lang.String;@160bc7c0
```

Мы можем вызвать equals(), потому что массив — это объект. Он возвращает true из-за равенства ссылок. Метод equals() для
массивов не рассматривает элементы массива. Помните, что это сработает даже для int[]. Тип int — примитив; 
int[] — объект.

Второй оператор печати еще более интересен. Что такое [Ljava.lang.String;@160bc7c0? Вам не нужно знать это для экзамена,
но [L означает, что это массив, java.lang.String — это ссылочный тип, а 160bc7c0 — это хэш-код. Вы будете получать 
разные цифры и буквы каждый раз, когда запускаете его, поскольку это ссылка.

_Java предоставляет метод, который красиво печатает массив: Arrays.toString(bugs) напечатает [cricket, beetle, ladybug]._

Убедитесь, что вы понимаете рис. 4.6. Массив не выделяет место для объектов String. Вместо этого он выделяет место 
для ссылки на то, где действительно хранятся объекты.

#### Рис. 4.6 - Массив с указанием строк

В качестве краткого обзора, как вы думаете, на что указывает этот массив?

```
public class Names {
   String names[];
}
```

Вы поняли нас. Это был обзор главы 1, а не обсуждение массивов. Ответ null. Код никогда не создавал экземпляр массива, 
так что это просто ссылочная переменная для null. Давайте попробуем ещё раз: как вы думаете, на что указывает этот 
массив?

```
public class Names {
   String names[] = new String[2];
}
```

Это массив, потому что он имеет скобки. Это массив типа String, поскольку именно этот тип указан в объявлении. Он имеет 
два элемента, потому что длина равна 2. Каждый из этих двух слотов в настоящее время имеет значение null, но 
потенциально может указывать на объект String.

Помните приведение из предыдущей главы, когда вы хотели принудительно преобразовать больший тип в меньший? Вы можем 
сделать это и с массивами тоже:

```
3: String[] strings = { "stringValue" };
4: Object[] objects = strings;
5: String[] againStrings = (String[]) objects;
6: againStrings[0] = new StringBuilder();     // DOES NOT COMPILE
7: objects[0] = new StringBuilder();          // Внимательно!
```

Строка 3 создает массив типа String. Строка 4 не требует приведения, потому что Object является более широким типом, 
чем String. В строке 5 требуется приведение, потому что мы переходим к более конкретному типу. Строка 6 не компилируется, 
потому что String[] допускает только объекты String, а StringBuilder не является String.

В строке 7 это становится интересным. С точки зрения компилятора это нормально. Объект StringBuilder явно может 
находиться в Object[]. Проблема в том, что у нас на самом деле нет Object[]. У нас есть String[], на которую ссылается 
переменная Object[]. Во время выполнения код вызывает исключение ArrayStoreException. Вам не нужно запоминать имя 
этого исключения, но вам нужно знать, что код будет генерировать исключение.

### Использование массива

Теперь, когда вы знаете, как создать массив, давайте попробуем получить доступ к нему:

```
4: String[] mammals = {"monkey", "chimp", "donkey"};
5: System.out.println(mammals.length);             // 3
6: System.out.println(mammals[0]);                 // monkey
7: System.out.println(mammals[1]);                 // chimp
8: System.out.println(mammals[2]);                 // donkey
```

Строка 4 объявляет и инициализирует массив. Строка 5 сообщает нам, сколько элементов может содержать массив. Остальная 
часть кода печатает массив. Обратите внимание, что элементы индексируются, начиная с 0. Это должно быть знакомо по 
String и StringBuilder, которые также начинают считать с 0. Эти классы также считают длину количеством элементов. 
Обратите внимание, что после длины нет скобок, так как это не метод. Остерегайтесь ошибок компилятора, таких как 
следующие на экзамене!

```
4: String[] mammals = {"monkey", "chimp", "donkey"};
5: System.out.println(mammals.length());           // DOES NOT COMPILE
```

Чтобы убедиться, что вы понимаете, как работает длина, как вы думаете, что это выводит?

```
var birds = new String[6];
System.out.println(birds.length);
```

Ответ — 6. Несмотря на то, что все шесть элементов массива равны null, их все же шесть. length не учитывает, что 
находится в массиве; он учитывает только количество выделенных слотов.

Очень часто при чтении из массива или записи в него используется цикл. Этот цикл устанавливает для каждого элемента 
numbers значение на пять больше текущего индекса:

```
5: var numbers = new int[10];
6: for (int i = 0; i < numbers.length; i++)
7:    numbers[i] = i + 5;
```

Строка 5 просто создает массив с 10 слотами. Строка 6 — это цикл for, в котором используется очень распространенный 
шаблон. Он начинается с индекса 0, где также начинается массив. Он продолжает работать по одному, пока не достигнет 
конца массива. Строка 7 устанавливает текущий элемент чисел.

Экзамен проверит, насколько вы наблюдательны, пытаясь получить доступ к элементам, которых нет в массиве. Можете ли вы 
сказать, почему каждый из них генерирует исключение ArrayIndexOutOfBoundsException для нашего массива размером 10?

```
numbers[10] = 3;

numbers[numbers.length] = 5;

for (int i = 0; i <= numbers.length; i++)
   numbers[i] = i + 5;
```

Первый из них пытается выяснить, знаете ли вы, что индексы начинаются с 0. Поскольку в нашем массиве 10 элементов, это 
означает, что допустимы только числа от [0] до [9]. Во втором примере предполагается, что вы достаточно умны, чтобы 
знать, что 10 недопустимо, и маскируете это с помощью значения поля length. Однако длина всегда на единицу больше 
максимально допустимого индекса. Наконец, цикл for неправильно использует <= вместо <, что также является способом 
ссылки на этот десятый элемент.

### Сортировка

Java упрощает сортировку массива, предоставляя метод сортировки — или, скорее, набор методов сортировки. Точно так же, 
как StringBuilder позволял вам передавать практически все в append(), вы можете передавать практически любой массив 
в Arrays.sort().

Для массивов требуется импорт. Чтобы использовать его, в вашем классе должно быть одно из следующих двух утверждений:

```
import java.util.*;        // импортируем весь пакет, включая массивы
import java.util.Arrays;   // импортируем только массивы
```

Есть одно исключение, хотя оно не часто встречается на экзамене. Вы можете писать java.util.Arrays каждый раз, когда он 
используется в классе, вместо того, чтобы указывать его как импорт.

Помните, что если вам показывают фрагмент кода, вы можете предположить, что необходимый импорт есть. Этот простой 
пример сортирует три числа:

```
int[] numbers = { 6, 9, 1 };
Arrays.sort(numbers);
for (int i = 0; i < numbers.length; i++)
   System.out.print(numbers[i] + " ");
```

Результат 1 6 9, как и следовало ожидать. Обратите внимание, что мы перебрали входные данные, чтобы напечатать значения 
в массиве. Простое печатание переменной массива напрямую дало бы раздражающий хэш [I@2bd9c3e7. В качестве альтернативы 
мы могли бы напечатать Arrays.toString(numbers) вместо использования цикла. Это будет вывод [1, 6, 9].

Попробуйте это еще раз с типом String:

```
String[] strings = { "10", "9", "100" };
Arrays.sort(strings);
for (String s : strings)
  System.out.print(s + " ");
```

На этот раз результат может быть не таким, как вы ожидаете. Этот код выводит 10 100 9. Проблема в том, что String 
сортируется в алфавитном порядке, а 1 сортируется до 9. (Числа сортируются перед буквами, а прописные — перед 
строчными.) В главе 9 «Коллекции и обобщения» вы узнаете, как создавать пользовательские порядки сортировки, используя 
нечто, называемое компаратором.

Вы заметили, что мы внедрили в этот пример расширенный цикл for? Поскольку мы не используем индекс, нам не нужен 
традиционный цикл for. Тем не менее, это не помешает создателям экзаменов использовать его, поэтому мы обязательно 
будем использовать оба варианта, чтобы вы были в форме!

### Поиск (Searching)

Java также предоставляет удобный способ поиска, но только в том случае, если массив уже отсортирован. В таблице 4.3 
описаны правила бинарного поиска.

#### Таблица 4.3. - Правила бинарного поиска

|                       Сценарий                       |                                                                                    Результат                                                                                     | 
|:----------------------------------------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|   Целевой элемент найден в отсортированном массиве   |                                                                               Индекс соответствия                                                                                |
| Целевой элемент не найден в отсортированном массиве  | Отрицательное значение, показывающее единицу, меньшую,<br/> чем отрицательное значение индекса,<br/>  где необходимо вставить совпадение для сохранения отсортированного порядка |
|                Несортированный массив                 |                                                                      Сюрприз; этот результат не определен                                                                        |

Давайте попробуем эти правила на примере:

```
3: int[] numbers = {2,4,6,8};
4: System.out.println(Arrays.binarySearch(numbers, 2)); // 0
5: System.out.println(Arrays.binarySearch(numbers, 4)); // 1
6: System.out.println(Arrays.binarySearch(numbers, 1)); // -1
7: System.out.println(Arrays.binarySearch(numbers, 3)); // -2
8: System.out.println(Arrays.binarySearch(numbers, 9)); // -5
```

Обратите внимание на тот факт, что строка 3 - отсортированный массив. Если это не так, мы не могли бы применить ни одно 
из других правил. Строка 4 поиск индекса 2. Ответ индекс - 0. Строка 5 поиск индекса 4. Ответ индекс - 1.

В строке 6 выполняется поиск по индексу 1. Хотя 1 отсутствует в списке, поиск может определить, что он должен быть 
вставлен в элемент 0, чтобы сохранить порядок сортировки. Поскольку 0 уже что-то означает для индексов массива, Java 
необходимо вычесть 1, чтобы дать нам ответ, равный -1. Строка 7 аналогична. Хотя 3 нет в списке, его нужно было бы 
вставить в элемент 1, чтобы сохранить порядок сортировки. Мы отрицаем и вычитаем 1 для согласованности, получая -1 -1, 
также известное как -2. Наконец, строка 8 хочет сообщить нам, что 9 должно быть вставлено в индекс 4. Мы снова отрицаем 
и вычитаем 1, получая -4 -1, также известное как -5.

Как вы думаете, что происходит в этом примере?

```
5: int[] numbers = new int[] {3,2,1};
6: System.out.println(Arrays.binarySearch(numbers, 2));
7: System.out.println(Arrays.binarySearch(numbers, 3));
```

Обратите внимание, что в строке 5 массив не отсортирован. Это означает, что выходные данные не будут определены. При 
тестировании этого примера строка 6 правильно выдавала 1 в качестве выходных данных. Однако строка 7 дала неправильный 
ответ. Создатели экзамена не будут ожидать, что вы будете знать, какие неправильные значения получаются. Как только вы 
увидите, что массив не отсортирован, поищите вариант ответа о непредсказуемом выводе.

На экзамене вам нужно знать, что возвращает двоичный поиск в различных сценариях. Как ни странно, вам не нужно знать, 
почему в названии есть слово “binary”. На случай, если вам интересно, двоичный поиск разбивает массив на две равные 
части (помните, что 2 является двоичным) и определяет, в какой половине находится цель. Этот процесс повторяется до 
тех пор, пока не останется только один элемент.

### Сравнение

Java также предоставляет методы для сравнения двух массивов, чтобы определить, какой из них «меньше». Сначала мы 
рассмотрим метод compare(), а затем перейдем к mismatch(). Эти методы перегружены, чтобы принимать различные параметры.

#### Использование compare()

Есть множество правил, которые вам нужно знать, прежде чем вызывать compare(). К счастью, это те же правила, которые 
вам нужно знать в главе 9 при написании Comparator.

Сначала вам нужно узнать, что означает возвращаемое значение. Вам не нужно знать точные возвращаемые значения, но вам 
нужно знать следующее:

+ Отрицательное число означает, что первый массив меньше второго.
+ Ноль означает, что массивы равны.
+ Положительное число означает, что первый массив больше второго.

Вот пример:

```
System.out.println(Arrays.compare(new int[] {1}, new int[] {2}));
```

Этот код печатает отрицательное число. Должно быть довольно интуитивно понятно, что 1 меньше 2, что делает первый 
массив меньше.

Теперь, когда вы знаете, как сравнивать одно значение, давайте посмотрим, как сравнивать массивы разной длины:

+ Если оба массива имеют одинаковую длину и имеют одинаковые значения в каждой точке в одном и том же порядке, 
верните ноль.
+ Если все элементы одинаковы, но второй массив имеет лишние элементы в конце, вернуть отрицательное число.
+ Если все элементы одинаковы, но в конце первого массива есть лишние элементы, вернуть положительное число.
+ Если первый отличающийся элемент меньше в первом массиве, вернуть отрицательное число.
+ Если первый отличающийся элемент больше в первом массиве, вернуть положительное число.

Наконец, что значит меньше? Вот еще несколько правил, которые применяются здесь и для compareTo(), которые вы видели в 
главе 8, «Лямбда-выражения и функциональные интерфейсы»:

+ null меньше любого другого значения.
+ Для чисел применяется обычный числовой порядок.
+ Для строк один меньше, если он является префиксом другого.
+ Для строк/символов числа меньше букв.
+ Для строк/символов прописные буквы меньше строчных.

В таблице 4.4 показаны примеры этих правил в действии.

#### Таблица 4.4. - Примеры Arrays.compare()

|    Певрый массив    |    Второй массив     |      Результат       |                     Причина                      | 
|:-------------------:|:--------------------:|:--------------------:|:------------------------------------------------:|
|  new int[] {1, 2}   |    new int[] {1}     | Положительное число  | Первый элемент тот же, но первый массив длиннее. |
|  new int[] {1, 2}   |   new int[] {1, 2}   |         Нуль         |                Точное совпадение                 |
| new String[] {"a"}  | new String[] {"aa"}  | Отрицательное число  |   Первый элемент является подстрокой второго.    |
| new String[] {"a"}  |  new String[] {"A"}  | Положительное число  |         Прописные буквы меньше строчных.         |
| new String[] {"a"}  | new String[] {null}  | Положительное число  |                null меньше буквы.                |

Наконец, этот код не компилируется, потому что типы разные. При сравнении двух массивов они должны быть одного 
типа массива.

```
System.out.println(Arrays.compare(
   new int[] {1}, new String[] {"a"})); // DOES NOT COMPILE
```

#### Использование mismatch()

Теперь, когда вы знакомы с функцией compare(), пришло время узнать о mismatch(). Если массивы равны, mismatch() 
возвращает -1. В противном случае он возвращает первый индекс, где они различаются. Вы можете понять, что они печатают?

```
System.out.println(Arrays.mismatch(new int[] {1}, new int[] {1}));
System.out.println(Arrays.mismatch(new String[] {"a"}, new String[] {"A"}));
System.out.println(Arrays.mismatch(new int[] {1, 2}, new int[] {1}));
```

В первом примере массивы одинаковы, поэтому результат равен -1. Во втором примере записи в элементе 0 не равны, поэтому 
результат равен 0. В третьем примере записи в элементе 0 равны, поэтому мы продолжаем поиск. Элемент с индексом 1 не 
равен. Или, более конкретно, в одном массиве есть элемент с индексом 1, а в другом - нет. Следовательно, результат 
равен 1.

Чтобы убедиться, что вы понимаете методы compare() и mismatch(), изучите таблицу 4.5. Если вы не понимаете, почему там 
указаны все значения, пожалуйста, вернитесь и изучите этот раздел еще раз.

#### Таблица 4.5. - Equality vs. comparison vs. mismatch

|    Метод    | Когда массивы содержат одни и те же данные |         Когда массивы разные          |
|:-----------:|:------------------------------------------:|:-------------------------------------:|
|  equals()   |                    true                    |                 false                 | 
|  compare()  |                     0                      | Положительное или отрицательное число |
| mismatch()  |                    -1                      |   Нулевой или положительный индекс    |

### Использование методов с Varargs

Когда вы сами создаете массив, он выглядит так, как мы видели до сих пор. Когда один из них передается вашему методу, 
он может выглядеть по-другому. Вот три примера с использованием метода main():

```
public static void main(String[] args)
public static void main(String args[])
public static void main(String... args) // varargs
```

В третьем примере используется синтаксис, называемый varargs (переменные аргументы), который вы видели в главе 1. 
Вы узнаете, как вызывать метод с использованием varargs, в главе 5, «Методы». На данный момент все, что вам нужно 
знать, это то, что вы можете использовать переменную, определенную с помощью varargs, как если бы это был обычный массив. 
Например, допустимы args.length и args[0].

### Работа с многомерными массивами

Массивы — это объекты, и, конечно, компоненты массива могут быть объектами. Сопоставление этих двух фактов не займет 
много времени, чтобы задаться вопросом, могут ли массивы содержать другие массивы, и, конечно же, могут.

#### Создание многомерного массива

Несколько разделителей массивов — это все, что нужно для объявления массивов с несколькими измерениями. Вы можете найти 
их по имени типа или переменной в объявлении, как и раньше:

```
int[][] vars1;                // двумерный массив
int vars2 [][];               // двумерный массив
int[] vars3[];                // двумерный массив
int[] vars4 [], space [][];   // двумерный и трехмерный массив
```

В первых двух примерах нет ничего удивительного, и они объявляют двумерный (2D) массив. В третьем примере также 
объявляется двумерный массив. Нет веской причины использовать этот стиль, кроме как запутать читателей своим кодом. 
Последний пример объявляет два массива в одной строке. Сложив скобки, мы видим, что vars4 — это 2D-массив, 
а space — 3D-массив. Опять же, нет никакой причины использовать этот стиль, кроме как сбить с толку читателей вашего 
кода. Однако создатели экзамена любят пытаться вас запутать. К счастью, вы их понимаете и не позволите этому случиться 
с вами!

Вы можете указать размер вашего многомерного массива в объявлении, если хотите:

```
String [][] rectangle = new String[3][2];
```

Результатом этого оператора является прямоугольник массива с тремя элементами, каждый из которых ссылается на массив из 
двух элементов. Вы можете думать об адресуемом диапазоне как от [0][0] до [2][1], но не думайте о нем как о структуре 
адресов вроде [0,0] или [2,1].

Теперь предположим, что мы установили одно из этих значений:

```
rectangle[0][1] = "set";
```

Вы можете визуализировать результат, как показано на Рис. 4.7. Этот массив редко заполняется, потому что он имеет много 
нулевых значений. Вы можете видеть, что прямоугольник по-прежнему указывает на массив из трех элементов и что у нас 
есть три массива из двух элементов. Вы также можете проследить путь от ссылки до одного значения, указывающего на 
строку. Вы начинаете с индекса 0 в верхнем массиве. Затем вы переходите к индексу 1 в следующем массиве.

#### Рис. 4.7 - Малонаселенный многомерный массив


Несмотря на то, что этот массив имеет прямоугольную форму, он не обязательно должен быть таким. Рассмотрим это:

```
int[][] differentSizes = {{1, 4}, {3}, {9,8,7}};
```

Мы по-прежнему начинаем с массива из трех элементов. Однако на этот раз элементы следующего уровня имеют разные размеры. 
Один имеет длину 2, следующий — 1, а последний — 3. См. рис. 4.8. На этот раз массив состоит из примитивов, поэтому они 
отображаются так, как будто они сами находятся в массиве.

#### Рис. 4.8 - Асимметричный многомерный массив


Другой способ создания асимметричного массива - инициализировать только первое измерение массива и определить размер 
каждого компонента массива в отдельном операторе:

```
int [][] args = new int[4][];
args[0] = new int[5];
args[1] = new int[3];
```

Этот метод раскрывает то, что вы действительно получаете с Java: массивы массивов, которые при правильном управлении 
дают многомерный эффект.

#### Использование многомерного массива

Наиболее распространенной операцией над многомерным массивом является его перебор. В этом примере выводится 
двумерный массив:

```
var twoD = new int[3][2];
for (int i = 0; i < twoD.length; i++) {
   for (int j = 0; j < twoD[i].length; j++)
      System.out.print(twoD[i][j] + " ");  // print element
   System.out.println();                   // time for a new row
}
```

Здесь у нас есть два цикла. Первый использует индекс i и проходит через первый подмассив для twoD. Во втором 
используется другая переменная цикла, j. Важно, чтобы это были разные имена переменных, чтобы циклы не перепутались. 
Внутренний цикл проверяет, сколько элементов находится в массиве второго уровня. Внутренний цикл печатает элемент и 
оставляет пространство для удобства чтения. Когда внутренний цикл завершается, внешний цикл переходит к новой строке и 
повторяет процесс для следующего элемента.

Все это упражнение было бы легче прочитать с помощью расширенного цикла for.

```
for(int[] inner : twoD) {
   for(int num : inner)
      System.out.print(num + " ");
   System.out.println();
}
```

Мы признаем, что строк не меньше, но каждая строка менее сложна, и нет никаких переменных цикла или условий завершения, 
которые можно было бы перепутать.

## Вычисления с помощью Math API

Неудивительно, что компьютеры хорошо вычисляют числа. Java поставляется с мощным классом Math со множеством методов, 
облегчающих вашу жизнь. Здесь мы рассмотрим лишь несколько наиболее распространенных из них, которые, скорее всего, 
появятся на экзамене. При выполнении собственных проектов загляните в Math Javadoc, чтобы узнать, какие другие методы 
могут вам помочь. Обратите особое внимание на возвращаемые типы в математических вопросах. Это отличная возможность 
для обмана!

### Поиск минимума и максимума

Методы min() и max() сравнивают два значения и возвращают одно из них.
Сигнатуры метода для min() следующие:

```
public static double min(double a, double b)
public static float min(float a, float b)
public static int min(int a, int b)
public static long min(long a, long b)
```

Существует четыре перегруженных метода, поэтому у вас всегда будет доступный API с одним и тем же типом. Каждый метод 
возвращает меньшее из значений a или b. Метод max() работает так же, за исключением того, что он возвращает большее 
значение.

Ниже показано, как использовать эти методы:

```
int first = Math.max(3, 7);    // 7
int second = Math.min(7, -9);  // -9
```

Первая строка возвращает 7, потому что она больше. Вторая строка возвращает -9, потому что она меньше. Помните из 
школы, что отрицательные значения меньше положительных.

### Округление чисел

Метод round() избавляется от десятичной части значения, выбирая следующее большее число, если это необходимо. Если 
дробная часть равна .5 или выше, мы округляем в большую сторону.

Сигнатуры метода для round() следующие:

```
public static long round(double num)
public static int round(float num)
```

Существует два перегруженных метода, гарантирующих наличие достаточного места для хранения округленного double при 
необходимости. Ниже показано, как использовать этот метод:

```
long low = Math.round(123.45);        // 123
long high = Math.round(123.50);       // 124
int fromFloat = Math.round(123.45f);  // 123
```

Первая строка возвращает 123, потому что .45 меньше половины. Вторая строка возвращает 124, потому что дробная часть 
составляет едва ли половину. Последняя строка показывает, что явное значение float запускает сигнатуру метода, которая 
возвращает значение int.

### Округление в большую и меньшую сторону

Метод ceil() принимает double значение. Если это целое число, то оно возвращает то же значение. Если оно имеет 
какое-либо дробное значение, оно округляется до следующего целого числа. В отличие от этого, метод floor() отбрасывает 
любые значения после десятичной дроби. 

Сигнатуры методов следующие:

```
public static double ceil(double num)
public static double floor(double num)
```

Ниже показано, как использовать эти методы:

```
double c = Math.ceil(3.14); // 4.0
double f = Math.floor(3.14); // 3.0
```

Первая строка возвращает 4.0, потому что четыре - это целое число, только больше. Вторая строка возвращает 
значение 3.0, потому что это целое число, только меньшее.

### Возведение в степень

Метод pow() обрабатывает показатели степени. Как вы помните из уроков математики в начальной школе, 3^(2) означает 
три в квадрате. Это 3 * 3 или 9. Допускаются также дробные показатели степени. Шестнадцать в степени 0,5 означает 
квадратный корень из 16, что равно 4. (Не волнуйтесь, вам не придется вычислять квадратный корень на экзамене.)

Сигнатура метода выглядит следующим образом:

```
public static double pow(double number, double exponent)
```

Ниже показано, как использовать этот метод:

```
double squared = Math.pow(5, 2);  // 25.0
```

Обратите внимание, что результат равен 25.0, а не 25, так как это double. Опять же, не волнуйтесь; экзамен не потребует 
от вас выполнения какой-либо сложной математики.

### Генерация случайных чисел

Метод random() возвращает значение, большее или равное 0 и меньшее 1. Сигнатура метода выглядит следующим образом:

```
public static double random()
```

Ниже показано, как использовать этот метод:

```
double num = Math.random();
```

Поскольку это случайное число, мы не можем знать результат заранее. Однако мы можем исключить определенные числа. 
Например, оно не может быть отрицательным, потому что оно меньше 0. Это не может быть 1.0, потому что это не меньше 1.

_Вне экзамена класс Random обычно используется для создания псевдослучайных чисел. Позволяет генерировать числа разных типов._

## Работа с датой и временем

Java предоставляет ряд API для работы с датами и временем. Еще есть старый класс java.util.Date, но его нет на экзамене. 
Вам нужен оператор импорта для работы с современными классами даты и времени. Чтобы использовать его, добавьте этот 
импорт в свою программу:

```
import java.time.*;   // import time classes
```

---

#### Day vs. Date

В американском английском слово date используется для обозначения двух разных понятий. Иногда это комбинация 
месяца/дня/года, когда что-то произошло, например, 1 января 2000 года. Иногда это день месяца, например, 
«Сегодняшнее число — 6-е».

Это верно; слова "day" и "data" часто используются как синонимы. Будьте внимательны к этому на экзамене, особенно если 
вы живете где-то, где люди более точно понимают это различие.

---

В следующих разделах мы рассмотрим создание и изменение даты и времени, включая часовые пояса и переход на летнее время.

### Создание даты и времени

В реальном мире мы обычно говорим о датах и часовых поясах так, как будто другой человек находится рядом с нами. 
Например, если вы говорите мне: «Я позвоню вам в 11:00 во вторник утром», мы предполагаем, что 11:00 означает одно и то 
же для нас обоих. Но если я живу в Нью-Йорке, а вы живете в Калифорнии, нам нужно быть более конкретными. В Калифорнии 
на три часа раньше, чем в Нью-Йорке, потому что штаты находятся в разных часовых поясах. Вместо этого вы бы сказали: 
«Я позвоню вам в 11:00 по восточному поясному времени (восточное стандартное время) во вторник утром».

При работе с датами и временем первое, что нужно сделать, это решить, сколько информации вам нужно. 
Экзамен дает вам четыре варианта:

**LocalDate** Содержит только дату — без времени и без часового пояса. Хорошим примером LocalDate является ваш день 
рождения в этом году. Это ваш день рождения на целый день, независимо от того, который сейчас час.

**LocalTime** Содержит только время — без даты и без часового пояса. Хорошим примером LocalTime является полночь. 
Полночь в одно и то же время каждый день.

**LocalDateTime** Содержит дату и время, но не часовой пояс. Хорошим примером LocalDateTime является «удар полуночи в 
канун Нового года». Полночь 2 января не такая особенная, что делает дату относительно неважной, и, очевидно, час после 
полуночи тоже не такой особенный.

**ZonedDateTime** Содержит дату, время и часовой пояс. Хорошим примером ZonedDateTime является «конференц-связь в 9:00 
утра по восточному поясному времени». Если вы живете в Калифорнии, вам придется вставать очень рано, так как звонок 
в 6:00 утра по местному времени!

Вы получаете экземпляры даты и времени, используя статический метод:

```
System.out.println(LocalDate.now());
System.out.println(LocalTime.now());
System.out.println(LocalDateTime.now());
System.out.println(ZonedDateTime.now());
```

Каждый из четырех классов имеет статический метод с именем now(), который возвращает текущую дату и время. Ваш вывод 
будет зависеть от даты/времени, когда вы его запустите, и от того, где вы живете. Авторы живут в Соединенных Штатах, 
поэтому вывод при запуске 25 октября в 9:13 утра выглядит следующим образом:

```
2021–10–25
09:13:07.768
2021–10–25T09:13:07.768
2021–10–25T09:13:07.769–05:00[America/New_York]
```

Ключом является тип информации на выходе. Первая строка содержит только дату и не содержит времени. Вторая содержит 
только время и не содержит даты. Время отображает часы, минуты, секунды и доли секунды. Третий содержит дату и время. 
Выходные данные используют T для разделения даты и времени при преобразовании LocalDateTime в String. Наконец, в 
четвертом добавляется смещение часового пояса и часовой пояс. Нью-Йорк находится в четырех часовых поясах от среднего 
времени по Гринвичу (GMT).

Среднее время по Гринвичу - это часовой пояс в Европе, который используется в качестве нулевого часового пояса при 
обсуждении смещений. Возможно, вы также слышали о Всемирном координированном времени, которое является стандартом 
часового пояса. Он сокращен до UTC, как компромисс между английским и французским названиями. (Это не опечатка. UTC на 
самом деле не является подходящей аббревиатурой ни на одном из языков!) UTC использует тот же нулевой часовой пояс, 
что и GMT.

Во-первых, давайте попробуем выяснить, насколько далеко друг от друга эти моменты во времени. Обратите внимание, что у 
Индии есть получасовое смещение, а не полный час. Чтобы подойти к такой проблеме, вы вычитаете часовой пояс из времени. 
Это дает вам эквивалент времени по Гринвичу:

```
2022–06–20T06:50+05:30[Asia/Kolkata]  // GMT 2022–06–20 01:20
2022–06–20T07:50-05:00[US/Eastern]    // GMT 2022–06–20 12:50
```

Помните, что прибавлять нужно при вычитании отрицательного числа. После преобразования в GMT вы можете увидеть, что 
восточное время США на 11 с половиной часов отстает от времени Калькутты.

_Смещение часового пояса может быть указано по-разному: +02:00, GMT+2 и UTC+2 означают одно и то же. Вы можете увидеть 
любой из них на экзамене._

Если у вас возникли проблемы с запоминанием этого, попробуйте запомнить один пример, где часовые пояса находятся на 
расстоянии нескольких зон друг от друга, и запомните направление. В Соединенных Штатах большинство людей знают, что 
Восточное побережье на три часа опережает Западное. И большинство людей знают, что Азия опережает Европу. Просто не 
пересекайте нулевой часовой пояс в примере, который вы решили запомнить. Вычисление работает таким же образом, но это 
не так здорово помогает запоминанию.

---

#### Подождите, я не живу в Соединенных Штатах

Экзамен признает, что сдающие экзамен проживают по всему миру, и он не будет спрашивать вас о деталях форматов даты и 
времени в США. Тем не менее, в наших примерах используются форматы даты и времени в США, как и в вопросах на экзамене. 
Просто помните, что месяц предшествует дате. Кроме того, Java, как правило, использует 24-часовые часы, хотя в 
Соединенных Штатах используются 12-часовые часы с am / pm.

---

Теперь, когда вы знаете, как создать текущую дату и время, давайте рассмотрим другие конкретные даты и время. 
Для начала давайте создадим просто дату без учета времени. В обоих этих примерах создается одна и та же дата:

```
var date1 = LocalDate.of(2022, Month.JANUARY, 20);
var date2 = LocalDate.of(2022, 1, 20);
```

Оба проходят в год, месяц и дату. Хотя хорошо использовать константы Month (чтобы облегчить чтение кода), вы можете 
передать int-номер месяца напрямую. Просто используйте номер месяца так же, как если бы вы писали дату в реальной жизни.

Сигнатуры методов следующие:

```
public static LocalDate of(int year, int month, int dayOfMonth)
public static LocalDate of(int year, Month month, int dayOfMonth)
```

_До сих пор мы постоянно говорили вам, что счет в Java начинается с 0. Месяцы — исключение. Месяцы в новых методах даты 
и времени Java считает, начиная с 1, как и мы, люди._

При создании времени вы можете выбрать, насколько подробно вы хотите быть. Вы можете указать только часы и минуты или 
указать количество секунд. Вы даже можете включить наносекунды, если хотите быть очень точным. (Наносекунда — это 
миллиардная доля секунды, хотя вам, вероятно, не нужно быть таким конкретным.)

```
var time1 = LocalTime.of(6, 15);            // hour and minute
var time2 = LocalTime.of(6, 15, 30);        // + seconds
var time3 = LocalTime.of(6, 15, 30, 200);   // + nanoseconds
```

Все эти три раза разные, но с интервалом в минуту друг от друга. Сигнатуры метода следующие:

```
public static LocalTime of(int hour, int minute)
public static LocalTime of(int hour, int minute, int second)
public static LocalTime of(int hour, int minute, int second, int nanos)
```

Вы можете объединить даты и время в один объект:

```
var dateTime1 = LocalDateTime.of(2022, Month.JANUARY, 20, 6, 15, 30);
var dateTime2 = LocalDateTime.of(date1, time1);
```

Первая строка кода показывает, как вы можете указать всю информацию о LocalDateTime прямо в той же строке. Вторая 
строка кода показывает, как вы можете сначала создать объекты LocalDate и LocalTime по отдельности, а затем объединить 
их для создания объекта LocalDateTime.

Существует множество сигнатур методов, поскольку существует больше конфигураций. В следующих сигнатурах методов 
используются целочисленные значения:

```
public static LocalDateTime of(int year, int month,
       int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, int month,
       int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, int month,
       int dayOfMonth, int hour, int minute, int second, int nanos)
```

Другие берут Month ссылку:

```
public static LocalDateTime of(int year, Month month,
       int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, Month month,
       int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, Month month,
       int dayOfMonth, int hour, int minute, int second, int nanos)
```

Наконец, можно взять существующие LocalDate и LocalTime:

```
public static LocalDateTime of(LocalDate date, LocalTime time)
```

Чтобы создать ZonedDateTime, нам сначала нужно получить желаемый часовой пояс. В наших примерах мы будем использовать 
US/Eastern:

```
var zone = ZoneId.of("US/Eastern");
var zoned1 = ZonedDateTime.of(2022, 1, 20,
       6, 15, 30, 200, zone);
var zoned2 = ZonedDateTime.of(date1, time1, zone);
var zoned3 = ZonedDateTime.of(dateTime1, zone);
```

We start by getting the time zone object. Then we use one of three approaches to create
the ZonedDateTime. The first passes all of the fields individually. We don’t recommend this
approach—there are too many numbers, and it is hard to read. A better approach is to pass
a LocalDate object and a LocalTime object, or a LocalDateTime object.

Хотя есть и другие способы создания ZonedDateTime, для экзамена вам нужно знать только три:

```
public static ZonedDateTime of(int year, int month,
   int dayOfMonth, int hour, int minute, int second,
   int nanos, ZoneId zone)
public static ZonedDateTime of(LocalDate date, LocalTime time,
   ZoneId zone)
public static ZonedDateTime of(LocalDateTime dateTime, ZoneId zone)
```

Notice that there isn’t an option to pass in the Month enum. Also, we did not use a constructor in any of the examples. The date and time classes have private constructors along
with static methods that return instances. This is known as the factory pattern. The exam
creators may throw something like this at you:

```
var d = new LocalDate(); // DOES NOT COMPILE
```

Не поддавайтесь этому. Вам не разрешено создавать объект даты или времени напрямую. Еще одна хитрость заключается в 
том, что происходит, когда вы передаете недопустимые числа в функцию of(), например:

```
var d = LocalDate.of(2022, Month.JANUARY, 32) // DateTimeException
```

Вам не нужно знать точное исключение, которое выбрасывается, но оно очевидно:

```
java.time.DateTimeException: Invalid value for DayOfMonth
       (valid values 1-28/31): 32
```

### Манипулирование датами и временем

Добавить дату легко. Классы даты и времени неизменяемы. Не забудьте присвоить результаты этих методов ссылочной 
переменной, чтобы они не были потеряны.

```
12: var date = LocalDate.of(2022, Month.JANUARY, 20);
13: System.out.println(date);    // 2022–01–20
14: date = date.plusDays(2);
15: System.out.println(date);    // 2022–01–22
16: date = date.plusWeeks(1);
17: System.out.println(date);    // 2022–01–29
18: date = date.plusMonths(1);
19: System.out.println(date);    // 2022–02–28
20: date = date.plusYears(5);
21: System.out.println(date);    // 2027–02–28
```

Этот код хорош, потому что он делает именно то, на что он похож. Мы начинаем с 20 января 2022 года. В строке 14 мы 
добавляем к нему два дня и переназначаем его нашей ссылочной переменной. В строке 16 мы добавляем неделю. Этот метод 
позволяет нам писать более понятный код, чем plusDays(7). Теперь дата 29 января 2022 года. В строке 18 мы добавляем 
месяц. Это приведет нас к 29 февраля 2022 года.

Однако 2022 год не является високосным. (2020 и 2024 годы — високосные.) Java достаточно умен, чтобы понять, что 
29 февраля 2022 года не существует, и вместо этого дает нам 28 февраля 2022 года. Наконец, строка 20 добавляет пять лет.

_29 февраля существует только в високосный год. Високосные годы — это годы, кратные 4 или 400, но не кратные 100. 
Например, 2000 и 2016 годы являются високосными, а 2100 — нет._

Есть также хорошие и простые способы вернуться назад во времени. На этот раз давайте поработаем с LocalDateTime:

```
22: var date = LocalDate.of(2024, Month.JANUARY, 20);
23: var time = LocalTime.of(5, 15);
24: var dateTime = LocalDateTime.of(date, time);
25: System.out.println(dateTime);        // 2024–01–20T05:15
26: dateTime = dateTime.minusDays(1);
27: System.out.println(dateTime);        // 2024–01–19T05:15
28: dateTime = dateTime.minusHours(10);
29: System.out.println(dateTime);        // 2024–01–18T19:15
30: dateTime = dateTime.minusSeconds(30);
31: System.out.println(dateTime);        // 2024–01–18T19:14:30
```

Строка 25 выводит исходную дату 20 января 2024 года в 5:15 утра, строка 26 вычитает полный день, приводя нас к 19 января 2024 года в 5:15 утра, строка 28 вычитает 10 часов, показывая, что дата изменится, если часы заставят ее скорректировать, и это приводит к США до 18 января 2024 года, в 19:15 (7:15 вечера). Наконец, строка 30 вычитает 30 секунд. Вы можете видеть, что внезапно отображаемое значение начинает показывать секунды. Java достаточно умна, чтобы скрывать секунды и наносекунды, когда мы их не используем.
or
В строке 25 выводится исходная дата 20 января 2024 года, 5:15 утра. В строке 26 вычитаются полные сутки, что приводит нас к 19 января 2024 года, 5:15 утра. В строке 28 вычитается 10 часов, показывая, что дата изменится, если часы заставляют его корректироваться, и это приводит нас к 18 января 2024 года, в 19:15 (19:15). Наконец, строка 30 вычитает 30 секунд. Вы можете видеть, что внезапно отображаемое значение начинает показывать секунды. Java достаточно умен, чтобы скрывать секунды и наносекунды, когда мы их не используем.

Обычно методы даты и времени связаны друг с другом. Например, без операторов печати предыдущий пример можно было бы 
переписать следующим образом:

```
var date = LocalDate.of(2024, Month.JANUARY, 20);
var time = LocalTime.of(5, 15);
var dateTime = LocalDateTime.of(date, time)
       .minusDays(1).minusHours(10).minusSeconds(30);

```

Когда у вас есть много манипуляций, эта цепочка пригодится. Есть два способа, которыми создатели экзамена могут 
попытаться вас обмануть. Как вы думаете, что это печатает?

```
var date = LocalDate.of(2024, Month.JANUARY, 20);
date.plusDays(10);
System.out.println(date);
```

Он печатает 20 января 2024 года. Добавлять 10 дней было бесполезно, потому что программа проигнорировала результат. 
Всякий раз, когда вы видите неизменяемые типы, обратите внимание, чтобы убедиться, что возвращаемое значение вызова 
метода не игнорируется. Экзамен также может проверить, помните ли вы, что включает в себя каждый из объектов даты и 
времени. Вы видите, что здесь не так?

```
var date = LocalDate.of(2024, Month.JANUARY, 20);
date = date.plusMinutes(1);                 // DOES NOT COMPILE
```

LocalDate не содержит время. Это означает, что вы не можете добавить к нему минуты. Это может быть сложно в цепочке 
операций сложения/вычитания, поэтому убедитесь, что вы знаете, какие методы из таблицы 4.6 можно вызывать для 
каких типов.

#### Таблица 4.6. - Методы в LocalDate, LocalTime, LocalDateTime, и ZonedDateTime

|                                    | Можно вызвать на<br/>LocalDate? | Можно вызвать на<br/>LocalTime? | Можно вызвать на<br/>LocalDateTime или ZonedDateTime? |
|:----------------------------------:|:-------------------------------:|:-------------------------------:|:-----------------------------------------------------:|
|   plusYears() <br/> minusYears()   |               Yes               |               No                |                          Yes                          | 
|  plusMonths() <br/> minusMonths()  |               Yes               |               No                |                          Yes                          |
|   plusWeeks() <br/> minusWeeks()   |               Yes               |               No                |                          Yes                          |
|    plusDays() <br/> minusDays()    |               Yes               |               No                |                          Yes                          |
|   plusHours() <br/> minusHours()   |               No                |               Yes               |                          Yes                          |
| plusMinutes() <br/> minusMinutes() |               No                |               Yes               |                          Yes                          |
| plusSeconds() <br/> minusSeconds() |               No                |               Yes               |                          Yes                          |
|  plusNanos() <br/> minusNanos ()   |               No                |               Yes               |                          Yes                          |

### Работа с периодами

Теперь вы знаете достаточно, чтобы сделать что-нибудь интересное с датами! В нашем зоопарке проводятся мероприятия по 
обогащению животных, чтобы дать животным какое-то приятное занятие. Главный смотритель зоопарка решил менять игрушки 
каждый месяц. Эта система будет действовать в течение трех месяцев, чтобы посмотреть, как она работает.

```
public static void main(String[] args) {
   var start = LocalDate.of(2022, Month.JANUARY, 1);
   var end = LocalDate.of(2022, Month.MARCH, 30);
   performAnimalEnrichment(start, end);
}
private static void performAnimalEnrichment(LocalDate start, LocalDate end) {
   var upTo = start;
   while (upTo.isBefore(end)) {   // check if still before end
      System.out.println("give new toy: " + upTo);
      upTo = upTo.plusMonths(1);  // add a month
} }
```

Этот код работает нормально. Он добавляет месяц к дате, пока не достигнет конечной даты. Проблема в том, что этот 
метод нельзя использовать повторно. Наш смотритель зоопарка хочет попробовать разные расписания, чтобы понять, какое 
работает лучше всего.

_LocalDate и LocalDateTime имеют метод преобразования самих себя в длинные значения, эквивалентные количеству 
миллисекунд, прошедших с 1 января 1970 года, называемых эпохой. Что особенного в этой дате? Это то, что Unix начал 
использовать для стандартов даты, поэтому Java использовала его повторно._

К счастью, в Java есть класс Period, который мы можем передать. Этот код делает то же самое, что и предыдущий пример:

```
public static void main(String[] args) {
   var start = LocalDate.of(2022, Month.JANUARY, 1);
   var end = LocalDate.of(2022, Month.MARCH, 30);
   var period = Period.ofMonths(1);    // create a period
   performAnimalEnrichment(start, end, period);
}
private static void performAnimalEnrichment(LocalDate start, LocalDate end,
   Period period) {       // uses the generic period
   
   var upTo = start;
   while (upTo.isBefore(end)) {
      System.out.println("give new toy: " + upTo);
      upTo = upTo.plus(period); // adds the period
} }
```

Метод может добавлять произвольный период времени, который передается. Это позволяет нам повторно использовать один и 
тот же метод для разных периодов времени, когда наш смотритель зоопарка передумает.

Существует пять способов создания класса Period:

```
var annually = Period.ofYears(1);           // every 1 year
var quarterly = Period.ofMonths(3);         // every 3 months
var everyThreeWeeks = Period.ofWeeks(3);    // every 3 weeks
var everyOtherDay = Period.ofDays(2);       // every 2 days
var everyYearAndAWeek = Period.of(1, 0, 7); // every year and 7 days
```

Есть одна загвоздка. Вы не можете связать методы при создании Period. Следующий код выглядит так, как будто он 
эквивалентен примеру everyYearAndAWeek, но это не так. Используется только последний метод, поскольку методы Period.of 
являются static.

```
var wrong = Period.ofYears(1).ofWeeks(1); // every week
```

Этот запутанный код действительно похож на следующий:

```
var wrong = Period.ofYears(1);
wrong = Period.ofWeeks(1);
```

Это явно не то, что вы предполагали! Вот почему метод of() позволяет вам передавать количество лет, месяцев и дней. 
Все они включены в один и тот же период. Вы получите предупреждение компилятора об этом. Предупреждения компилятора 
сообщают вам, что что-то не так или подозрительно, без сбоев компиляции.

Метод of() занимает только годы, месяцы и дни. Возможность использовать другой заводской метод для прохождения недель - это просто удобство. Как вы можете себе представить, фактический период хранится в виде лет, месяцев и дней. Когда вы распечатываете значение, Java отображает все ненулевые части, используя формат, показанный на рисунке 4.9.
or
Метод of() занимает всего несколько лет, месяцев и дней. Возможность использовать другой фабричный метод, чтобы скоротать недели, — это просто удобство. Как вы можете себе представить, фактический период хранится в годах, месяцах и днях. Когда вы распечатываете значение, Java отображает все ненулевые части, используя формат, показанный на рис. 4.9.

#### Рис. 4.9 - Формат периода


Как вы можете видеть, P всегда начинается со String, чтобы показать, что это мера периода. Затем идет количество лет, 
количество месяцев и количество дней. Если какой-либо из них равен нулю, они опускаются.

Вы можете понять, что это выводит?

```
System.out.println(Period.ofMonths(3));
```

Выводит - P3M. Помните, что Java опускает любые меры, которые равны нулю. Последнее, что нужно знать о Period, — это то, 
с какими объектами его можно использовать. Давайте посмотрим на код:

```
3: var date = LocalDate.of(2022, 1, 20);
4: var time = LocalTime.of(6, 15);
5: var dateTime = LocalDateTime.of(date, time);
6: var period = Period.ofMonths(1);
7: System.out.println(date.plus(period));      // 2022–02–20
8: System.out.println(dateTime.plus(period));  // 2022–02–20T06:15
9: System.out.println(time.plus(period));      // Exception
```

Строки 7 и 8 работают как положено. Они добавляют месяц к 20 января 2022 года, что дает нам 20 февраля 2022 года. 
У первого есть только дата, а у второго есть и дата, и время.

Строка 9 пытается добавить месяц к объекту, у которого есть только время. Это не сработает. Java выдает исключение 
UnsupportedTemporalTypeException и жалуется, что мы пытались использовать неподдерживаемую единицу измерения: Месяцы
(Unsupported unit: Months).

Как видите, вы должны обращать внимание на тип объектов даты и времени в каждом месте, где вы их видите.

### Работа с длительностью

