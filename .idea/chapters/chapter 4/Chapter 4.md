# Основные API

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Обработка даты, времени, текста, числовых и логических значений

+ Используйте примитивы и классы-оболочки, включая Math API, круглые скобки, продвижение(или повышение) и 
приведение типов для вычисления арифметических и логических выражений
+ Манипулируйте текстом, включая текстовые блоки, используя классы String и StringBuilder
+ Манипулируйте датой, временем, продолжительностью, периодом, мгновенными объектами и объектами часового пояса с 
помощью Date-Time API

#### Работа с массивами и коллекциями

+ Создавайте массивы Java, коллекции List, Set, Map и Deque, а также добавляйте, удаляйте, обновляйте, извлекайте и 
сортируйте их элементы

---

В контексте интерфейса прикладного программирования (API) интерфейс относится к группе классов или определений 
интерфейса Java, предоставляющих вам доступ к функциональности.

В этой главе вы узнаете о многих основных структурах данных в Java, а также о наиболее распространенных API для доступа 
к ним. Например, String и StringBuilder вместе со связанными с ними API используются для создания текстовых данных и 
управления ими. Затем мы покрываем массивы. Наконец, мы изучаем математические API и API даты/времени.

## Создание и манипулирование строками

Класс String - это настолько фундаментальный класс, что вам было бы трудно писать код без него. В конце концов, вы даже 
не можете написать метод main() без использования класса String. Строка - это, по сути, последовательность символов; 
вот пример:

```
String name = "Fluffy";
```

Как вы узнали из главы 1 “Строительные блоки”, это пример ссылочного типа. Вы также узнали, что ссылочные типы создаются
с использованием ключевого слова new. Подождите минуту. В предыдущем примере чего-то не хватает: в нем нет new! В Java 
эти два фрагмента создают строку:

```
String name = "Fluffy";
String name = new String("Fluffy");
```

Оба дают вам ссылочную переменную с именем name, указывающую на объект String "Fluffy". Как вы увидите далее в этой 
главе, они немного отличаются. А пока просто помните, что класс String особенный и его не нужно создавать с помощью new.

Кроме того, текстовые блоки — это ещё один способ создания String. Для обзора этот текстовый блок такой же, как и 
предыдущие переменные:

```
String name = """
              Fluffy""";
```

Поскольку String - это последовательность символов, вы, вероятно, не удивитесь, услышав, что она реализует интерфейс 
CharSequence. Этот интерфейс представляет собой общий способ представления нескольких классов, включая String и 
StringBuilder. Вы узнаете больше об интерфейсах в главе 7 “За пределами классов”.

В этом разделе мы рассмотрим конкатенацию, общие методы и цепочку методов.

### Конкатенация

В главе 2 «Операторы» вы узнали, как складывать числа. 1 + 2 — это явно 3. Но что такое «1» + «2»? Это «12», потому что 
Java объединяет два объекта String. Размещение одной строки перед другой строкой и их объединение называется 
конкатенацией строк. Создателям экзамена нравится конкатенация строк, потому что оператор + можно использовать двумя 
способами в одной строке кода. Для этого не так много правил, но вы должны их хорошо знать:

1. Если оба операнда являются числовыми, + означает числовое сложение.
2. Если любой из операндов является строкой, + означает конкатенацию.
3. Выражение оценивается слева направо.

Теперь давайте рассмотрим несколько примеров:

```
System.out.println(1 + 2);             // 3
System.out.println("a" + "b");         // ab
System.out.println("a" + "b" + 3);     // ab3
System.out.println(1 + 2 + "c");       // 3c
System.out.println("c" + 1 + 2);       // c12
System.out.println("c" + null);        // cnull
```

В первом примере используется первое правило. Оба операнда являются числами, поэтому мы используем обычное сложение. 
Второй пример — простая конкатенация строк, описанная во втором правиле. Кавычки для строки используются только в коде; 
они не получают выход.

Третий пример объединяет второе и третье правила. Поскольку мы начинаем слева, Java выясняет, чему соответствует 
"a" + "b". Вы уже знаете это: это «ab». Затем Java просматривает оставшееся выражение «ab» + 3. Второе правило говорит 
нам о конкатенации, поскольку один из операндов является строкой.

В четвертом примере мы начинаем с третьего правила, которое говорит нам рассмотреть 1 + 2. Оба операнда являются 
числовыми, поэтому первое правило говорит нам, что ответ равен 3. Затем у нас есть 3 + «с», которое использует второе 
правило, чтобы дать нам "3c". Заметили, что все три правила используются в одной строке?

Пятый пример показывает важность третьего правила. Сначала у нас есть "c" + 1, который использует второе правило, чтобы 
дать нам "c1". Затем у нас есть «c1» + 2, который снова использует второе правило, чтобы дать нам «c12».

Наконец, последний пример показывает, как null представляется в виде строки при объединении или печати, что дает нам 
«cnull».

Экзамен делает ещё один шаг вперед и попытается одурачить вас чем-то вроде этого:

```
int three = 3;
String four = "4";
System.out.println(1 + 2 + three + four);
```

Когда вы увидите это, просто не торопитесь, запомните три правила и обязательно проверьте типы переменных. В этом 
примере мы начинаем с третьего правила, которое говорит нам рассмотреть 1 + 2.

Первое правило дает нам 3. Далее у нас есть 3 + three. Поскольку число three имеет тип int, мы по-прежнему используем 
первое правило, что дает нам число 6. Тогда у нас есть 6 + four. Так как четыре имеет тип String, мы переключаемся на 
второе правило и получаем окончательный ответ «64». Когда вы видите такие вопросы, просто не торопитесь и проверьте 
типы. Методичность окупается.

Есть еще одна вещь, которую нужно знать о конкатенации, но это несложно. В этом примере вам просто нужно помнить, что 
делает +=. Имейте в виду, что s += "2" означает то же самое, что и s = s + "2".

```
4: var s = "1";                // s currently holds "1"
5: s += "2";                   // s currently holds "12"
6: s += 3;                     // s currently holds "123"
7: System.out.println(s);      // 123
```

В строке 5 мы «добавляем» две строки, что означает их конкатенацию. Строка 6 пытается обмануть вас, добавляя число, но 
это точно так же, как мы написали s = s + 3. Мы знаем, что строка «плюс» что-либо еще означает использование 
конкатенации.

Чтобы просмотреть правила еще раз: используйте числовое сложение, если участвуют два числа, используйте конкатенацию в 
противном случае и оценивайте слева направо. Вы уже выучили эти три правила? Обязательно сделайте это перед экзаменом!


## Важные методы String

Класс String имеет десятки методов. К счастью, для экзамена вам нужно знать лишь несколько. Создатели экзамена выбирают 
большинство методов, которые разработчики используют в реальном мире.

Для всех этих методов вам нужно помнить, что строка представляет собой последовательность символов, а Java отсчитывает 
от 0 при индексации. На рис. 4.1 показано, как индексируется каждый символ в строке «animals».

#### Рис. 4.1 - Индексация для строки

Вам также необходимо знать, что String является неизменяемым или неизменным. Это означает, что вызов метода для 
String вернет другой объект String, а не изменит значение ссылки. В этой главе вы используете неизменяемые объекты. 
В главе 6 “Проектирование классов” вы узнаете, как создавать собственные неизменяемые объекты.

Давайте рассмотрим несколько методов класса String. Многие из них просты, поэтому мы не будем подробно их обсуждать. 
Вы должны знать, как использовать эти методы.

### Определение длины

Метод length() возвращает количество символов в строке. Сигнатура метода выглядит следующим образом:

```
public int length()
```

Следующий код показывает, как использовать length():

```
var name = "animals";
System.out.println(name.length());  // 7
```

Ждать. Выдает 7? Разве мы только что не говорили вам, что Java считает с 0? Разница в том, что нулевой подсчет 
происходит только тогда, когда вы используете индексы или позиции в списке. При определении общего размера или длины 
Java снова использует обычный подсчет.

### Получение одного символа

Метод charAt() позволяет вам запросить строку, чтобы узнать, какой символ находится в определенном индексе. 
Сигнатура метода выглядит следующим образом:

```
public char charAt(int index)
```

Следующий код показывает, как использовать charAt():

```
var name = "animals";
System.out.println(name.charAt(0));  // a
System.out.println(name.charAt(6));  // s
System.out.println(name.charAt(7));  // exception
```

Поскольку индексы начинают считать с 0, charAt(0) возвращает «первый» символ в последовательности. Точно так же 
charAt(6) возвращает «седьмой» символ в последовательности. Однако проблема с charAt(7). Он запрашивает «восьмой» 
символ в последовательности, но присутствует только семь символов. Когда что-то идет не так, с чем Java не знает, что 
делать, она генерирует исключение, как показано здесь. Вы узнаете больше об исключениях в главе 11, «Исключения и 
локализация».

```
java.lang.StringIndexOutOfBoundsException: String index out of range: 7
```

### Поиск индекса

Метод indexOf() просматривает символы в строке и находит первый индекс, соответствующий нужному значению. Метод indexOf 
может работать с отдельным символом или целой строкой в качестве входных данных. Он также может начинаться с 
запрошенной позиции. Помните, что char может быть передан в тип параметра int. На экзамене вы увидите только символ, 
переданный в параметры с именем ch. Сигнатуры методов следующие:

```
public int indexOf(int ch)

public int indexOf(int ch, int fromIndex)
public int indexOf(String str)
public int indexOf(String str, int fromIndex)
```

Следующий код показывает, как использовать indexOf():

```
var name = "animals";
System.out.println(name.indexOf('a'));       // 0
System.out.println(name.indexOf("al"));      // 4
System.out.println(name.indexOf('a', 4));    // 4
System.out.println(name.indexOf("al", 5));   // -1
```

Поскольку индексы начинаются с 0, первая буква «а» соответствует этой позиции. Второй оператор ищет более конкретную 
строку, поэтому она соответствует позже. Третий оператор говорит, что Java не должен смотреть на символы, пока не 
доберется до индекса 4. Последний оператор ничего не находит, потому что он начинает искать после совпадения. В отличие 
от charAt(), метод indexOf() не генерирует исключение, если не может найти совпадение, вместо этого возвращает -1. 
Поскольку индексы начинаются с 0, вызывающая сторона знает, что -1 не может быть допустимым индексом. Это делает 
обычным значением для метода указание вызывающей стороне, что совпадение не найдено.

### Получение подстроки

Метод substring() также ищет символы в строке. Он возвращает части строки. Первый параметр — это индекс, с которого 
начинается возвращаемая строка. Как обычно, это индекс с отсчетом от нуля. Существует необязательный второй параметр, 
который является конечным индексом, на котором вы хотите остановиться.

Обратите внимание, мы сказали “остановиться на”, а не “включить”. Это означает, что параметру endIndex разрешено быть 
на единицу больше конца последовательности, если вы хотите остановиться в конце последовательности. Однако это было бы 
излишним, поскольку в этом случае вы могли бы полностью опустить второй параметр. В вашем собственном коде вы хотите 
избежать этой избыточности. Однако не удивляйтесь, если на экзамене он будет использоваться. Сигнатуры метода следующие:

```
public String substring(int beginIndex)
public String substring(int beginIndex, int endIndex)
```

Это помогает немного по-другому относиться к индексам для методов подстроки. Представьте, что индексы находятся прямо перед символом, на который они будут указывать. Рисунок 4.2 помогает визуализировать это. Обратите внимание, как стрелка с 0 указывает на символ, который будет иметь индекс 0. Стрелка с цифрой 1 указывает между символами с индексами 0 и 1. В строке семь символов. Поскольку Java использует индексы на основе нуля, это означает, что последний символ имеет индекс 6. Стрелка с 7 точками сразу после этого последнего символа. Это поможет вам помнить, что endIndex не выдает исключение, выходящее за пределы, когда оно находится на единицу дальше конца строки.

Это помогает думать об индексах немного по-другому для методов подстроки. Представьте, что индексы находятся прямо перед символом, на который они указывают. Рисунок 4.2 помогает визуализировать это. Обратите внимание, как стрелка с 0 указывает на символ, который должен иметь индекс 0. Стрелка с 1 указывает между символами с индексами 0 и 1. В строке семь символов. Так как Java использует индексы, начинающиеся с нуля, это означает, что последний символ имеет индекс 6. Стрелка с 7 указывает сразу после этого последнего символа. Это поможет вам помнить, что endIndex не выдает исключения за пределами диапазона, когда он находится за концом строки на единицу.

#### Рис. 4.2 - Индексы для подстроки


Следующий код показывает, как использовать substring():

```
var name = "animals";
System.out.println(name.substring(3));                   // mals
System.out.println(name.substring(name.indexOf('m')));   // mals
System.out.println(name.substring(3, 4));                // m
System.out.println(name.substring(3, 7));                // mals
```

Метод substring() - самый сложный строковый метод на экзамене. В первом примере говорится, что нужно брать символы, 
начиная с индекса 3 и заканчивая концом, что дает нам "mals". Во втором примере делается то же самое, но он вызывает 
indexOf() для получения индекса, а не жестко задает его. Это обычная практика при кодировании, потому что вы можете не 
знать индекс заранее.

В третьем примере говорится, что нужно брать символы, начинающиеся с индекса 3, до символа с индексом 4, но не включая 
его. Это сложный способ сказать, что нам нужна строка с одним символом: с индексом 3. В результате получается "m".
В последнем примере говорится, что нужно брать символы, начинающиеся с индекса 3, пока мы не дойдем до индекса 7. 
Поскольку индекс 7 совпадает с концом строки, это эквивалентно первому примеру.

Мы надеемся, что это не слишком сбило с толку. Следующие примеры менее очевидны:

```
System.out.println(name.substring(3, 3));  // empty string (пустая строка)
System.out.println(name.substring(3, 2));  // exception
System.out.println(name.substring(3, 8));  // exception
```

Первый пример в этом наборе печатает пустую строку. Запрос касается символов, начинающихся с индекса 3, пока мы не 
доберемся до индекса 3. Поскольку мы начинаем и заканчиваем с одним и тем же индексом, между ними нет символов. Второй 
пример в этом наборе вызывает исключение, потому что индексы не могут быть обратными. Java прекрасно знает, что она 
никогда не доберется до индекса 2, если начнет с индекса 3. В третьем примере предлагается продолжать до восьмого 
символа. Восьмой позиции нет, поэтому Java выдает исключение. Конечно, седьмого символа тоже нет, но зато есть 
невидимая позиция «конец строки».

Давайте рассмотрим это еще раз, так как функция substring() сложная. Метод возвращает строку, начинающуюся с 
запрошенного индекса. Если запрашивается конечный индекс, он останавливается прямо перед этим индексом. В противном 
случае он переходит в конец строки.

### Настройка регистра

После этого умственного упражнения приятно иметь методы, которые действуют именно так, как звучат! 
Эти методы упрощают преобразование ваших данных. Сигнатуры методов следующие:

```
public String toLowerCase()
public String toUpperCase()
```

В следующем коде показано, как использовать эти методы:

```
var name = "animals";
System.out.println(name.toUpperCase());      // ANIMALS
System.out.println("Abc123".toLowerCase());  // abc123
```

Эти методы делают то, что говорят. Метод toUpperCase() преобразует все символы нижнего регистра в верхний регистр в 
возвращаемой строке. Метод toLowerCase() преобразует любые символы верхнего регистра в нижний регистр в возвращаемой 
строке. Эти методы оставляют в покое любые символы, кроме букв. Кроме того, помните, что строки неизменяемы, поэтому 
исходная строка остается неизменной.

### Проверка на равенство

Метод equals() проверяет, содержат ли два объекта String одни и те же символы в одном и том же порядке. Метод 
equalsIgnoreCase() проверяет, содержат ли два объекта String одинаковые символы, за исключением того, что он игнорирует 
регистр символов. Сигнатуры методов следующие:

```
public boolean equals(Object obj)
public boolean equalsIgnoreCase(String str)
```

Возможно, вы заметили, что equals() принимает объект, а не строку. Это связано с тем, что метод одинаков для всех 
объектов. Если вы передадите что-то, что не является строкой, это просто вернет значение false. В отличие от этого, 
метод equalsIgnoreCase() применяется только к строковым объектам, поэтому он может принимать более конкретный тип в 
качестве параметра.

В Java значения String чувствительны к регистру. Это означает, что «abc» и «ABC» считаются разными значениями. 
Имея это в виду, следующий код показывает, как использовать эти методы:

```
System.out.println("abc".equals("ABC"));            // false
System.out.println("ABC".equals("ABC"));            // true
System.out.println("abc".equalsIgnoreCase("ABC"));  // true
```

Этот пример должен быть достаточно интуитивным. В первом примере значения не совсем совпадают. Во втором они точно 
такие же. В третьем они отличаются только регистром, но ничего страшного, потому что мы вызвали метод, который 
игнорирует различия в регистре.

---

#### Переопределение (Overriding) toString(), equals(Object), and hashCode()

Знание того, как правильно переопределять toString(), equals(Object) и hashCode(), в прошлом было частью 
сертификационных экзаменов Java. Как профессиональному разработчику Java, вам по-прежнему важно знать, по крайней мере, 
основные правила переопределения каждого из этих методов:

+ toString(): Метод toString() вызывается, когда вы пытаетесь напечатать объект или объединить объект со строкой. 
Обычно он переопределяется версией, которая печатает уникальное описание экземпляра, используя его поля экземпляра.
+ equals(Object): Метод equals(Object) используется для сравнения объектов, а реализация по умолчанию использует только 
оператор ==. Вы должны переопределять метод equals(Object) каждый раз, когда хотите удобно сравнить элементы на 
равенство, особенно если это требует проверки множества полей.
+ hashCode(): Каждый раз, когда вы переопределяете equals(Object), вы должны переопределить hashCode(), чтобы быть 
согласованным. Это означает, что для любых двух объектов, если значение a.equals(b) равно true, то значение 
a.hashCode()==b.hashCode() также должно быть true. Если они не согласованы, это может привести к неверным данным и 
побочным эффектам в коллекциях на основе хэша, таких как HashMap и HashSet.

Все эти методы обеспечивают реализацию по умолчанию в Object, но если вы хотите использовать их с умом, вы должны 
переопределить их.

---

### Поиск подстроки

Часто вам нужно выполнить поиск в строке большего размера, чтобы определить, содержится ли в ней подстрока. Методы 
startsWith() и endsWith() проверяют, соответствует ли предоставленное значение части строки. Метод contains() не столь 
специфичен; он ищет совпадения в любом месте строки. Сигнатуры метода следующие:

```
public boolean startsWith(String prefix)
public boolean endsWith(String suffix)
public boolean contains(CharSequence charSeq)
```

В следующем коде показано, как использовать эти методы:

```
System.out.println("abc".startsWith("a")); // true
System.out.println("abc".startsWith("A")); // false

System.out.println("abc".endsWith("c")); // true
System.out.println("abc".endsWith("a")); // false

System.out.println("abc".contains("b")); // true
System.out.println("abc".contains("B")); // false
```

Опять же, здесь нет ничего удивительного. Java выполняет проверку предоставленных значений с учетом регистра. Обратите 
внимание, что метод contains() является удобным методом, поэтому вам не нужно писать str.indexOf(otherString) != -1.

### Замена значений

Метод replace() выполняет простой поиск и замену в строке. Есть версия, которая принимает параметры char, а также 
версия, которая принимает параметры CharSequence. Сигнатуры методов следующие:

```
public String replace(char oldChar, char newChar)
public String replace(CharSequence target, CharSequence replacement)
```

В следующем коде показано, как использовать эти методы:

```
System.out.println("abcabc".replace('a', 'A'));   // AbcAbc
System.out.println("abcabc".replace("a", "A"));   // AbcAbc
```

В первом примере используется сигнатура первого метода, передающая параметры char. Во втором примере используется 
сигнатура второго метода, передающая String параметры.

### Удаление пробелов

Эти методы удаляют пустое пространство в начале и/или конце строки. Методы strip() и trim() удаляют пробелы в начале и 
в конце строки. С точки зрения экзамена пробел состоит из пробелов, а также символов \t (табуляция) и \n (новая строка). 
Другие символы, такие как \r (возврат каретки), также включаются в то, что обрезается. Метод strip() делает все то же, 
что и trim(), но поддерживает Unicode.

_Вам не нужно знать о Unicode для экзамена. Но если вы хотите проверить разницу, один из пробельных символов Unicode 
выглядит следующим образом:_

```
char ch = '\u2000';
```

Кроме того, метод stripLeading() удаляет пробелы в начале строки и оставляет их в конце. Метод stripTrailing() делает 
обратное. Он удаляет пробелы с конца строки и оставляет их в начале. Сигнатуры методов следующие:

```
public String strip()
public String stripLeading()
public String stripTrailing()
public String trim()
```

В следующем коде показано, как использовать эти методы:

```
System.out.println("abc".strip());          // abc
System.out.println("\t a b c\n".strip());   // a b c

String text = " abc\t ";
System.out.println(text.trim().length());            // 3
System.out.println(text.strip().length());           // 3
System.out.println(text.stripLeading().length());    // 5
System.out.println(text.stripTrailing().length());   // 4
```

Во-первых, помните, что \t — это одиночный символ. Обратная косая черта экранирует t для обозначения табуляции. 
В первом примере печатается исходная строка, поскольку в начале и в конце нет пробельных символов. Второй пример 
избавляется от ведущей табуляции, последующих пробелов и завершающей новой строки. Он оставляет пробелы в середине 
строки.

Остальные примеры просто печатают количество оставшихся символов. Вы можете видеть, что функции trim() и strip() 
оставляют одни и те же три символа «abc», потому что они удаляют как начальные, так и конечные пробелы. Метод 
stripLeading() удаляет только один пробел в начале строки. Он оставляет вкладку и пробел в конце. Метод stripTrailing() 
удаляет эти два символа в конце, но оставляет символ в начале строки.

### Работа с отступом

Теперь, когда Java поддерживает текстовые блоки, полезно иметь методы для работы с отступами. Оба они немного сложны, 
так что читайте внимательно!

```
public String indent(int numberSpaces)
public String stripIndent()
```

Метод indent() добавляет одинаковое количество пробелов в начало каждой строки, если вы передаете положительное число. 
Если вы передаете отрицательное число, он пытается удалить это количество пробельных символов с начала строки. Если вы 
передадите ноль, отступ не изменится.

_Если вы вызовете indent() с отрицательным числом и попытаетесь удалить больше пробелов, чем присутствует в начале 
строки, Java удалит все, что сможет найти._

Это кажется достаточно простым. Однако функция indent() также нормализует символы пробела. Что означает нормализация пробелов, спросите вы? Во-первых, в конец строки добавляется разрыв строки, если его там еще нет. Во-вторых, любые разрывы строк преобразуются в формат \n. Независимо от того, использует ли ваша операционная система \ r \ n (Windows) или \ n (Mac / Unix), Java будет стандартизировать \ n для вас.
or
Это кажется достаточно простым. Однако indent() также нормализует символы пробела. Вы спросите, что означает нормализация пробелов? Во-первых, в конец строки добавляется разрыв строки, если его еще нет. Во-вторых, любые разрывы строк преобразуются в формат \n. Независимо от того, использует ли ваша операционная система \r\n (Windows) или\n (Mac/Unix), Java стандартизирует \n для вас.

Метод stripIndent() полезен, когда String был построен с конкатенацией, а не с использованием текстового блока. Он избавляется от всех случайных пробелов. Это означает, что все непустые строки сдвигаются влево, поэтому из каждой строки удаляется одинаковое количество пробелов, а первый оставшийся символ не является пустым. Как и indent(), \r\n превращается в \n. Однако метод stripIndent() не добавляет разрыв строки в конце, если он отсутствует.
or
Метод stripIndent() полезен, когда строка была создана с помощью конкатенации, а не с использованием текстового блока. Это избавляет от всех случайных пробелов. Это означает, что все непустые строки сдвигаются влево, поэтому из каждой строки удаляется одинаковое количество пробелов, а первый оставшийся символ не является пустым. Как и indent(), \r\n превращается в \n. Однако метод stripIndent() не добавляет завершающий разрыв строки, если он отсутствует.

Что ж, это было очень много правил. В таблице 4.1 приведены ссылки, облегчающие их запоминание.

#### Таблица 4.1. - Правила для indent() и stripIndent()

|         Метод          |                                                     Изменение отступа                                                     | Нормализует существующие<br/>  разрывы строк | Добавляет разрыв строки<br/>  в конце, если он отсутствует |  
|:----------------------:|:-------------------------------------------------------------------------------------------------------------------------:|:--------------------------------------------:|:----------------------------------------------------------:|
| indent(n) where n > 0  |                                     Добавляет n пробелов<br/> в начало каждой строки                                      |                      Да                      |                             Да                             |
| indent(n) where n == 0 |                                                       Без изменений                                                       |                      Да                      |                             Да                             |
| indent(n) where n < 0  | Удаляет до n пробелов из каждой строки, при этом одинаковое<br/> количество символов удаляется из каждой непустой строки. |                      Да                      |                             Да                             |
|     stripIndent()      |                                          Удаляет все ведущие случайные пробелы                                            |                      Да                      |                            Нет                             |

Следующий код показывает, как использовать эти методы. Не волнуйтесь, если результаты окажутся не такими, как вы 
ожидаете. Мы объясняем каждый из них.

```
10: var block = """
11:             a
12:              b
13:             c""";
14: var concat = " a\n"
15:            + " b\n"
16:            + " c";
17: System.out.println(block.length());                  // 6
18: System.out.println(concat.length());                 // 9
19: System.out.println(block.indent(1).length());        // 10
20: System.out.println(concat.indent(-1).length());      // 7
21: System.out.println(concat.indent(-4).length());      // 6
22: System.out.println(concat.stripIndent().length());   // 6
```

Строки 10-16 создают аналогичные строки, используя текстовый блок и обычную строку соответственно. Мы говорим “похожий”,
потому что concat имеет пробельный символ в начале каждой строки, в то время как block - нет.

Строка 17 подсчитывает шесть символов в блоке: три буквы, пробел перед b и \n после a и b. Строка 18 подсчитывает девять символов в concat, которые представляют собой три буквы, один пробел перед a, два пробела перед b, один пробел перед c и \n после a и b. Считайте их сами. Если вы не понимаете, какие символы учитываются, это только еще больше запутает.
or
Строка 17 подсчитывает шесть символов в блоке, которые представляют собой три буквы, пробел перед b и \ n после a и b. Строка 18 подсчитывает девять символов в concat, которые представляют собой три буквы, один пробел перед a, два пробела перед b, один пробел перед c и \ n после a и b. Подсчитайте их сами. Если вы не понимаете, какие символы подсчитываются, это только еще больше запутает.

В строке 19 мы просим Java добавить один пробел к каждой из трех строк блока. Однако вывод говорит, что мы добавили 4 символа, а не 3, поскольку длина увеличилась с 6 до 10. Этот загадочный дополнительный символ появился благодаря нормализации конца строки. Поскольку текстовый блок не имеет разрыва строки в конце, indent() добавляет его!
or
В строке 19 мы просим Java добавить по одному пробелу к каждой из трех строк в блоке. Однако в выходных данных говорится, что мы добавили 4 символа, а не 3, поскольку длина увеличилась с 6 до 10. Этот таинственный дополнительный символ появился благодаря нормализации окончания строки. Поскольку текстовый блок не имеет разрыва строки в конце, функция indent() добавляет его!

В строке 20 мы удаляем по одному символу пробела из каждой из трех строк concat. Это дает длину семь. Мы начали с девяти, избавились от трех символов и добавили конечную нормализованную новую строку.
or
В строке 20 мы удаляем по одному пробелу из каждой из трех строк concat. Это дает длину семь. Мы начали с девяти, избавились от трех символов и добавили завершающую нормализованную новую строку.

В строке 21 мы просим Java удалить четыре пробела из тех же трех строк. Поскольку четырех пробельных символов нет, Java делает все возможное. Одиночный пробел удаляется перед a и c. Оба пробела удаляются перед b. Длина шесть должна иметь смысл здесь; мы удалили здесь на один символ больше, чем в строке 20.
or
В строке 21 мы просим Java удалить четыре пробельных символа из тех же трех строк. Поскольку в нем нет четырех пробельных символов, Java делает все возможное. Единственный пробел удаляется перед a и c. Оба пробела удаляются перед b. Длина в шесть должна иметь смысл здесь; мы удалили здесь на один символ больше, чем в строке 20.

Наконец, в строке 22 используется метод stripIndent(). Во всех строках есть хотя бы один пробельный символ. Поскольку не все они содержат два пробельных символа, метод избавляется только от одного символа в строке. Так как stripIndent() не добавляет новую строку, длина равна шести, что на три меньше исходных девяти.
or
Наконец, в строке 22 используется метод stripIndent(). Все строки содержат по крайней мере один пробел. Поскольку не все они содержат два пробельных символа, метод избавляется только от одного символа в строке. Поскольку stripIndent() не добавляет новую строку, длина равна шести, что на три меньше, чем исходные девять.

### Перевод побегов (Translating Escapes)

Когда мы экранируем символы, мы используем одну обратную косую черту. Например, \t — это табуляция. Если мы не хотим 
такого поведения, мы добавляем ещё одну обратную косую черту, чтобы избежать обратной косой черты, поэтому 
\\t — буквальная строка \t. Метод translateEscapes() берет эти литералы и превращает их в эквивалентные экранированные 
символы. Сигнатура метода выглядит следующим образом:

```
public String translateEscapes()
```

В следующем коде показано, как использовать эти методы:

```
var str = "1\\t2";
System.out.println(str);                     // 1\t2
System.out.println(str.translateEscapes());  // 1 2
```

Первая строка выводит литеральную строку \t, потому что обратная косая черта экранирована. Вторая строка выводит 
фактическую вкладку, так как мы перевели escape. Этот метод можно использовать для управляющих последовательностей, 
таких как \t (табуляция), \n (новая строка), \s (пробел), \" (двойная кавычка) и \' (одинарная кавычка).

### Проверка пустых или незаполненных строк

Java предоставляет удобные методы для определения того, имеет ли строка нулевую длину или содержит только символы 
пробела. Сигнатуры методов следующие:

```
public boolean isEmpty()
public boolean isBlank()
```

В следующем коде показано, как использовать эти методы:

```
System.out.println(" ".isEmpty());  // false
System.out.println("".isEmpty());   // true
System.out.println(" ".isBlank());  // true
System.out.println("".isBlank());   // true
```

Первая строка выводит false, потому что строка не пуста; в нем есть пустое место. Вторая строка выводит true, потому 
что на этот раз в строке нет символов. Последние две строки выводят true, потому что нет никаких символов, кроме 
пробелов.

### Форматирование значений

Существуют методы форматирования строковых значений с использованием флагов форматирования. Два метода принимают строку формата в качестве параметра, а другой использует экземпляр для этого значения. Один из методов использует Locale, о котором вы узнаете в главе 11.

Параметры метода используются для создания форматированной строки в одном вызове метода, а не с помощью множества 
операций форматирования и конкатенации. Они возвращают ссылку на экземпляр, для которого они вызываются, чтобы операции 
можно было связать вместе. Сигнатуры методов следующие:

```
public static String format(String format, Object args...)
public static String format(Locale loc, String format, Object args...)
public String formatted(Object args...)
```

В следующем коде показано, как использовать эти методы:

```
var name = "Kate";
var orderId = 5;

// All print: Hello Kate, order 5 is ready
System.out.println("Hello " + name + ", order " + orderId + " is ready");
System.out.println(String.format("Hello %s, order %d is ready",
   name, orderId));
System.out.println("Hello %s, order %d is ready"
   .formatted(name, orderId));
```

В операциях format() и formatted() параметры вставляются и форматируются с помощью символов в том порядке, в котором 
они указаны в vararg. В таблице 4.2 перечислены те, которые вы должны знать для сдачи экзамена.

#### Таблица 4.2. - Распространенные символы форматирования

| Условное обозначение |                                   Описание                                   |  
|:--------------------:|:----------------------------------------------------------------------------:|
|          %s          |           Применяется к любому типу, обычно к строковым значениям            |                                     
|          %d          |         Применяется к целочисленным значениям, таким как int и long          |                                        
|          %f          |    Применяется к значениям с плавающей запятой, таким как float и double     |                                   
|          %n          | Вставляет разрыв строки, используя разделитель строк, зависящий от системы.  |

В следующем примере используются все четыре символа из таблицы 4.2:

```
var name = "James";
var score = 90.25;
var total = 100;
System.out.println("%s:%n Score: %f out of %d"
   .formatted(name, score, total));
```

При этом выводится следующее:

```
James:
   Score: 90.250000 out of 100
```

Смешивание типов данных может вызвать исключения во время выполнения. Например, следующее выдает исключение, поскольку 
число с плавающей запятой используется, когда ожидается целочисленное значение:

```
var str = "Food: %d tons".formatted(2.0);     // IllegalFormatConversionException
```

---

#### Использование format() с флагами

Помимо поддержки символов, Java также поддерживает необязательные флаги между % и символом. В предыдущем примере число 
с плавающей запятой было напечатано как 90,250000. По умолчанию %f отображает ровно шесть цифр после запятой.
Если вы хотите отображать только одну цифру после запятой, вы можете использовать %.1f вместо %f. Метод format() 
основан на округлении, а не на усечении при сокращении чисел. Например, 90.250000 будет отображаться как 90.3 
(а не 90.2) при передаче в format() с %.1f.

Метод format() также поддерживает две дополнительные функции. Вы можете указать общую длину выходных данных, используя 
число перед десятичным символом. По умолчанию метод заполнит пустое пространство пробелами. Вы также можете заполнить 
пустое пространство нулями, поместив один ноль перед десятичным символом. В следующих примерах используются квадратные 
скобки [], чтобы показать начало/конец форматированного значения:

```
var pi = 3.14159265359;
System.out.format("[%f]",pi);        // [3.141593]
System.out.format("[%12.8f]",pi);    // [ 3.14159265]
System.out.format("[%012f]",pi);     // [00003.141593]
System.out.format("[%12.2f]",pi);    // [ 3.14]
System.out.format("[%.3f]",pi);      // [3.142]
```

Метод format() поддерживает множество других символов и флагов. Вам не нужно знать ни одного из них для экзамена, кроме 
того(тех), что мы уже обсуждали.

---

### Цепочка методов

Готовы собрать воедино все, о чем вы только что узнали? Обычно вызывается несколько методов, как показано здесь:

```
var start = "AniMaL ";
var trimmed = start.trim();                    // "AniMaL"
var lowercase = trimmed.toLowerCase();         // "animal"
var result = lowercase.replace('a', 'A');      // "AnimAl"
System.out.println(result);
```

Это всего лишь серия строковых методов. Каждый раз, когда вызывается один из них, возвращаемое значение помещается в 
новую переменную. На этом пути есть четыре строковых значения, и выводится AnimAl.

Однако на экзамене существует тенденция впихивать как можно больше кода в небольшое пространство. Вы увидите код, 
использующий технику, называемую цепочкой методов. Вот пример:

```
String result = "AniMaL ".trim().toLowerCase().replace('a', 'A');
System.out.println(result);
```

Этот код эквивалентен предыдущему примеру. Он также создает четыре строковых объекта и выводит AnimAl. Чтобы прочитать 
код, использующий цепочку методов, начните слева и оцените первый метод. Затем вызовите следующий метод на основе 
возвращаемого значения первого метода. Продолжайте, пока не дойдете до точки с запятой.

Как вы думаете, каков результат этого кода?

```
5: String a = "abc";
6: String b = a.toUpperCase();
7: b = b.replace("B", "2").replace('C', '3');
8: System.out.println("a=" + a);
9: System.out.println("b=" + b);
```

В строке 5 мы установили 'a' так, чтобы оно указывало на "abc", и никогда не указывали 'a' ни на что другое. Поскольку 
ни один код в строках 6 и 7 не изменяет 'a', значение остается "abc".

Однако 'b' немного сложнее. В строке 6 буква 'b' указывает на «ABC», что несложно. В строке 7 у нас есть цепочка 
методов. Сначала вызывается "ABC".replace("B", "2"). Это возвращает "A2C". Затем вызывается "A2C".replace('C', '3'). 
Это возвращает "A23". Наконец, b изменяется, чтобы указать на эту возвращенную строку. Когда строка 9 выполняется, 
b равно "A23".

## Использование класса StringBuilder

Небольшая программа может очень быстро создать множество объектов String. Например, как вы думаете, сколько объектов 
создает этот фрагмент кода?

```
10: String alpha = "";
11: for (char current = 'a'; current <= 'z'; current++)
12:      alpha += current;
13: System.out.println(alpha);
```

Создается экземпляр пустой строки в строке 10, а затем в строке 12 добавляется буква "а". Однако, поскольку объект String является неизменяемым, новый объект String присваивается alpha, и объект "" становится пригодным для сборки мусора. При следующем прохождении цикла alpha присваивается новый строковый объект "ab", и объект "a" становится пригодным для сборки мусора. Следующая итерация присваивает alpha "abc", и объект "ab" становится пригодным для сборки мусора, и так далее.

Эта последовательность событий продолжается, и после 26 итераций цикла создается в общей сложности 27 объектов, большинство из которых немедленно подлежат сборке мусора.

Это очень неэффективно. К счастью, у Java есть решение. Класс StringBuilder создает String без сохранения всех этих промежуточных значений String. В отличие от класса String, StringBuilder не является неизменным.

```
15: StringBuilder alpha = new StringBuilder();
16: for(char current = 'a'; current <= 'z'; current++)
17:    alpha.append(current);
18: System.out.println(alpha);
```

В строке 15 создается экземпляр нового объекта StringBuilder. Вызов append() в строке 17 добавляет символ к объекту StringBuilder каждый раз через цикл for, добавляя значение current к концу alpha. Этот код повторно использует один и тот же StringBuilder без создания промежуточной строки каждый раз.

В старом коде вы можете увидеть ссылки на StringBuffer. Он работает так же, за исключением того, что поддерживает потоки, о которых вы узнаете в главе 13 «Параллелизм». StringBuffer не на экзамене. Он работает медленнее, чем StringBuilder, поэтому просто используйте StringBuilder.

В этом разделе мы рассмотрим создание StringBuilder и использование его общих методов.

### Изменчивость и цепочка

Мы уверены, что вы заметили это из предыдущего примера, но StringBuilder не является неизменяемым. Фактически, мы дали ему 27 различных значений в примере (пробел плюс добавление каждой буквы в алфавите). Экзамен, скорее всего, попытается обмануть вас в отношении того, что String и StringBuilder являются изменяемыми.

Цепочка делает это еще более интересным. Когда мы связали вызовы методов String, результатом стала новая String с ответом. Цепочка методов StringBuilder так не работает. Вместо этого StringBuilder изменяет свое собственное состояние и возвращает ссылку на себя. Давайте рассмотрим пример, чтобы было понятнее:

```
4: StringBuilder sb = new StringBuilder("start");
5: sb.append("+middle");                            // sb = "start+middle"
6: StringBuilder same = sb.append("+end");          // "start+middle+end"
```

Строка 5 добавляет текст в конец sb. Он также возвращает ссылку на sb, которая игнорируется. Строка 6 также добавляет текст в конец sb и возвращает ссылку на sb. На этот раз ссылка сохраняется в файле same. Это означает, что sb и same указывают на один и тот же объект и выводят одно и то же значение.

Экзамен не всегда сделает код легко читаемым, если в каждой строке будет только один метод. Как вы думаете, что печатает этот пример?

```
4: StringBuilder a = new StringBuilder("abc");
5: StringBuilder b = a.append("de");
6: b = b.append("f").append("g");
7: System.out.println("a=" + a);
8: System.out.println("b=" + b);
```

Вы сказали, что оба печатают "abcdefg"? Хорошо. Здесь есть только один объект StringBuilder. Мы знаем это, потому что new StringBuilder() вызывается только один раз. В строке 5 есть две переменные, ссылающиеся на этот объект, который имеет значение "abcde". В строке 6 эти две переменные по-прежнему ссылаются на тот же объект, который теперь имеет значение "abcdefg". Кстати, присвоение обратно b абсолютно ничего не делает. b уже указывает на этот StringBuilder.

### Создание StringBuilder 

Существует три способа создания StringBuilder:

```
StringBuilder sb1 = new StringBuilder();
StringBuilder sb2 = new StringBuilder("animal");
StringBuilder sb3 = new StringBuilder(10);
```

В первом предлагается создать StringBuilder, содержащий пустую последовательность символов, и назначить sb1 для указания 
на нее. Второй предлагает создать StringBuilder, содержащий определенное значение, и назначить sb2 для указания на него. 
Первые два примера говорят Java управлять деталями реализации. Последний пример говорит Java, что у нас есть некоторое 
представление о том, насколько большим будет конечное значение, и мы хотели бы, чтобы StringBuilder зарезервировал 
определенную емкость или количество слотов для символов.

## Важные методы StringBuilder

Как и в случае со String, мы не собираемся рассматривать каждый метод класса StringBuilder. Это те, которые вы можете 
увидеть на экзамене.

### Использование общих методов

Эти четыре метода работают точно так же, как и в классе String. Убедитесь, что вы можете идентифицировать вывод этого примера:

```
var sb = new StringBuilder("animals");
String sub = sb.substring(sb.indexOf("a"), sb.indexOf("al"));
int len = sb.length();
char ch = sb.charAt(6);
System.out.println(sub + " " + len + " " + ch);
```

Правильный ответ - anim 7 s. Вызовы метода indexOf() возвращают 0 и 4 соответственно. Метод substring() возвращает 
строку, начинающуюся с индекса 0 и заканчивающуюся непосредственно перед индексом 4.

Метод length() возвращает 7, потому что это количество символов в StringBuilder, а не индекс. Наконец, charAt() 
возвращает символ с индексом 6. Здесь мы начинаем с 0, потому что имеем в виду индексы. Если это не кажется вам 
знакомым, вернитесь и снова прочитайте раздел о String.

Обратите внимание, что substring() возвращает String, а не StringBuilder. Вот почему sb не меняется. Метод substring() на самом деле просто метод, который запрашивает состояние StringBuilder.

### Добавление значений

Метод append() на сегодняшний день является наиболее часто используемым методом в StringBuilder. На самом деле, он настолько часто используется, что мы просто начали использовать его без комментариев. К счастью, этот метод делает именно то, на что он похож: он добавляет параметр в StringBuilder и возвращает ссылку на текущий StringBuilder. Одна из сигнатур метода выглядит следующим образом:

```
public StringBuilder append(String str)
```

Обратите внимание, что мы упомянули одну из сигнатур метода. Существует более 10 сигнатур методов, которые выглядят 
одинаково, но принимают в качестве параметров разные типы данных, такие как int, char и т.д. Все эти методы представлены
для того, чтобы вы могли написать код, подобный этому:

```
var sb = new StringBuilder().append(1).append('c');
sb.append("-").append(true);
System.out.println(sb);      // 1c-true
```

Хорошая цепочка методов, не так ли? Метод append() вызывается непосредственно после конструктора. Имея все эти сигнатуры 
методов, вы можете просто вызвать append() без необходимости сначала преобразовывать свой параметр в строку.

### Вставка данных

Метод insert() добавляет символы в StringBuilder по запрошенному индексу и возвращает ссылку на текущий StringBuilder. 
Так же, как и append(), существует множество сигнатур методов для разных типов. Вот один:

```
public StringBuilder insert(int offset, String str)
```

Обратите внимание на смещение в этих примерах. Это индекс, в который мы хотим вставить запрошенный параметр.

```
3: var sb = new StringBuilder("animals");
4: sb.insert(7, "-");                    // sb = animals
5: sb.insert(0, "-");                    // sb = -animals
6: sb.insert(4, "-");                    // sb = -ani-mals
7: System.out.println(sb);
```

В строке 4 предлагается вставить тире в индексе 7, который является концом последовательности символов. В строке 5 
предлагается вставить тире в индексе 0, что оказывается самым началом. Наконец, в строке 6 предлагается вставить тире 
прямо перед индексом 4. Создатели экзамена попытаются сбить вас с толку. Когда мы добавляем и удаляем символы, их 
индексы меняются. Когда вы видите вопрос, связанный с такими операциями, нарисуйте, что происходит, используя доступные 
письменные принадлежности, чтобы не запутаться.

### Удаление содержимого

Метод delete() противоположен методу insert(). Он удаляет символы из последовательности и возвращает ссылку на текущий 
StringBuilder. Метод deleteCharAt() удобен, когда вы хотите удалить только один символ. Сигнатуры метода следующие:

```
public StringBuilder delete(int startIndex, int endIndex)
public StringBuilder deleteCharAt(int index)
```

Следующий код показывает, как использовать эти методы

```
var sb = new StringBuilder("abcdef");
sb.delete(1, 3);                    // sb = adef
sb.deleteCharAt(5);                 // exception
```

Сначала мы удаляем символы, начинающиеся с индекса 1 и заканчивающиеся непосредственно перед индексом 3. Это дает 
нам adef. Далее мы просим Java удалить символ в позиции 5. Однако оставшееся значение имеет длину всего четыре символа, 
поэтому оно вызывает исключение StringIndexOutOfBoundsException.

Метод delete() является более гибким, чем некоторые другие, когда дело доходит до индексов массива. Если вы укажете 
второй параметр, который находится после конца StringBuilder, Java просто предположит, что вы имели в виду конец. 
Это означает, что этот код является законным:

```
var sb = new StringBuilder("abcdef");
sb.delete(1, 100);                   // sb = a
```

### Замена частей (Replacing Portions)

Метод replace() работает для StringBuilder иначе, чем для String. Сигнатура метода выглядит следующим образом:

```
public StringBuilder replace(int startIndex, int endIndex, String newString)
```

Следующий код показывает, как использовать эти методы:

```
var builder = new StringBuilder("pigeon dirty");
builder.replace(3, 6, "sty");
System.out.println(builder);   // pigsty dirty
```

Во-первых, Java удаляет символы, начинающиеся с индекса 3 и заканчивающиеся непосредственно перед индексом 6. Это дает 
нам pig dirty. Затем Java вставляет значение "sty" в эту позицию.

В этом примере количество удаленных и вставленных символов одинаковое. Однако нет никаких причин, по которым они должны 
быть такими. Как вы думаете, что это делает?

```
var builder = new StringBuilder("pigeon dirty");
builder.replace(3, 100, "");
System.out.println(builder);
```

Печатает "pig". Помните, метод сначала выполняет логическое удаление. Метод replace() позволяет указать второй параметр, 
который находится за концом StringBuilder. Это означает, что остаются только первые три символа.

### Реверсирование (Reversing)

После всего этого пришло время для хорошего, простого метода. Метод reverse() делает именно то, на что он похож: он 
меняет местами символы в последовательностях и возвращает ссылку на текущий StringBuilder. 
Сигнатура метода выглядит следующим образом:

```
public StringBuilder reverse()
```

Следующий код показывает, как использовать эти методы:

```
var sb = new StringBuilder("ABC");
sb.reverse();
System.out.println(sb);
```

Как и ожидалось, это выводит CBA. Этот метод не так уж интересен. Возможно, создатели экзамена хотели бы включить его, 
чтобы побудить вас записать значение, а не полагаться на память для индексов.

---

#### Работа с toString()

Класс Object содержит метод toString(), который многие классы предоставляют пользовательские реализации. Класс 
StringBuilder является одним из них.

Следующий код показывает, как использовать этот метод:

```
var sb = new StringBuilder("ABC");
String s = sb.toString();
```

Часто StringBuilder используется внутри для повышения производительности, но конечным результатом должен быть String. 
Например, возможно, его нужно передать другому методу, который ожидает String.

---

## Понимание равенства

В главе 2 вы узнали, как использовать == для сравнения чисел и что ссылки на объекты относятся к одному и тому же 
объекту. В этом разделе мы рассмотрим, что означает, когда два объекта эквивалентны или одинаковы. Мы также рассмотрим 
влияние пула строк на равенство.

### Сравнение equals() и ==

Рассмотрим следующий код, который использует == с объектами:

```
var one = new StringBuilder();
var two = new StringBuilder();
var three = one.append("a");
System.out.println(one == two); // false
System.out.println(one == three); // true
```

Поскольку этот пример не имеет дело с примитивами, мы знаем, что нужно искать, относятся ли ссылки к одному и тому же 
объекту. Переменные one и two являются полностью отдельными объектами StringBuilder, что дает нам два объекта.
Следовательно, первый оператор печати дает нам false. Переменная three интереснее. Помните, как методы StringBuilder 
возвращают текущую ссылку для цепочки? Это означает, что one и three указывают на один и тот же объект, а второй 
оператор печати возвращает нам значение true.

Ранее вы видели, что equals() использует логическое равенство, а не равенство объектов для объектов String:

```
var x = "Hello World";
var z = " Hello World".trim();
System.out.println(x.equals(z));  // true
```

Это работает, потому что авторы класса String реализовали стандартный метод equals() для проверки значений внутри 
String, а не самой ссылки на строку. Если в классе нет метода equals(), Java определяет, указывают ли ссылки на один и 
тот же объект, что и делает ==.

Если вам интересно, авторы StringBuilder не реализовали функцию equals(). Если вы вызовете equals() для двух 
экземпляров StringBuilder, он проверит равенство ссылок. Вы можете вызвать toString() в StringBuilder, чтобы получить 
String для проверки на равенство.

Наконец, экзамен может попытаться обмануть вас таким вопросом. Можете ли вы догадаться, почему код не компилируется?

```
var name = "a";
var builder = new StringBuilder("a");
System.out.println(name == builder); // DOES NOT COMPILE
```

Помните, что == проверяет равенство ссылок на объекты. Компилятор достаточно умен, чтобы понять, что две ссылки не 
могут указывать на один и тот же объект, если они совершенно разных типов.

### Пул строк

Поскольку строки в Java повсюду, они занимают много памяти. В некоторых производственных приложениях они могут 
использовать большой объем памяти во всей программе. Java понимает, что многие строки повторяются в программе, и решает 
эту проблему, повторно используя общие. Пул строк, также известный как внутренний пул, представляет собой место в 
виртуальной машине Java (JVM), в котором собираются все эти строки.

Пул строк содержит литеральные значения и константы, которые отображаются в вашей программе. Например, "name" является 
литералом и, следовательно, попадает в пул строк. Метод MyObject.toString() возвращает строку, но не литерал, поэтому 
он не попадает в пул строк.

Теперь давайте перейдем к более сложному и запутанному сценарию, равенству строк, отчасти благодаря тому, как JVM 
повторно использует строковые литералы.

```
var x = "Hello World";
var y = "Hello World";
System.out.println(x == y);   // true
```

Помните, что строка неизменяема, а литералы объединены в пул. JVM создала только один литерал в памяти. Переменные x и y
указывают на одно и то же местоположение в памяти; следовательно, оператор выводит значение true. Это становится ещё 
сложнее. Рассмотрим этот код:

```
var x = "Hello World";
var z = " Hello World".trim();
System.out.println(x == z);    // false
```

В этом примере у нас нет двух одинаковых строковых литералов. Хотя x и z вычисляются в одной и той же строке, одна из 
них вычисляется во время выполнения. Поскольку во время компиляции это не одно и то же, создается новый объект String. 
Давайте попробуем еще один. Как вы думаете, что здесь выводится?

```
var singleString = "hello world";
var concat = "hello ";
concat += "world";
System.out.println(singleString == concat); // false
```

Это выводит значение false. Вызов += аналогичен вызову метода и приводит к созданию новой строки. Вы даже можете 
принудительно устранить проблему, создав новую строку:

```
var x = "Hello World";
var y = new String("Hello World");
System.out.println(x == y);        // false
```

Первый говорит об обычном использовании пула строк. Второй говорит: «Нет, JVM, я действительно не хочу, чтобы вы 
использовали пул строк. Пожалуйста, создайте для меня новый объект, даже если он менее эффективен».

Вы также можете сделать обратное и указать Java использовать пул строк. Метод intern() будет использовать объект в пуле 
строк, если он присутствует.

```
public String intern()
```

Если литерала еще нет в пуле строк, Java добавит его в это время.

```
var name = "Hello World";
var name2 = new String("Hello World").intern();
System.out.println(name == name2);     // true
```

Сначала мы сообщаем Java, что для name обычно используется пул строк. Затем для name2 мы сообщаем Java создать новый 
объект с помощью конструктора, но интернировать его и в любом случае использовать пул строк. Поскольку обе переменные 
указывают на одну и ту же ссылку в пуле строк, мы можем использовать оператор ==.

Давайте попробуем еще один. Как вы думаете, что это выводит на печать? Будь осторожен. Это сложно.

```
15: var first = "rat" + 1;
16: var second = "r" + "a" + "t" + "1";
17: var third = "r" + "a" + "t" + new String("1");
18: System.out.println(first == second);
19: System.out.println(first == second.intern());
20: System.out.println(first == third);
21: System.out.println(first == third.intern());
```

В строке 15 у нас есть константа времени компиляции, которая автоматически помещается в пул строк как «rat1». 
В строке 16 у нас есть более сложное выражение, которое также является константой времени компиляции. Следовательно, 
first и second используют одну и ту же ссылку на пул строк. Это делает строки 18 и 19 true.

В строке 17 у нас есть конструктор String. Это означает, что у нас больше нет константы времени компиляции, и third не
указывает на ссылку в пуле строк. Следовательно, строка 20 выводит значение false. В строке 21 вызов intern()
просматривает пул строк. Java замечает, что сначала указывает на ту же строку и выводит true.

Когда вы пишете программы, вам не хотелось бы создавать строку из строки или использовать метод intern(). Для сдачи 
экзамена вам нужно знать, что и то, и другое разрешено и как они себя ведут.

_Помните, что никогда не используйте intern() или == для сравнения строковых объектов в вашем коде. Единственный раз, 
когда вам следует иметь с этим дело, - это на экзамене._

## Понимание массивов

До сих пор мы называли классы String и StringBuilder «последовательностью символов». Это правда. Они реализованы с 
использованием массива символов. Массив — это область памяти в куче с местом для определенного количества элементов. 
Строка реализована как массив с некоторыми методами, которые вы можете захотеть использовать при работе с конкретными 
символами. StringBuilder реализован как массив, в котором объект массива заменяется новым, более крупным объектом 
массива, когда в нем заканчивается место для хранения всех символов. Большая разница в том, что массив может быть любого
другого типа Java. Если бы мы по какой-то причине не хотели использовать String, мы могли бы напрямую использовать 
массив примитивов char:

```
char[] letters;
```

Это было бы не очень удобно, потому что мы потеряли бы все специальные свойства, которые дает нам String, такие как 
запись «Java». Имейте в виду, что letters — это ссылочная переменная, а не примитив. Тип char является примитивным. 
Но char — это то, что входит в массив, а не тип самого массива. Сам массив имеет тип char[]. Вы можете мысленно 
прочитать скобки ([]) как «массив».

Другими словами, массив — это упорядоченный список. Он может содержать дубликаты. В этом разделе мы рассмотрим создание 
массива примитивов и объектов, сортировку, поиск, varargs и многомерные массивы.

### Создание массива примитивов

Наиболее распространенный способ создания массива показан на рис. 4.3. Он указывает тип массива (int) и размер (3). 
Квадратные скобки говорят вам, что это массив.

#### Рис. 4.3 - Базовая структура массива


Когда вы используете эту форму для создания экземпляра массива, всем элементам присваивается значение по умолчанию для 
этого типа. Как вы узнали из главы 1, значение int по умолчанию равно 0. Поскольку numbers является ссылочной 
переменной, она указывает на объект array, как показано на рис. 4.4. Как вы можете видеть, значение по умолчанию для 
всех элементов равно 0. Кроме того, индексы начинаются с 0 и подсчитываются, как и для строки.

#### Рис. 4.4 - Пустой массив


Другой способ создать массив - указать все элементы, с которых он должен начинаться:

```
int[] moreNumbers = new int[] {42, 55, 99};
```

В этом примере мы также создаем массив int размера 3. На этот раз мы указываем начальные значения этих трех элементов 
вместо использования значений по умолчанию. На рис. 4.5 показано, как выглядит этот массив.

#### Рис. 4.5 - Инициализированный массив


Java распознает, что это выражение является избыточным. Поскольку вы указываете тип массива слева от знака равенства, 
Java уже знает этот тип. И поскольку вы указываете начальные значения, он уже знает размер. В качестве ярлыка Java 
позволяет написать следующее:

```
int[] moreNumbers = {42, 55, 99};
```

Такой подход называется _анонимным массивом_. Это анонимно, потому что вы не указываете тип и размер.

Наконец, вы можете ввести [] до или после имени, а добавление пробела необязательно. Это означает, что все пять из этих 
утверждений делают одно и то же:

```
int[] numAnimals;
int [] numAnimals2;
int []numAnimals3;
int numAnimals4[];
int numAnimals5 [];
```

Большинство людей используют первый вариант. Однако вы можете увидеть любой из них на экзамене, так что привыкайте 
видеть скобки в разных местах.

---

#### Несколько "массивов" в объявлении

Как вы думаете, какие типы ссылочных переменных создает следующий код?

```
int[] ids, types;
```

Правильный ответ — две переменные типа int[]. Это выглядит достаточно логично. Ведь int a, b; создал две переменные 
типа int. А как насчет этого примера?

```
int ids[], types;
```

Все, что мы сделали, это передвинули скобки, но это изменило поведение. На этот раз мы получаем один массив типа int[] 
и переменную типа int. Java видит эту строчку кода и думает примерно так: «Они хотят две переменные типа int. 
Первый называется ids[]. Это  int[] под названием ids. Второй просто называется types. Без скобок, так что это обычное 
целое число».

Разумеется, вы не должны писать код, который выглядит так. Но вам нужно понять это для экзамена.

---

### Создание массива со ссылочными переменными

Вы можете выбрать любой тип Java в качестве типа массива. Сюда входят классы, которые вы создаете самостоятельно. 
Давайте посмотрим на встроенный тип со String:

```
String[] bugs = { "cricket", "beetle", "ladybug" };
String[] alias = bugs;
System.out.println(bugs.equals(alias));   // true
System.out.println(bugs.toString());      // [Ljava.lang.String;@160bc7c0
```

Мы можем вызвать equals(), потому что массив — это объект. Он возвращает true из-за равенства ссылок. Метод equals() для
массивов не рассматривает элементы массива. Помните, что это сработает даже для int[]. Тип int — примитив; 
int[] — объект.

Второй оператор печати еще более интересен. Что такое [Ljava.lang.String;@160bc7c0? Вам не нужно знать это для экзамена,
но [L означает, что это массив, java.lang.String — это ссылочный тип, а 160bc7c0 — это хэш-код. Вы будете получать 
разные цифры и буквы каждый раз, когда запускаете его, поскольку это ссылка.

_Java предоставляет метод, который красиво печатает массив: Arrays.toString(bugs) напечатает [cricket, beetle, ladybug]._

Убедитесь, что вы понимаете рис. 4.6. Массив не выделяет место для объектов String. Вместо этого он выделяет место 
для ссылки на то, где действительно хранятся объекты.

#### Рис. 4.6 - Массив с указанием строк

В качестве краткого обзора, как вы думаете, на что указывает этот массив?

```
public class Names {
   String names[];
}
```

Вы поняли нас. Это был обзор главы 1, а не обсуждение массивов. Ответ null. Код никогда не создавал экземпляр массива, 
так что это просто ссылочная переменная для null. Давайте попробуем ещё раз: как вы думаете, на что указывает этот 
массив?

```
public class Names {
   String names[] = new String[2];
}
```

Это массив, потому что он имеет скобки. Это массив типа String, поскольку именно этот тип указан в объявлении. Он имеет 
два элемента, потому что длина равна 2. Каждый из этих двух слотов в настоящее время имеет значение null, но 
потенциально может указывать на объект String.

Помните приведение из предыдущей главы, когда вы хотели принудительно преобразовать больший тип в меньший? Вы можем 
сделать это и с массивами тоже:

```
3: String[] strings = { "stringValue" };
4: Object[] objects = strings;
5: String[] againStrings = (String[]) objects;
6: againStrings[0] = new StringBuilder();     // DOES NOT COMPILE
7: objects[0] = new StringBuilder();          // Внимательно!
```

Строка 3 создает массив типа String. Строка 4 не требует приведения, потому что Object является более широким типом, 
чем String. В строке 5 требуется приведение, потому что мы переходим к более конкретному типу. Строка 6 не компилируется, 
потому что String[] допускает только объекты String, а StringBuilder не является String.

В строке 7 это становится интересным. С точки зрения компилятора это нормально. Объект StringBuilder явно может 
находиться в Object[]. Проблема в том, что у нас на самом деле нет Object[]. У нас есть String[], на которую ссылается 
переменная Object[]. Во время выполнения код вызывает исключение ArrayStoreException. Вам не нужно запоминать имя 
этого исключения, но вам нужно знать, что код будет генерировать исключение.

### Using an Array
















