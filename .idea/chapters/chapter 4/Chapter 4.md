# Основные API

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Обработка даты, времени, текста, числовых и логических значений

+ Используйте примитивы и классы-оболочки, включая Math API, круглые скобки, продвижение(или повышение) и 
приведение типов для вычисления арифметических и логических выражений
+ Манипулируйте текстом, включая текстовые блоки, используя классы String и StringBuilder
+ Манипулируйте датой, временем, продолжительностью, периодом, мгновенными объектами и объектами часового пояса с 
помощью Date-Time API

#### Работа с массивами и коллекциями

+ Создавайте массивы Java, коллекции List, Set, Map и Deque, а также добавляйте, удаляйте, обновляйте, извлекайте и 
сортируйте их элементы

---

В контексте интерфейса прикладного программирования (API) интерфейс относится к группе классов или определений 
интерфейса Java, предоставляющих вам доступ к функциональности.

В этой главе вы узнаете о многих основных структурах данных в Java, а также о наиболее распространенных API для доступа 
к ним. Например, String и StringBuilder вместе со связанными с ними API используются для создания текстовых данных и 
управления ими. Затем мы покрываем массивы. Наконец, мы изучаем математические API и API даты/времени.

## Создание и манипулирование строками

Класс String - это настолько фундаментальный класс, что вам было бы трудно писать код без него. В конце концов, вы даже не можете написать метод main() без использования класса String. Строка - это, по сути, последовательность символов; вот пример:

```
String name = "Fluffy";
```

Как вы узнали из главы 1 “Строительные блоки”, это пример ссылочного типа. Вы также узнали, что ссылочные типы создаются
с использованием ключевого слова new. Подождите минуту. В предыдущем примере чего-то не хватает: в нем нет new! В Java 
эти два фрагмента создают строку:

```
String name = "Fluffy";
String name = new String("Fluffy");
```

Оба дают вам ссылочную переменную с именем name, указывающую на объект String "Fluffy". Как вы увидите далее в этой 
главе, они немного отличаются. А пока просто помните, что класс String особенный и его не нужно создавать с помощью new.

Кроме того, текстовые блоки — это ещё один способ создания String. Для обзора этот текстовый блок такой же, как и 
предыдущие переменные:

```
String name = """
              Fluffy""";
```

Поскольку String - это последовательность символов, вы, вероятно, не удивитесь, услышав, что она реализует интерфейс 
CharSequence. Этот интерфейс представляет собой общий способ представления нескольких классов, включая String и 
StringBuilder. Вы узнаете больше об интерфейсах в главе 7 “За пределами классов”.

В этом разделе мы рассмотрим конкатенацию, общие методы и цепочку методов.

### Конкатенация

В главе 2 «Операторы» вы узнали, как складывать числа. 1 + 2 — это явно 3. Но что такое «1» + «2»? Это «12», потому что 
Java объединяет два объекта String. Размещение одной строки перед другой строкой и их объединение называется 
конкатенацией строк. Создателям экзамена нравится конкатенация строк, потому что оператор + можно использовать двумя 
способами в одной строке кода. Для этого не так много правил, но вы должны их хорошо знать:

1. Если оба операнда являются числовыми, + означает числовое сложение.
2. Если любой из операндов является строкой, + означает конкатенацию.
3. Выражение оценивается слева направо.

Теперь давайте рассмотрим несколько примеров:

```
System.out.println(1 + 2);             // 3
System.out.println("a" + "b");         // ab
System.out.println("a" + "b" + 3);     // ab3
System.out.println(1 + 2 + "c");       // 3c
System.out.println("c" + 1 + 2);       // c12
System.out.println("c" + null);        // cnull
```

В первом примере используется первое правило. Оба операнда являются числами, поэтому мы используем обычное сложение. 
Второй пример — простая конкатенация строк, описанная во втором правиле. Кавычки для строки используются только в коде; 
они не получают выход.

Третий пример объединяет второе и третье правила. Поскольку мы начинаем слева, Java выясняет, чему соответствует 
"a" + "b". Вы уже знаете это: это «ab». Затем Java просматривает оставшееся выражение «ab» + 3. Второе правило говорит 
нам о конкатенации, поскольку один из операндов является строкой.

В четвертом примере мы начинаем с третьего правила, которое говорит нам рассмотреть 1 + 2. Оба операнда являются 
числовыми, поэтому первое правило говорит нам, что ответ равен 3. Затем у нас есть 3 + «с», которое использует второе 
правило, чтобы дать нам "3c". Заметили, что все три правила используются в одной строке?

Пятый пример показывает важность третьего правила. Сначала у нас есть "c" + 1, который использует второе правило, чтобы 
дать нам "c1". Затем у нас есть «c1» + 2, который снова использует второе правило, чтобы дать нам «c12».

Наконец, последний пример показывает, как null представляется в виде строки при объединении или печати, что дает нам 
«cnull».

Экзамен делает ещё один шаг вперед и попытается одурачить вас чем-то вроде этого:

```
int three = 3;
String four = "4";
System.out.println(1 + 2 + three + four);
```

Когда вы увидите это, просто не торопитесь, запомните три правила и обязательно проверьте типы переменных. В этом 
примере мы начинаем с третьего правила, которое говорит нам рассмотреть 1 + 2.

Первое правило дает нам 3. Далее у нас есть 3 + three. Поскольку число three имеет тип int, мы по-прежнему используем 
первое правило, что дает нам число 6. Тогда у нас есть 6 + four. Так как четыре имеет тип String, мы переключаемся на 
второе правило и получаем окончательный ответ «64». Когда вы видите такие вопросы, просто не торопитесь и проверьте 
типы. Методичность окупается.

Есть еще одна вещь, которую нужно знать о конкатенации, но это несложно. В этом примере вам просто нужно помнить, что 
делает +=. Имейте в виду, что s += "2" означает то же самое, что и s = s + "2".

```
4: var s = "1";                // s currently holds "1"
5: s += "2";                   // s currently holds "12"
6: s += 3;                     // s currently holds "123"
7: System.out.println(s);      // 123
```

В строке 5 мы «добавляем» две строки, что означает их конкатенацию. Строка 6 пытается обмануть вас, добавляя число, но 
это точно так же, как мы написали s = s + 3. Мы знаем, что строка «плюс» что-либо еще означает использование 
конкатенации.

Чтобы просмотреть правила еще раз: используйте числовое сложение, если участвуют два числа, используйте конкатенацию в 
противном случае и оценивайте слева направо. Вы уже выучили эти три правила? Обязательно сделайте это перед экзаменом!


## Важные методы String

Класс String имеет десятки методов. К счастью, для экзамена вам нужно знать лишь несколько. Создатели экзамена выбирают 
большинство методов, которые разработчики используют в реальном мире.

Для всех этих методов вам нужно помнить, что строка представляет собой последовательность символов, а Java отсчитывает 
от 0 при индексации. На рис. 4.1 показано, как индексируется каждый символ в строке «animals».

#### Рис. 4.1 - Индексация для строки

Вам также необходимо знать, что String является неизменяемым или неизменным. Это означает, что вызов метода для 
String вернет другой объект String, а не изменит значение ссылки. В этой главе вы используете неизменяемые объекты. 
В главе 6 “Проектирование классов” вы узнаете, как создавать собственные неизменяемые объекты.

Давайте рассмотрим несколько методов класса String. Многие из них просты, поэтому мы не будем подробно их обсуждать. 
Вы должны знать, как использовать эти методы.

### Определение длины

Метод length() возвращает количество символов в строке. Сигнатура метода выглядит следующим образом:

```
public int length()
```

Следующий код показывает, как использовать length():

```
var name = "animals";
System.out.println(name.length());  // 7
```

Ждать. Выдает 7? Разве мы только что не говорили вам, что Java считает с 0? Разница в том, что нулевой подсчет 
происходит только тогда, когда вы используете индексы или позиции в списке. При определении общего размера или длины 
Java снова использует обычный подсчет.

### Получение одного символа

Метод charAt() позволяет вам запросить строку, чтобы узнать, какой символ находится в определенном индексе. 
Сигнатура метода выглядит следующим образом:

```
public char charAt(int index)
```

Следующий код показывает, как использовать charAt():

```
var name = "animals";
System.out.println(name.charAt(0));  // a
System.out.println(name.charAt(6));  // s
System.out.println(name.charAt(7));  // exception
```

Поскольку индексы начинают считать с 0, charAt(0) возвращает «первый» символ в последовательности. Точно так же 
charAt(6) возвращает «седьмой» символ в последовательности. Однако проблема с charAt(7). Он запрашивает «восьмой» 
символ в последовательности, но присутствует только семь символов. Когда что-то идет не так, с чем Java не знает, что 
делать, она генерирует исключение, как показано здесь. Вы узнаете больше об исключениях в главе 11, «Исключения и 
локализация».

```
java.lang.StringIndexOutOfBoundsException: String index out of range: 7
```

### Поиск индекса

Метод indexOf() просматривает символы в строке и находит первый индекс, соответствующий нужному значению. Метод indexOf 
может работать с отдельным символом или целой строкой в качестве входных данных. Он также может начинаться с 
запрошенной позиции. Помните, что char может быть передан в тип параметра int. На экзамене вы увидите только символ, 
переданный в параметры с именем ch. Сигнатуры методов следующие:

```
public int indexOf(int ch)

public int indexOf(int ch, int fromIndex)
public int indexOf(String str)
public int indexOf(String str, int fromIndex)
```

Следующий код показывает, как использовать indexOf():

```
var name = "animals";
System.out.println(name.indexOf('a'));      // 0
System.out.println(name.indexOf("al"));     // 4
System.out.println(name.indexOf('a', 4));   // 4
System.out.println(name.indexOf("al", 5));  // -1
```


