# Основные API

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Обработка даты, времени, текста, числовых и логических значений

+ Используйте примитивы и классы-оболочки, включая Math API, круглые скобки, продвижение(или повышение) и 
приведение типов для вычисления арифметических и логических выражений
+ Манипулируйте текстом, включая текстовые блоки, используя классы String и StringBuilder
+ Манипулируйте датой, временем, продолжительностью, периодом, мгновенными объектами и объектами часового пояса с 
помощью Date-Time API

#### Работа с массивами и коллекциями

+ Создавайте массивы Java, коллекции List, Set, Map и Deque, а также добавляйте, удаляйте, обновляйте, извлекайте и 
сортируйте их элементы

---

В контексте интерфейса прикладного программирования (API) интерфейс относится к группе классов или определений 
интерфейса Java, предоставляющих вам доступ к функциональности.

В этой главе вы узнаете о многих основных структурах данных в Java, а также о наиболее распространенных API для доступа 
к ним. Например, String и StringBuilder вместе со связанными с ними API используются для создания текстовых данных и 
управления ими. Затем мы покрываем массивы. Наконец, мы изучаем математические API и API даты/времени.

## Создание и манипулирование строками

Класс String - это настолько фундаментальный класс, что вам было бы трудно писать код без него. В конце концов, вы даже 
не можете написать метод main() без использования класса String. Строка - это, по сути, последовательность символов; 
вот пример:

```
String name = "Fluffy";
```

Как вы узнали из главы 1 “Строительные блоки”, это пример ссылочного типа. Вы также узнали, что ссылочные типы создаются
с использованием ключевого слова new. Подождите минуту. В предыдущем примере чего-то не хватает: в нем нет new! В Java 
эти два фрагмента создают строку:

```
String name = "Fluffy";
String name = new String("Fluffy");
```

Оба дают вам ссылочную переменную с именем name, указывающую на объект String "Fluffy". Как вы увидите далее в этой 
главе, они немного отличаются. А пока просто помните, что класс String особенный и его не нужно создавать с помощью new.

Кроме того, текстовые блоки — это ещё один способ создания String. Для обзора этот текстовый блок такой же, как и 
предыдущие переменные:

```
String name = """
              Fluffy""";
```

Поскольку String - это последовательность символов, вы, вероятно, не удивитесь, услышав, что она реализует интерфейс 
CharSequence. Этот интерфейс представляет собой общий способ представления нескольких классов, включая String и 
StringBuilder. Вы узнаете больше об интерфейсах в главе 7 “За пределами классов”.

В этом разделе мы рассмотрим конкатенацию, общие методы и цепочку методов.

### Конкатенация

В главе 2 «Операторы» вы узнали, как складывать числа. 1 + 2 — это явно 3. Но что такое «1» + «2»? Это «12», потому что 
Java объединяет два объекта String. Размещение одной строки перед другой строкой и их объединение называется 
конкатенацией строк. Создателям экзамена нравится конкатенация строк, потому что оператор + можно использовать двумя 
способами в одной строке кода. Для этого не так много правил, но вы должны их хорошо знать:

1. Если оба операнда являются числовыми, + означает числовое сложение.
2. Если любой из операндов является строкой, + означает конкатенацию.
3. Выражение оценивается слева направо.

Теперь давайте рассмотрим несколько примеров:

```
System.out.println(1 + 2);             // 3
System.out.println("a" + "b");         // ab
System.out.println("a" + "b" + 3);     // ab3
System.out.println(1 + 2 + "c");       // 3c
System.out.println("c" + 1 + 2);       // c12
System.out.println("c" + null);        // cnull
```

В первом примере используется первое правило. Оба операнда являются числами, поэтому мы используем обычное сложение. 
Второй пример — простая конкатенация строк, описанная во втором правиле. Кавычки для строки используются только в коде; 
они не получают выход.

Третий пример объединяет второе и третье правила. Поскольку мы начинаем слева, Java выясняет, чему соответствует 
"a" + "b". Вы уже знаете это: это «ab». Затем Java просматривает оставшееся выражение «ab» + 3. Второе правило говорит 
нам о конкатенации, поскольку один из операндов является строкой.

В четвертом примере мы начинаем с третьего правила, которое говорит нам рассмотреть 1 + 2. Оба операнда являются 
числовыми, поэтому первое правило говорит нам, что ответ равен 3. Затем у нас есть 3 + «с», которое использует второе 
правило, чтобы дать нам "3c". Заметили, что все три правила используются в одной строке?

Пятый пример показывает важность третьего правила. Сначала у нас есть "c" + 1, который использует второе правило, чтобы 
дать нам "c1". Затем у нас есть «c1» + 2, который снова использует второе правило, чтобы дать нам «c12».

Наконец, последний пример показывает, как null представляется в виде строки при объединении или печати, что дает нам 
«cnull».

Экзамен делает ещё один шаг вперед и попытается одурачить вас чем-то вроде этого:

```
int three = 3;
String four = "4";
System.out.println(1 + 2 + three + four);
```

Когда вы увидите это, просто не торопитесь, запомните три правила и обязательно проверьте типы переменных. В этом 
примере мы начинаем с третьего правила, которое говорит нам рассмотреть 1 + 2.

Первое правило дает нам 3. Далее у нас есть 3 + three. Поскольку число three имеет тип int, мы по-прежнему используем 
первое правило, что дает нам число 6. Тогда у нас есть 6 + four. Так как четыре имеет тип String, мы переключаемся на 
второе правило и получаем окончательный ответ «64». Когда вы видите такие вопросы, просто не торопитесь и проверьте 
типы. Методичность окупается.

Есть еще одна вещь, которую нужно знать о конкатенации, но это несложно. В этом примере вам просто нужно помнить, что 
делает +=. Имейте в виду, что s += "2" означает то же самое, что и s = s + "2".

```
4: var s = "1";                // s currently holds "1"
5: s += "2";                   // s currently holds "12"
6: s += 3;                     // s currently holds "123"
7: System.out.println(s);      // 123
```

В строке 5 мы «добавляем» две строки, что означает их конкатенацию. Строка 6 пытается обмануть вас, добавляя число, но 
это точно так же, как мы написали s = s + 3. Мы знаем, что строка «плюс» что-либо еще означает использование 
конкатенации.

Чтобы просмотреть правила еще раз: используйте числовое сложение, если участвуют два числа, используйте конкатенацию в 
противном случае и оценивайте слева направо. Вы уже выучили эти три правила? Обязательно сделайте это перед экзаменом!


## Важные методы String

Класс String имеет десятки методов. К счастью, для экзамена вам нужно знать лишь несколько. Создатели экзамена выбирают 
большинство методов, которые разработчики используют в реальном мире.

Для всех этих методов вам нужно помнить, что строка представляет собой последовательность символов, а Java отсчитывает 
от 0 при индексации. На рис. 4.1 показано, как индексируется каждый символ в строке «animals».

#### Рис. 4.1 - Индексация для строки

Вам также необходимо знать, что String является неизменяемым или неизменным. Это означает, что вызов метода для 
String вернет другой объект String, а не изменит значение ссылки. В этой главе вы используете неизменяемые объекты. 
В главе 6 “Проектирование классов” вы узнаете, как создавать собственные неизменяемые объекты.

Давайте рассмотрим несколько методов класса String. Многие из них просты, поэтому мы не будем подробно их обсуждать. 
Вы должны знать, как использовать эти методы.

### Определение длины

Метод length() возвращает количество символов в строке. Сигнатура метода выглядит следующим образом:

```
public int length()
```

Следующий код показывает, как использовать length():

```
var name = "animals";
System.out.println(name.length());  // 7
```

Ждать. Выдает 7? Разве мы только что не говорили вам, что Java считает с 0? Разница в том, что нулевой подсчет 
происходит только тогда, когда вы используете индексы или позиции в списке. При определении общего размера или длины 
Java снова использует обычный подсчет.

### Получение одного символа

Метод charAt() позволяет вам запросить строку, чтобы узнать, какой символ находится в определенном индексе. 
Сигнатура метода выглядит следующим образом:

```
public char charAt(int index)
```

Следующий код показывает, как использовать charAt():

```
var name = "animals";
System.out.println(name.charAt(0));  // a
System.out.println(name.charAt(6));  // s
System.out.println(name.charAt(7));  // exception
```

Поскольку индексы начинают считать с 0, charAt(0) возвращает «первый» символ в последовательности. Точно так же 
charAt(6) возвращает «седьмой» символ в последовательности. Однако проблема с charAt(7). Он запрашивает «восьмой» 
символ в последовательности, но присутствует только семь символов. Когда что-то идет не так, с чем Java не знает, что 
делать, она генерирует исключение, как показано здесь. Вы узнаете больше об исключениях в главе 11, «Исключения и 
локализация».

```
java.lang.StringIndexOutOfBoundsException: String index out of range: 7
```

### Поиск индекса

Метод indexOf() просматривает символы в строке и находит первый индекс, соответствующий нужному значению. Метод indexOf 
может работать с отдельным символом или целой строкой в качестве входных данных. Он также может начинаться с 
запрошенной позиции. Помните, что char может быть передан в тип параметра int. На экзамене вы увидите только символ, 
переданный в параметры с именем ch. Сигнатуры методов следующие:

```
public int indexOf(int ch)

public int indexOf(int ch, int fromIndex)
public int indexOf(String str)
public int indexOf(String str, int fromIndex)
```

Следующий код показывает, как использовать indexOf():

```
var name = "animals";
System.out.println(name.indexOf('a'));       // 0
System.out.println(name.indexOf("al"));      // 4
System.out.println(name.indexOf('a', 4));    // 4
System.out.println(name.indexOf("al", 5));   // -1
```

Поскольку индексы начинаются с 0, первая буква «а» соответствует этой позиции. Второй оператор ищет более конкретную 
строку, поэтому она соответствует позже. Третий оператор говорит, что Java не должен смотреть на символы, пока не 
доберется до индекса 4. Последний оператор ничего не находит, потому что он начинает искать после совпадения. В отличие 
от charAt(), метод indexOf() не генерирует исключение, если не может найти совпадение, вместо этого возвращает -1. 
Поскольку индексы начинаются с 0, вызывающая сторона знает, что -1 не может быть допустимым индексом. Это делает 
обычным значением для метода указание вызывающей стороне, что совпадение не найдено.

### Получение подстроки

Метод substring() также ищет символы в строке. Он возвращает части строки. Первый параметр — это индекс, с которого 
начинается возвращаемая строка. Как обычно, это индекс с отсчетом от нуля. Существует необязательный второй параметр, 
который является конечным индексом, на котором вы хотите остановиться.

Обратите внимание, мы сказали “остановиться на”, а не “включить”. Это означает, что параметру endIndex разрешено быть 
на единицу больше конца последовательности, если вы хотите остановиться в конце последовательности. Однако это было бы 
излишним, поскольку в этом случае вы могли бы полностью опустить второй параметр. В вашем собственном коде вы хотите 
избежать этой избыточности. Однако не удивляйтесь, если на экзамене он будет использоваться. Сигнатуры метода следующие:

```
public String substring(int beginIndex)
public String substring(int beginIndex, int endIndex)
```

Это помогает немного по-другому относиться к индексам для методов подстроки. Представьте, что индексы находятся прямо перед символом, на который они будут указывать. Рисунок 4.2 помогает визуализировать это. Обратите внимание, как стрелка с 0 указывает на символ, который будет иметь индекс 0. Стрелка с цифрой 1 указывает между символами с индексами 0 и 1. В строке семь символов. Поскольку Java использует индексы на основе нуля, это означает, что последний символ имеет индекс 6. Стрелка с 7 точками сразу после этого последнего символа. Это поможет вам помнить, что endIndex не выдает исключение, выходящее за пределы, когда оно находится на единицу дальше конца строки.

Это помогает думать об индексах немного по-другому для методов подстроки. Представьте, что индексы находятся прямо перед символом, на который они указывают. Рисунок 4.2 помогает визуализировать это. Обратите внимание, как стрелка с 0 указывает на символ, который должен иметь индекс 0. Стрелка с 1 указывает между символами с индексами 0 и 1. В строке семь символов. Так как Java использует индексы, начинающиеся с нуля, это означает, что последний символ имеет индекс 6. Стрелка с 7 указывает сразу после этого последнего символа. Это поможет вам помнить, что endIndex не выдает исключения за пределами диапазона, когда он находится за концом строки на единицу.

#### Рис. 4.2 - Индексы для подстроки


Следующий код показывает, как использовать substring():

```
var name = "animals";
System.out.println(name.substring(3));                   // mals
System.out.println(name.substring(name.indexOf('m')));   // mals
System.out.println(name.substring(3, 4));                // m
System.out.println(name.substring(3, 7));                // mals
```

Метод substring() - самый сложный строковый метод на экзамене. В первом примере говорится, что нужно брать символы, 
начиная с индекса 3 и заканчивая концом, что дает нам "mals". Во втором примере делается то же самое, но он вызывает 
indexOf() для получения индекса, а не жестко задает его. Это обычная практика при кодировании, потому что вы можете не 
знать индекс заранее.

В третьем примере говорится, что нужно брать символы, начинающиеся с индекса 3, до символа с индексом 4, но не включая 
его. Это сложный способ сказать, что нам нужна строка с одним символом: с индексом 3. В результате получается "m".
В последнем примере говорится, что нужно брать символы, начинающиеся с индекса 3, пока мы не дойдем до индекса 7. 
Поскольку индекс 7 совпадает с концом строки, это эквивалентно первому примеру.

Мы надеемся, что это не слишком сбило с толку. Следующие примеры менее очевидны:

```
System.out.println(name.substring(3, 3));  // empty string (пустая строка)
System.out.println(name.substring(3, 2));  // exception
System.out.println(name.substring(3, 8));  // exception
```

Первый пример в этом наборе печатает пустую строку. Запрос касается символов, начинающихся с индекса 3, пока мы не 
доберемся до индекса 3. Поскольку мы начинаем и заканчиваем с одним и тем же индексом, между ними нет символов. Второй 
пример в этом наборе вызывает исключение, потому что индексы не могут быть обратными. Java прекрасно знает, что она 
никогда не доберется до индекса 2, если начнет с индекса 3. В третьем примере предлагается продолжать до восьмого 
символа. Восьмой позиции нет, поэтому Java выдает исключение. Конечно, седьмого символа тоже нет, но зато есть 
невидимая позиция «конец строки».

Давайте рассмотрим это еще раз, так как функция substring() сложная. Метод возвращает строку, начинающуюся с 
запрошенного индекса. Если запрашивается конечный индекс, он останавливается прямо перед этим индексом. В противном 
случае он переходит в конец строки.

### Настройка или Регулировка или Управление или  Регистра

После этого умственного упражнения приятно иметь методы, которые действуют именно так, как звучат! 
Эти методы упрощают преобразование ваших данных. Сигнатуры методов следующие:

```
public String toLowerCase()
public String toUpperCase()
```

В следующем коде показано, как использовать эти методы:

```
var name = "animals";
System.out.println(name.toUpperCase());      // ANIMALS
System.out.println("Abc123".toLowerCase());  // abc123
```

Эти методы делают то, что говорят. Метод toUpperCase() преобразует все символы нижнего регистра в верхний регистр в 
возвращаемой строке. Метод toLowerCase() преобразует любые символы верхнего регистра в нижний регистр в возвращаемой 
строке. Эти методы оставляют в покое любые символы, кроме букв. Кроме того, помните, что строки неизменяемы, поэтому 
исходная строка остается неизменной.

### Checking for Equality