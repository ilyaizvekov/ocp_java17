# Основные API

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Обработка даты, времени, текста, числовых и логических значений

+ Используйте примитивы и классы-оболочки, включая Math API, круглые скобки, продвижение(или повышение) и 
приведение типов для вычисления арифметических и логических выражений
+ Манипулируйте текстом, включая текстовые блоки, используя классы String и StringBuilder
+ Манипулируйте датой, временем, продолжительностью, периодом, мгновенными объектами и объектами часового пояса с 
помощью Date-Time API

#### Работа с массивами и коллекциями

+ Создавайте массивы Java, коллекции List, Set, Map и Deque, а также добавляйте, удаляйте, обновляйте, извлекайте и 
сортируйте их элементы

---

В контексте интерфейса прикладного программирования (API) интерфейс относится к группе классов или определений 
интерфейса Java, предоставляющих вам доступ к функциональности.

В этой главе вы узнаете о многих основных структурах данных в Java, а также о наиболее распространенных API для доступа 
к ним. Например, String и StringBuilder вместе со связанными с ними API используются для создания текстовых данных и 
управления ими. Затем мы покрываем массивы. Наконец, мы изучаем математические API и API даты/времени.

## Создание и манипулирование строками

Класс String - это настолько фундаментальный класс, что вам было бы трудно писать код без него. В конце концов, вы даже 
не можете написать метод main() без использования класса String. Строка - это, по сути, последовательность символов; 
вот пример:

```
String name = "Fluffy";
```

Как вы узнали из главы 1 “Строительные блоки”, это пример ссылочного типа. Вы также узнали, что ссылочные типы создаются
с использованием ключевого слова new. Подождите минуту. В предыдущем примере чего-то не хватает: в нем нет new! В Java 
эти два фрагмента создают строку:

```
String name = "Fluffy";
String name = new String("Fluffy");
```

Оба дают вам ссылочную переменную с именем name, указывающую на объект String "Fluffy". Как вы увидите далее в этой 
главе, они немного отличаются. А пока просто помните, что класс String особенный и его не нужно создавать с помощью new.

Кроме того, текстовые блоки — это ещё один способ создания String. Для обзора этот текстовый блок такой же, как и 
предыдущие переменные:

```
String name = """
              Fluffy""";
```

Поскольку String - это последовательность символов, вы, вероятно, не удивитесь, услышав, что она реализует интерфейс 
CharSequence. Этот интерфейс представляет собой общий способ представления нескольких классов, включая String и 
StringBuilder. Вы узнаете больше об интерфейсах в главе 7 “За пределами классов”.

В этом разделе мы рассмотрим конкатенацию, общие методы и цепочку методов.

### Конкатенация

В главе 2 «Операторы» вы узнали, как складывать числа. 1 + 2 — это явно 3. Но что такое «1» + «2»? Это «12», потому что 
Java объединяет два объекта String. Размещение одной строки перед другой строкой и их объединение называется 
конкатенацией строк. Создателям экзамена нравится конкатенация строк, потому что оператор + можно использовать двумя 
способами в одной строке кода. Для этого не так много правил, но вы должны их хорошо знать:

1. Если оба операнда являются числовыми, + означает числовое сложение.
2. Если любой из операндов является строкой, + означает конкатенацию.
3. Выражение оценивается слева направо.

Теперь давайте рассмотрим несколько примеров:

```
System.out.println(1 + 2);             // 3
System.out.println("a" + "b");         // ab
System.out.println("a" + "b" + 3);     // ab3
System.out.println(1 + 2 + "c");       // 3c
System.out.println("c" + 1 + 2);       // c12
System.out.println("c" + null);        // cnull
```

В первом примере используется первое правило. Оба операнда являются числами, поэтому мы используем обычное сложение. 
Второй пример — простая конкатенация строк, описанная во втором правиле. Кавычки для строки используются только в коде; 
они не получают выход.

Третий пример объединяет второе и третье правила. Поскольку мы начинаем слева, Java выясняет, чему соответствует 
"a" + "b". Вы уже знаете это: это «ab». Затем Java просматривает оставшееся выражение «ab» + 3. Второе правило говорит 
нам о конкатенации, поскольку один из операндов является строкой.

В четвертом примере мы начинаем с третьего правила, которое говорит нам рассмотреть 1 + 2. Оба операнда являются 
числовыми, поэтому первое правило говорит нам, что ответ равен 3. Затем у нас есть 3 + «с», которое использует второе 
правило, чтобы дать нам "3c". Заметили, что все три правила используются в одной строке?

Пятый пример показывает важность третьего правила. Сначала у нас есть "c" + 1, который использует второе правило, чтобы 
дать нам "c1". Затем у нас есть «c1» + 2, который снова использует второе правило, чтобы дать нам «c12».

Наконец, последний пример показывает, как null представляется в виде строки при объединении или печати, что дает нам 
«cnull».

Экзамен делает ещё один шаг вперед и попытается одурачить вас чем-то вроде этого:

```
int three = 3;
String four = "4";
System.out.println(1 + 2 + three + four);
```

Когда вы увидите это, просто не торопитесь, запомните три правила и обязательно проверьте типы переменных. В этом 
примере мы начинаем с третьего правила, которое говорит нам рассмотреть 1 + 2.

Первое правило дает нам 3. Далее у нас есть 3 + three. Поскольку число three имеет тип int, мы по-прежнему используем 
первое правило, что дает нам число 6. Тогда у нас есть 6 + four. Так как четыре имеет тип String, мы переключаемся на 
второе правило и получаем окончательный ответ «64». Когда вы видите такие вопросы, просто не торопитесь и проверьте 
типы. Методичность окупается.

Есть еще одна вещь, которую нужно знать о конкатенации, но это несложно. В этом примере вам просто нужно помнить, что 
делает +=. Имейте в виду, что s += "2" означает то же самое, что и s = s + "2".

```
4: var s = "1";                // s currently holds "1"
5: s += "2";                   // s currently holds "12"
6: s += 3;                     // s currently holds "123"
7: System.out.println(s);      // 123
```

В строке 5 мы «добавляем» две строки, что означает их конкатенацию. Строка 6 пытается обмануть вас, добавляя число, но 
это точно так же, как мы написали s = s + 3. Мы знаем, что строка «плюс» что-либо еще означает использование 
конкатенации.

Чтобы просмотреть правила еще раз: используйте числовое сложение, если участвуют два числа, используйте конкатенацию в 
противном случае и оценивайте слева направо. Вы уже выучили эти три правила? Обязательно сделайте это перед экзаменом!


## Важные методы String

Класс String имеет десятки методов. К счастью, для экзамена вам нужно знать лишь несколько. Создатели экзамена выбирают 
большинство методов, которые разработчики используют в реальном мире.

Для всех этих методов вам нужно помнить, что строка представляет собой последовательность символов, а Java отсчитывает 
от 0 при индексации. На рис. 4.1 показано, как индексируется каждый символ в строке «animals».

#### Рис. 4.1 - Индексация для строки

Вам также необходимо знать, что String является неизменяемым или неизменным. Это означает, что вызов метода для 
String вернет другой объект String, а не изменит значение ссылки. В этой главе вы используете неизменяемые объекты. 
В главе 6 “Проектирование классов” вы узнаете, как создавать собственные неизменяемые объекты.

Давайте рассмотрим несколько методов класса String. Многие из них просты, поэтому мы не будем подробно их обсуждать. 
Вы должны знать, как использовать эти методы.

### Определение длины

Метод length() возвращает количество символов в строке. Сигнатура метода выглядит следующим образом:

```
public int length()
```

Следующий код показывает, как использовать length():

```
var name = "animals";
System.out.println(name.length());  // 7
```

Ждать. Выдает 7? Разве мы только что не говорили вам, что Java считает с 0? Разница в том, что нулевой подсчет 
происходит только тогда, когда вы используете индексы или позиции в списке. При определении общего размера или длины 
Java снова использует обычный подсчет.

### Получение одного символа

Метод charAt() позволяет вам запросить строку, чтобы узнать, какой символ находится в определенном индексе. 
Сигнатура метода выглядит следующим образом:

```
public char charAt(int index)
```

Следующий код показывает, как использовать charAt():

```
var name = "animals";
System.out.println(name.charAt(0));  // a
System.out.println(name.charAt(6));  // s
System.out.println(name.charAt(7));  // exception
```

Поскольку индексы начинают считать с 0, charAt(0) возвращает «первый» символ в последовательности. Точно так же 
charAt(6) возвращает «седьмой» символ в последовательности. Однако проблема с charAt(7). Он запрашивает «восьмой» 
символ в последовательности, но присутствует только семь символов. Когда что-то идет не так, с чем Java не знает, что 
делать, она генерирует исключение, как показано здесь. Вы узнаете больше об исключениях в главе 11, «Исключения и 
локализация».

```
java.lang.StringIndexOutOfBoundsException: String index out of range: 7
```

### Поиск индекса

Метод indexOf() просматривает символы в строке и находит первый индекс, соответствующий нужному значению. Метод indexOf 
может работать с отдельным символом или целой строкой в качестве входных данных. Он также может начинаться с 
запрошенной позиции. Помните, что char может быть передан в тип параметра int. На экзамене вы увидите только символ, 
переданный в параметры с именем ch. Сигнатуры методов следующие:

```
public int indexOf(int ch)

public int indexOf(int ch, int fromIndex)
public int indexOf(String str)
public int indexOf(String str, int fromIndex)
```

Следующий код показывает, как использовать indexOf():

```
var name = "animals";
System.out.println(name.indexOf('a'));       // 0
System.out.println(name.indexOf("al"));      // 4
System.out.println(name.indexOf('a', 4));    // 4
System.out.println(name.indexOf("al", 5));   // -1
```

Поскольку индексы начинаются с 0, первая буква «а» соответствует этой позиции. Второй оператор ищет более конкретную 
строку, поэтому она соответствует позже. Третий оператор говорит, что Java не должен смотреть на символы, пока не 
доберется до индекса 4. Последний оператор ничего не находит, потому что он начинает искать после совпадения. В отличие 
от charAt(), метод indexOf() не генерирует исключение, если не может найти совпадение, вместо этого возвращает -1. 
Поскольку индексы начинаются с 0, вызывающая сторона знает, что -1 не может быть допустимым индексом. Это делает 
обычным значением для метода указание вызывающей стороне, что совпадение не найдено.

### Получение подстроки

Метод substring() также ищет символы в строке. Он возвращает части строки. Первый параметр — это индекс, с которого 
начинается возвращаемая строка. Как обычно, это индекс с отсчетом от нуля. Существует необязательный второй параметр, 
который является конечным индексом, на котором вы хотите остановиться.

Обратите внимание, мы сказали “остановиться на”, а не “включить”. Это означает, что параметру endIndex разрешено быть 
на единицу больше конца последовательности, если вы хотите остановиться в конце последовательности. Однако это было бы 
излишним, поскольку в этом случае вы могли бы полностью опустить второй параметр. В вашем собственном коде вы хотите 
избежать этой избыточности. Однако не удивляйтесь, если на экзамене он будет использоваться. Сигнатуры метода следующие:

```
public String substring(int beginIndex)
public String substring(int beginIndex, int endIndex)
```

Это помогает немного по-другому относиться к индексам для методов подстроки. Представьте, что индексы находятся прямо перед символом, на который они будут указывать. Рисунок 4.2 помогает визуализировать это. Обратите внимание, как стрелка с 0 указывает на символ, который будет иметь индекс 0. Стрелка с цифрой 1 указывает между символами с индексами 0 и 1. В строке семь символов. Поскольку Java использует индексы на основе нуля, это означает, что последний символ имеет индекс 6. Стрелка с 7 точками сразу после этого последнего символа. Это поможет вам помнить, что endIndex не выдает исключение, выходящее за пределы, когда оно находится на единицу дальше конца строки.

Это помогает думать об индексах немного по-другому для методов подстроки. Представьте, что индексы находятся прямо перед символом, на который они указывают. Рисунок 4.2 помогает визуализировать это. Обратите внимание, как стрелка с 0 указывает на символ, который должен иметь индекс 0. Стрелка с 1 указывает между символами с индексами 0 и 1. В строке семь символов. Так как Java использует индексы, начинающиеся с нуля, это означает, что последний символ имеет индекс 6. Стрелка с 7 указывает сразу после этого последнего символа. Это поможет вам помнить, что endIndex не выдает исключения за пределами диапазона, когда он находится за концом строки на единицу.

#### Рис. 4.2 - Индексы для подстроки


Следующий код показывает, как использовать substring():

```
var name = "animals";
System.out.println(name.substring(3));                   // mals
System.out.println(name.substring(name.indexOf('m')));   // mals
System.out.println(name.substring(3, 4));                // m
System.out.println(name.substring(3, 7));                // mals
```

Метод substring() - самый сложный строковый метод на экзамене. В первом примере говорится, что нужно брать символы, 
начиная с индекса 3 и заканчивая концом, что дает нам "mals". Во втором примере делается то же самое, но он вызывает 
indexOf() для получения индекса, а не жестко задает его. Это обычная практика при кодировании, потому что вы можете не 
знать индекс заранее.

В третьем примере говорится, что нужно брать символы, начинающиеся с индекса 3, до символа с индексом 4, но не включая 
его. Это сложный способ сказать, что нам нужна строка с одним символом: с индексом 3. В результате получается "m".
В последнем примере говорится, что нужно брать символы, начинающиеся с индекса 3, пока мы не дойдем до индекса 7. 
Поскольку индекс 7 совпадает с концом строки, это эквивалентно первому примеру.

Мы надеемся, что это не слишком сбило с толку. Следующие примеры менее очевидны:

```
System.out.println(name.substring(3, 3));  // empty string (пустая строка)
System.out.println(name.substring(3, 2));  // exception
System.out.println(name.substring(3, 8));  // exception
```

Первый пример в этом наборе печатает пустую строку. Запрос касается символов, начинающихся с индекса 3, пока мы не 
доберемся до индекса 3. Поскольку мы начинаем и заканчиваем с одним и тем же индексом, между ними нет символов. Второй 
пример в этом наборе вызывает исключение, потому что индексы не могут быть обратными. Java прекрасно знает, что она 
никогда не доберется до индекса 2, если начнет с индекса 3. В третьем примере предлагается продолжать до восьмого 
символа. Восьмой позиции нет, поэтому Java выдает исключение. Конечно, седьмого символа тоже нет, но зато есть 
невидимая позиция «конец строки».

Давайте рассмотрим это еще раз, так как функция substring() сложная. Метод возвращает строку, начинающуюся с 
запрошенного индекса. Если запрашивается конечный индекс, он останавливается прямо перед этим индексом. В противном 
случае он переходит в конец строки.

### Настройка регистра

После этого умственного упражнения приятно иметь методы, которые действуют именно так, как звучат! 
Эти методы упрощают преобразование ваших данных. Сигнатуры методов следующие:

```
public String toLowerCase()
public String toUpperCase()
```

В следующем коде показано, как использовать эти методы:

```
var name = "animals";
System.out.println(name.toUpperCase());      // ANIMALS
System.out.println("Abc123".toLowerCase());  // abc123
```

Эти методы делают то, что говорят. Метод toUpperCase() преобразует все символы нижнего регистра в верхний регистр в 
возвращаемой строке. Метод toLowerCase() преобразует любые символы верхнего регистра в нижний регистр в возвращаемой 
строке. Эти методы оставляют в покое любые символы, кроме букв. Кроме того, помните, что строки неизменяемы, поэтому 
исходная строка остается неизменной.

### Проверка на равенство

Метод equals() проверяет, содержат ли два объекта String одни и те же символы в одном и том же порядке. Метод 
equalsIgnoreCase() проверяет, содержат ли два объекта String одинаковые символы, за исключением того, что он игнорирует 
регистр символов. Сигнатуры методов следующие:

```
public boolean equals(Object obj)
public boolean equalsIgnoreCase(String str)
```

Возможно, вы заметили, что equals() принимает объект, а не строку. Это связано с тем, что метод одинаков для всех 
объектов. Если вы передадите что-то, что не является строкой, это просто вернет значение false. В отличие от этого, 
метод equalsIgnoreCase() применяется только к строковым объектам, поэтому он может принимать более конкретный тип в 
качестве параметра.

В Java значения String чувствительны к регистру. Это означает, что «abc» и «ABC» считаются разными значениями. 
Имея это в виду, следующий код показывает, как использовать эти методы:

```
System.out.println("abc".equals("ABC"));            // false
System.out.println("ABC".equals("ABC"));            // true
System.out.println("abc".equalsIgnoreCase("ABC"));  // true
```

Этот пример должен быть достаточно интуитивным. В первом примере значения не совсем совпадают. Во втором они точно 
такие же. В третьем они отличаются только регистром, но ничего страшного, потому что мы вызвали метод, который 
игнорирует различия в регистре.

---

#### Переопределение (Overriding) toString(), equals(Object), and hashCode()

Знание того, как правильно переопределять toString(), equals(Object) и hashCode(), в прошлом было частью 
сертификационных экзаменов Java. Как профессиональному разработчику Java, вам по-прежнему важно знать, по крайней мере, 
основные правила переопределения каждого из этих методов:

+ toString(): Метод toString() вызывается, когда вы пытаетесь напечатать объект или объединить объект со строкой. 
Обычно он переопределяется версией, которая печатает уникальное описание экземпляра, используя его поля экземпляра.
+ equals(Object): Метод equals(Object) используется для сравнения объектов, а реализация по умолчанию использует только 
оператор ==. Вы должны переопределять метод equals(Object) каждый раз, когда хотите удобно сравнить элементы на 
равенство, особенно если это требует проверки множества полей.
+ hashCode(): Каждый раз, когда вы переопределяете equals(Object), вы должны переопределить hashCode(), чтобы быть 
согласованным. Это означает, что для любых двух объектов, если значение a.equals(b) равно true, то значение 
a.hashCode()==b.hashCode() также должно быть true. Если они не согласованы, это может привести к неверным данным и 
побочным эффектам в коллекциях на основе хэша, таких как HashMap и HashSet.

Все эти методы обеспечивают реализацию по умолчанию в Object, но если вы хотите использовать их с умом, вы должны 
переопределить их.

---

### Поиск подстроки

Часто вам нужно выполнить поиск в строке большего размера, чтобы определить, содержится ли в ней подстрока. Методы 
startsWith() и endsWith() проверяют, соответствует ли предоставленное значение части строки. Метод contains() не столь 
специфичен; он ищет совпадения в любом месте строки. Сигнатуры метода следующие:

```
public boolean startsWith(String prefix)
public boolean endsWith(String suffix)
public boolean contains(CharSequence charSeq)
```

В следующем коде показано, как использовать эти методы:

```
System.out.println("abc".startsWith("a")); // true
System.out.println("abc".startsWith("A")); // false

System.out.println("abc".endsWith("c")); // true
System.out.println("abc".endsWith("a")); // false

System.out.println("abc".contains("b")); // true
System.out.println("abc".contains("B")); // false
```

Опять же, здесь нет ничего удивительного. Java выполняет проверку предоставленных значений с учетом регистра. Обратите 
внимание, что метод contains() является удобным методом, поэтому вам не нужно писать str.indexOf(otherString) != -1.

### Замена значений

Метод replace() выполняет простой поиск и замену в строке. Есть версия, которая принимает параметры char, а также 
версия, которая принимает параметры CharSequence. Сигнатуры методов следующие:

```
public String replace(char oldChar, char newChar)
public String replace(CharSequence target, CharSequence replacement)
```

В следующем коде показано, как использовать эти методы:

```
System.out.println("abcabc".replace('a', 'A'));   // AbcAbc
System.out.println("abcabc".replace("a", "A"));   // AbcAbc
```

В первом примере используется сигнатура первого метода, передающая параметры char. Во втором примере используется 
сигнатура второго метода, передающая String параметры.

### Удаление пробелов

Эти методы удаляют пустое пространство в начале и/или конце строки. Методы strip() и trim() удаляют пробелы в начале и 
в конце строки. С точки зрения экзамена пробел состоит из пробелов, а также символов \t (табуляция) и \n (новая строка). 
Другие символы, такие как \r (возврат каретки), также включаются в то, что обрезается. Метод strip() делает все то же, 
что и trim(), но поддерживает Unicode.

_Вам не нужно знать о Unicode для экзамена. Но если вы хотите проверить разницу, один из пробельных символов Unicode 
выглядит следующим образом:_

```
char ch = '\u2000';
```

Кроме того, метод stripLeading() удаляет пробелы в начале строки и оставляет их в конце. Метод stripTrailing() делает 
обратное. Он удаляет пробелы с конца строки и оставляет их в начале. Сигнатуры методов следующие:

```
public String strip()
public String stripLeading()
public String stripTrailing()
public String trim()
```

В следующем коде показано, как использовать эти методы:

```
System.out.println("abc".strip());          // abc
System.out.println("\t a b c\n".strip());   // a b c

String text = " abc\t ";
System.out.println(text.trim().length());            // 3
System.out.println(text.strip().length());           // 3
System.out.println(text.stripLeading().length());    // 5
System.out.println(text.stripTrailing().length());   // 4
```

Во-первых, помните, что \t — это одиночный символ. Обратная косая черта экранирует t для обозначения табуляции. 
В первом примере печатается исходная строка, поскольку в начале и в конце нет пробельных символов. Второй пример 
избавляется от ведущей табуляции, последующих пробелов и завершающей новой строки. Он оставляет пробелы в середине 
строки.

Остальные примеры просто печатают количество оставшихся символов. Вы можете видеть, что функции trim() и strip() 
оставляют одни и те же три символа «abc», потому что они удаляют как начальные, так и конечные пробелы. Метод 
stripLeading() удаляет только один пробел в начале строки. Он оставляет вкладку и пробел в конце. Метод stripTrailing() 
удаляет эти два символа в конце, но оставляет символ в начале строки.

### Работа с отступом

Теперь, когда Java поддерживает текстовые блоки, полезно иметь методы для работы с отступами. Оба они немного сложны, 
так что читайте внимательно!

```
public String indent(int numberSpaces)
public String stripIndent()
```

Метод indent() добавляет одинаковое количество пробелов в начало каждой строки, если вы передаете положительное число. 
Если вы передаете отрицательное число, он пытается удалить это количество пробельных символов с начала строки. Если вы 
передадите ноль, отступ не изменится.

_Если вы вызовете indent() с отрицательным числом и попытаетесь удалить больше пробелов, чем присутствует в начале 
строки, Java удалит все, что сможет найти._

Это кажется достаточно простым. Однако функция indent() также нормализует символы пробела. Что означает нормализация пробелов, спросите вы? Во-первых, в конец строки добавляется разрыв строки, если его там еще нет. Во-вторых, любые разрывы строк преобразуются в формат \n. Независимо от того, использует ли ваша операционная система \ r \ n (Windows) или \ n (Mac / Unix), Java будет стандартизировать \ n для вас.
or
Это кажется достаточно простым. Однако indent() также нормализует символы пробела. Вы спросите, что означает нормализация пробелов? Во-первых, в конец строки добавляется разрыв строки, если его еще нет. Во-вторых, любые разрывы строк преобразуются в формат \n. Независимо от того, использует ли ваша операционная система \r\n (Windows) или\n (Mac/Unix), Java стандартизирует \n для вас.

Метод stripIndent() полезен, когда String был построен с конкатенацией, а не с использованием текстового блока. Он избавляется от всех случайных пробелов. Это означает, что все непустые строки сдвигаются влево, поэтому из каждой строки удаляется одинаковое количество пробелов, а первый оставшийся символ не является пустым. Как и indent(), \r\n превращается в \n. Однако метод stripIndent() не добавляет разрыв строки в конце, если он отсутствует.
or
Метод stripIndent() полезен, когда строка была создана с помощью конкатенации, а не с использованием текстового блока. Это избавляет от всех случайных пробелов. Это означает, что все непустые строки сдвигаются влево, поэтому из каждой строки удаляется одинаковое количество пробелов, а первый оставшийся символ не является пустым. Как и indent(), \r\n превращается в \n. Однако метод stripIndent() не добавляет завершающий разрыв строки, если он отсутствует.

Что ж, это было очень много правил. В таблице 4.1 приведены ссылки, облегчающие их запоминание.

#### Таблица 4.1. - Правила для indent() и stripIndent()

|         Метод          |                                                     Изменение отступа                                                     | Нормализует существующие<br/>  разрывы строк | Добавляет разрыв строки<br/>  в конце, если он отсутствует |  
|:----------------------:|:-------------------------------------------------------------------------------------------------------------------------:|:--------------------------------------------:|:----------------------------------------------------------:|
| indent(n) where n > 0  |                                     Добавляет n пробелов<br/> в начало каждой строки                                      |                      Да                      |                             Да                             |
| indent(n) where n == 0 |                                                       Без изменений                                                       |                      Да                      |                             Да                             |
| indent(n) where n < 0  | Удаляет до n пробелов из каждой строки, при этом одинаковое<br/> количество символов удаляется из каждой непустой строки. |                      Да                      |                             Да                             |
|     stripIndent()      |                                          Удаляет все ведущие случайные пробелы                                            |                      Да                      |                            Нет                             |

Следующий код показывает, как использовать эти методы. Не волнуйтесь, если результаты окажутся не такими, как вы 
ожидаете. Мы объясняем каждый из них.

```
10: var block = """
11:             a
12:              b
13:             c""";
14: var concat = " a\n"
15:            + " b\n"
16:            + " c";
17: System.out.println(block.length());                  // 6
18: System.out.println(concat.length());                 // 9
19: System.out.println(block.indent(1).length());        // 10
20: System.out.println(concat.indent(-1).length());      // 7
21: System.out.println(concat.indent(-4).length());      // 6
22: System.out.println(concat.stripIndent().length());   // 6
```

Строки 10-16 создают аналогичные строки, используя текстовый блок и обычную строку соответственно. Мы говорим “похожий”,
потому что concat имеет пробельный символ в начале каждой строки, в то время как block - нет.

Строка 17 подсчитывает шесть символов в блоке: три буквы, пробел перед b и \n после a и b. Строка 18 подсчитывает девять символов в concat, которые представляют собой три буквы, один пробел перед a, два пробела перед b, один пробел перед c и \n после a и b. Считайте их сами. Если вы не понимаете, какие символы учитываются, это только еще больше запутает.
or
Строка 17 подсчитывает шесть символов в блоке, которые представляют собой три буквы, пробел перед b и \ n после a и b. Строка 18 подсчитывает девять символов в concat, которые представляют собой три буквы, один пробел перед a, два пробела перед b, один пробел перед c и \ n после a и b. Подсчитайте их сами. Если вы не понимаете, какие символы подсчитываются, это только еще больше запутает.

В строке 19 мы просим Java добавить один пробел к каждой из трех строк блока. Однако вывод говорит, что мы добавили 4 символа, а не 3, поскольку длина увеличилась с 6 до 10. Этот загадочный дополнительный символ появился благодаря нормализации конца строки. Поскольку текстовый блок не имеет разрыва строки в конце, indent() добавляет его!
or
В строке 19 мы просим Java добавить по одному пробелу к каждой из трех строк в блоке. Однако в выходных данных говорится, что мы добавили 4 символа, а не 3, поскольку длина увеличилась с 6 до 10. Этот таинственный дополнительный символ появился благодаря нормализации окончания строки. Поскольку текстовый блок не имеет разрыва строки в конце, функция indent() добавляет его!

В строке 20 мы удаляем по одному символу пробела из каждой из трех строк concat. Это дает длину семь. Мы начали с девяти, избавились от трех символов и добавили конечную нормализованную новую строку.
or
В строке 20 мы удаляем по одному пробелу из каждой из трех строк concat. Это дает длину семь. Мы начали с девяти, избавились от трех символов и добавили завершающую нормализованную новую строку.

В строке 21 мы просим Java удалить четыре пробела из тех же трех строк. Поскольку четырех пробельных символов нет, Java делает все возможное. Одиночный пробел удаляется перед a и c. Оба пробела удаляются перед b. Длина шесть должна иметь смысл здесь; мы удалили здесь на один символ больше, чем в строке 20.
or
В строке 21 мы просим Java удалить четыре пробельных символа из тех же трех строк. Поскольку в нем нет четырех пробельных символов, Java делает все возможное. Единственный пробел удаляется перед a и c. Оба пробела удаляются перед b. Длина в шесть должна иметь смысл здесь; мы удалили здесь на один символ больше, чем в строке 20.

Наконец, в строке 22 используется метод stripIndent(). Во всех строках есть хотя бы один пробельный символ. Поскольку не все они содержат два пробельных символа, метод избавляется только от одного символа в строке. Так как stripIndent() не добавляет новую строку, длина равна шести, что на три меньше исходных девяти.
or
Наконец, в строке 22 используется метод stripIndent(). Все строки содержат по крайней мере один пробел. Поскольку не все они содержат два пробельных символа, метод избавляется только от одного символа в строке. Поскольку stripIndent() не добавляет новую строку, длина равна шести, что на три меньше, чем исходные девять.

### Перевод побегов (Translating Escapes)

Когда мы экранируем символы, мы используем одну обратную косую черту. Например, \t — это табуляция. Если мы не хотим 
такого поведения, мы добавляем ещё одну обратную косую черту, чтобы избежать обратной косой черты, поэтому 
\\t — буквальная строка \t. Метод translateEscapes() берет эти литералы и превращает их в эквивалентные экранированные 
символы. Сигнатура метода выглядит следующим образом:

```
public String translateEscapes()
```

В следующем коде показано, как использовать эти методы:

```
var str = "1\\t2";
System.out.println(str);                     // 1\t2
System.out.println(str.translateEscapes());  // 1 2
```

Первая строка выводит литеральную строку \t, потому что обратная косая черта экранирована. Вторая строка выводит 
фактическую вкладку, так как мы перевели escape. Этот метод можно использовать для управляющих последовательностей, 
таких как \t (табуляция), \n (новая строка), \s (пробел), \" (двойная кавычка) и \' (одинарная кавычка).

### Проверка пустых или незаполненных строк

Java предоставляет удобные методы для определения того, имеет ли строка нулевую длину или содержит только символы 
пробела. Сигнатуры методов следующие:

```
public boolean isEmpty()
public boolean isBlank()
```

В следующем коде показано, как использовать эти методы:

```
System.out.println(" ".isEmpty());  // false
System.out.println("".isEmpty());   // true
System.out.println(" ".isBlank());  // true
System.out.println("".isBlank());   // true
```

Первая строка выводит false, потому что строка не пуста; в нем есть пустое место. Вторая строка выводит true, потому 
что на этот раз в строке нет символов. Последние две строки выводят true, потому что нет никаких символов, кроме 
пробелов.

### Форматирование значений

Существуют методы форматирования строковых значений с использованием флагов форматирования. Два метода принимают строку формата в качестве параметра, а другой использует экземпляр для этого значения. Один из методов использует Locale, о котором вы узнаете в главе 11.

Параметры метода используются для создания форматированной строки в одном вызове метода, а не с помощью множества 
операций форматирования и конкатенации. Они возвращают ссылку на экземпляр, для которого они вызываются, чтобы операции 
можно было связать вместе. Сигнатуры методов следующие:

```
public static String format(String format, Object args...)
public static String format(Locale loc, String format, Object args...)
public String formatted(Object args...)
```

В следующем коде показано, как использовать эти методы:

```
var name = "Kate";
var orderId = 5;

// All print: Hello Kate, order 5 is ready
System.out.println("Hello " + name + ", order " + orderId + " is ready");
System.out.println(String.format("Hello %s, order %d is ready",
   name, orderId));
System.out.println("Hello %s, order %d is ready"
   .formatted(name, orderId));
```

В операциях format() и formatted() параметры вставляются и форматируются с помощью символов в том порядке, в котором 
они указаны в vararg. В таблице 4.2 перечислены те, которые вы должны знать для сдачи экзамена.

#### Таблица 4.2. - Распространенные символы форматирования

| Условное обозначение |                                   Описание                                   |  
|:--------------------:|:----------------------------------------------------------------------------:|
|          %s          |           Применяется к любому типу, обычно к строковым значениям            |                                     
|          %d          |         Применяется к целочисленным значениям, таким как int и long          |                                        
|          %f          |    Применяется к значениям с плавающей запятой, таким как float и double     |                                   
|          %n          | Вставляет разрыв строки, используя разделитель строк, зависящий от системы.  |

В следующем примере используются все четыре символа из таблицы 4.2:

```
var name = "James";
var score = 90.25;
var total = 100;
System.out.println("%s:%n Score: %f out of %d"
   .formatted(name, score, total));
```

При этом выводится следующее:

```
James:
   Score: 90.250000 out of 100
```

Смешивание типов данных может вызвать исключения во время выполнения. Например, следующее выдает исключение, поскольку 
число с плавающей запятой используется, когда ожидается целочисленное значение:

```
var str = "Food: %d tons".formatted(2.0);     // IllegalFormatConversionException
```

---

#### Использование format() с флагами

Помимо поддержки символов, Java также поддерживает необязательные флаги между % и символом. В предыдущем примере число 
с плавающей запятой было напечатано как 90,250000. По умолчанию %f отображает ровно шесть цифр после запятой.
Если вы хотите отображать только одну цифру после запятой, вы можете использовать %.1f вместо %f. Метод format() 
основан на округлении, а не на усечении при сокращении чисел. Например, 90.250000 будет отображаться как 90.3 
(а не 90.2) при передаче в format() с %.1f.

Метод format() также поддерживает две дополнительные функции. Вы можете указать общую длину выходных данных, используя 
число перед десятичным символом. По умолчанию метод заполнит пустое пространство пробелами. Вы также можете заполнить 
пустое пространство нулями, поместив один ноль перед десятичным символом. В следующих примерах используются квадратные 
скобки [], чтобы показать начало/конец форматированного значения:

```
var pi = 3.14159265359;
System.out.format("[%f]",pi);        // [3.141593]
System.out.format("[%12.8f]",pi);    // [ 3.14159265]
System.out.format("[%012f]",pi);     // [00003.141593]
System.out.format("[%12.2f]",pi);    // [ 3.14]
System.out.format("[%.3f]",pi);      // [3.142]
```

Метод format() поддерживает множество других символов и флагов. Вам не нужно знать ни одного из них для экзамена, кроме 
того(тех), что мы уже обсуждали.

---

### Цепочка методов

