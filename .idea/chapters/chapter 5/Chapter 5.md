# Методы

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Создавать классы и записи, а также определять и использовать: экземпляры объекта, статические поля и методы,
конструкторы, а также экземпляры объекта и статические инициализаторы
+ Реализовывать перегрузку, включая методы vararg

---

В предыдущих главах вы узнали, как писать фрагменты кода, не особо задумываясь о методах, которые содержат этот код.
В этой главе вы подробно изучите методы, включая модификаторы, аргументы, varargs, перегрузку и автоупаковку.
Многие из этих основных принципов, такие как доступ и статические модификаторы, применимы к классам и другим типам в 
остальной части книги. Если у вас возникли трудности, возможно, вам стоит прочитать эту главу дважды!

## Создание методов

В каждой интересной Java-программе, которую мы видели, был метод main(). Вы можете написать и другие методы. Например, 
вы можете написать базовый метод для сна, как показано на рис. 5.1.

#### Рис. 5.1 - Объявление метода


Это называется _объявлением метода_, в котором указывается вся информация, необходимая для вызова метода. Здесь много 
частей, и мы рассмотрим каждую из них более подробно. Две части — имя метода и список параметров — называются _сигнатурой_
_метода_. Сигнатура метода содержит инструкции о том, как вызывающие пользователи могут ссылаться на этот метод.
Сигнатура метода не включает тип возвращаемого значения и модификаторы доступа, которые определяют, где можно ссылаться 
на метод.

Таблица 5.1 представляет собой краткую информацию об элементах объявления метода. Не волнуйтесь, если вам покажется, 
что информации слишком много — к тому времени, как вы закончите эту главу, все это будет сходиться воедино.

#### Таблица 5.1 - Элементы объявления метода на рис. 5.1

|          Элемент          | Значения в примере nap()    |              Обязательный?              |  
|:-------------------------:|:----------------------------|:---------------------------------------:|
|    Модификатор доступа    | public                      |                   Нет                   |                                     
| Опциональный спецификатор | final                       |                   Нет                   |                                        
|     Возвращаемый тип      | void                        |                   Да                    |                                   
|        Имя метода         | nap                         |                   Да                    |
|     Список параметров     | (int minutes)               |     Да, но могут быть пустые скобки     |
|     Сигнатура метода      | nap(int minutes)            |                   Да                    |
|     Список исключений     | throws InterruptedException |                   Нет                   |
|       Тело метода         | {<br/>// take a nap<br/>}   | Да, за исключением абстрактных методов  |

Чтобы вызвать этот метод, просто используйте сигнатуру метода и укажите значение int в скобках:

```
nap(10);
```

Давайте начнем с рассмотрения каждой из этих частей базового метода.

### Модификаторы доступа

Модификатор доступа определяет, из каких классов можно получить доступ к методу. Думайте об этом как о охраннике. 
Некоторые классы - хорошие друзья, некоторые - дальние родственники, а некоторые - совершенно незнакомые люди. 
Модификаторы доступа помогают обеспечить соблюдение того, когда этим компонентам разрешено взаимодействовать друг с 
другом. Java предлагает четыре варианта модификатора доступа:

**private** Модификатор _private_  означает, что метод может быть вызван только из этого же класса.

**Package Access** При доступе к пакету метод можно вызвать только из класса в том же пакете. Это сложно, потому что нет 
ключевого слова. Вы просто опускаете модификатор доступа. Пакетный доступ иногда называют пакетно-приватным или доступом 
по умолчанию (даже в этой книге!).

**protected** Модификатор protected означает, что метод может быть вызван только из класса в том же пакете или подклассе.

**public** Модификатор public означает, что метод может быть вызван из любого места.

_Для простоты мы в первую очередь рассмотрим модификаторы доступа, применяемые к методам и полям в этой главе. Правила 
для модификаторов доступа также применимы к классам и другим типам, о которых вы узнаете в главе 7 “За пределами 
классов", таким как интерфейсы, перечисления и записи._

Далее в этой главе мы рассмотрим значение различных модификаторов доступа. На данный момент просто научитесь определять 
допустимый синтаксис методов. Создатели экзамена любят обманывать вас, размещая элементы метода в неправильном порядке 
или используя неправильные значения.

Мы увидим практические примеры, когда будем рассматривать каждый из элементов метода в этой главе. Убедитесь, что вы 
понимаете, почему каждое из них является допустимым или недопустимым объявлением метода. Обратите внимание на 
модификаторы доступа, когда вы будете выяснять, что не так с теми, которые не компилируются при вставке в класс:

```
public class ParkTrip {
   public void skip1() {}
   default void skip2() {} // DOES NOT COMPILE
   void public skip3() {} // DOES NOT COMPILE
   void skip4() {}
}
```

Метод skip1() является допустимым объявлением с открытым доступом. Метод skip4() является допустимым объявлением с 
доступом к пакету. Метод skip2() не компилируется, потому что default не является допустимым модификатором доступа. 
Существует ключевое слово default, которое используется в операторах switch и интерфейсах, но default никогда не 
используется в качестве модификатора доступа. Метод skip3() не компилируется, поскольку модификатор доступа указан 
после типа возвращаемого значения.

### Опциональные спецификаторы

Существует ряд опциональных спецификаторов для методов, показанных в таблице 5.2. В отличие от модификаторов доступа, 
вы можете использовать несколько спецификаторов в одном и том же методе (хотя не все комбинации допустимы). Когда это 
произойдет, вы можете указать их в любом порядке. И поскольку эти спецификаторы являются необязательными, вам разрешено 
вообще не использовать ни один из них. Это означает, что в объявлении метода может быть ноль или более спецификаторов.

Как видно из таблицы 5.2, четыре модификатора метода рассматриваются в последующих главах, а последние два даже не 
входят в предмет экзамена (и редко используются в реальной жизни). В этой главе мы сосредоточимся на том, чтобы 
познакомить вас с этими модификаторами. Для их использования часто требуется гораздо больше правил.

#### Таблица 5.2 - Опциональные спецификаторы для методов

| Модификатор  |                                                    Описание                                                    | Глава охвачена |  
|:------------:|:--------------------------------------------------------------------------------------------------------------:|:--------------:|
|    static    |                           Указывает, что метод является членом объекта общего класса                           |    Глава 5     |                                     
|   abstract   |                 Используется в абстрактном классе или интерфейсе, когда тело метода исключено.                 |    Глава 6     |                                        
|    final     |                          Указывает, что метод не может быть переопределен в подклассе                          |    Глава 6     |                                   
|   default    | Используется в интерфейсе для предоставления реализации метода по умолчанию для классов, реализующих интерфейс |    Глава 7     |
| synchronized |                                       Используется с многопоточным кодом                                       |    Глава 13    |
|    native    |               Используется при взаимодействии с кодом, написанным на другом языке, например C++.               |   За рамками   |
|  strictfp    |                            Используется для переноса вычислений с плавающей точкой                             |   За рамками   |

Хотя модификаторы доступа и опциональные спецификаторы могут отображаться в любом порядке, все они должны отображаться 
перед возвращаемым типом. На практике обычно сначала перечисляют модификатор доступа. Также, как вы узнаете в следующих 
главах, некоторые спецификаторы несовместимы друг с другом. Например, вы не можете объявить метод (или класс) 
одновременно final и abstract.

_Помните, что модификаторы доступа и опциональные спецификаторы могут быть перечислены в любом порядке, но как только 
указан возвращаемый тип, остальные части метода записываются в определенном порядке: имя, список параметров, 
список исключений, тело._

Опять же, пока просто сосредоточьтесь на синтаксисе. Вы понимаете, почему они компилируются или не компилируются?

```
public class Exercise {
   public void bike1() {}
   public final void bike2() {}
   public static final void bike3() {}
   public final static void bike4() {}
   public modifier void bike5() {} // DOES NOT COMPILE
   public void final bike6() {} // DOES NOT COMPILE
   final public void bike7() {}
}
```

Метод bike1() является допустимым объявлением без опционального спецификатора. Это нормально — в конце концов, это 
опционально. Метод bike2() является допустимым объявлением, с final в качестве опционального спецификатора. Методы 
bike3() и bike4() являются допустимыми объявлениями с как final, так и static в качестве опциональных спецификаторов.
Порядок этих двух ключевых слов не имеет значения. Метод bike5() не компилируется, поскольку modifier не является 
допустимым опциональным спецификатором. Метод bike6() не компилируется, поскольку необязательный спецификатор находится 
после возвращаемого типа.

Метод bike7() компилируется. Java позволяет указывать опциональные спецификаторы перед модификатором доступа. Это 
странный случай, и его не нужно знать для экзамена. Мы упоминаем об этом, чтобы вы не запутались во время практики.

### Возвращаемый тип

Следующий элемент в объявлении метода - это возвращаемый тип. Он должен отображаться после любых модификаторов доступа 
или опциональных спецификаторов и перед именем метода. Возвращаемый тип может быть действительным типом Java, таким как 
String или int. Если возвращаемый тип отсутствует, используется ключевое слово void. Этот специальный тип возврата 
происходит из английского языка: void означает без содержимого.

_Помните, что метод должен иметь возвращаемый тип. Если значение не возвращается, необходимо использовать ключевое 
слово void. Нельзя опускать тип возвращаемого значения._

При проверке возвращаемых типов вы также должны заглянуть внутрь тела метода. Методы с типом возвращаемого значения, 
отличным от void, должны иметь оператор return внутри тела метода. Этот оператор return должен включать в себя примитив 
или объект, который должен быть возвращен. Методы, возвращающие тип void, могут иметь оператор return без возвращаемого 
значения или полностью опускать оператор return. Думайте об операторе return в методе void как о методе, говорящем: 
«Я закончил!» и завершающий работу досрочно, например, следующий:

```
public void swim(int distance) {
   if(distance <= 0) {
      // Exit early, nothing to do!
      return;
   }
   System.out.print("Fish is swimming " + distance + " meters");
}
```

Готовы к примерам? Можете ли вы объяснить, почему эти методы компилируются или нет?

```
public class Hike {
   public void hike1() {}
   public void hike2() { return; }
   public String hike3() { return ""; }
   public String hike4() {}        // DOES NOT COMPILE
   public hike5() {}               // DOES NOT COMPILE
   public String int hike6() { }   // DOES NOT COMPILE
   String hike7(int a) {           // DOES NOT COMPILE
      if (1 < 2) return "orange";
   }
}
```

Поскольку возвращаемый тип метода hike1() — void, оператор return необязателен. В методе hike2() показан необязательный 
оператор return, который ничего не возвращает. Метод hike3() является допустимым объявлением с возвращаемым типом String 
и оператором возврата, который возвращает String. Метод hike4() не компилируется из-за отсутствия оператора return.
Метод hike5() не компилируется, так как отсутствует тип возвращаемого значения. Метод hike6() не компилируется, 
поскольку он пытается использовать два типа возвращаемых значений. Вы получаете только один тип возвращаемого значения.

Метод hike7() немного сложнее. Существует оператор return, но он не всегда выполняется. Несмотря на то, что 1 всегда 
меньше 2, компилятор не будет полностью оценивать оператор if и потребует оператор return, если это условие false. 
Как насчет этой модифицированной версии?

```
String hike8(int a) {
   if (1 < 2) return "orange";
   return "apple";                // COMPILER WARNING
}
```

Код компилируется, хотя компилятор выдаст предупреждение о недоступном коде (или мертвом коде). 
Это означает, что компилятор оказался достаточно умен, чтобы понять, что вы написали код, до которого невозможно 
добраться.

При возвращении значения оно должно быть присвоено возвращаемому типу. Можете ли вы определить, что не так с двумя из 
приведенных примеров?

```
public class Measurement {
 int getHeight1() {
    int temp = 9;
    return temp;
 }
 int getHeight2() {
    int temp = 9L;   // DOES NOT COMPILE
    return temp;
 }
 int getHeight3() {
    long temp = 9L;
    return temp;     // DOES NOT COMPILE
 }
}
```

Метод getHeight2() не компилируется, потому что вы не можете присвоить значение long типу int.
Метод getHeight3() не компилируется, потому что вы не можете вернуть long значение в виде int. 
Если вам это непонятно, вам следует вернуться к главе 2, «Операторы», и перечитать разделы, посвященные числовым типам 
и приведению типов.

### Имя метода

Имена методов подчиняются тем же правилам, которые мы применяли к именам переменных в главе 1, «Строительные блоки». 
Чтобы проверить, идентификатор может содержать только буквы, цифры, символы валюты или _. Кроме того, первый символ не 
может быть числом, а зарезервированные слова не допускаются. Наконец, один символ подчеркивания не допускается.

По соглашению методы начинаются со строчной буквы, но это не обязательно. Поскольку это обзор главы 1, мы можем сразу 
перейти к практике с некоторыми примерами:

```
public class BeachTrip {
   public void jog1() {}
   public void 2jog() {}  // DOES NOT COMPILE
   public jog3 void() {}  // DOES NOT COMPILE
   public void Jog_$() {}
   public _() {}          // DOES NOT COMPILE
   public void() {}       // DOES NOT COMPILE
}
```

Метод jog1() является допустимым объявлением с традиционным именем. Метод 2jog() не компилируется, поскольку 
идентификаторы не могут начинаться с цифр. Метод jog3() не компилируется, потому что имя метода стоит перед типом 
возвращаемого значения. Метод Jog_$() является допустимым объявлением. Хотя, конечно, не рекомендуется начинать имя 
метода с заглавной буквы и заканчивать знаком препинания, но это допустимо. Метод _ не разрешен, так как он состоит из 
одного символа подчеркивания. Последняя строка кода не компилируется, потому что отсутствует имя метода.

### Список параметров

Хотя список параметров является обязательным, но не обязательно, что он должен содержать какие-либо параметры. Это 
означает, что вы можете просто поставить пустую пару круглых скобок после имени метода следующим образом:

```
public class Sleep {
   void nap() {}
}
```

Если у вас есть несколько параметров, вы разделяете их запятой. Есть ещё пара правил для списка параметров, которые вы 
увидите, когда мы вскоре рассмотрим varargs. А пока давайте потренируемся смотреть на объявление метода с «обычными» 
параметрами:

```
public class PhysicalEducation {
   public void run1() {}
   public void run2 {}                // DOES NOT COMPILE
   public void run3(int a) {}
   public void run4(int a; int b) {}  // DOES NOT COMPILE
   public void run5(int a, int b) {}
}
```

Метод run1() является допустимым объявлением без каких-либо параметров. Метод run2() не компилируется, потому что в нем 
отсутствуют круглые скобки вокруг списка параметров. Метод run3() является допустимым объявлением с одним параметром. 
Метод run4() не компилируется, поскольку параметры разделены точкой с запятой, а не запятой. Точки с запятой 
предназначены для разделения операторов, а не для списков параметров. Метод run5() является допустимым объявлением с 
двумя параметрами.

### Cигнатура метода

Сигнатура метода, состоящая из имени метода и списка параметров, — это то, что Java использует для однозначного 
определения того, какой именно метод вы пытаетесь вызвать. Как только он определяет, какой метод вы пытаетесь вызвать, 
он определяет, разрешен ли вызов. Например, попытка доступа к private методу вне класса или присвоение возвращаемого 
значения метода void переменной int приводит к ошибкам компилятора. Однако ни одна из этих ошибок компилятора не 
связана с сигнатурой метода.

Важно отметить, что имена параметров в сигнатуре метода не используются как часть сигнатуры метода. Список параметров 
содержит информацию о типах параметров и их порядке. Например, следующие два метода имеют одинаковую сигнатуру:

```
public class Trip {
   public void visitZoo(String name, int waitTime) {}
   public void visitZoo(String attraction, int rainFall) {}  // DOES NOT COMPILE
}
```

Несмотря на разные имена параметров, эти два метода имеют одинаковую сигнатуру и не могут быть объявлены в одном классе. 
Однако изменение порядка типов параметров позволяет компилировать метод:

```
public class Trip {
   public void visitZoo(String name, int waitTime) {}
   public void visitZoo(int rainFall, String attraction) {}
}
```

Мы рассмотрим эти правила более подробно, когда мы перейдем к перегрузке методов позже в этой главе.

### Список исключений

В Java код может указать, что что-то пошло не так, сгенерировав исключение. Мы рассмотрим это в главе 11, «Исключения и 
локализация». На данный момент вам просто нужно знать, что это необязательно, и где в объявлении метода он находится, 
если присутствует. Например, InterruptedException является типом Exception. В этом предложении вы можете перечислить 
столько типов исключений, сколько хотите, разделив их запятыми. Вот пример:

```
public class ZooMonorail {
 public void zeroExceptions() {}
 
 public void oneException() throws IllegalArgumentException {}
 
 public void twoExceptions() throws
    IllegalArgumentException, InterruptedException {}
}
```

Хотя список исключений является необязательным, он может потребоваться компилятору в зависимости от того, что появляется 
внутри тела метода. Вы узнаете больше об этом, а также о том, как методы, вызывающие их, могут потребоваться для 
обработки этих объявлений исключений, в главе 11.

### Тело метода

Заключительной частью объявления метода является тело метода. Тело метода — это просто блок кода. Он имеет фигурные 
скобки, которые содержат ноль или более операторов Java. Мы уже рассмотрели операторы Java в нескольких главах, так что 
вам должно быть понятно, почему они компилируются или нет:

```
public class Bird {
   public void fly1() {}
   public void fly2()         // DOES NOT COMPILE
   public void fly3(int a) { int name = 5; }
}
```

Метод fly1() является допустимым объявлением с пустым телом метода. Метод fly2() не компилируется, потому что в нем 
отсутствуют фигурные скобки вокруг пустого тела метода. Методы должны иметь тело, если только они не объявлены 
абстрактными. Мы рассмотрим абстрактные методы в главе 6 «Проектирование классов». Метод fly3() является допустимым 
объявлением с одним оператором в теле метода.

Поздравляем! Вы прошли через основы определения правильных и неправильных объявлений методов. Теперь можно углубиться 
в детали.

## Объявление локальных переменных и переменных экземпляра

Теперь, когда у нас есть методы, нам нужно немного поговорить о переменных, которые они могут создавать или использовать. 
Как вы, возможно, помните из главы 1, локальные переменные — это те, которые определены с помощью метода или блока, а переменные экземпляра — это те, которые определены как члены класса. Рассмотрим пример:

```
public class Lion {
   int hunger = 4;
   
   public int feedZooAnimals() {
      int snack = 10;     // Local variable
      if (snack > 4) {
         long dinnerTime = snack++;
         hunger--;
      }
      return snack;
   }
}
```

В классе Lion snack и dinnerTime являются локальными переменными, доступными только в соответствующих блоках кода, в то 
время как hunger является переменной экземпляра и создается в каждом объекте класса Lion.

Объект или значение, возвращаемые методом, могут быть доступны вне метода, но ссылка на переменную snack отсутствует. 
Имейте это в виду при чтении этой главы: все ссылки на локальные переменные уничтожаются после выполнения блока, но 
объекты, на которые они указывают, все еще могут быть доступны.

### Модификаторы локальных переменных

Есть только один модификатор, который может быть применен к локальной переменной: final. Легко запоминается, верно? При 
написании методов разработчики могут захотеть установить переменную, которая не изменяется в ходе выполнения метода. В 
этом примере кода попытка изменить значение или объект, на который ссылаются эти переменные, приводит к ошибке 
компилятора:

```
public void zooAnimalCheckup(boolean isWeekend) {
   final int rest;
   if(isWeekend) rest = 5; else rest = 20;
   System.out.print(rest);
   
   final var giraffe = new Animal();
   final int[] friends = new int[5];
   
   rest = 10;                // DOES NOT COMPILE
   giraffe = new Animal();   // DOES NOT COMPILE
   friends = null;           // DOES NOT COMPILE
}
```

Как показано с переменной rest, нам не нужно присваивать значение при объявлении переменной final. Правило только в том,
что ему должно быть присвоено значение, прежде чем его можно будет использовать. Мы даже можем использовать var и final 
вместе. Сравните это со следующим примером:

```
public void zooAnimalCheckup(boolean isWeekend) {
   final int rest;
   if(isWeekend) rest = 5;
   System.out.print(rest);   // DOES NOT COMPILE
}
```

Переменной rest могло не быть присвоено значение, например, если isWeekend равно false. Поскольку компилятор не 
позволяет использовать локальные переменные, которым не было присвоено значение, код не компилируется.

Означает ли использование модификатора final, что мы не можем изменять данные? Нет. Атрибут final относится только к 
ссылке на переменную; содержимое можно свободно изменять (при условии, что объект не является неизменяемым).

```
public void zooAnimalCheckup() {
   final int rest = 5;
   final Animal giraffe = new Animal();
   final int[] friends = new int[5];
   
   giraffe.setName("George");
   friends[2] = 2;
}
```

Переменная rest является примитивом, поэтому это просто значение, которое не может быть изменено. С другой стороны, 
содержимое переменных giraffe и friends может быть свободно изменено, при условии, что переменные не переназначены.

_Хотя это может показаться неочевидным, пометка локальной переменной final часто является хорошей практикой. Например, 
у вас может быть сложный метод, в котором на переменную ссылаются десятки раз. Было бы действительно плохо, если бы 
кто-то пришел и переназначил переменную в середине метода. Использование атрибута final похоже на отправку сообщения 
другим разработчикам, чтобы они оставили переменную в покое!_

### Эффективные final переменные
































