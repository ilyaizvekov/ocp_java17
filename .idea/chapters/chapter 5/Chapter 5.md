# Методы

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Создавать классы и записи, а также определять и использовать: экземпляры объекта, статические поля и методы,
конструкторы, а также экземпляры объекта и статические инициализаторы
+ Реализовывать перегрузку, включая методы vararg

---

В предыдущих главах вы узнали, как писать фрагменты кода, не особо задумываясь о методах, которые содержат этот код.
В этой главе вы подробно изучите методы, включая модификаторы, аргументы, varargs, перегрузку и автоупаковку.
Многие из этих основных принципов, такие как доступ и статические модификаторы, применимы к классам и другим типам в 
остальной части книги. Если у вас возникли трудности, возможно, вам стоит прочитать эту главу дважды!

## Создание методов

В каждой интересной Java-программе, которую мы видели, был метод main(). Вы можете написать и другие методы. Например, 
вы можете написать базовый метод для сна, как показано на рис. 5.1.

#### Рис. 5.1 - Объявление метода


Это называется _объявлением метода_, в котором указывается вся информация, необходимая для вызова метода. Здесь много 
частей, и мы рассмотрим каждую из них более подробно. Две части — имя метода и список параметров — называются _сигнатурой_
_метода_. Сигнатура метода содержит инструкции о том, как вызывающие пользователи могут ссылаться на этот метод.
Сигнатура метода не включает тип возвращаемого значения и модификаторы доступа, которые определяют, где можно ссылаться 
на метод.

Таблица 5.1 представляет собой краткую информацию об элементах объявления метода. Не волнуйтесь, если вам покажется, 
что информации слишком много — к тому времени, как вы закончите эту главу, все это будет сходиться воедино.

#### Таблица 5.1 - Элементы объявления метода на рис. 5.1

|          Элемент          | Значения в примере nap()    |              Обязательный?              |  
|:-------------------------:|:----------------------------|:---------------------------------------:|
|    Модификатор доступа    | public                      |                   Нет                   |                                     
| Опциональный спецификатор | final                       |                   Нет                   |                                        
|     Возвращаемый тип      | void                        |                   Да                    |                                   
|        Имя метода         | nap                         |                   Да                    |
|     Список параметров     | (int minutes)               |     Да, но могут быть пустые скобки     |
|     Сигнатура метода      | nap(int minutes)            |                   Да                    |
|     Список исключений     | throws InterruptedException |                   Нет                   |
|       Тело метода         | {<br/>// take a nap<br/>}   | Да, за исключением абстрактных методов  |

Чтобы вызвать этот метод, просто используйте сигнатуру метода и укажите значение int в скобках:

```
nap(10);
```

Давайте начнем с рассмотрения каждой из этих частей базового метода.

### Модификаторы доступа

Модификатор доступа определяет, из каких классов можно получить доступ к методу. Думайте об этом как о охраннике. 
Некоторые классы - хорошие друзья, некоторые - дальние родственники, а некоторые - совершенно незнакомые люди. 
Модификаторы доступа помогают обеспечить соблюдение того, когда этим компонентам разрешено взаимодействовать друг с 
другом. Java предлагает четыре варианта модификатора доступа:

**private** Модификатор _private_  означает, что метод может быть вызван только из этого же класса.

**Package Access** При доступе к пакету метод можно вызвать только из класса в том же пакете. Это сложно, потому что нет 
ключевого слова. Вы просто опускаете модификатор доступа. Пакетный доступ иногда называют пакетно-приватным или доступом 
по умолчанию (даже в этой книге!).

**protected** Модификатор protected означает, что метод может быть вызван только из класса в том же пакете или подклассе.

**public** Модификатор public означает, что метод может быть вызван из любого места.

_Для простоты мы в первую очередь рассмотрим модификаторы доступа, применяемые к методам и полям в этой главе. Правила 
для модификаторов доступа также применимы к классам и другим типам, о которых вы узнаете в главе 7 “За пределами 
классов", таким как интерфейсы, перечисления и записи._

Далее в этой главе мы рассмотрим значение различных модификаторов доступа. На данный момент просто научитесь определять 
допустимый синтаксис методов. Создатели экзамена любят обманывать вас, размещая элементы метода в неправильном порядке 
или используя неправильные значения.

Мы увидим практические примеры, когда будем рассматривать каждый из элементов метода в этой главе. Убедитесь, что вы 
понимаете, почему каждое из них является допустимым или недопустимым объявлением метода. Обратите внимание на 
модификаторы доступа, когда вы будете выяснять, что не так с теми, которые не компилируются при вставке в класс:

```
public class ParkTrip {
   public void skip1() {}
   default void skip2() {} // DOES NOT COMPILE
   void public skip3() {} // DOES NOT COMPILE
   void skip4() {}
}
```

Метод skip1() является допустимым объявлением с открытым доступом. Метод skip4() является допустимым объявлением с 
доступом к пакету. Метод skip2() не компилируется, потому что default не является допустимым модификатором доступа. 
Существует ключевое слово default, которое используется в операторах switch и интерфейсах, но default никогда не 
используется в качестве модификатора доступа. Метод skip3() не компилируется, поскольку модификатор доступа указан 
после типа возвращаемого значения.

### Опциональные спецификаторы

Существует ряд опциональных спецификаторов для методов, показанных в таблице 5.2. В отличие от модификаторов доступа, 
вы можете использовать несколько спецификаторов в одном и том же методе (хотя не все комбинации допустимы). Когда это 
произойдет, вы можете указать их в любом порядке. И поскольку эти спецификаторы являются необязательными, вам разрешено 
вообще не использовать ни один из них. Это означает, что в объявлении метода может быть ноль или более спецификаторов.

Как видно из таблицы 5.2, четыре модификатора метода рассматриваются в последующих главах, а последние два даже не 
входят в предмет экзамена (и редко используются в реальной жизни). В этой главе мы сосредоточимся на том, чтобы 
познакомить вас с этими модификаторами. Для их использования часто требуется гораздо больше правил.

#### Таблица 5.2 - Опциональные спецификаторы для методов

| Модификатор  |                                                    Описание                                                    | Глава охвачена |  
|:------------:|:--------------------------------------------------------------------------------------------------------------:|:--------------:|
|    static    |                           Указывает, что метод является членом объекта общего класса                           |    Глава 5     |                                     
|   abstract   |                 Используется в абстрактном классе или интерфейсе, когда тело метода исключено.                 |    Глава 6     |                                        
|    final     |                          Указывает, что метод не может быть переопределен в подклассе                          |    Глава 6     |                                   
|   default    | Используется в интерфейсе для предоставления реализации метода по умолчанию для классов, реализующих интерфейс |    Глава 7     |
| synchronized |                                       Используется с многопоточным кодом                                       |    Глава 13    |
|    native    |               Используется при взаимодействии с кодом, написанным на другом языке, например C++.               |   За рамками   |
|  strictfp    |                            Используется для переноса вычислений с плавающей точкой                             |   За рамками   |

Хотя модификаторы доступа и опциональные спецификаторы могут отображаться в любом порядке, все они должны отображаться 
перед возвращаемым типом. На практике обычно сначала перечисляют модификатор доступа. Также, как вы узнаете в следующих 
главах, некоторые спецификаторы несовместимы друг с другом. Например, вы не можете объявить метод (или класс) 
одновременно final и abstract.

_Помните, что модификаторы доступа и опциональные спецификаторы могут быть перечислены в любом порядке, но как только 
указан возвращаемый тип, остальные части метода записываются в определенном порядке: имя, список параметров, 
список исключений, тело._

Опять же, пока просто сосредоточьтесь на синтаксисе. Вы понимаете, почему они компилируются или не компилируются?

```
public class Exercise {
   public void bike1() {}
   public final void bike2() {}
   public static final void bike3() {}
   public final static void bike4() {}
   public modifier void bike5() {} // DOES NOT COMPILE
   public void final bike6() {} // DOES NOT COMPILE
   final public void bike7() {}
}
```

Метод bike1() является допустимым объявлением без опционального спецификатора. Это нормально — в конце концов, это 
опционально. Метод bike2() является допустимым объявлением, с final в качестве опционального спецификатора. Методы 
bike3() и bike4() являются допустимыми объявлениями с как final, так и static в качестве опциональных спецификаторов.
Порядок этих двух ключевых слов не имеет значения. Метод bike5() не компилируется, поскольку modifier не является 
допустимым опциональным спецификатором. Метод bike6() не компилируется, поскольку необязательный спецификатор находится 
после возвращаемого типа.

Метод bike7() компилируется. Java позволяет указывать опциональные спецификаторы перед модификатором доступа. Это 
странный случай, и его не нужно знать для экзамена. Мы упоминаем об этом, чтобы вы не запутались во время практики.

### Возвращаемый тип

Следующий элемент в объявлении метода - это возвращаемый тип. Он должен отображаться после любых модификаторов доступа 
или опциональных спецификаторов и перед именем метода. Возвращаемый тип может быть действительным типом Java, таким как 
String или int. Если возвращаемый тип отсутствует, используется ключевое слово void. Этот специальный тип возврата 
происходит из английского языка: void означает без содержимого.

_Помните, что метод должен иметь возвращаемый тип. Если значение не возвращается, необходимо использовать ключевое 
слово void. Нельзя опускать тип возвращаемого значения._

При проверке возвращаемых типов вы также должны заглянуть внутрь тела метода. Методы с типом возвращаемого значения, 
отличным от void, должны иметь оператор return внутри тела метода. Этот оператор return должен включать в себя примитив 
или объект, который должен быть возвращен. Методы, возвращающие тип void, могут иметь оператор return без возвращаемого 
значения или полностью опускать оператор return. Думайте об операторе return в методе void как о методе, говорящем: 
«Я закончил!» и завершающий работу досрочно, например, следующий:

```
public void swim(int distance) {
   if(distance <= 0) {
      // Exit early, nothing to do!
      return;
   }
   System.out.print("Fish is swimming " + distance + " meters");
}
```

Готовы к примерам? Можете ли вы объяснить, почему эти методы компилируются или нет?

```
public class Hike {
   public void hike1() {}
   public void hike2() { return; }
   public String hike3() { return ""; }
   public String hike4() {}        // DOES NOT COMPILE
   public hike5() {}               // DOES NOT COMPILE
   public String int hike6() { }   // DOES NOT COMPILE
   String hike7(int a) {           // DOES NOT COMPILE
      if (1 < 2) return "orange";
   }
}
```

Поскольку возвращаемый тип метода hike1() — void, оператор return необязателен. В методе hike2() показан необязательный 
оператор return, который ничего не возвращает. Метод hike3() является допустимым объявлением с возвращаемым типом String 
и оператором возврата, который возвращает String. Метод hike4() не компилируется из-за отсутствия оператора return.
Метод hike5() не компилируется, так как отсутствует тип возвращаемого значения. Метод hike6() не компилируется, 
поскольку он пытается использовать два типа возвращаемых значений. Вы получаете только один тип возвращаемого значения.

Метод hike7() немного сложнее. Существует оператор return, но он не всегда выполняется. Несмотря на то, что 1 всегда 
меньше 2, компилятор не будет полностью оценивать оператор if и потребует оператор return, если это условие false. 
Как насчет этой модифицированной версии?

```
String hike8(int a) {
   if (1 < 2) return "orange";
   return "apple";                // COMPILER WARNING
}
```

Код компилируется, хотя компилятор выдаст предупреждение о недоступном коде (или мертвом коде). 
Это означает, что компилятор оказался достаточно умен, чтобы понять, что вы написали код, до которого невозможно 
добраться.

При возвращении значения оно должно быть присвоено возвращаемому типу. Можете ли вы определить, что не так с двумя из 
приведенных примеров?

```
public class Measurement {
 int getHeight1() {
    int temp = 9;
    return temp;
 }
 int getHeight2() {
    int temp = 9L;   // DOES NOT COMPILE
    return temp;
 }
 int getHeight3() {
    long temp = 9L;
    return temp;     // DOES NOT COMPILE
 }
}
```

Метод getHeight2() не компилируется, потому что вы не можете присвоить значение long типу int.
Метод getHeight3() не компилируется, потому что вы не можете вернуть long значение в виде int. 
Если вам это непонятно, вам следует вернуться к главе 2, «Операторы», и перечитать разделы, посвященные числовым типам 
и приведению типов.

### Имя метода




















































