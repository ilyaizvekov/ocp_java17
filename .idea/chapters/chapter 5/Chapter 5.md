# Методы

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Создавать классы и записи, а также определять и использовать: экземпляры объекта, статические поля и методы,
конструкторы, а также экземпляры объекта и статические инициализаторы
+ Реализовывать перегрузку, включая методы vararg

---

В предыдущих главах вы узнали, как писать фрагменты кода, не особо задумываясь о методах, которые содержат этот код.
В этой главе вы подробно изучите методы, включая модификаторы, аргументы, varargs, перегрузку и автоупаковку.
Многие из этих основных принципов, такие как доступ и статические модификаторы, применимы к классам и другим типам в 
остальной части книги. Если у вас возникли трудности, возможно, вам стоит прочитать эту главу дважды!

## Создание методов

В каждой интересной Java-программе, которую мы видели, был метод main(). Вы можете написать и другие методы. Например, 
вы можете написать базовый метод для сна, как показано на рис. 5.1.

#### Рис. 5.1 - Объявление метода


Это называется _объявлением метода_, в котором указывается вся информация, необходимая для вызова метода. Здесь много 
частей, и мы рассмотрим каждую из них более подробно. Две части — имя метода и список параметров — называются _сигнатурой_
_метода_. Сигнатура метода содержит инструкции о том, как вызывающие пользователи могут ссылаться на этот метод.
Сигнатура метода не включает тип возвращаемого значения и модификаторы доступа, которые определяют, где можно ссылаться 
на метод.

Таблица 5.1 представляет собой краткую информацию об элементах объявления метода. Не волнуйтесь, если вам покажется, 
что информации слишком много — к тому времени, как вы закончите эту главу, все это будет сходиться воедино.

#### Таблица 5.1 - Элементы объявления метода на рис. 5.1

|          Элемент          | Значения в примере nap()    |              Обязательный?              |  
|:-------------------------:|:----------------------------|:---------------------------------------:|
|    Модификатор доступа    | public                      |                   Нет                   |                                     
| Опциональный спецификатор | final                       |                   Нет                   |                                        
|     Возвращаемый тип      | void                        |                   Да                    |                                   
|        Имя метода         | nap                         |                   Да                    |
|     Список параметров     | (int minutes)               |     Да, но могут быть пустые скобки     |
|     Сигнатура метода      | nap(int minutes)            |                   Да                    |
|     Список исключений     | throws InterruptedException |                   Нет                   |
|       Тело метода         | {<br/>// take a nap<br/>}   | Да, за исключением абстрактных методов  |

Чтобы вызвать этот метод, просто используйте сигнатуру метода и укажите значение int в скобках:

```
nap(10);
```

Давайте начнем с рассмотрения каждой из этих частей базового метода.

### Модификаторы доступа

Модификатор доступа определяет, из каких классов можно получить доступ к методу. Думайте об этом как о охраннике. 
Некоторые классы - хорошие друзья, некоторые - дальние родственники, а некоторые - совершенно незнакомые люди. 
Модификаторы доступа помогают обеспечить соблюдение того, когда этим компонентам разрешено взаимодействовать друг с 
другом. Java предлагает четыре варианта модификатора доступа:

**private** Модификатор _private_  означает, что метод может быть вызван только из этого же класса.

**Package Access** При доступе к пакету метод можно вызвать только из класса в том же пакете. Это сложно, потому что нет 
ключевого слова. Вы просто опускаете модификатор доступа. Пакетный доступ иногда называют пакетно-приватным или доступом 
по умолчанию (даже в этой книге!).

**protected** Модификатор protected означает, что метод может быть вызван только из класса в том же пакете или подклассе.

**public** Модификатор public означает, что метод может быть вызван из любого места.

_Для простоты мы в первую очередь рассмотрим модификаторы доступа, применяемые к методам и полям в этой главе. Правила 
для модификаторов доступа также применимы к классам и другим типам, о которых вы узнаете в главе 7 “За пределами 
классов", таким как интерфейсы, перечисления и записи._

Далее в этой главе мы рассмотрим значение различных модификаторов доступа. На данный момент просто научитесь определять 
допустимый синтаксис методов. Создатели экзамена любят обманывать вас, размещая элементы метода в неправильном порядке 
или используя неправильные значения.

Мы увидим практические примеры, когда будем рассматривать каждый из элементов метода в этой главе. Убедитесь, что вы 
понимаете, почему каждое из них является допустимым или недопустимым объявлением метода. Обратите внимание на 
модификаторы доступа, когда вы будете выяснять, что не так с теми, которые не компилируются при вставке в класс:

```
public class ParkTrip {
   public void skip1() {}
   default void skip2() {} // DOES NOT COMPILE
   void public skip3() {} // DOES NOT COMPILE
   void skip4() {}
}
```

Метод skip1() является допустимым объявлением с открытым доступом. Метод skip4() является допустимым объявлением с 
доступом к пакету. Метод skip2() не компилируется, потому что default не является допустимым модификатором доступа. 
Существует ключевое слово default, которое используется в операторах switch и интерфейсах, но default никогда не 
используется в качестве модификатора доступа. Метод skip3() не компилируется, поскольку модификатор доступа указан 
после типа возвращаемого значения.

### Опциональные спецификаторы

Существует ряд опциональных спецификаторов для методов, показанных в таблице 5.2. В отличие от модификаторов доступа, 
вы можете использовать несколько спецификаторов в одном и том же методе (хотя не все комбинации допустимы). Когда это 
произойдет, вы можете указать их в любом порядке. И поскольку эти спецификаторы являются необязательными, вам разрешено 
вообще не использовать ни один из них. Это означает, что в объявлении метода может быть ноль или более спецификаторов.

Как видно из таблицы 5.2, четыре модификатора метода рассматриваются в последующих главах, а последние два даже не 
входят в предмет экзамена (и редко используются в реальной жизни). В этой главе мы сосредоточимся на том, чтобы 
познакомить вас с этими модификаторами. Для их использования часто требуется гораздо больше правил.

#### Таблица 5.2 - Опциональные спецификаторы для методов

| Модификатор  |                                                    Описание                                                    | Глава охвачена |  
|:------------:|:--------------------------------------------------------------------------------------------------------------:|:--------------:|
|    static    |                           Указывает, что метод является членом объекта общего класса                           |    Глава 5     |                                     
|   abstract   |                 Используется в абстрактном классе или интерфейсе, когда тело метода исключено.                 |    Глава 6     |                                        
|    final     |                          Указывает, что метод не может быть переопределен в подклассе                          |    Глава 6     |                                   
|   default    | Используется в интерфейсе для предоставления реализации метода по умолчанию для классов, реализующих интерфейс |    Глава 7     |
| synchronized |                                       Используется с многопоточным кодом                                       |    Глава 13    |
|    native    |               Используется при взаимодействии с кодом, написанным на другом языке, например C++.               |   За рамками   |
|  strictfp    |                            Используется для переноса вычислений с плавающей точкой                             |   За рамками   |

Хотя модификаторы доступа и опциональные спецификаторы могут отображаться в любом порядке, все они должны отображаться 
перед возвращаемым типом. На практике обычно сначала перечисляют модификатор доступа. Также, как вы узнаете в следующих 
главах, некоторые спецификаторы несовместимы друг с другом. Например, вы не можете объявить метод (или класс) 
одновременно final и abstract.

_Помните, что модификаторы доступа и опциональные спецификаторы могут быть перечислены в любом порядке, но как только 
указан возвращаемый тип, остальные части метода записываются в определенном порядке: имя, список параметров, 
список исключений, тело._

Опять же, пока просто сосредоточьтесь на синтаксисе. Вы понимаете, почему они компилируются или не компилируются?

```
public class Exercise {
   public void bike1() {}
   public final void bike2() {}
   public static final void bike3() {}
   public final static void bike4() {}
   public modifier void bike5() {} // DOES NOT COMPILE
   public void final bike6() {} // DOES NOT COMPILE
   final public void bike7() {}
}
```

Метод bike1() является допустимым объявлением без опционального спецификатора. Это нормально — в конце концов, это 
опционально. Метод bike2() является допустимым объявлением, с final в качестве опционального спецификатора. Методы 
bike3() и bike4() являются допустимыми объявлениями с как final, так и static в качестве опциональных спецификаторов.
Порядок этих двух ключевых слов не имеет значения. Метод bike5() не компилируется, поскольку modifier не является 
допустимым опциональным спецификатором. Метод bike6() не компилируется, поскольку необязательный спецификатор находится 
после возвращаемого типа.

Метод bike7() компилируется. Java позволяет указывать опциональные спецификаторы перед модификатором доступа. Это 
странный случай, и его не нужно знать для экзамена. Мы упоминаем об этом, чтобы вы не запутались во время практики.

### Возвращаемый тип

Следующий элемент в объявлении метода - это возвращаемый тип. Он должен отображаться после любых модификаторов доступа 
или опциональных спецификаторов и перед именем метода. Возвращаемый тип может быть действительным типом Java, таким как 
String или int. Если возвращаемый тип отсутствует, используется ключевое слово void. Этот специальный тип возврата 
происходит из английского языка: void означает без содержимого.

_Помните, что метод должен иметь возвращаемый тип. Если значение не возвращается, необходимо использовать ключевое 
слово void. Нельзя опускать тип возвращаемого значения._

При проверке возвращаемых типов вы также должны заглянуть внутрь тела метода. Методы с типом возвращаемого значения, 
отличным от void, должны иметь оператор return внутри тела метода. Этот оператор return должен включать в себя примитив 
или объект, который должен быть возвращен. Методы, возвращающие тип void, могут иметь оператор return без возвращаемого 
значения или полностью опускать оператор return. Думайте об операторе return в методе void как о методе, говорящем: 
«Я закончил!» и завершающий работу досрочно, например, следующий:

```
public void swim(int distance) {
   if(distance <= 0) {
      // Exit early, nothing to do!
      return;
   }
   System.out.print("Fish is swimming " + distance + " meters");
}
```

Готовы к примерам? Можете ли вы объяснить, почему эти методы компилируются или нет?

```
public class Hike {
   public void hike1() {}
   public void hike2() { return; }
   public String hike3() { return ""; }
   public String hike4() {}        // DOES NOT COMPILE
   public hike5() {}               // DOES NOT COMPILE
   public String int hike6() { }   // DOES NOT COMPILE
   String hike7(int a) {           // DOES NOT COMPILE
      if (1 < 2) return "orange";
   }
}
```

Поскольку возвращаемый тип метода hike1() — void, оператор return необязателен. В методе hike2() показан необязательный 
оператор return, который ничего не возвращает. Метод hike3() является допустимым объявлением с возвращаемым типом String 
и оператором возврата, который возвращает String. Метод hike4() не компилируется из-за отсутствия оператора return.
Метод hike5() не компилируется, так как отсутствует тип возвращаемого значения. Метод hike6() не компилируется, 
поскольку он пытается использовать два типа возвращаемых значений. Вы получаете только один тип возвращаемого значения.

Метод hike7() немного сложнее. Существует оператор return, но он не всегда выполняется. Несмотря на то, что 1 всегда 
меньше 2, компилятор не будет полностью оценивать оператор if и потребует оператор return, если это условие false. 
Как насчет этой модифицированной версии?

```
String hike8(int a) {
   if (1 < 2) return "orange";
   return "apple";                // COMPILER WARNING
}
```

Код компилируется, хотя компилятор выдаст предупреждение о недоступном коде (или мертвом коде). 
Это означает, что компилятор оказался достаточно умен, чтобы понять, что вы написали код, до которого невозможно 
добраться.

При возвращении значения оно должно быть присвоено возвращаемому типу. Можете ли вы определить, что не так с двумя из 
приведенных примеров?

```
public class Measurement {
   int getHeight1() {
      int temp = 9;
      return temp;
   }
   int getHeight2() {
      int temp = 9L;   // DOES NOT COMPILE
      return temp;
   }
   int getHeight3() {
      long temp = 9L;
      return temp;     // DOES NOT COMPILE
   }
}
```

Метод getHeight2() не компилируется, потому что вы не можете присвоить значение long типу int.
Метод getHeight3() не компилируется, потому что вы не можете вернуть long значение в виде int. 
Если вам это непонятно, вам следует вернуться к главе 2, «Операторы», и перечитать разделы, посвященные числовым типам 
и приведению типов.

### Имя метода

Имена методов подчиняются тем же правилам, которые мы применяли к именам переменных в главе 1, «Строительные блоки». 
Чтобы проверить, идентификатор может содержать только буквы, цифры, символы валюты или _. Кроме того, первый символ не 
может быть числом, а зарезервированные слова не допускаются. Наконец, один символ подчеркивания не допускается.

По соглашению методы начинаются со строчной буквы, но это не обязательно. Поскольку это обзор главы 1, мы можем сразу 
перейти к практике с некоторыми примерами:

```
public class BeachTrip {
   public void jog1() {}
   public void 2jog() {}  // DOES NOT COMPILE
   public jog3 void() {}  // DOES NOT COMPILE
   public void Jog_$() {}
   public _() {}          // DOES NOT COMPILE
   public void() {}       // DOES NOT COMPILE
}
```

Метод jog1() является допустимым объявлением с традиционным именем. Метод 2jog() не компилируется, поскольку 
идентификаторы не могут начинаться с цифр. Метод jog3() не компилируется, потому что имя метода стоит перед типом 
возвращаемого значения. Метод Jog_$() является допустимым объявлением. Хотя, конечно, не рекомендуется начинать имя 
метода с заглавной буквы и заканчивать знаком препинания, но это допустимо. Метод _ не разрешен, так как он состоит из 
одного символа подчеркивания. Последняя строка кода не компилируется, потому что отсутствует имя метода.

### Список параметров

Хотя список параметров является обязательным, но не обязательно, что он должен содержать какие-либо параметры. Это 
означает, что вы можете просто поставить пустую пару круглых скобок после имени метода следующим образом:

```
public class Sleep {
   void nap() {}
}
```

Если у вас есть несколько параметров, вы разделяете их запятой. Есть ещё пара правил для списка параметров, которые вы 
увидите, когда мы вскоре рассмотрим varargs. А пока давайте потренируемся смотреть на объявление метода с «обычными» 
параметрами:

```
public class PhysicalEducation {
   public void run1() {}
   public void run2 {}                // DOES NOT COMPILE
   public void run3(int a) {}
   public void run4(int a; int b) {}  // DOES NOT COMPILE
   public void run5(int a, int b) {}
}
```

Метод run1() является допустимым объявлением без каких-либо параметров. Метод run2() не компилируется, потому что в нем 
отсутствуют круглые скобки вокруг списка параметров. Метод run3() является допустимым объявлением с одним параметром. 
Метод run4() не компилируется, поскольку параметры разделены точкой с запятой, а не запятой. Точки с запятой 
предназначены для разделения операторов, а не для списков параметров. Метод run5() является допустимым объявлением с 
двумя параметрами.

### Cигнатура метода

Сигнатура метода, состоящая из имени метода и списка параметров, — это то, что Java использует для однозначного 
определения того, какой именно метод вы пытаетесь вызвать. Как только он определяет, какой метод вы пытаетесь вызвать, 
он определяет, разрешен ли вызов. Например, попытка доступа к private методу вне класса или присвоение возвращаемого 
значения метода void переменной int приводит к ошибкам компилятора. Однако ни одна из этих ошибок компилятора не 
связана с сигнатурой метода.

Важно отметить, что имена параметров в сигнатуре метода не используются как часть сигнатуры метода. Список параметров 
содержит информацию о типах параметров и их порядке. Например, следующие два метода имеют одинаковую сигнатуру:

```
public class Trip {
   public void visitZoo(String name, int waitTime) {}
   public void visitZoo(String attraction, int rainFall) {}  // DOES NOT COMPILE
}
```

Несмотря на разные имена параметров, эти два метода имеют одинаковую сигнатуру и не могут быть объявлены в одном классе. 
Однако изменение порядка типов параметров позволяет компилировать метод:

```
public class Trip {
   public void visitZoo(String name, int waitTime) {}
   public void visitZoo(int rainFall, String attraction) {}
}
```

Мы рассмотрим эти правила более подробно, когда мы перейдем к перегрузке методов позже в этой главе.

### Список исключений

В Java код может указать, что что-то пошло не так, сгенерировав исключение. Мы рассмотрим это в главе 11, «Исключения и 
локализация». На данный момент вам просто нужно знать, что это необязательно, и где в объявлении метода он находится, 
если присутствует. Например, InterruptedException является типом Exception. В этом предложении вы можете перечислить 
столько типов исключений, сколько хотите, разделив их запятыми. Вот пример:

```
public class ZooMonorail {
 public void zeroExceptions() {}
 
 public void oneException() throws IllegalArgumentException {}
 
 public void twoExceptions() throws
    IllegalArgumentException, InterruptedException {}
}
```

Хотя список исключений является необязательным, он может потребоваться компилятору в зависимости от того, что появляется 
внутри тела метода. Вы узнаете больше об этом, а также о том, как методы, вызывающие их, могут потребоваться для 
обработки этих объявлений исключений, в главе 11.

### Тело метода

Заключительной частью объявления метода является тело метода. Тело метода — это просто блок кода. Он имеет фигурные 
скобки, которые содержат ноль или более операторов Java. Мы уже рассмотрели операторы Java в нескольких главах, так что 
вам должно быть понятно, почему они компилируются или нет:

```
public class Bird {
   public void fly1() {}
   public void fly2()         // DOES NOT COMPILE
   public void fly3(int a) { int name = 5; }
}
```

Метод fly1() является допустимым объявлением с пустым телом метода. Метод fly2() не компилируется, потому что в нем 
отсутствуют фигурные скобки вокруг пустого тела метода. Методы должны иметь тело, если только они не объявлены 
абстрактными. Мы рассмотрим абстрактные методы в главе 6 «Проектирование классов». Метод fly3() является допустимым 
объявлением с одним оператором в теле метода.

Поздравляем! Вы прошли через основы определения правильных и неправильных объявлений методов. Теперь можно углубиться 
в детали.

## Объявление локальных переменных и переменных экземпляра

Теперь, когда у нас есть методы, нам нужно немного поговорить о переменных, которые они могут создавать или использовать. 
Как вы, возможно, помните из главы 1, локальные переменные — это те, которые определены с помощью метода или блока, а переменные экземпляра — это те, которые определены как члены класса. Рассмотрим пример:

```
public class Lion {
   int hunger = 4;
   
   public int feedZooAnimals() {
      int snack = 10;     // Local variable
      if (snack > 4) {
         long dinnerTime = snack++;
         hunger--;
      }
      return snack;
   }
}
```

В классе Lion snack и dinnerTime являются локальными переменными, доступными только в соответствующих блоках кода, в то 
время как hunger является переменной экземпляра и создается в каждом объекте класса Lion.

Объект или значение, возвращаемые методом, могут быть доступны вне метода, но ссылка на переменную snack отсутствует. 
Имейте это в виду при чтении этой главы: все ссылки на локальные переменные уничтожаются после выполнения блока, но 
объекты, на которые они указывают, все еще могут быть доступны.

### Модификаторы локальных переменных

Есть только один модификатор, который может быть применен к локальной переменной: final. Легко запоминается, верно? При 
написании методов разработчики могут захотеть установить переменную, которая не изменяется в ходе выполнения метода. В 
этом примере кода попытка изменить значение или объект, на который ссылаются эти переменные, приводит к ошибке 
компилятора:

```
public void zooAnimalCheckup(boolean isWeekend) {
   final int rest;
   if(isWeekend) rest = 5; else rest = 20;
   System.out.print(rest);
   
   final var giraffe = new Animal();
   final int[] friends = new int[5];
   
   rest = 10;                // DOES NOT COMPILE
   giraffe = new Animal();   // DOES NOT COMPILE
   friends = null;           // DOES NOT COMPILE
}
```

Как показано с переменной rest, нам не нужно присваивать значение при объявлении переменной final. Правило только в том,
что ему должно быть присвоено значение, прежде чем его можно будет использовать. Мы даже можем использовать var и final 
вместе. Сравните это со следующим примером:

```
public void zooAnimalCheckup(boolean isWeekend) {
   final int rest;
   if(isWeekend) rest = 5;
   System.out.print(rest);   // DOES NOT COMPILE
}
```

Переменной rest могло не быть присвоено значение, например, если isWeekend равно false. Поскольку компилятор не 
позволяет использовать локальные переменные, которым не было присвоено значение, код не компилируется.

Означает ли использование модификатора final, что мы не можем изменять данные? Нет. Атрибут final относится только к 
ссылке на переменную; содержимое можно свободно изменять (при условии, что объект не является неизменяемым).

```
public void zooAnimalCheckup() {
   final int rest = 5;
   final Animal giraffe = new Animal();
   final int[] friends = new int[5];
   
   giraffe.setName("George");
   friends[2] = 2;
}
```

Переменная rest является примитивом, поэтому это просто значение, которое не может быть изменено. С другой стороны, 
содержимое переменных giraffe и friends может быть свободно изменено, при условии, что переменные не переназначены.

_Хотя это может показаться неочевидным, пометка локальной переменной final часто является хорошей практикой. Например, 
у вас может быть сложный метод, в котором на переменную ссылаются десятки раз. Было бы действительно плохо, если бы 
кто-то пришел и переназначил переменную в середине метода. Использование атрибута final похоже на отправку сообщения 
другим разработчикам, чтобы они оставили переменную в покое!_

### Effectively final переменные

Effectively final локальная переменная - это та, которая не изменяется после её назначения. Это означает, что 
значение переменной не изменяется после её установки, независимо от того, помечено ли оно явно как final. Если 
вы не уверены, является ли локальная переменная  effectively final, просто добавьте ключевое слово final. Если код все 
ещё компилируется, переменная является  effectively final.

Учитывая это определение, какие из следующих переменных являются _ effectively final_?

```
11: public String zooFriends() {
12:    String name = "Harry the Hippo";
13:    var size = 10;
14:    boolean wet;
15:    if(size > 100) size++;
16:    name.substring(0);
17:    wet = true;
18:    return name;
19: }
```

Помните, что быстрая проверка effectively final заключается в том, чтобы просто добавить final к объявлению переменной 
и посмотреть, компилируется ли она. В этом примере name и wet являются effectively final и могут быть обновлены 
модификатором final, но не size. Переменной name присваивается значение в строке 12 и не переназначается.
Строка 16 создает значение, которое никогда не используется. Помните из главы 4, «Основные API», что строки неизменяемы.
Переменная size не является effectively final, поскольку ее можно увеличить в строке 15. Переменной wet присваивается 
значение только один раз, после чего она не изменяется.

---

### Effective Final Parameters

Вспомним из главы 1, что параметры метода и конструктора — это предварительно инициализированные локальные переменные. 
В контексте локальных переменных применяются те же правила, что и для final и effectively final. Это особенно важно в 
главе 7 и главе 8, «Лямбда-выражения и функциональные интерфейсы», поскольку локальные классы и лямбда-выражения, 
объявленные в методе, могут ссылаться только на локальные переменные, которые являются final или effectively final.

---

### Модификаторы переменных экземпляра

Подобно методам, переменные экземпляра могут использовать модификаторы доступа, такие как private, package, protected и 
public. Помните, что доступ к package обозначается отсутствием каких-либо модификаторов. В этой главе мы кратко 
рассмотрим каждый из различных модификаторов доступа. Переменные экземпляра также могут использовать опциональные 
спецификаторы, описанные в таблице 5.3.

#### Таблица 5.3 - Опциональные спецификаторы для переменных экземпляра

| Модификатор |                                                   Описание                                                   | Глава охвачена |  
|:-----------:|:------------------------------------------------------------------------------------------------------------:|:--------------:|
|    final    | Указывает, что переменная экземпляра должна быть инициализирована с каждым экземпляром класса ровно один раз |    Глава 5     |                                     
|  volatile   |              Указывает JVM, что значение в этой переменной может быть изменено другими потоками              |    Глава 13    |                                        
| transient   |      Используется для указания того, что переменная экземпляра не должна быть сериализована с классом        |    Глава 14    |                                   

Похоже, в этой главе нам нужно обсудить только final! Если переменная экземпляра помечена как final, то ей должно быть 
присвоено значение при ее объявлении или при создании экземпляра объекта. Однако, как и локальная конечная переменная, 
ей нельзя присвоить значение более одного раза. Следующий класс PolarBear демонстрирует эти свойства:

```
public class PolarBear {
   final int age = 10;
   final int fishEaten;
   final String name;
 
   { fishEaten = 10; }
 
   public PolarBear() {
      name = "Robert";
   }
}
```

Переменной age присваивается значение при её объявлении, а переменной fishEaten присваивается значение в инициализаторе 
экземпляра. Переменная name получает значение в конструкторе без аргументов. Невыполнение инициализации переменной 
экземпляра (или присвоение значения более одного раза) приведет к ошибке компилятора. Мы более подробно поговорим об 
инициализации переменных final, когда будем рассматривать конструкторы в следующей главе.

_В главе 1 мы показываем, что переменные экземпляра получают значения по умолчанию в зависимости от их типа, если они не 
заданы. Например, int получает значение по умолчанию 0, а ссылка на объект получает значение по умолчанию null. Однако 
компилятор не применяет значение по умолчанию к переменным final. final экземпляр объекта или final static переменная 
должны получить значение при объявлении или как часть инициализации._

## Работа с Varargs

Как упоминалось в главе 4, метод может использовать параметр varargs (переменный аргумент), как если бы он был массивом. 
Создание метода с параметром varargs немного сложнее. Фактически, вызов такого метода может вообще не использовать 
массив.

### Создание методов с Varargs

Существует ряд важных правил создания метода с параметром varargs.

**Правила создания метода с параметром Varargs**

1. Метод может иметь не более одного параметра varargs.
2. Если метод содержит параметр varargs, он должен быть последним параметром в списке.

Учитывая эти правила, можете ли вы определить, почему каждое из них компилируется или не компилируется? (Да, в этой 
главе много практики. Вы должны хорошо уметь определять допустимые и недопустимые методы для экзамена.)

```
public class VisitAttractions {
   public void walk1(int... steps) {}
   public void walk2(int start, int... steps) {}
   public void walk3(int... steps, int start) {}     // DOES NOT COMPILE
   public void walk4(int... start, int... steps) {}  // DOES NOT COMPILE
}
```

Метод walk1() является допустимым объявлением с одним параметром varargs. Метод walk2() является допустимым объявлением 
с одним параметром int и одним параметром varargs. Методы walk3() и walk4() не компилируются, потому что у них есть 
параметр varargs в не последней позиции.

### Вызов методов с Varargs

При вызове метода с параметром varargs у вас есть выбор. Вы можете передать массив, или вы можете перечислить элементы 
массива и позволить Java создать его за вас. Учитывая наш предыдущий метод walk1(), который принимает параметр varargs, 
мы можем вызвать его одним из двух способов:

```
// Передать массив
int[] data = new int[] {1, 2, 3};
walk1(data);

// Передать список значений
walk1(1,2,3);
```

Независимо от того, какой из них вы используете для вызова метода, метод получит массив, содержащий элементы. Мы можем 
подкрепить это следующим примером:

```
public void walk1(int... steps) {
   int[] step2 = steps;      // Не обязательно, но показывает шаги типа int[]
   System.out.print(step2.length);
}
```

Вы даже можете опустить значения varargs в вызове метода, и Java создаст для вас массив нулевой длины.

```
walk1();
```

### Доступ к элементам Vararg

Доступ к параметру varargs аналогичен доступу к массиву. Он использует индексацию массива. Пример:

```
16: public static void run(int... steps) {
17:    System.out.print(steps[1]);
18: }
19: public static void main(String[] args) {
20:    run(11, 77);   // 77
21: }
```

Строка 20 вызывает метод varargs с двумя параметрами. При вызове метода он видит массив размера 2. Поскольку индексы 
отсчитываются от нуля, печатается 77.

### Использование переменных Varargs с другими параметрами метода

Наконец! Вы можете сделать что-то другое, кроме как определить, допустимы ли объявления методов. Вместо этого вы можете 
просматривать вызовы методов. Можете ли вы понять, почему каждый вызов метода выводит то, что он делает? На данный 
момент вы можете игнорировать модификатор static в объявлении метода walkDog(); мы расскажем об этом позже в этой главе.

```
1: public class DogWalker {
2:    public static void walkDog(int start, int... steps) {
3:       System.out.println(steps.length);
4:    }
5:    public static void main(String[] args) {
6:       walkDog(1);                    // 0
7:       walkDog(1, 2);                 // 1
8:       walkDog(1, 2, 3);              // 2
9:       walkDog(1, new int[] {4, 5});  // 2
10: } }
```

Строка 6 передает 1 как start, но больше ничего. Это означает, что Java создает массив длиной 0 для steps.
Строка 7 передает 1 в качестве start и ещё одно значение. Java преобразует это единственное значение в массив длиной 1.
Строка 8 передает 1 в качестве start и ещё два значения. Java преобразует эти два значения в массив длиной 2.
Строка 9 передает 1 как start и массив длиной 2 непосредственно как steps.

Вы видели, что Java создаст пустой массив, если для vararg не будут переданы никакие параметры. Однако по-прежнему можно
передать null в явном виде. Следующий фрагмент компилируется:

```
walkDog(1, null);   // Triggers NullPointerException in walkDog()
```

Так как null не является int, Java рассматривает его как ссылку на массив, которая оказывается равной null.
Он просто передает объект массива null в функцию walkDog(). Затем метод walkDog() выдает исключение, потому что он 
пытается определить длину null.

## Применение модификаторов доступа

Вы уже видели, что существует четыре модификатора доступа: private, package, protected и public.
Мы собираемся обсудить их в порядке от наиболее ограничивающих к наименее ограничивающим:

+ private: Доступен только в пределах одного класса.
+ Package access: private плюс другие члены того же пакета. Иногда называют как package-private или default доступ
+ protected: Пакетный доступ плюс доступ внутри подклассов.
+ public: protected плюс классы в других пакетах.

Мы рассмотрим влияние этих четырех уровней доступа на участников класса.

### Private доступ

Давайте начнем с доступа private, который является самым простым. Только код в том же классе может вызывать private 
методы или получать доступ к private полям.

Во-первых, взгляните на рис. 5.2. Он показывает классы, которые вы будете использовать для изучения private и 
packfge доступа. Большие прямоугольники — это названия пакетов. Меньшие коробки внутри них — это классы в каждом 
пакете. Вы можете вернуться к этому рисунку, если хотите быстро увидеть, как соотносятся классы.

#### Рис. 5.2 - Классы, используемые для отображения private и package access


Это совершенно правильный код, потому что все является одним классом:

```
1: package pond.duck;
2: public class FatherDuck {
3:    private String noise = "quack";
4:    private void quack() {
5:       System.out.print(noise);     // private access is ok
6:    }
7: }
```

Пока всё хорошо. FatherDuck объявляет приватный метод quack() и использует приватную переменную экземпляра noise в 
строке 5.

Теперь мы добавим ещё один класс:

```
1: package pond.duck;
2: public class BadDuckling {
3:    public void makeNoise() {
4:       var duck = new FatherDuck();
5:       duck.quack();                  // DOES NOT COMPILE
6:       System.out.print(duck.noise);  // DOES NOT COMPILE
7:    }
8: }
```

BadDuckling пытается получить доступ к переменной экземпляра и методу, к которому он не имеет никакого отношения. 
В строке 5 он пытается получить доступ к private методу в другом классе. В строке 6 он пытается получить доступ к 
private переменной экземпляра в другом классе. Оба генерируют ошибки компилятора. Плохой утенок!

Нашему гадкому утёнку всего несколько дней, и он ещё ничего не знает. К счастью, вы знаете, что доступ к private членам 
других классов запрещен, и вам нужно использовать другой тип доступа.

_В предыдущем примере FatherDuck и BadDuckling находятся в отдельных файлах, но что, если бы они были объявлены в одном 
и том же файле? Даже в этом случае код все равно не скомпилируется, так как Java запрещает доступ за пределами класса._

### Package Access

К счастью, MotherDuck более сговорчива в отношении того, что могут делать её утята. Она разрешает классам в том же 
пакете доступ к своим членам. Когда модификатор доступа отсутствует, Java предполагает пакетный доступ.

```
package pond.duck;
public class MotherDuck {
   String noise = "quack";
   void quack() {
      System.out.print(noise);   // package access is ok
   }
}
```

MotherDuck может ссылаться на noise и вызывать quack(). В конце концов, члены одного класса находятся в одном пакете.
Большая разница заключается в том, что MotherDuck позволяет другим классам в том же пакете получать доступ к членам, в 
то время как FatherDuck этого не делает (из-за того, что он private). У GoodDuckling гораздо лучший опыт, чем 
у BadDuckling:

```
package pond.duck;
public class GoodDuckling {
   public void makeNoise() {
      var duck = new MotherDuck();
      duck.quack();                  // package access is ok
      System.out.print(duck.noise);  // package access is ok
   }
}
```

GoodDuckling успешно учится quack() и издавать noise, копируя свою мать. Обратите внимание, что все классы, рассмотренные 
до сих пор, находятся в одном пакете pond.duck. Это позволяет получить доступ к пакету для работы.

В этом же пруду лебедь только что родила детеныша лебедя. Детеныш лебедя называется лебедёнок. Лебедёнок видит, как 
утята учатся крякать, и решает тоже поучиться у MotherDuck.

```
package pond.swan;
import pond.duck.MotherDuck;             // импортируем другой пакет
public class BadCygnet {
   public void makeNoise() {
      var duck = new MotherDuck();
      duck.quack();                      // DOES NOT COMPILE
      System.out.print(duck.noise);      // DOES NOT COMPILE
   }
}
```

О, нет! MotherDuck разрешает уроки только другим уткам, ограничивая доступ к пакету pond.duck. Бедный маленький 
BadCygnet находится в пакете pond.swan, и его код не компилируется. Помните, что когда у элемента нет модификатора 
доступа, только классы в том же пакете могут получить доступ к элементу.

### Protected доступ

Protected доступ позволяет всё, что делает package access, и даже больше. Модификатор доступа protected добавляет 
возможность доступа к членам родительского класса. Мы подробно рассмотрим создание подклассов в главе 6. Сейчас мы 
рассмотрим простейшее возможное использование подкласса. В следующем примере «дочерний» класс ClownFish является 
подклассом «родительского» класса Fish, для их соединения используется ключевое слово extends:

```
public class Fish {}

public class ClownFish extends Fish {}
```

Расширяя класс, подкласс получает доступ ко всем protected и public членам родительского класса, как если бы 
они были объявлены в подклассе. Если два класса находятся в одном пакете, то подкласс также получает доступ ко всем 
членам пакета.

На рисунке 5.3 показано множество классов, которые мы создаем в этом разделе. Существует множество классов и пакетов, 
так что не беспокойтесь о том, чтобы держать их все в своей голове. Просто сверяйтесь с этим рисунком по ходу дела.

#### Рис. 5.3 - Классы, используемые для отображения protected access


Сначала создайте класс Bird и предоставьте protected доступ его членам:

```
package pond.shore;
public class Bird {
   protected String text = "floating";
   protected void floatInWater() {
      System.out.print(text);            // protected access is ok
   }
}
```

Далее создаем подкласс:

```
package pond.goose;                          // Different package than Bird
import pond.shore.Bird;
public class Gosling extends Bird {          // Gosling is a subclass of Bird
   public void swim() {
      floatInWater();                        // protected access is ok
      System.out.print(text);                // protected access is ok
   }
   public static void main(String[] args) {
      new Gosling().swim();
   }
}
```

Это простой подкласс. Он расширяет(extends) класс Bird. Расширение означает создание подкласса, который имеет доступ к 
любым protected или public членам родительского класса. Запуск этой программы дважды выводит float значения: один раз 
из вызова floatInWater() и один раз из оператора печати в swim(). Поскольку Gosling является подклассом Bird, он может 
получить доступ к этим членам, даже если он находится в другом пакете.

Помните, что protected также дает нам доступ ко всему, что делает пакетный доступ(package access). Это означает, что 
класс в том же пакете, что и Bird, может получить доступ к своим protected членам.

```
package pond.shore;                  // Same package as Bird
public class BirdWatcher {
   public void watchBird() {
      Bird bird = new Bird();
      bird.floatInWater();           // protected access is ok
      System.out.print(bird.text);   // protected access is ok
   }
}
```

Поскольку Bird и BirdWatcher находятся в одном пакете, BirdWatcher может получить доступ к членам пакета переменной bird. 
Определение protected разрешает доступ к подклассам и классам в одном пакете. В этом примере используется та же часть 
пакета, что и в этом определении.

Теперь давайте попробуем то же самое из другого пакета:

```
package pond.inland;                  // Different package than Bird
import pond.shore.Bird;
public class BirdWatcherFromAfar {    // Not a subclass of Bird
   public void watchBird() {
      Bird bird = new Bird();
      bird.floatInWater();            // DOES NOT COMPILE
      System.out.print(bird.text);    // DOES NOT COMPILE
   }
}
```

BirdWatcherFromAfar не находится в том же пакете, что и Bird, и не наследуется от Bird. Это означает, что доступ к 
protected членам Bird запрещен.

Поняли это? Только подклассы и классы в одном пакете имеют доступ к protected членам.

Есть одна уловка для protected доступа. Рассмотрим этот класс:

```
1: package pond.swan;                        // Different package than Bird
2: import pond.shore.Bird;
3: public class Swan extends Bird {          // Swan is a subclass of Bird
4:    public void swim() {
5:       floatInWater();                     // protected access is ok
6:       System.out.print(text);             // protected access is ok
7:    }
8:    public void helpOtherSwanSwim() {
9:       Swan other = new Swan();
10:      other.floatInWater();               // subclass access to superclass
11:      System.out.print(other.text);       // subclass access to superclass
12:   }
13:   public void helpOtherBirdSwim() {
14:      Bird other = new Bird();
15:      other.floatInWater();               // DOES NOT COMPILE
16:      System.out.print(other.text);       // DOES NOT COMPILE
17:   }
18: }
```

Сделайте глубокий вдох. Это интересно. Swan находится не в том же пакете, что и Bird, но расширяет его, что означает, 
что он имеет доступ к protected членам Bird, поскольку он является подклассом. И это так. Строки 5 и 6 относятся к 
protected членам посредством их наследования.

Строки 10 и 11 также успешно используют protected члены Bird. Это разрешено, потому что эти строки относятся к объекту 
Swan. Swan наследуется от Bird, так что все в порядке. Это своего рода двухэтапная проверка. Классу Swan разрешено 
использовать protected члены Bird, и мы имеем в виду объект Swan. Конечно, это объект Swan, созданный в строке 9, а не 
унаследованный, но это все ещё объект Swan.

Строки 15 и 16 не компилируются. Подождите минуту. Они почти такие же, как строки 10 и 11! Есть одно ключевое отличие. 
На этот раз используется ссылка на Bird, а не наследование. Он создается в строке 14. Bird находится в другом пакете, 
и этот код не наследуется от Bird, поэтому он не может использовать protected члены. Что теперь сказать? Мы только что 
неоднократно повторяли, что Swan наследует от Bird. И это так. Однако ссылка на переменную — это не Swan. Код просто 
оказался в классе Swan.

Это нормально - быть сбитым с толку. Это, пожалуй, один из самых запутанных моментов на экзамене. Если посмотреть на 
это с другой стороны, protected правила применяются в двух сценариях:

+ Член используется без ссылки на переменную. Так обстоит дело в строках 5 и 6. В этом случае мы используем преимущества
наследования, и разрешен protected доступ.
+ Член используется через переменную. Это относится к строкам 10, 11, 15 и 16. В этом случае важны правила для 
ссылочного типа переменной. Если это подкласс, разрешен protected доступ. Это работает для ссылок на один и тот же класс
или подкласс.

Мы попробуем это еще раз, чтобы убедиться, что вы понимаете, что происходит. Можете ли вы понять, почему эти примеры 
не компилируются?

```
package pond.goose;
import pond.shore.Bird;
public class Goose extends Bird {
   public void helpGooseSwim() {
      Goose other = new Goose();
      other.floatInWater();
      System.out.print(other.text);
   }
   public void helpOtherGooseSwim() {
      Bird other = new Goose();
      other.floatInWater();           // DOES NOT COMPILE
      System.out.print(other.text);   // DOES NOT COMPILE
   }
}
```

Первый способ хорош. По сути, это эквивалентно примеру с Swan. Goose расширяется до Bird. Поскольку мы находимся в 
подклассе Goose и ссылаемся на ссылку Goose, он может получить доступ к protected членам. Второй способ - проблема.
Хотя объект оказывается Goose, он хранится в ссылке на Bird. Нам не разрешено ссылаться на членов класса Bird, поскольку
мы не находимся в одном пакете, а ссылочный тип other не является подклассом Goose.

Что насчет этого?

```
package pond.duck;
import pond.goose.Goose;
public class GooseWatcher {
   public void watch() {
      Goose goose = new Goose();
      goose.floatInWater();      // DOES NOT COMPILE
   }
}
```

Этот код не компилируется, потому что мы не находимся в объекте goose. Метод floatInWater() объявлен в Bird. 
GooseWatcher не входит в тот же пакет, что и Bird, и не расширяет его. Goose расширяется до Bird. Это позволяет Goose 
обращаться только к floatInWater(), а не к вызывающим объектам Goose.

Если это все ещё вызывает затруднения, попробуйте. Введите код и попробуйте его скомпилировать. Затем перечитайте этот 
раздел. Не волнуйтесь — в первый раз это тоже не было очевидно для нас!

### Public Access

Protected доступ был сложной концепцией. К счастью, последний тип модификатора доступа прост: public означает, что 
любой может получить доступ к члену из любого места.

Система модулей Java переопределяет «где угодно», и становится возможным ограничить доступ к общедоступному коду за 
пределами модуля. Мы рассмотрим это более подробно в главе 12, «Модули». При наличии примеров кода вы можете 
предположить, что они находятся в одном и том же модуле, если явно не указано иное.

Давайте создадим класс с public членами:

```
package pond.duck;
public class DuckTeacher {
   public String name = "helpful";
   public void swim() {
      System.out.print(name);         // public access is ok
   }
}
```

DuckTeacher позволяет получить доступ к любому классу, который этого хочет. Теперь мы можем попробовать:

```
package pond.goose;
import pond.duck.DuckTeacher;
public class LostDuckling {
   public void swim() {
      var teacher = new DuckTeacher();
      teacher.swim();                             // allowed
      System.out.print("Thanks" + teacher.name);  // allowed
   }
}
```

LostDuckling может ссылаться на swim() и name на DuckTeacher, потому что они public. У истории счастливый конец. 
LostDuckling научился плавать и может найти своих родителей — и всё потому, что DuckTeacher сделал членов public.

### Обзор модификаторов доступа

Убедитесь, что вы знаете, почему все в таблице 5.4 верно. Используйте первый столбец для первого пробела и первую строку
для второго пробела. Кроме того, помните, что член — это метод или поле.

#### Таблица 5.4 - A method in ______ can access a ______ member.

|                                    | private | package | protected | public |  
|------------------------------------|---------|:-------:|:---------:|:------:|
|       (один и) тот же класс        |   Yes   |   Yes   |    Yes    |  Yes   |                                     
|    другой класс в том же пакете    |   No    |   Yes   |    Yes    |  Yes   |                                        
|      подкласс в другом пакете      |   No    |   No    |    Yes    |  Yes   | 
| несвязанный класс в другом пакете  |   No    |   No    |    No     |  Yes   |

## Доступ к статическим данным

Когда ключевое слово static применяется к переменной, методу или классу, оно принадлежит классу, а не определенному 
экземпляру класса. В этом разделе вы увидите, что ключевое слово static также можно применять к операторам импорта.

### Создание static методов и переменных

За исключением метода main(), мы рассмотрели методы экземпляра. Методы и переменные, объявленные как static, не требуют 
экземпляра класса. Они являются общими для всех пользователей класса. Например, взгляните на следующий класс Penguin:

```
public class Penguin {
   String name;
   static String nameOfTallestPenguin;
}
```

В этом классе каждый экземпляр Penguin имеет собственное имя, например Willy или Lilly, но только один Penguin среди 
всех экземпляров является самым высоким. Вы можете думать о static переменной как о члене одного объекта класса, который
существует независимо от каких-либо экземпляров этого класса. Рассмотрим следующий пример:

```
public static void main(String[] unused) {
   var p1 = new Penguin();
   p1.name = "Lilly";
   p1.nameOfTallestPenguin = "Lilly";
   var p2 = new Penguin();
   p2.name = "Willy";
   p2.nameOfTallestPenguin = "Willy";
   System.out.println(p1.name);                   // Lilly
   System.out.println(p1.nameOfTallestPenguin);   // Willy
   System.out.println(p2.name);                   // Willy
   System.out.println(p2.nameOfTallestPenguin);   // Willy
}
```

Мы видим, что каждому экземпляру пингвина присваивается собственное уникальное имя. Однако поле nameOfTallestPenguin 
является static и, следовательно, общим, поэтому при каждом его обновлении оно влияет на все экземпляры класса.

Вы видели один static метод, начиная с главы 1. Метод main() является static методом. Это означает, что вы 
можете вызвать его, используя имя класса:

```
public class Koala {
   public static int count = 0;               // static variable
   public static void main(String[] args) {   // static method
      System.out.print(count);
   }
}
```

Здесь JVM в основном вызывает Koala.main() для запуска программы. Вы тоже можете это сделать. У нас может быть 
KoalaTester, который ничего не делает, кроме вызова метода main():

```
public class KoalaTester {
   public static void main(String[] args) {
      Koala.main(new String[0]);             // call static method
   }
}
```

Довольно сложный способ напечатать 0, не так ли? Когда мы запускаем KoalaTester, он вызывает метод main() Koala, который
выводит значение count. Цель всех этих примеров — показать, что main() можно вызывать так же, как и любой другой 
static метод.

В дополнение к методам main(), static методы имеют две основные цели:

+ Для служебных или вспомогательных методов, которым не требуется какое-либо состояние объекта. Поскольку нет 
необходимости обращаться к переменным экземпляра, наличие static методов избавляет вызывающую сторону от необходимости 
создавать экземпляр объекта только для вызова метода.
+ Для состояния, которое является общим для всех экземпляров класса, например, для (counter)счетчика. Все экземпляры 
должны иметь одно и то же состояние. Методы, которые просто используют это состояние, также должны быть static.

В следующих разделах мы рассмотрим некоторые примеры, охватывающие другие static концепции.

### Доступ к static переменной или методу

Обычно получить доступ к static элементу несложно.

```
public class Snake {
   public static long hiss = 2;
}
```

Вы просто помещаете имя класса перед методом или переменной, и все готово. Вот пример:

```
System.out.println(Snake.hiss);
```

Красиво и легко. Есть одно правило, которое сложнее. Вы можете использовать экземпляр объекта для вызова static метода. 
Компилятор проверяет тип ссылки и использует его вместо объекта, что является хитростью Java. Этот код совершенно 
законен:

```
5: Snake s = new Snake();
6: System.out.println(s.hiss); // s is a Snake
7: s = null;
8: System.out.println(s.hiss); // s is still a Snake
```

Вы не поверите, но этот код дважды выводит 2. Строка 6 видит, что s — это Snake, а hiss — это статическая переменная, поэтому она считывает эту статическую переменную. Строка 8 делает то же самое. Java не волнует, что s оказывается нулевым. Поскольку мы ищем статическую переменную, это не имеет значения.

_Не забывайте смотреть на ссылочный тип переменной, когда видите статический метод или переменную. Создатели экзамена попытаются обмануть вас, заставив вас думать, что возникает исключение NullPointerException, потому что переменная оказалась нулевой. Не дайте себя обмануть!_

Еще раз, потому что это действительно важно: что выводит следующее?

```
Snake.hiss = 4;
Snake snake1 = new Snake();
Snake snake2 = new Snake();
snake1.hiss = 6;
snake2.hiss = 5;
System.out.println(Snake.hiss);
```

Надеемся, вы ответили на 5. Переменная шипения только одна, так как она статическая. Он устанавливается на 4, затем на 6 и, наконец, на 5. Все переменные Snake просто отвлекают внимание.

### Class vs. Instance Membership

Есть ещё один способ, с помощью которого создатели экзамена попытаются обмануть вас в отношении static членов и 
элементов-экземпляров. Static член не может вызывать член экземпляра без ссылки на экземпляр класса. Это не должно быть 
сюрпризом, поскольку static не требует существования каких-либо экземпляров класса.

Следующая распространенная ошибка, которую совершают программисты-новички:

```
public class MantaRay {
   private String name = "Sammy";
   public static void first() { }
   public static void second() { }
   public void third() { System.out.print(name); }
   public static void main(String args[]) {
      first();
      second();
      third();   // DOES NOT COMPILE
   }
}
```

Компилятор выдаст вам ошибку о создании static ссылки на метод экземпляра. Если мы исправим это, добавив static в 
функцию Third(), мы создадим новую проблему. Вы можете понять, что это такое?

```
public static void third() { System.out.print(name); }   // DOES NOT COMPILE
```

Все, что это делает, - это перемещает проблему. Теперь Third() ссылается на имя переменной экземпляра. Есть два способа исправить это. 
Во-первых, нужно также добавить static в переменную name.

```
public class MantaRay {
   private static String name = "Sammy";
   ...
   public static void third() { System.out.print(name); }
   ...
}
```

Вторым решением было бы вызвать third() в качестве метода экземпляра и не использовать static для метода или переменной.

```
public class MantaRay {
   private String name = "Sammy";
   ...
   public void third() { System.out.print(name); }
   public static void main(String args[]) {
      ...
      var ray = new MantaRay();
      ray.third();
   }
}
```

Создателям экзамена эта тема очень нравится. Static метод или метод экземпляра может вызывать static метод, потому что 
static методы не требуют использования объекта. Только метод экземпляра может вызывать другой метод экземпляра в том же 
классе без использования ссылочной переменной, потому что для методов экземпляра требуется объект. Аналогичная логика 
применима к экземпляру и static переменным.

Предположим, у нас есть класс Giraffe: 

```
public class Giraffe {
   public void eat(Giraffe g) {}
   public void drink() {};
   public static void allGiraffeGoHome(Giraffe g) {}
   public static void allGiraffeComeOut() {}
}
```

Прежде чем продолжить, убедитесь, что вы поняли таблицу 5.5.

#### Таблица 5.5 - Статические и экземплярные вызовы (Static vs. instance calls)

| Метод              | Вызов               | Законно? |
|:-------------------|:--------------------|:--------:|
| allGiraffeGoHome() | allGiraffeComeOut() |   Yes    |                                    
| allGiraffeGoHome() | drink()             |    No    |                                       
| allGiraffeGoHome() | g.eat()             |   Yes    |
| eat()              | allGiraffeComeOut() |   Yes    |
| eat()              | drink()             |   Yes    |
| eat()              | g.eat()             |   Yes    |

Давайте попробуем еще один пример, чтобы у вас было больше практики в распознавании этого сценария. Понимаете ли вы, 
почему следующие строки не компилируются?

```
1: public class Gorilla {
2:    public static int count;
3:    public static void addGorilla() { count++; }
4:    public void babyGorilla() { count++; }
5:    public void announceBabies() {
6:       addGorilla();
7:       babyGorilla();
8:    }
9:    public static void announceBabiesToEveryone() {
10:      addGorilla();
11:      babyGorilla();            // DOES NOT COMPILE
12:   }
13:   public int total;
14:   public static double average
15:      = total / count;          // DOES NOT COMPILE
16: }
```

Строки 3 и 4 подходят, потому что и static методы, и методы экземпляра могут ссылаться на static переменную. 
Строки 5–8 хороши, потому что метод экземпляра может вызывать static метод. Строка 11 не компилируется, потому что 
static метод не может вызвать метод экземпляра. Точно так же строка 15 не компилируется, потому что static переменная 
пытается использовать переменную экземпляра.

Часто static переменные используются для подсчета количества экземпляров:

```
public class Counter {
   private static int count;
   public Counter() { count++; }
   public static void main(String[] args) {
      Counter c1 = new Counter();
      Counter c2 = new Counter();
      Counter c3 = new Counter();
      System.out.println(count); // 3
   }
}
```

Каждый раз, когда вызывается конструктор, он увеличивает count на единицу. Этот пример основан на том факте, что static 
(и экземплярные) переменные автоматически инициализируются значением по умолчанию для этого типа, которое равно 0 для 
int. См. главу 1, чтобы просмотреть значения по умолчанию.

Также обратите внимание, что мы не написали Counter.count. Мы могли бы. В этом нет необходимости, потому что мы уже 
находимся в этом классе, поэтому компилятор может сделать вывод.

Убедитесь, что вы действительно хорошо понимаете этот раздел. Об этом говорится на протяжении всей этой книги. Вы даже 
столкнетесь с подобной темой, когда мы будем говорить об интерфейсах в главе 7. Например, метод static интерфейса не 
может вызывать метод интерфейса default без ссылки, во многом так же, как внутри класса static метод не может вызывать 
метод экземпляра без ссылки.

### static модификаторы переменных

Возвращаясь к таблице 5.3, static переменные могут быть объявлены с теми же модификаторами, что и переменные экземпляра,
например final, transient и volatile. В то время как некоторые static переменные предназначены для изменения во время 
работы программы, как в нашем примере с count, другие предназначены для того, чтобы никогда не изменяться. Этот тип 
static переменной известен как constant. Он использует модификатор final, чтобы гарантировать, что переменная никогда 
не изменится.

Константы используют модификатор static final и соглашение об именах переменных, отличное от других переменных. Они 
используют все прописные буквы с подчеркиванием между «словами». Вот пример:

```
public class ZooPen {
   private static final int NUM_BUCKETS = 45;
   public static void main(String[] args) {
      NUM_BUCKETS = 5;             // DOES NOT COMPILE
   }
}
```

Компилятор позаботится о том, чтобы вы случайно не попытались обновить final переменную. Это может оказатсья интересным.
Как вы думаете, компилируется ли следующее?

```
import java.util.*;
public class ZooInventoryManager {
   private static final String[] treats = new String[10];
   public static void main(String[] args) {
      treats[0] = "popcorn";
   }
}
```

На самом деле он компилируется, поскольку treats являются ссылочной переменной. Нам разрешено изменять указанный объект 
или содержимое массива. Все, что может сделать компилятор, — это проверить, не пытаемся ли мы переназначить treats 
так, чтобы они указывали на другой объект.

Правила для static final переменных аналогичны final переменным экземпляра, за исключением того, что они не используют 
static конструкторы (такой вещи не существует!) и используют static инициализаторы вместо инициализаторов экземпляра.

```
public class Panda {
   final static String name = "Ronda";
   static final int bamboo;
   static final double height;     // DOES NOT COMPILE
   static { bamboo = 5;}
}
```

Переменной name присваивается значение при её объявлении, а переменной bamboo присваивается значение в static 
инициализаторе. Переменной height нигде в определении класса не присваивается значение, поэтому эта строка не 
компилируется. Помните, что переменные final должны быть инициализированы значением. Далее мы рассмотрим static 
инициализаторы.

### static Инициализаторы

В главе 1 мы рассмотрели инициализаторы экземпляров, которые выглядели как безымянные методы — просто код внутри 
фигурных скобок. static инициализаторы выглядят аналогично. Они добавляют ключевое слово static, чтобы указать, что они 
должны запускаться при первой загрузке класса. Вот пример:

```
private static final int NUM_SECONDS_PER_MINUTE;
private static final int NUM_MINUTES_PER_HOUR;
private static final int NUM_SECONDS_PER_HOUR;
static {
   NUM_SECONDS_PER_MINUTE = 60;
   NUM_MINUTES_PER_HOUR = 60;
}
static {
   NUM_SECONDS_PER_HOUR
      = NUM_SECONDS_PER_MINUTE * NUM_MINUTES_PER_HOUR;
}
```

Все static инициализаторы запускаются при первом использовании класса в порядке их определения. Операторы в них 
запускаются и назначают любые static переменные по мере необходимости. В этом примере есть кое-что интересное. 
Мы только что сказали, что переменные final не могут быть переназначены. Ключевым моментом здесь является то, что static
инициализатор является первым назначением. И поскольку это происходит до начала, это нормально.

Давайте попробуем ещё один пример, чтобы убедиться, что вы понимаете разницу:

```
14: private static int one;
15: private static final int two;
16: private static final int three = 3;
17: private static final int four;     // DOES NOT COMPILE
18: static {
19:    one = 1;
20:    two = 2;
21:    three = 3;                      // DOES NOT COMPILE
22:    two = 4;                        // DOES NOT COMPILE
23: }
```

Строка 14 объявляет static переменную, которая не является final. Её можно назначать сколько угодно раз. Строка 15 
объявляет переменную final без инициализации. Это означает, что мы можем инициализировать её ровно один раз в static
блоке. Строка 22 не компилируется, потому что это вторая попытка. Строка 16 объявляет переменную final и одновременно 
инициализирует её. Нам не разрешено присваивать её повторно, поэтому строка 21 не компилируется. Строка 17 объявляет 
переменную final, которая никогда не инициализируется. Компилятор выдает ошибку компилятора, потому что он знает, что 
static блоки — единственное место, где может быть инициализирована переменная. Поскольку программист забыл, это явно 
ошибка.

---

#### Старайтесь избегать static инициализаторов и инициализаторов экземпляров

Использование static инициализаторов и инициализаторов экземпляров может значительно усложнить чтение вашего кода. 
Все, что можно было бы сделать в инициализаторе экземпляра, можно было бы сделать в конструкторе. Многие люди находят 
подход конструктора более легким для чтения.

Существует распространенный случай использования static инициализатора: когда вам нужно инициализировать static поле, 
а код для этого требует более одной строки. Это часто происходит, когда вы хотите инициализировать коллекцию, такую как 
ArrayList или HashMap. Если вам нужно использовать static инициализатор, поместите всю static инициализацию в один и тот
же блок. Таким образом, порядок очевиден.

---

### static Импорт

В главе 1 вы видели, что можно импортировать определенный класс или все классы в пакете. Если вы раньше не встречались 
с ArrayList или List, не волнуйтесь, потому что мы подробно рассмотрим их в главе 9 «Коллекции и обобщения».

```
import java.util.ArrayList;
import java.util.*;
```

Мы можем использовать этот метод для импорта двух классов:

```
import java.util.List;
import java.util.Arrays;
public class Imports {
   public static void main(String[] args) {
      List<String> list = Arrays.asList("one", "two");
   }
} 
```

Импорт удобен тем, что вам не нужно указывать, откуда берется каждый класс каждый раз, когда вы его используете. 
Существует ещё один тип импорта, называемый static import. Обычный импорт предназначен для импорта классов, а
static импорт — для импорта static членов классов, таких как переменные и методы.

Как и при обычном импорте, вы можете использовать подстановочный знак или импортировать определенный элемент. Идея 
состоит в том, что вам не нужно указывать, откуда берется каждый static метод или переменная, каждый раз, когда вы их 
используете. Примером того, когда static импорт светиться, является то, что вы ссылаетесь на множество констант в 
другом классе.

Мы переписали наш предыдущий пример для использования static импорта. В результате получается следующее:

```
import java.util.List;
import static java.util.Arrays.asList;             // static import
public class ZooParking {
   public static void main(String[] args) {
      List<String> list = asList("one", "two");    // No Arrays. prefix
   }
}
```

В этом примере мы специально импортируем метод asList. Это означает, что каждый раз, когда мы обращаемся к asList в 
классе, он будет вызывать Arrays.asList().

Интересно, что произойдет, если мы создадим метод asList в нашем классе ZooParking. Java отдаст ему предпочтение перед 
импортированным, и будет использоваться метод, который мы закодировали.

Экзамен попытается обмануть вас, неправильно используя static импорт. Этот пример показывает почти всё, что вы можете 
сделать неправильно. Сможете ли вы понять, что не так с каждым?

```
1: import static java.util.Arrays;        // DOES NOT COMPILE
2: import static java.util.Arrays.asList;
3: static import java.util.Arrays.*;      // DOES NOT COMPILE
4: public class BadZooParking {
5:    public static void main(String[] args) {
6:       Arrays.asList("one");            // DOES NOT COMPILE
7:    }
8: }
```

Строка 1 пытается использовать static импорт для импорта класса. Помните, что static импорт предназначен только для 
импорта static элементов, таких как метод или переменная. Обычный импорт предназначен для импорта класса. Строка 3 
пытается увидеть, обращаете ли вы внимание на порядок ключевых слов. Синтаксис import static, а не наоборот. Строка 6 -
это хитрость. Метод asList импортируется в строке 2. Однако класс Arrays нигде не импортируется. Это позволяет писать 
asList("one"), но не Arrays.asList("one").

Есть только ещё один сценарий со static импортом. В главе 1 вы узнали, что импорт двух классов с одинаковыми именами 
приводит к ошибке компилятора. Это верно и для static импорта. Компилятор будет жаловаться, если вы попытаетесь явно 
выполнить static импорт двух методов с одинаковыми именами или двух static переменных с одинаковыми именами.

Вот пример:

```
import static zoo.A.TYPE;
import static zoo.B.TYPE;    // DOES NOT COMPILE
```

К счастью, когда это происходит, мы можем просто ссылаться на static члены через имя их класса в коде вместо того, 
чтобы пытаться использовать static импорт.

_В большой программе static импортом можно злоупотреблять. При импорте из многих мест может быть трудно запомнить, откуда
берется каждый static элемент. Используйте их экономно!_

## Передача данных между методами


