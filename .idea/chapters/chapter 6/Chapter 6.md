# Дизайн класса (or Проектирование класса)

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Создавать классы и записи, а также определять и использовать: экземпляры объекта, статические поля и методы,
  конструкторы, а также экземпляры объекта и статические инициализаторы
+ Понимать области видимости переменных, использовать вывод типа локальной переменной, применять инкапсуляцию и делать 
  объекты неизменяемыми
+ Реализуйте полиморфизм и различайте тип объекта по сравнению с ссылочным типом. Выполнение приведения типов, 
   идентификация типов объектов с помощью оператора instanceof и сопоставления с образцом

---

В главе 1 «Строительные блоки» мы представили базовое определение класса в Java. В главе 5 «Методы» мы подробно 
рассмотрели методы и модификаторы и показали, как их можно использовать для создания более структурированных классов. 
В этой главе мы пойдем еще дальше и покажем, что структура классов и наследование — одна из самых мощных функций языка 
Java.

По своей сути правильный дизайн классов Java связан с повторным использованием кода, расширенной функциональностью и 
стандартизацией. Например, создав новый класс, который расширяет существующий класс, вы можете получить доступ к 
множеству унаследованных примитивов, объектов и методов, что увеличивает повторное использование кода.

Эта глава является кульминацией некоторых из наиболее важных тем в Java, включая наследование, проектирование классов, 
конструкторы, порядок инициализации, методы переопределения, абстрактные классы и неизменяемые объекты. Внимательно 
прочитайте эту главу и убедитесь, что вы хорошо понимаете все темы. Эта глава составляет основу главы 7 
«Помимо классов», в которой мы расширяем обсуждение типов, включив в него другие высокоуровневые и вложенные типы.

## Понимание наследования

При создании нового класса в Java вы можете определить класс как унаследованный от существующего класса. 
Наследование — это процесс, посредством которого подкласс автоматически включает определенные члены класса, включая 
примитивы, объекты или методы, определенные в родительском классе.

В иллюстративных целях мы называем любой класс, наследуемый от другого класса, _подклассом_ или _дочерним классом_, 
поскольку он считается потомком этого класса. В качестве альтернативы мы называем класс, от которого наследует потомок, 
_суперклассом_ или _родительским_ классом, поскольку он считается предком класса.

_При работе с другими типами, такими как интерфейсы, мы обычно используем общие термины подтип и супертип. Подробнее об 
этом вы узнаете в следующей главе._

### Объявление подкласса

Начнем с объявления класса и его подкласса. На рис. 6.1 показан пример суперкласса Mammal и подкласса Rhinoceros.

#### Рис. 6.1 - Объявление подкласса и суперкласса


Мы указываем, что класс является подклассом, объявляя его с помощью ключевого слова extends. Нам не нужно ничего 
объявлять в суперклассе, кроме как убедиться, что он не помечен как final. Подробнее об этом в ближайшее время.

Одним из ключевых аспектов наследования является его транзитивность. Для трех классов [X, Y, Z], если X расширяет Y, а 
Y расширяет Z, то X считается подклассом или потомком Z. Точно так же Z является суперклассом или предком X. 
Иногда мы используем термин прямой подкласс или потомок, чтобы указать, что класс напрямую расширяет родительский класс.
Например, X является прямым потомком только класса Y, а не Z.

В предыдущей главе вы узнали, что существует четыре уровня доступа: public, protected, package и private. Когда один 
класс наследуется от родительского класса, все public и protected члены автоматически становятся частью дочернего 
класса. Если два класса находятся в одном пакете, члены пакета доступны дочернему классу. И последнее, но не менее 
важное: private члены ограничены классом, в котором они определены, и никогда не доступны через наследование. 
Это не означает, что родительский класс не может иметь private членов, которые могут хранить данные или изменять объект; 
это просто означает, что подкласс не имеет к ним прямого доступа.

Давайте рассмотрим простой пример:

```
public class BigCat {
   protected double size;
}

public class Jaguar extends BigCat {
   public Jaguar() {
      size = 10.2;
   }
   public void printDetails() {
      System.out.print(size);
   }
}

public class Spider {
   public void printDetails() {
      System.out.println(size);     // DOES NOT COMPILE
   }
}
```

Jaguar является подклассом или потомком BigCat, что делает BigCat надклассом или родителем Jaguar. В классе Jaguar 
size доступен, потому что он помечен как protected. С помощью наследования подкласс Jaguar может читать или 
записывать size, как если бы он был его собственным членом. Сравните это с классом Spider, у которого нет доступа к 
size, поскольку он не наследуется.

### Модификаторы класса








