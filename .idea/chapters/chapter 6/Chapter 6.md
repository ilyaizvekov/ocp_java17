# Дизайн класса (or Проектирование класса)

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Создавать классы и записи, а также определять и использовать: экземпляры объекта, статические поля и методы,
  конструкторы, а также экземпляры объекта и статические инициализаторы
+ Понимать области видимости переменных, использовать вывод типа локальной переменной, применять инкапсуляцию и делать 
  объекты неизменяемыми
+ Реализуйте полиморфизм и различайте тип объекта по сравнению с ссылочным типом. Выполнение приведения типов, 
   идентификация типов объектов с помощью оператора instanceof и сопоставления с образцом

---

В главе 1 «Строительные блоки» мы представили базовое определение класса в Java. В главе 5 «Методы» мы подробно 
рассмотрели методы и модификаторы и показали, как их можно использовать для создания более структурированных классов. 
В этой главе мы пойдем еще дальше и покажем, что структура классов и наследование — одна из самых мощных функций языка 
Java.

По своей сути правильный дизайн классов Java связан с повторным использованием кода, расширенной функциональностью и 
стандартизацией. Например, создав новый класс, который расширяет существующий класс, вы можете получить доступ к 
множеству унаследованных примитивов, объектов и методов, что увеличивает повторное использование кода.

Эта глава является кульминацией некоторых из наиболее важных тем в Java, включая наследование, проектирование классов, 
конструкторы, порядок инициализации, методы переопределения, абстрактные классы и неизменяемые объекты. Внимательно 
прочитайте эту главу и убедитесь, что вы хорошо понимаете все темы. Эта глава составляет основу главы 7 
«Помимо классов», в которой мы расширяем обсуждение типов, включив в него другие высокоуровневые и вложенные типы.

## Понимание наследования

При создании нового класса в Java вы можете определить класс как унаследованный от существующего класса. 
Наследование — это процесс, посредством которого подкласс автоматически включает определенные члены класса, включая 
примитивы, объекты или методы, определенные в родительском классе.

В иллюстративных целях мы называем любой класс, наследуемый от другого класса, _подклассом_ или _дочерним классом_, 
поскольку он считается потомком этого класса. В качестве альтернативы мы называем класс, от которого наследует потомок, 
_суперклассом_ или _родительским_ классом, поскольку он считается предком класса.

_При работе с другими типами, такими как интерфейсы, мы обычно используем общие термины подтип и супертип. Подробнее об 
этом вы узнаете в следующей главе._

### Объявление подкласса

Начнем с объявления класса и его подкласса. На рис. 6.1 показан пример суперкласса Mammal и подкласса Rhinoceros.

#### Рис. 6.1 - Объявление подкласса и суперкласса


Мы указываем, что класс является подклассом, объявляя его с помощью ключевого слова extends. Нам не нужно ничего 
объявлять в суперклассе, кроме как убедиться, что он не помечен как final. Подробнее об этом в ближайшее время.

Одним из ключевых аспектов наследования является его транзитивность. Для трех классов [X, Y, Z], если X расширяет Y, а 
Y расширяет Z, то X считается подклассом или потомком Z. Точно так же Z является суперклассом или предком X. 
Иногда мы используем термин прямой подкласс или потомок, чтобы указать, что класс напрямую расширяет родительский класс.
Например, X является прямым потомком только класса Y, а не Z.

В предыдущей главе вы узнали, что существует четыре уровня доступа: public, protected, package и private. Когда один 
класс наследуется от родительского класса, все public и protected члены автоматически становятся частью дочернего 
класса. Если два класса находятся в одном пакете, члены пакета доступны дочернему классу. И последнее, но не менее 
важное: private члены ограничены классом, в котором они определены, и никогда не доступны через наследование. 
Это не означает, что родительский класс не может иметь private членов, которые могут хранить данные или изменять объект; 
это просто означает, что подкласс не имеет к ним прямого доступа.

Давайте рассмотрим простой пример:

```
public class BigCat {
   protected double size;
}

public class Jaguar extends BigCat {
   public Jaguar() {
      size = 10.2;
   }
   public void printDetails() {
      System.out.print(size);
   }
}

public class Spider {
   public void printDetails() {
      System.out.println(size);     // DOES NOT COMPILE
   }
}
```

Jaguar является подклассом или потомком BigCat, что делает BigCat надклассом или родителем Jaguar. В классе Jaguar 
size доступен, потому что он помечен как protected. С помощью наследования подкласс Jaguar может читать или 
записывать size, как если бы он был его собственным членом. Сравните это с классом Spider, у которого нет доступа к 
size, поскольку он не наследуется.

### Модификаторы класса

Подобно методам и переменным, объявление класса может иметь различные модификаторы. В Таблице 6.1 перечислены 
модификаторы, которые вы должны знать для экзамена.

#### Таблица 6.1 - Модификаторы класса

|    Модификатор    | Описание                                                                                                                  | Охваченная глава |  
|:-----------------:|:--------------------------------------------------------------------------------------------------------------------------|:----------------:|
|       final       | Класс не может быть расширен.                                                                                             |     Глава 6      |                                     
|     abstract      | Класс является абстрактным, может содержать абстрактные методы<br/>  и требует создания экземпляра конкретного подкласса. |     Глава 6      |                                        
|      sealed       | Класс может быть расширен только определенным списком классов.                                                                                                                      |     Глава 7      |                                   
|    non-sealed     | Подкласс закрытого класса допускает потенциально неназванные подклассы.                                                                                                                       |     Глава 7      |
|      static       | Используется для static вложенных классов, определенных внутри класса.                                                                                                             |     Глава 7      |

Мы рассмотрим abstract классы позже в этой главе. В следующей главе мы рассмотрим sealed и non-sealed классы, а также 
static вложенные классы.

А пока давайте поговорим об отметке final класса. Модификатор final предотвращает дальнейшее расширение класса. 
Например, следующее не компилируется:

```
public final class Rhinoceros extends Mammal { }

public class Clara extends Rhinoceros { } // DOES NOT COMPILE
```

На экзамене обратите внимание на любой класс с пометкой final. Если вы видите другой класс, расширяющий его, вы сразу 
понимаете, что код не компилируется.

### Одиночное и множественное наследование

Java поддерживает _одиночное наследование_, при котором класс может наследовать только от одного прямого родительского 
класса. Java также поддерживает несколько уровней наследования, посредством которых один класс может расширять другой 
класс, который, в свою очередь, расширяет другой класс. Вы можете иметь любое количество уровней наследования, позволяя 
каждому потомку получить доступ к членам своего предка.

Чтобы по-настоящему понять одиночное наследование, полезно сравнить его с множественным наследованием, при котором у 
класса может быть несколько прямых родителей. Java не поддерживает множественное наследование в языке, потому что 
множественное наследование может привести к сложным, часто трудным для сопровождения моделям данных. Java допускает 
одно исключение из правила единственного наследования, которое вы видите в главе 7 — класс может реализовывать несколько
интерфейсов.

На рис. 6.2 показаны различные типы моделей наследования. Элементы слева считаются одиночным наследованием, поскольку у 
каждого потомка есть только один родитель. Вы можете заметить, что одиночное наследование не мешает родителям иметь 
несколько детей. Справа показаны элементы, имеющие множественное наследование. Как видите, объект Dog имеет несколько 
родительских обозначений.

#### Рис. 6.2 - Типы наследования


Часть того, что усложняет множественное наследование, — это определение того, от какого родителя наследовать значения в 
случае конфликта. Например, если у вас есть объект или метод, определенный во всех родителях, какой из них наследует 
потомок? В этом примере нет естественного порядка для родителей, поэтому Java избегает этих проблем, полностью запрещая 
множественное наследование.

### Наследование объекта 

При обсуждении Java в этой книге мы много раз использовали слово «объект» — и не без оснований. В Java все классы 
наследуются от одного класса: java.lang.Object или для краткости Object. Кроме того, Object — единственный класс, у 
которого нет родительского класса.

Вы можете задаться вопросом: «Ни один из классов, которые я написал до сих пор, не расширяет Object, так как же все 
классы наследуют от него?» Ответ заключается в том, что компилятор автоматически вставляет код в любой написанный вами 
класс, который не расширяет конкретный класс. Например, следующие два эквивалентны:

```
public class Zoo { }

public class Zoo extends java.lang.Object { }
```

Суть в том, что когда Java видит, что вы определяете класс, который не расширяет другой класс, компилятор автоматически 
добавляет синтаксис extends java.lang.Object в определение класса. В результате каждый класс получает доступ к любым 
доступным методам класса Object. Например, методы toString() и equals() доступны в Object; следовательно, они доступны 
во всех классах. Однако без переопределения в подклассе они могут быть не особенно полезны. Мы рассмотрим методы 
переопределения позже в этой главе.

С другой стороны, когда вы определяете новый класс, который расширяет существующий класс, Java не расширяет 
автоматически класс Object. Поскольку все классы наследуются от Object, расширение существующего класса означает, что 
дочерний класс уже наследуется от Object по определению. Если вы посмотрите на структуру наследования любого класса, 
она всегда будет заканчиваться Object в верхней части дерева, как показано на рис. 6.3.

#### Рис. 6.3 - Наследование объектов Java


Примитивные типы, такие как int и boolean, не наследуются от Object, поскольку они не являются классами. Как вы узнали 
из главы 5, с помощью автоупаковки они могут быть назначены или переданы как экземпляр объекта связанного 
класса-оболочки, который наследует Object.

## Создание классов

Теперь, когда мы поняли, как работает наследование в Java, мы можем использовать его для определения и создания сложных
отношений между классами. В этом разделе мы рассмотрим основы создания классов и работы с ними.

### Расширение класса

Давайте создадим два файла в одном пакете, Animal.java и Lion.java.

```
// Animal.java
public class Animal {
   private int age;
   protected String name;
   public int getAge() {
      return age;
   }
   public void setAge(int newAge) {
      age = newAge;
   }
}

// Lion.java
public class Lion extends Animal {
   protected void setProperties(int age, String n) {
      setAge(age);
      name = n;
   }
   public void roar() {
      System.out.print(name + ", age " + getAge() + ", says: Roar!");
   }
   public static void main(String[] args) {
      var lion = new Lion();
      lion.setProperties(3, "kion");
      lion.roar();
   }
}
```

Здесь много всего происходит, мы знаем! Переменная age существует в родительском классе Animal и недоступна напрямую в 
дочернем классе Lion. Он косвенно доступен через метод setAge(). Переменная name protected, поэтому она наследуется в 
классе Lion и доступна напрямую. Мы создаем экземпляр Lion в методе main() и используем setProperties() для установки 
переменных экземпляра. Наконец, мы вызываем метод roar(), который выводит следующее:

```
kion, age 3, says: Roar!
```

Давайте посмотрим на членов класса Lion. Переменная экземпляра age помечена как private и недоступна напрямую из 
подкласса Lion. Следовательно, следующее не будет компилироваться:

```
public class Lion extends Animal {
   public void roar() {
      System.out.print("Lions age: " + age);  // DOES NOT COMPILE
   }
}
```

При работе с подклассами помните, что private члены никогда не наследуются, а члены пакета наследуются только в том 
случае, если два класса находятся в одном пакете. Если вам нужно освежить в памяти модификаторы доступа, вам стоит ещё 
раз прочитать главу 5.

### Применение модификаторов доступа к классу

Подобно переменным и методам, к классам можно применять модификаторы доступа. Как вы, возможно, помните из главы 1, 
класс верхнего уровня не определен внутри другого класса. Также помните, что файл .java может иметь не 
более одного класса верхнего уровня.

Хотя у вас может быть только один класс верхнего уровня, вы можете иметь столько классов (в любом порядке) с доступом к 
пакету, сколько захотите. На самом деле вам даже не нужно объявлять публичный класс! Далее объявляются три класса, 
каждый из которых имеет доступ к пакету:

```
// Bear.java
class Bird {}
class Bear {}
class Fish {}
```

Однако попытка объявить класс верхнего уровня с protected или private классом приведет к ошибке компилятора:

```
// ClownFish.java
protected class ClownFish{} // DOES NOT COMPILE

// BlueTang.java
private class BlueTang {} // DOES NOT COMPILE
```

Означает ли это, что класс нельзя объявить protected или private? Не совсем. В главе 7 мы представим вложенные типы и 
покажем, что, когда вы определяете класс внутри другого, он может использовать любой модификатор доступа.

### Доступ к this ссылке

Что происходит, когда параметр метода имеет то же имя, что и существующая переменная экземпляра? Давайте посмотрим на 
пример. Как вы думаете, что выводит следующая программа?

```
public class Flamingo {
   private String color = null;
   public void setColor(String color) {
      color = color;
   }
   public static void main(String... unused) {
      var f = new Flamingo();
      f.setColor("PINK");
      System.out.print(f.color);
   }
}
```

Если бы вы сказали null, то вы были бы правы. Java использует наиболее детальную область видимости, поэтому, когда он 
видит color = color, он думает, что вы присваиваете значение параметра метода самому себе (а не переменной экземпляра). 
Присвоение завершается успешно внутри метода, но значение переменной экземпляра color никогда не изменяется и равно null
при печати в методе main().

Если у вас есть локальная переменная с тем же именем, что и у переменной экземпляра, исправление заключается в 
использовании ссылки или ключевого слова this. Ссылка this относится к текущему экземпляру класса и может использоваться
для доступа к любому члену класса, включая унаследованные члены. Его можно использовать в любом методе экземпляра, 
конструкторе или блоке инициализатора экземпляра. Его нельзя использовать, когда нет неявного экземпляра класса, 
например, в статическом методе или статическом блоке инициализатора. Применим это к нашей предыдущей реализации метода 
следующим образом:

```
public void setColor(String color) {
   this.color = color;     // Sets the instance variable with method parameter
}
```

Исправленный код теперь будет печатать цвет PINK, как и ожидалось. Во многих случаях ссылка this является 
необязательной. Если Java встречает переменную или метод, который не может найти, он проверяет иерархию классов, чтобы 
узнать, доступны ли они.

Теперь давайте рассмотрим несколько примеров, которые встречаются нечасто, но которые вы можете увидеть на экзамене.

```
1: public class Duck {
2:    private String color;
3:    private int height;
4:    private int length;
5:
6:    public void setData(int length, int theHeight) {
7:       length = this.length;      // Backwards -- no good!
8:       height = theHeight;        // Fine, because a different name
9:       this.color = "white";      // Fine, but this. reference not necessary
10:   }
11:
12:   public static void main(String[] args) {
13:      Duck b = new Duck();
14:      b.setData(1,2);
15:      System.out.print(b.length + " " + b.height + " " + b.color);
16:   } }
```

Этот код компилирует и печатает следующее:

```
0 2 white
```

Хотя, возможно, это не то, что вы ожидали. Строка 7 неверна, и вы должны следить за ней на экзамене. Переменная 
экземпляра length начинается со значения 0. Этот 0 присваивается параметру метода length. Переменная экземпляра остается
равной 0. Строка 8 более прямолинейна. Параметр theHeight и переменная экземпляра height имеют разные имена. Поскольку 
конфликта имён нет, this не требуется. Наконец, строка 9 показывает, что при присвоении переменной разрешено 
использовать ссылку this, даже если имена переменных не дублируются.

### Calling the super Reference (Вызов суперссылки)

В Java переменную или метод можно определить как в родительском, так и в дочернем классе. Это означает, что экземпляр 
объекта фактически содержит две копии одной и той же переменной с одним и тем же базовым именем. Когда это происходит, 
как нам ссылаться на версию в родительском классе, а не на текущий класс? Давайте посмотрим на пример.

```
// Reptile.java
1: public class Reptile {
2:    protected int speed = 10;
3: }

// Crocodile.java
1: public class Crocodile extends Reptile {
2:    protected int speed = 20;
3:    public int getSpeed() {
4:       return speed;
5:    }
6:    public static void main(String[] data) {
7:       var croc = new Crocodile();
8:       System.out.println(croc.getSpeed()); // 20
9:    } }
```

Одна из самых важных вещей, которые следует помнить об этом коде, заключается в том, что экземпляр Crocodile хранит два 
отдельных значения speed: одно на уровне Reptile и одно на уровне Crocodile. В строке 4 Java сначала проверяет наличие 
локальной переменной или параметра метода с именем speed. Так как нет, то проверяется this.speed; и поскольку он 
существует, программа печатает 20.

_Объявление переменной с тем же именем, что и унаследованная переменная, называется скрытием переменной и обсуждается 
далее в этой главе._

Но что, если мы хотим, чтобы программа напечатала значение в классе Reptile? Вместо этого внутри класса Crocodile мы 
можем получить доступ к родительскому значению speed, используя ссылку super или ключевое слово. Ссылка super похожа на 
ссылку this, за исключением того, что она исключает все члены, найденные в текущем классе. Другими словами, член должен 
быть доступен через наследование.

```
3:    public int getSpeed() {
4:       return super.speed; // Causes the program to now print 10
5:    }
```

Посмотрим, усвоили ли вы this и super. Что выводит следующая программа?

```
1:   class Insect {
2:      protected int numberOfLegs = 4;
3:      String label = "buggy";
4:   }
5:
6:   public class Beetle extends Insect {
7:      protected int numberOfLegs = 6;
8:      short age = 3;
9:      public void printData() {
10:        System.out.println(this.label);
11:        System.out.println(super.label);
12:        System.out.println(this.age);
13:        System.out.println(super.age);
14:        System.out.println(numberOfLegs);
15:     }
16:     public static void main(String []n) {
17:        new Beetle().printData();
18:     }
19: }
```

Это был вопрос с подвохом — этот программный код не компилировался! Давайте рассмотрим каждую строку метода printData().
Поскольку label определена в родительском классе, она доступна как через this, так и через super ссылки. По этой причине
строки 10 и 11 компилируются и обе выведут buggy, если класс скомпилируется. С другой стороны, переменная age определена
только в текущем классе, что делает её доступной через this, но не через super. По этой причине строка 12 компилируется 
(и выводит 3), а строка 13 — нет. Помните, что в то время как this включает текущие и унаследованные элементы, super 
включает только унаследованные элементы.

И последнее, но не менее важное: что будет напечатано в строке 14, если строка 13 будет закомментирована? Несмотря на 
то, что обе переменные numberOfLegs доступны в Beetle, Java выполняет проверку снаружи, начиная с самой узкой области 
видимости. По этой причине используется значение numberOfLegs в классе Beetle, и печатается 6. В этом примере 
this.numberOfLegs и super.numberOfLegs ссылаются на разные переменные с разными значениями.

Поскольку this включает в себя унаследованные члены, вы часто используете super только тогда, когда у вас возникает 
конфликт имен из-за наследования. Например, у вас есть метод или переменная, определенные в текущем классе, которые 
соответствуют методу или переменной в родительском классе. Обычно это возникает при переопределении методов и сокрытии 
переменных, которые обсуждаются далее в этой главе.

Фу, это было много! К использованию this и super может потребоваться некоторое время, чтобы привыкнуть. Поскольку мы 
будем часто использовать их в следующих разделах, убедитесь, что вы действительно хорошо понимаете последний пример, 
прежде чем двигаться дальше.

## Объявление конструкторов

Как вы узнали из главы 1, конструктор — это специальный метод, который соответствует имени класса и не имеет 
возвращаемого типа. Он вызывается при создании нового экземпляра класса. Для экзамена вам нужно знать много правил о 
конструкторах. В этом разделе мы покажем, как создать конструктор. Затем мы рассмотрим конструкторы по умолчанию, 
перегрузку конструкторы, вызов родительских конструкторов, конечные поля и порядок инициализации в классе.

### Создание конструктора

Давайте начнем с простого конструктора:

```
public class Bunny {
   public Bunny() {
      System.out.print("hop");
   }
}
```

Имя конструктора Bunny совпадает с именем класса Bunny, а тип возвращаемого значения отсутствует, даже void. Это делает 
его конструктором. Можете ли вы сказать, почему эти два конструктора недопустимы для класса Bunny?

```
public class Bunny {
   public bunny() {} // DOES NOT COMPILE
   public void Bunny() {}
}
```

Первый не соответствует имени класса, потому что Java чувствителен к регистру. Поскольку он не совпадает, Java знает, 
что он не может быть конструктором и должен быть обычным методом. Однако в нем отсутствует возвращаемый тип, и он не 
компилируется. Второй метод — очень хороший метод, но он не является конструктором, поскольку имеет возвращаемый тип.

Как и параметры метода, параметры конструктора могут быть любым допустимым классом, массивом или примитивным типом, 
включая дженерики, но не могут включать var. Например, следующее не компилируется:

```
public class Bonobo {
   public Bonobo(var food) {  // DOES NOT COMPILE
   }
}
```

Класс может иметь несколько конструкторов, если каждый конструктор имеет уникальную сигнатуру конструктора. В данном 
случае это означает, что параметры конструктора должны быть разными. Подобно методам с одинаковым именем, но разными 
сигнатурами, объявление нескольких конструкторов с разными сигнатурами называется _перегрузкой конструктора_. Следующий 
класс Turtle имеет четыре различных перегруженных конструктора:

```
public class Turtle {
   private String name;
   public Turtle() {
      name = "John Doe";
   }
   public Turtle(int age) {}
   public Turtle(long age) {}
   public Turtle(String newName, String... favoriteFoods) {
      name = newName;
   }
}
```

Конструкторы используются при создании нового объекта. Этот процесс называется _созданием экземпляра_, поскольку он 
создает новый экземпляр класса. Конструктор вызывается, когда мы пишем new, за которым следует имя класса, который мы 
хотим создать. Вот пример:

```
new Turtle(15)
```

Когда Java видит ключевое слово new, она выделяет память для нового объекта. Затем он ищет конструктор с соответствующей
сигнатурой и вызывает его.

### Конструктор по умолчанию

У каждого класса в Java есть конструктор, независимо от того, пишете вы его или нет. Если вы не включите конструкторы в 
класс, Java создаст его без каких-либо параметров.

Этот созданный Java конструктор называется _конструктором по умолчанию_ и добавляется каждый раз, когда класс 
объявляется без каких-либо конструкторов. Для ясности мы часто называем его конструктором без аргументов по умолчанию. 
Вот пример:

```
public class Rabbit {
   public static void main(String[] args) {
      new Rabbit();       // Calls the default constructor
   }
}
```

В классе Rabbit Java видит, что конструктор не был закодирован, и создает его. Предыдущий класс эквивалентен следующему, 
в котором предоставляется конструктор по умолчанию и, следовательно, не вставляется компилятором:

```
public class Rabbit {
   public Rabbit() {}
   public static void main(String[] args) {
      new Rabbit();       // Calls the user-defined constructor
   }
}
```

Конструктор по умолчанию имеет пустой список параметров и пустое тело. Это нормально, если вы напечатаете это сами. 
Однако, поскольку он ничего не делает, Java с радостью сгенерирует его для вас и избавит вас от необходимости печатать.

Мы продолжаем говорить сгенерировано. Это происходит на этапе компиляции. Если вы посмотрите на файл с расширением 
.java, конструктор всё равно будет отсутствовать. Он появляется только в скомпилированном файле с расширением .class.

Для экзамена одно из самых важных правил, которое вам нужно знать, заключается в том, что компилятор вставляет 
конструктор по умолчанию только тогда, когда конструкторы не определены. Как вы думаете, у какого из этих классов есть 
конструктор по умолчанию?

```
public class Rabbit1 {}

public class Rabbit2 {
   public Rabbit2() {}
}

public class Rabbit3 {
   public Rabbit3(boolean b) {}
}

public class Rabbit4 {
   private Rabbit4() {}
}
```

Только Rabbit1 получает конструктор без аргументов по умолчанию. У него нет закодированного конструктора, поэтому Java 
генерирует конструктор по умолчанию без аргументов. У Rabbit2 и Rabbit3 уже есть общедоступные конструкторы. Rabbit4 
имеет private конструктор. Поскольку для этих трёх классов определен конструктор, конструктор без аргументов по 
умолчанию не вставляется.

Давайте кратко рассмотрим, как вызывать эти конструкторы:

```
1: public class RabbitsMultiply {
2:    public static void main(String[] args) {
3:       var r1 = new Rabbit1();
4:       var r2 = new Rabbit2();
5:       var r3 = new Rabbit3(true);
6:       var r4 = new Rabbit4();   // DOES NOT COMPILE
7:    } }
```

Строка 3 вызывает сгенерированный по умолчанию конструктор без аргументов. Строки 4 и 5 вызывают предоставленные 
пользователем конструкторы. Строка 6 не компилируется. Rabbit4 сделал конструктор private, чтобы другие классы не могли 
его вызвать.

_Наличие в классе только private конструкторов указывает компилятору не предоставлять конструктор по умолчанию без 
аргументов. Это также предотвращает создание экземпляра класса другими классами. Это полезно, когда класс имеет только 
static методы или разработчик хочет иметь полный контроль над всеми вызовами для создания новых экземпляров класса._

### Вызов перегруженных конструкторов с помощью this()

Вы разбираетесь в основах конструкторов и ссылок на них? Хорошо, потому что скоро всё станет немного сложнее. Поскольку
класс может содержать несколько перегруженных конструкторов, эти конструкторы могут вызывать друг друга. 
Давайте начнем с простого класса, содержащего два перегруженных конструктора:

```
public class Hamster {
   private String color;
   private int weight;
   public Hamster(int weight, String color) {   // First constructor
      this.weight = weight;
      this.color = color;
   }
   public Hamster(int weight) {   // Second constructor
      this.weight = weight;
      color = "brown";
   }
}
```

Один из конструкторов принимает единственный параметр типа int. Другой принимает int и String. Эти списки параметров 
отличаются, поэтому конструкторы успешно перегружаются.

Есть небольшое дублирование, так как this.weight присваивается одинаково в обоих конструкторах. В программировании даже 
небольшое дублирование имеет тенденцию превращаться в большое дублирование, поскольку мы продолжаем добавлять «еще одну 
вещь». Например, представьте, что у нас есть пять переменных, установленных как this.weight, а не только одна. На самом 
деле мы хотим, чтобы первый конструктор вызывал второй конструктор с двумя параметрами. Итак, как вы можете заставить 
конструктор вызывать другой конструктор? У вас может возникнуть соблазн переписать первый конструктор следующим образом:

```
public Hamster(int weight) {  // Second constructor
   Hamster(weight, "brown");  // DOES NOT COMPILE
}
```

Это не будет работать. Конструкторы можно вызывать, только написав new перед именем конструктора. Они не похожи на 
обычные методы, которые можно просто вызвать. Что произойдет, если мы вставим new перед именем конструктора?

```
public Hamster(int weight) {    // Second constructor
 new Hamster(weight, "brown");  // Компилируется, но создает дополнительный объект
}
```

Эта попытка действительно компилируется. Однако это не дает того, чего мы хотим. Когда вызывается этот конструктор, он 
создает новый объект с weight и color по умолчанию. Затем он создает другой объект с желаемым weight и color. 
Таким образом, в итоге мы получаем два объекта, один из которых отбрасывается после его создания. Это не то, чего мы 
хотим. Мы хотим, чтобы weight и color были установлены для объекта, который мы пытаемся создать в первую очередь.

Java предлагает решение: this() — да, то же самое ключевое слово, которое мы использовали для обозначения членов 
экземпляра, но с круглыми скобками. Когда this() используется со скобками, Java вызывает другой конструктор для того же 
экземпляра класса.

```
public Hamster(int weight) {   // Second constructor
   this(weight, "brown");
}
```

Успех! Теперь Java вызывает конструктор, который принимает два параметра с заданным weight и color, как и ожидалось.

---

#### this vs. this()

Несмотря на использование одного и того же ключевого слова, this и this() очень разные. Первый, this, относится к 
экземпляру класса, а второй, this(), относится к вызову конструктора внутри класса. Экзамен может попытаться обмануть 
вас, используя оба вместе, поэтому убедитесь, что вы знаете, какой из них использовать и почему.

---

Вызов this() имеет одно специальное правило, которое вам нужно знать. Если вы решите вызвать его, вызов this() должен 
быть первым оператором в конструкторе. Побочным эффектом этого является то, что в любом конструкторе может быть только 
один вызов this().

```
3:    public Hamster(int weight) {
4:       System.out.println("chew");
5:       // Set weight and default color
6:       this(weight, "brown");      // DOES NOT COMPILE
7:    }
```

Несмотря на то, что оператор печати в строке 4 не меняет никаких переменных, он все ещё является оператором Java, и его 
нельзя вставлять перед вызовом this(). Комментарий к строке 5 подходит. Комментарии не считаются утверждениями и 
разрешены в любом месте.

Есть ещё одно правило для перегруженных конструкторов, о котором вам следует знать. Рассмотрим следующее определение 
класса Gopher:

```
public class Gopher {
   public Gopher(int dugHoles) {
      this(5);   // DOES NOT COMPILE
   }
}
```

Компилятор способен определить, что этот конструктор бесконечно вызывает сам себя. Это часто называют циклом, и он 
похож на бесконечные циклы, которые мы обсуждали в главе 3 «Принятие решений». Поскольку код никогда не может 
завершиться, компилятор останавливается и сообщает об этом как об ошибке. Аналогично, это тоже не компилируется:

```
public class Gopher {
   public Gopher() {
      this(5);  // DOES NOT COMPILE
   }
   public Gopher(int dugHoles) {
      this();   // DOES NOT COMPILE
   }
}
```

В этом примере конструкторы вызывают друг друга, и процесс продолжается бесконечно. Поскольку компилятор может это 
обнаружить, он сообщает об ошибке.

Здесь мы суммируем правила, которые вы должны знать о конструкторах, которые мы рассмотрели в этом разделе. Изучите 
их хорошо!

+ Класс может содержать множество перегруженных конструкторов при условии, что сигнатура каждого из них отличается.
+ Компилятор вставляет конструктор по умолчанию без аргументов, если конструкторы не объявлены.
+ Если конструктор вызывает this(), то это должна быть первая строка конструктора.
+ Java не допускает циклических вызовов конструктора.

### Вызов родительских конструкторов с помощью super()

Поздравляем: вы уже на пути к тому, чтобы стать экспертом в использовании конструкторов! Тем не менее, есть ещё один 
набор правил, которые нам нужно рассмотреть для вызова конструкторов в родительском классе. В конце концов, как 
инициализируются члены экземпляра родительского класса?

Первым оператором каждого конструктора является вызов родительского конструктора с помощью super() или другого 
конструктора в классе с помощью this(). Прочитайте предыдущее предложение дважды, чтобы убедиться, что вы его запомнили.
Это действительно важно!

_Для простоты в этом разделе мы часто ссылаемся на super() и this() для обозначения любого вызова родительского или 
перегруженного конструктора, даже тех, которые принимают аргументы._

Давайте взглянем на класс Animal и его подкласс Zebra и посмотрим, как правильно написать их конструкторы, чтобы они 
вызывали друг друга:

```
public class Animal {
   private int age;
   public Animal(int age) {
      super();    // Refers to constructor in java.lang.Object
      this.age = age;
   }
}

public class Zebra extends Animal {
   public Zebra(int age) {
      super(age);   // Refers to constructor in Animal
   }
   public Zebra() {
      this(4);      // Refers to constructor in Zebra with int argument
   }
}
```

В классе Animal первая инструкция конструктора — это вызов родительского конструктора, определенного в java.lang.Object,
который не принимает аргументов. Во втором классе, Zebra, первый оператор первого конструктора — это вызов конструктора 
Animal, который принимает один аргумент. Класс Zebra также включает второй конструктор без аргументов, который не 
вызывает super(), а вместо этого вызывает другой конструктор в классе Zebra, используя this(4).

---

#### super vs. super()

Подобно this и this(), super и super() не связаны в Java. Первый, super, используется для ссылки на члены родительского 
класса, а второй, super(), вызывает родительский конструктор. Каждый раз, когда вы видите ключевое слово super на 
экзамене, убедитесь, что оно используется правильно.

---

Как и вызов this(), вызов super() можно использовать только в качестве первого оператора конструктора. Например, 
следующие два определения класса не будут компилироваться:

```
public class Zoo {
   public Zoo() {
      System.out.println("Zoo created");
      super();     // DOES NOT COMPILE
   }
}

public class Zoo {
   public Zoo() {
      super();
      System.out.println("Zoo created");
      super();     // DOES NOT COMPILE
   }
}
```

Первый класс не будет компилироваться, потому что вызов родительского конструктора должен быть первым оператором 
конструктора. Во втором фрагменте кода super() является первым оператором конструктора, но он также используется в 
качестве третьего оператора. Поскольку super() можно вызвать только один раз в качестве первого оператора конструктора, 
код не будет компилироваться.

Если родительский класс имеет более одного конструктора, дочерний класс может использовать в своем определении любой 
допустимый родительский конструктор, как показано в следующем примере:

```
public class Animal {
   private int age;
   private String name;
   public Animal(int age, String name) {
      super();
      this.age = age;
      this.name = name;
   }
   public Animal(int age) {
      super();
      this.age = age;
      this.name = null;
   }
}

public class Gorilla extends Animal {
   public Gorilla(int age) {
      super(age,"Gorilla");  // Calls the first Animal constructor
   }
   public Gorilla() {
      super(5);              // Calls the second Animal constructor
   }
}
```

В этом примере первый дочерний конструктор принимает один аргумент, age, и вызывает родительский конструктор, который 
принимает два аргумента, age и name. Второй дочерний конструктор не принимает аргументов и вызывает родительский 
конструктор, который принимает один аргумент — age. Обратите внимание, что в этом примере дочерние конструкторы не 
обязаны вызывать соответствующие родительские конструкторы. Любой допустимый родительский конструктор является 
допустимым, если предоставлены соответствующие входные параметры родительского конструктора.

### Понимание улучшений компилятора

Подождите секунду: мы сказали, что первая строка каждого конструктора является вызовом либо this(), либо super(), но в 
этой книге мы создавали классы и конструкторы, и мы редко делали то и другое. Как компилировались эти классы?

Ответ заключается в том, что компилятор Java автоматически вставляет вызов конструктора без аргументов super(), если вы 
явно не вызываете this() или super() в качестве первой строки конструктора. Например, следующие три определения класса 
и конструктора эквивалентны, потому что компилятор автоматически преобразует их все в последний пример:

```
public class Donkey {}

public class Donkey {
   public Donkey() {}
}

public class Donkey {
   public Donkey() {
      super();
   }
}
```

Убедитесь, что вы понимаете разницу между этими тремя определениями класса Donkey и почему Java автоматически 
преобразует их все в последнее определение. При чтении следующего раздела помните о процессе, который выполняет 
компилятор Java.

### Советы и рекомендации конструктора по умолчанию

До сих пор мы представили много правил, и вы могли кое-что заметить. Допустим, у нас есть класс, в котором нет 
конструктора без аргументов. Что произойдет, если мы определим подкласс без конструкторов или подкласс с конструктором, 
который не включает ссылку super()?

```
public class Mammal {
   public Mammal(int age) {}
}

public class Seal extends Mammal {}  // DOES NOT COMPILE

public class Elephant extends Mammal {
   public Elephant() {}              // DOES NOT COMPILE
}
```

Ответ заключается в том, что ни один из подклассов не компилируется. Поскольку Mammal определяет конструктор, компилятор
не вставляет конструктор без аргументов. Однако компилятор вставит конструктор по умолчанию без аргументов в Seal, но 
это будет простая реализация, которая просто вызывает несуществующий родительский конструктор по умолчанию.

```
public class Seal extends Mammal {
   public Seal() {
      super();    // DOES NOT COMPILE
   }
}
```

Точно так же Elephant не будет компилироваться по тем же причинам. Компилятор не видит вызов super() или this() в 
качестве первой строки конструктора, поэтому он автоматически вставляет вызов несуществующего super() без аргументов.

```
public class Elephant extends Mammal {
   public Elephant() {
      super();   // DOES NOT COMPILE
   }
}
```

В этих случаях компилятор не поможет, и вы должны создать хотя бы один конструктор в дочернем классе, который явно 
вызывает родительский конструктор с помощью команды super().

```
public class Seal extends Mammal {
   public Seal() {
      super(6);   // Explicit call to parent constructor
   }
}

public class Elephant extends Mammal {
   public Elephant() {
      super(4);   // Explicit call to parent constructor
   }
}
```

Подклассы могут включать конструкторы без аргументов, даже если их родительские классы этого не делают. Например, 
следующее компилируется, потому что Elephant включает конструктор без аргументов:

```
public class AfricanElephant extends Elephant {}
```

Мы знаем, что нужно многое понять. Для экзамена вы должны сразу понять, почему такие классы, как наши первые реализации 
Seal и Elephant, не компилировались.

---

#### super() Всегда относится к самому прямому родителю

У класса может быть несколько предков посредством наследования. В нашем предыдущем примере AfricanElephant является 
подклассом Elephant, который, в свою очередь, является подклассом Mammal. Однако для конструкторов super() всегда 
относится к самому прямому родителю. В этом примере вызов super() внутри класса AfricanElephant всегда относится к 
классу Elephant и никогда к классу Mammal.

---

Мы завершим этот раздел, добавив три правила конструктора к вашему набору навыков:

+ Первая строка каждого конструктора — это вызов родительского конструктора с помощью super() или перегруженного 
конструктора с помощью this().
+ Если конструктор не содержит ссылку this() или super(), компилятор автоматически вставляет super() без аргументов в 
качестве первой строки конструктора.
+ Если конструктор вызывает super(), то это должна быть первая строка конструктора.

Поздравляем: вы узнали всё, чему мы можем научить вас в объявлении конструкторов. Далее мы переходим к инициализации и 
обсудим, как использовать конструкторы.

## Инициализация объектов

В главе 1 мы рассмотрели порядок инициализации, хотя и очень упрощенно. Порядок инициализации относится к тому, как 
членам класса присваиваются значения. Им могут быть присвоены значения по умолчанию, например 0 для int, или могут 
потребоваться явные значения, например, для final переменных. В этом разделе мы более подробно рассмотрим, как 
работает порядок инициализации и как выявлять ошибки на экзамене.

### Инициализация классов

Мы начнем обсуждение порядка инициализации с инициализации класса. Во-первых, мы инициализируем класс, что включает в 
себя вызов всех static членов в иерархии классов, начиная с высшего суперкласса и спускаясь вниз. Это иногда называют 
_загрузкой (loading)_ класса. Виртуальная машина Java (JVM) контролирует, когда класс инициализируется, хотя вы можете 
предположить, что класс загружен до его использования. Класс может быть инициализирован при первом запуске программы, 
при ссылке на static член класса или незадолго до создания экземпляра класса.

Одно из наиболее важных правил инициализации класса состоит в том, что это происходит не более одного раза для каждого 
класса. Класс также может никогда не загружаться, если он не используется в программе. Мы резюмируем порядок 
инициализации класса следующим образом:

##### Инициализировать класс X

1. Если существует суперкласс Y класса X, то сначала инициализируйте класс Y.
2. Обработайте все объявления static переменных в том порядке, в котором они появляются в классе.
3. Обработайте все static инициализаторы в том порядке, в котором они появляются в классе.

Рассмотрим пример, что печатает следующая программа?

```
public class Animal {
   static { System.out.print("A"); }
}

public class Hippo extends Animal {
   public static void main(String[] grass) {
      System.out.print("C");
      new Hippo();
      new Hippo();
      new Hippo();
   }
   static { System.out.print("B"); }
}
```

Он печатает ABC ровно один раз. Поскольку метод main() находится внутри класса Hippo, класс будет инициализирован 
первым, начиная с суперкласса и выводя AB. После этого выполняется метод main(), печатающий C. Несмотря на то, что 
метод main() создает три экземпляра, класс загружается только один раз.

---

#### Почему программа Hippo напечатала C после AB

В предыдущем примере класс Hippo был инициализирован до выполнения метода main(). Это произошло из-за того, что наш 
метод main() находился внутри исполняемого класса, поэтому его нужно было загружать при запуске. Что, если вместо этого 
вы вызовете Hippo внутри другой программы?

```
public class HippoFriend {
   public static void main(String[] grass) {
      System.out.print("C");
      new Hippo();
   }
}
```

Предполагая, что на класс больше нигде не ссылаются, эта программа, скорее всего, напечатает CAB, при этом класс Hippo 
не будет загружен до тех пор, пока он не понадобится внутри метода main(). Мы говорим «вероятно», потому что правила 
загрузки классов определяются JVM во время выполнения. Для экзамена вам просто нужно знать, что класс должен быть 
инициализирован до того, как на него будут ссылаться или использовать. Кроме того, класс, содержащий точку входа в 
программу, также известный как метод main(), загружается до выполнения метода main().

---

### Инициализация final полей

Прежде чем мы углубимся в порядок инициализации членов экземпляра, нам нужно минутку поговорить о final полях 
(переменных экземпляра). Когда мы представили переменные экземпляра и класса в главе 1, мы сказали вам, что им 
присваивается значение по умолчанию на основе их типа, если значение не указано. Например, double инициализируется 
значением 0.0, а ссылка на объект инициализируется значением null. Однако значение по умолчанию применяется только к 
неконечному (non-final) полю.

Как вы видели в главе 5, final static переменным нужно явно присвоить значение ровно один раз. Поля, помеченные как 
final, подчиняются аналогичным правилам. Им могут быть присвоены значения в строке, в которой они объявлены, или в 
инициализаторе экземпляра.

```
public class MouseHouse {
   private final int volume;
   private final String name = "The Mouse House"; // Declaration assignment
   {
      volume = 10; // Instance initializer assignment
   }
}
```

Однако, в отличие от static членов класса, final поля экземпляра также могут быть установлены в конструкторе. 
Конструктор является частью процесса инициализации, поэтому ему разрешено назначать final переменные экземпляра.
Для сдачи экзамена нужно знать одно важное правило: _к моменту завершения работы конструктора всем final переменным 
экземпляра должно быть присвоено значение ровно один раз._

Давайте попробуем это на примере:

```
public class MouseHouse {
   private final int volume;
   private final String name;
   public MouseHouse() {
      this.name = "Empty House";   // Constructor assignment
   }
   {
      volume = 10;     // Instance initializer assignment
   }
}
```

В отличие от локальных final переменных, которые не обязаны иметь значение, если только они не используются на самом 
деле, final переменным экземпляра должно быть присвоено значение. Если им не присваивается значение при их объявлении 
или в инициализаторе экземпляра, то им должно быть присвоено значение в объявлении конструктора. Невыполнение этого 
требования приведет к ошибке компилятора в строке, объявляющей конструктор.

```
public class MouseHouse {
   private final int volume;
   private final String type;
   {
      this.volume = 10;
   }
   public MouseHouse(String type) {
      this.type = type;
   }
   public MouseHouse() {  // DOES NOT COMPILE
      this.volume = 2;    // DOES NOT COMPILE
   }
}
```

В этом примере компилируется первый конструктор, принимающий аргумент типа String. С точки зрения присвоения значений 
каждый конструктор рассматривается индивидуально, поэтому второй конструктор не компилируется. Во-первых, конструктору 
не удается установить значение для переменной type.

Компилятор обнаруживает, что значение никогда не устанавливается для type, и сообщает об ошибке в строке, где объявлен 
конструктор. Во-вторых, конструктор устанавливает значение для переменной volume, хотя ей уже было присвоено значение 
инициализатором экземпляра.

_На экзамене будьте осторожны с любыми переменными экземпляра, помеченными как final. Убедитесь, что им присвоено 
значение в строке, где они объявлены, в инициализаторе экземпляра или в конструкторе. Им следует присвоить значение 
только один раз, и отказ от присвоения значения считается ошибкой компилятора в конструкторе._

Как быть с final переменными экземпляра, когда конструктор вызывает другой конструктор в том же классе? В этом случае вы
должны внимательно следить за процессом, следя за тем, чтобы каждой final переменной экземпляра присваивалось значение 
ровно один раз. Мы можем заменить наш предыдущий плохой конструктор следующим, который компилируется:

```
public MouseHouse() {
   this(null);
}
```

Этот конструктор не выполняет никаких присваиваний каким-либо final переменным экземпляра, но вызывает конструктор 
MouseHouse(String), который, как мы видели, компилируется без проблем. Мы используем здесь null, чтобы 
продемонстрировать, что переменная не обязательно должна быть значением объекта. Мы можем присвоить null значение final 
переменным экземпляра, если они явно установлены.

### Инициализация экземпляров (Initializing Instances)

Мы рассмотрели инициализацию класса и final поля, теперь пришло время перейти к порядку инициализации объектов. 
Предупреждаем, что поначалу это может показаться немного громоздким, но вряд ли на экзамене будут заданы вопросы более 
сложные, чем примеры в этом разделе. Однако мы обещаем делать это медленно.

Во-первых, начните с конструктора самого низкого уровня, где используется ключевое слово new. Помните, что первая строка
каждого конструктора является вызовом this() или super(), и если она опущена, компилятор автоматически вставит вызов 
родительского конструктора без аргументов super(). Затем продвигайтесь вверх и обратите внимание на порядок 
конструкторов. Наконец, инициализируйте каждый класс, начиная с суперкласса, обрабатывая каждый инициализатор экземпляра
и конструктор в порядке, обратном их вызову. Мы резюмируем порядок инициализации экземпляра следующим образом:

##### Инициализация экземпляра X

1. Инициализируйте класс X, если он не был инициализирован ранее.
2. Если существует суперкласс Y для X, то сначала инициализируйте экземпляр Y.
3. Обработайте все объявления переменных экземпляра в том порядке, в котором они появляются в классе.
4. Обработайте все инициализаторы экземпляров в том порядке, в котором они появляются в классе.
5. Инициализируйте конструктор, включая любые перегруженные конструкторы, на которые ссылается this().

Давайте попробуем пример без наследования. Посмотрите, сможете ли вы понять, что выводит следующее приложение:

```
1: public class ZooTickets {
2:    private String name = "BestZoo";
3:    { System.out.print(name + "-"); }
4:    private static int COUNT = 0;
5:    static { System.out.print(COUNT + "-"); }
6:    static { COUNT += 10; System.out.print(COUNT + "-"); }
7:
8:    public ZooTickets() {
9:       System.out.print("z-");
10:   }
11:
12:   public static void main(String... patrons) {
13:      new ZooTickets();
14:   } }
```

Вывод следующий:

```
0-10-BestZoo-z
```

Во-первых, мы должны инициализировать класс. Поскольку суперкласс не объявлен, что означает, что суперклассом является 
Object, мы можем начать со static компонентов ZooTickets. В этом случае выполняются строки 4, 5 и 6, печатая 0- и 10-. 
Затем мы инициализируем экземпляр, созданный в строке 13. Опять же, поскольку суперкласс не объявлен, мы начинаем с 
компонентов экземпляра. Выполняются строки 2 и 3, что выводит BestZoo-. Наконец, мы запускаем конструктор в строках 
8–10, который выводит z-.

Далее давайте попробуем простой пример с наследованием:

```
class Primate {
   public Primate() {
      System.out.print("Primate-");
   } }
   
class Ape extends Primate {
   public Ape(int fur) {
      System.out.print("Ape1-");
   }
   public Ape() {
      System.out.print("Ape2-");
   } }
 
public class Chimpanzee extends Ape {
   public Chimpanzee() {
      super(2);
      System.out.print("Chimpanzee-");
   }
   public static void main(String[] args) {
      new Chimpanzee();
   } }
```

Компилятор вставляет команду super() в качестве первого оператора конструкторов Primate и Ape. Код будет выполняться с 
первым вызовом родительских конструкторов и даст следующий результат:

```
Primate-Ape1-Chimpanzee-
```

Обратите внимание, что вызывается только один из двух конструкторов Ape(). Вам нужно начать с вызова new Chimpanzee(), 
чтобы определить, какие конструкторы будут выполняться. Помните, что конструкторы выполняются снизу вверх, но поскольку 
первая строка каждого конструктора является вызовом другого конструктора, поток завершается выполнением родительского 
конструктора перед дочерним конструктором.

Следующий пример немного сложнее. Как вы думаете, что здесь происходит?

```
1:  public class Cuttlefish {
2:     private String name = "swimmy";
3:     { System.out.println(name); }
4:     private static int COUNT = 0;
5:     static { System.out.println(COUNT); }
6:     { COUNT++; System.out.println(COUNT); }
7:
8:     public Cuttlefish() {
9:        System.out.println("Constructor");
10:    }
11:
12:    public static void main(String[] args) {
13:       System.out.println("Ready");
14:       new Cuttlefish();
15:    } }
```

Вывод выглядит следующим образом:

```
0
Ready
swimmy
1
Constructor
```

Суперкласс не объявлен, поэтому мы можем пропустить любые шаги, связанные с наследованием. Сначала мы обрабатываем 
static переменные и static инициализаторы — строки 4 и 5, причем строка 5 выводит 0. Теперь, когда static инициализаторы
убраны, можно запустить метод main(), который выводит Ready. Затем мы создаем экземпляр, объявленный в строке 14. 
Строки 2, 3, и 6 обрабатываются, при этом строка 3 печатает swimmy, а строка 6 печатает 1. Наконец, в строках 8–10 
запускается конструктор, который печатает Constructor.

Готовы к более сложному примеру, который вы можете увидеть на экзамене? **Что выводит следующее?**

```
1:  class GiraffeFamily {
2:     static { System.out.print("A"); }
3:     { System.out.print("B"); }
4:
5:     public GiraffeFamily(String name) {
6:        this(1);
7:        System.out.print("C");
8:     }
9:
10:    public GiraffeFamily() {
11:       System.out.print("D");
12:    }
13:
14:    public GiraffeFamily(int stripes) {
15:       System.out.print("E");
16:    }
17: }
18: public class Okapi extends GiraffeFamily {
19:    static { System.out.print("F"); }
20:
21:    public Okapi(int stripes) {
22:       super("sugar");
23:       System.out.print("G");
24:    }
25:    { System.out.print("H"); }
26:
27:    public static void main(String[] grass) {
28:       new Okapi(1);
29:       System.out.println();
30:       new Okapi(2);
31:    }
32: }
```

Программа выводит следующее:

```
AFBECHG
BECHG
```

Давайте пройдемся по нему. Начните с инициализации класса Okapi. Поскольку у него есть надкласс GiraffeFamily, сначала 
инициализируйте его, напечатав A в строке 2. Затем инициализируйте класс Okapi, напечатав F в строке 19.

После инициализации классов выполните метод main() в строке 27. Первая строка метода main() создает новый объект Okapi, 
запуская процесс инициализации экземпляра. Согласно первому правилу, сначала инициализируется экземпляр суперкласса 
GiraffeFamily. В соответствии с нашим третьим правилом вызывается инициализатор экземпляра в суперклассе GiraffeFamily, 
и B печатается в строке 3. В соответствии с четвертым правилом мы инициализируем конструкторы. В данном случае это 
включает в себя вызов конструктора в строке 5, который, в свою очередь, вызывает перегруженный конструктор в строке 14. 
В результате печатается EC, поскольку тела конструктора разворачиваются в порядке, обратном их вызову.

Затем процесс продолжается инициализацией самого экземпляра Okapi. Согласно третьему и четвертому правилам, H печатается
в строке 25, а G — в строке 23 соответственно. Процесс намного упрощается, когда вам не нужно вызывать какие-либо 
перегруженные конструкторы. Строка 29 затем вставляет разрыв строки в вывод. Наконец, строка 30 инициализирует новый 
объект Okapi. Порядок и инициализация такие же, как в строке 28, за исключением инициализации класса, поэтому BECHG 
печатается снова. Обратите внимание, что D никогда не печатается, так как вызываются только два из трех конструкторов в 
суперклассе GiraffeFamily.

Этот пример сложен по нескольким причинам. Есть несколько перегруженных конструкторов, множество инициализаторов и 
сложный путь конструктора, который нужно отслеживать. К счастью, подобные вопросы на экзамене встречаются редко.
Если вы видите такое, просто запишите, что происходит, когда вы читаете код.

Мы завершаем этот раздел перечислением важных правил, которые вы должны знать перед экзаменом:

+ Класс инициализируется JVM не более одного раза, прежде чем на него ссылаются или используют.
+ Всем static final переменным должно быть присвоено значение ровно один раз, либо при их объявлении, либо в статическом
инициализаторе.
+ Всем final полям должно быть присвоено значение ровно один раз, либо при их объявлении, либо в инициализаторе 
экземпляра, либо в конструкторе.
+ Non-final static переменные и переменные экземпляра, определенные без значения, получают значение по умолчанию в 
зависимости от их типа.
+ Порядок инициализации следующий: объявления переменных, затем инициализаторы и, наконец, конструкторы.

## Inheriting Members

Теперь, когда мы создали класс, что мы можем с ним сделать? Одной из самых сильных сторон Java является использование 
модели наследования для упрощения кода. Например, предположим, что у вас есть пять классов, каждый из которых является 
продолжением класса Animal. Кроме того, каждый класс определяет метод eat() с идентичной реализацией. В этом случае 
намного лучше определить функцию eat() один раз в классе Animal, чем поддерживать один и тот же метод в пяти отдельных 
классах.

Наследование класса не только предоставляет доступ к унаследованным методам в родительском классе, но также создает 
условия для конфликтов между методами, определенными как в родительском классе, так и в подклассе. В этом разделе мы 
рассмотрим правила наследования методов и то, как Java обрабатывает такие сценарии.

Мы называем способность объекта принимать различные формы _полиморфизмом_. Мы рассмотрим это подробнее в следующей 
главе, а сейчас вам просто нужно знать, что объект можно использовать различными способами, частично на основе 
ссылочной переменной, используемой для вызова объекта.

### Переопределение метода

Что, если метод с одинаковой сигнатурой определен как в родительском, так и в дочернем классе? Например, вы можете 
захотеть определить новую версию метода и изменить его поведение для этого подкласса. Решение состоит в том, чтобы 
переопределить метод в дочернем классе. В Java _переопределение_ метода происходит, когда подкласс объявляет новую 
реализацию унаследованного метода с той же сигнатурой и совместимым типом возвращаемого значения.

_Помните, что сигнатура метода состоит из имени метода и параметров метода. Он не включает возвращаемый тип, 
модификаторы доступа, необязательные спецификаторы или любые объявленные исключения._

Когда вы переопределяете метод, вы по-прежнему можете ссылаться на родительскую версию метода, используя ключевое слово 
super. Таким образом, ключевые слова this и super позволяют выбирать между текущей и родительской версиями метода 
соответственно. Проиллюстрируем это на следующем примере:

```
public class Marsupial {
   public double getAverageWeight() {
      return 50;
   }
}
public class Kangaroo extends Marsupial {
   public double getAverageWeight() {
      return super.getAverageWeight()+20;
   }
   public static void main(String[] args) {
      System.out.println(new Marsupial().getAverageWeight());  // 50.0
      System.out.println(new Kangaroo().getAverageWeight());   // 70.0
   }
}
```

В этом примере класс Kangaroo переопределяет метод getAverageWeight(), но в процессе вызывает родительскую версию, 
используя суперссылку.

---

#### Метод, переопределяющий бесконечные вызовы (Method Overriding Infinite Calls)

Вам может быть интересно, требовалось ли использование super в предыдущем примере. Например, что выведет следующий код, 
если мы удалим ключевое слово super?

```
public double getAverageWeight() {
   return getAverageWeight()+20;    // StackOverflowError
}
```

В этом примере компилятор не будет вызывать родительский метод Marsupial; он вызовет текущий метод Kangaroo. Приложение 
попытается бесконечно вызывать себя и выдаст ошибку StackOverflowError во время выполнения.

Чтобы переопределить метод, вы должны следовать ряду правил. Компилятор выполняет следующие проверки при переопределении
метода:

1. Метод дочернего класса должен иметь ту же сигнатуру, что и метод родительского класса.
2. Метод в дочернем классе должен быть как минимум таким же доступным, как и метод в родительском классе.
3. Метод в дочернем классе не может объявлять проверенное исключение, которое является новым или шире, чем класс любого 
исключения, объявленного в методе родительского класса.
4. Если метод возвращает значение, оно должно быть тем же или подтипом метода в родительском классе, известном как 
ковариантные типы возвращаемых значений.

Хотя на первый взгляд эти правила могут показаться запутанными или произвольными, они необходимы для согласованности. 
Без этих правил в языке Java могут возникнуть противоречия.

### Правило #1: Сигнатуры методов

Первое правило переопределения метода не требует пояснений. Если два метода имеют одинаковое имя, но разные сигнатуры, 
методы перегружаются, а не переопределяются. Перегруженные методы считаются независимыми и не имеют таких же полиморфных
свойств, как переопределенные методы.

_Мы рассмотрели перегрузку метода в главе 5, и она похожа на переопределение метода, поскольку в обоих случаях 
используется определение метода с использованием одного и того же имени. Перегрузка отличается от переопределения тем, 
что перегруженные методы используют другой список параметров. Для экзамена важно, чтобы вы понимали это различие и 
чтобы у переопределенных методов была та же сигнатура и гораздо больше правил, чем у перегруженных методов._

### Правило #2: Модификаторы доступа

Какова цель второго правила о модификаторах доступа? Давайте попробуем привести наглядный пример:

```
public class Camel {
   public int getNumberOfHumps() {
      return 1;
   } }
   
public class BactrianCamel extends Camel {
   private int getNumberOfHumps() { // DOES NOT COMPILE
      return 2;
   } }
```

В этом примере BactrianCamel пытается переопределить метод getNumberOfHumps(), определенный в родительском классе, но 
терпит неудачу, поскольку модификатор доступа private имеет более строгие ограничения, чем модификатор, определенный в 
родительской версии метода. Допустим, BactrianCamel разрешили компилировать. Будет ли этот класс компилироваться?

```
public class Rider {
   public static void main(String[] args) {
      Camel c = new BactrianCamel();
      System.out.print(c.getNumberOfHumps()); // ???
   } }
```

Ответ: мы не знаем. Ссылочным типом объекта является Camel, где метод объявлен public, но на самом деле объект является 
экземпляром типа BactrianCamel, где метод объявлен private. Java позволяет избежать подобных проблем неоднозначности, 
ограничивая переопределение метода доступом к модификаторам, которые доступны или более доступны, чем версия в 
унаследованном методе.

### Правило #3: Проверенные исключения

Третье правило говорит о том, что переопределение метода не может объявлять новые проверенные исключения или проверенные
исключения более широкие, чем унаследованный метод. Это делается из полиморфных соображений, аналогичных модификаторам 
ограничения доступа. Другими словами, вы можете получить объект с более строгими ограничениями, чем ссылочный тип, 
которому он назначен, что приведет к проверенному исключению, которое не обрабатывается и не объявляется. Одним из 
следствий этого правила является то, что переопределенные методы могут свободно объявлять любое количество новых 
непроверенных исключений.

_Если вы не знаете, что такое проверенное или непроверенное исключение, не волнуйтесь. Мы рассмотрим это в главе 11, 
«Исключения и локализация». Пока вам просто нужно знать, что правило применяется только к проверенным исключениям. Также
полезно знать, что и IOException, и FileNotFoundException являются проверенными исключениями и что FileNotFoundException
является подклассом IOException._

Давайте попробуем на примере:

```
public class Reptile {
   protected void sleep() throws IOException {}
   
   protected void hide() {}
   
   protected void exitShell() throws FileNotFoundException {}
}

public class GalapagosTortoise extends Reptile {
   public void sleep() throws FileNotFoundException {}
   
   public void hide() throws FileNotFoundException {}   // DOES NOT COMPILE
 
   public void exitShell() throws IOException {}        // DOES NOT COMPILE
}
```

В этом примере у нас есть три переопределенных метода. Эти переопределенные методы используют более доступный 
модификатор public, разрешенный нашим вторым правилом для переопределенных методов. Первый переопределенный метод 
sleep() в GalapagosTortoise компилируется без проблем, потому что объявленное исключение более узкое, чем исключение, 
объявленное в родительском классе.

Переопределенный метод hide() не компилируется, поскольку он объявляет новое проверенное исключение, отсутствующее в 
родительском объявлении. Переопределенный метод exitShell() также не компилируется, поскольку IOException является более
широким проверяемым исключением, чем FileNotFoundException. Мы еще раз вернемся к этим классам исключений, в том числе 
запомним, какие из них являются подклассами друг друга, в главе 11.

### Правило #4: Ковариантные возвращаемые типы

Четвертое и последнее правило, касающееся переопределения метода, вероятно, является самым сложным, поскольку оно 
требует знания взаимосвязей между возвращаемыми типами. Переопределяемый метод должен использовать возвращаемый тип, 
который является ковариантным с возвращаемым типом унаследованного метода.

Давайте попробуем привести пример в иллюстративных целях:

```
public class Rhino {
   protected CharSequence getName() {
      return "rhino";
   }
   protected String getColor() {
      return "grey, black, or white";
   } }
   
public class JavanRhino extends Rhino {
   public String getName() {
      return "javan rhino";
   }
   public CharSequence getColor() {     // DOES NOT COMPILE
      return "grey";
   } }
```

Подкласс JavanRhino пытается переопределить два метода Rhino: getName() и getColor(). Оба переопределенных метода имеют 
то же имя и сигнатуру, что и унаследованные методы. Переопределенные методы также имеют более широкий модификатор 
доступа public, чем унаследованные методы. Помните, что в переопределенном методе допустим более широкий модификатор 
доступа.

Из главы 4 «Основные API» мы узнали, что String реализует интерфейс CharSequence, что делает String подтипом 
CharSequence. Следовательно, возвращаемый тип getName() в JavanRhino ковариантен с возвращаемым типом getName() в Rhino.

С другой стороны, переопределенный метод getColor() не компилируется, поскольку CharSequence не является подтипом 
String. Иными словами, все значения String являются значениями CharSequence, но не все значения CharSequence являются 
значениями String. Например, StringBuilder — это CharSequence, а не String. Для экзамена вам нужно знать, является ли 
возвращаемый тип переопределенного метода таким же, как или подтипом возвращаемого типа унаследованного метода.

_Простой тест на ковариантность заключается в следующем: учитывая унаследованный тип возвращаемого значения A и 
переопределяющий тип возвращаемого значения B, можете ли вы присвоить экземпляр B ссылочной переменной для A без 
приведения? Если да, то они ковариантны. Это правило применяется как к примитивным типам, так и к объектным типам. 
Если один из возвращаемых типов void, то они оба должны быть void, так как ничто не является 
ковариантным с void, кроме самого себя._

Это всё, что вам нужно знать о переопределении методов для этой главы. В главе 9 «Коллекции и дженерики» мы 
ещё раз вернемся к переопределяющим методам, использующим универсальные шаблоны. Всегда есть чему поучиться!

---

#### Сценарий реального мира

#### Маркировка методов с помощью аннотации @Override

Аннотация — это тег метаданных, который предоставляет дополнительную информацию о вашем коде. Вы можете использовать 
аннотацию @Override, чтобы сообщить компилятору, что вы пытаетесь переопределить метод.

```
public class Fish {
   public void swim() {};
}
public class Shark extends Fish {
   @Override
   public void swim() {};
}
```

При правильном использовании аннотация не влияет на код. С другой стороны, при неправильном использовании эта аннотация 
может уберечь вас от ошибки. Следующее не компилируется из-за наличия аннотации @Override:

```
public class Fish {
   public void swim() {};
}
public class Shark extends Fish {
   @Override
   public void swim(int speed) {};  // DOES NOT COMPILE
}
```

Компилятор видит, что вы пытаетесь переопределить метод, и ищет унаследованную версию swim(), которая принимает значение
int. Поскольку компилятор не находит его, он сообщает об ошибке. Хотя знание сложных тем (например, как создавать 
аннотации) не требуется для экзамена, знание того, как их правильно использовать, необходимо.

---













































