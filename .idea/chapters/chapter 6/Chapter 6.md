`# Дизайн класса (or Проектирование класса)

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Создавать классы и записи, а также определять и использовать: экземпляры объекта, статические поля и методы,
  конструкторы, а также экземпляры объекта и статические инициализаторы
+ Понимать области видимости переменных, использовать вывод типа локальной переменной, применять инкапсуляцию и делать 
  объекты неизменяемыми
+ Реализуйте полиморфизм и различайте тип объекта по сравнению с ссылочным типом. Выполнение приведения типов, 
   идентификация типов объектов с помощью оператора instanceof и сопоставления с образцом

---

В главе 1 «Строительные блоки» мы представили базовое определение класса в Java. В главе 5 «Методы» мы подробно 
рассмотрели методы и модификаторы и показали, как их можно использовать для создания более структурированных классов. 
В этой главе мы пойдем еще дальше и покажем, что структура классов и наследование — одна из самых мощных функций языка 
Java.

По своей сути правильный дизайн классов Java связан с повторным использованием кода, расширенной функциональностью и 
стандартизацией. Например, создав новый класс, который расширяет существующий класс, вы можете получить доступ к 
множеству унаследованных примитивов, объектов и методов, что увеличивает повторное использование кода.

Эта глава является кульминацией некоторых из наиболее важных тем в Java, включая наследование, проектирование классов, 
конструкторы, порядок инициализации, методы переопределения, абстрактные классы и неизменяемые объекты. Внимательно 
прочитайте эту главу и убедитесь, что вы хорошо понимаете все темы. Эта глава составляет основу главы 7 
«Помимо классов», в которой мы расширяем обсуждение типов, включив в него другие высокоуровневые и вложенные типы.

## Понимание наследования

При создании нового класса в Java вы можете определить класс как унаследованный от существующего класса. 
Наследование — это процесс, посредством которого подкласс автоматически включает определенные члены класса, включая 
примитивы, объекты или методы, определенные в родительском классе.

В иллюстративных целях мы называем любой класс, наследуемый от другого класса, _подклассом_ или _дочерним классом_, 
поскольку он считается потомком этого класса. В качестве альтернативы мы называем класс, от которого наследует потомок, 
_суперклассом_ или _родительским_ классом, поскольку он считается предком класса.

_При работе с другими типами, такими как интерфейсы, мы обычно используем общие термины подтип и супертип. Подробнее об 
этом вы узнаете в следующей главе._

### Объявление подкласса

Начнем с объявления класса и его подкласса. На рис. 6.1 показан пример суперкласса Mammal и подкласса Rhinoceros.

#### Рис. 6.1 - Объявление подкласса и суперкласса


Мы указываем, что класс является подклассом, объявляя его с помощью ключевого слова extends. Нам не нужно ничего 
объявлять в суперклассе, кроме как убедиться, что он не помечен как final. Подробнее об этом в ближайшее время.

Одним из ключевых аспектов наследования является его транзитивность. Для трех классов [X, Y, Z], если X расширяет Y, а 
Y расширяет Z, то X считается подклассом или потомком Z. Точно так же Z является суперклассом или предком X. 
Иногда мы используем термин прямой подкласс или потомок, чтобы указать, что класс напрямую расширяет родительский класс.
Например, X является прямым потомком только класса Y, а не Z.

В предыдущей главе вы узнали, что существует четыре уровня доступа: public, protected, package и private. Когда один 
класс наследуется от родительского класса, все public и protected члены автоматически становятся частью дочернего 
класса. Если два класса находятся в одном пакете, члены пакета доступны дочернему классу. И последнее, но не менее 
важное: private члены ограничены классом, в котором они определены, и никогда не доступны через наследование. 
Это не означает, что родительский класс не может иметь private членов, которые могут хранить данные или изменять объект; 
это просто означает, что подкласс не имеет к ним прямого доступа.

Давайте рассмотрим простой пример:

```
public class BigCat {
   protected double size;
}

public class Jaguar extends BigCat {
   public Jaguar() {
      size = 10.2;
   }
   public void printDetails() {
      System.out.print(size);
   }
}

public class Spider {
   public void printDetails() {
      System.out.println(size);     // DOES NOT COMPILE
   }
}
```

Jaguar является подклассом или потомком BigCat, что делает BigCat надклассом или родителем Jaguar. В классе Jaguar 
size доступен, потому что он помечен как protected. С помощью наследования подкласс Jaguar может читать или 
записывать size, как если бы он был его собственным членом. Сравните это с классом Spider, у которого нет доступа к 
size, поскольку он не наследуется.

### Модификаторы класса

Подобно методам и переменным, объявление класса может иметь различные модификаторы. В Таблице 6.1 перечислены 
модификаторы, которые вы должны знать для экзамена.

#### Таблица 6.1 - Модификаторы класса

|    Модификатор    | Описание                                                                                                                  | Охваченная глава |  
|:-----------------:|:--------------------------------------------------------------------------------------------------------------------------|:----------------:|
|       final       | Класс не может быть расширен.                                                                                             |     Глава 6      |                                     
|     abstract      | Класс является абстрактным, может содержать абстрактные методы<br/>  и требует создания экземпляра конкретного подкласса. |     Глава 6      |                                        
|      sealed       | Класс может быть расширен только определенным списком классов.                                                                                                                      |     Глава 7      |                                   
|    non-sealed     | Подкласс закрытого класса допускает потенциально неназванные подклассы.                                                                                                                       |     Глава 7      |
|      static       | Используется для static вложенных классов, определенных внутри класса.                                                                                                             |     Глава 7      |

Мы рассмотрим abstract классы позже в этой главе. В следующей главе мы рассмотрим sealed и non-sealed классы, а также 
static вложенные классы.

А пока давайте поговорим об отметке final класса. Модификатор final предотвращает дальнейшее расширение класса. 
Например, следующее не компилируется:

```
public final class Rhinoceros extends Mammal { }

public class Clara extends Rhinoceros { } // DOES NOT COMPILE
```

На экзамене обратите внимание на любой класс с пометкой final. Если вы видите другой класс, расширяющий его, вы сразу 
понимаете, что код не компилируется.

### Одиночное и множественное наследование

Java поддерживает _одиночное наследование_, при котором класс может наследовать только от одного прямого родительского 
класса. Java также поддерживает несколько уровней наследования, посредством которых один класс может расширять другой 
класс, который, в свою очередь, расширяет другой класс. Вы можете иметь любое количество уровней наследования, позволяя 
каждому потомку получить доступ к членам своего предка.

Чтобы по-настоящему понять одиночное наследование, полезно сравнить его с множественным наследованием, при котором у 
класса может быть несколько прямых родителей. Java не поддерживает множественное наследование в языке, потому что 
множественное наследование может привести к сложным, часто трудным для сопровождения моделям данных. Java допускает 
одно исключение из правила единственного наследования, которое вы видите в главе 7 — класс может реализовывать несколько
интерфейсов.

На рис. 6.2 показаны различные типы моделей наследования. Элементы слева считаются одиночным наследованием, поскольку у 
каждого потомка есть только один родитель. Вы можете заметить, что одиночное наследование не мешает родителям иметь 
несколько детей. Справа показаны элементы, имеющие множественное наследование. Как видите, объект Dog имеет несколько 
родительских обозначений.

#### Рис. 6.2 - Типы наследования


Часть того, что усложняет множественное наследование, — это определение того, от какого родителя наследовать значения в 
случае конфликта. Например, если у вас есть объект или метод, определенный во всех родителях, какой из них наследует 
потомок? В этом примере нет естественного порядка для родителей, поэтому Java избегает этих проблем, полностью запрещая 
множественное наследование.

### Наследование объекта 

При обсуждении Java в этой книге мы много раз использовали слово «объект» — и не без оснований. В Java все классы 
наследуются от одного класса: java.lang.Object или для краткости Object. Кроме того, Object — единственный класс, у 
которого нет родительского класса.

Вы можете задаться вопросом: «Ни один из классов, которые я написал до сих пор, не расширяет Object, так как же все 
классы наследуют от него?» Ответ заключается в том, что компилятор автоматически вставляет код в любой написанный вами 
класс, который не расширяет конкретный класс. Например, следующие два эквивалентны:

```
public class Zoo { }

public class Zoo extends java.lang.Object { }
```

Суть в том, что когда Java видит, что вы определяете класс, который не расширяет другой класс, компилятор автоматически 
добавляет синтаксис extends java.lang.Object в определение класса. В результате каждый класс получает доступ к любым 
доступным методам класса Object. Например, методы toString() и equals() доступны в Object; следовательно, они доступны 
во всех классах. Однако без переопределения в подклассе они могут быть не особенно полезны. Мы рассмотрим методы 
переопределения позже в этой главе.

С другой стороны, когда вы определяете новый класс, который расширяет существующий класс, Java не расширяет 
автоматически класс Object. Поскольку все классы наследуются от Object, расширение существующего класса означает, что 
дочерний класс уже наследуется от Object по определению. Если вы посмотрите на структуру наследования любого класса, 
она всегда будет заканчиваться Object в верхней части дерева, как показано на рис. 6.3.

#### Рис. 6.3 - Наследование объектов Java


Примитивные типы, такие как int и boolean, не наследуются от Object, поскольку они не являются классами. Как вы узнали 
из главы 5, с помощью автоупаковки они могут быть назначены или переданы как экземпляр объекта связанного 
класса-оболочки, который наследует Object.

## Создание классов

Теперь, когда мы поняли, как работает наследование в Java, мы можем использовать его для определения и создания сложных
отношений между классами. В этом разделе мы рассмотрим основы создания классов и работы с ними.

### Расширение класса

Давайте создадим два файла в одном пакете, Animal.java и Lion.java.

```
// Animal.java
public class Animal {
   private int age;
   protected String name;
   public int getAge() {
      return age;
   }
   public void setAge(int newAge) {
      age = newAge;
   }
}

// Lion.java
public class Lion extends Animal {
   protected void setProperties(int age, String n) {
      setAge(age);
      name = n;
   }
   public void roar() {
      System.out.print(name + ", age " + getAge() + ", says: Roar!");
   }
   public static void main(String[] args) {
      var lion = new Lion();
      lion.setProperties(3, "kion");
      lion.roar();
   }
}
```

Здесь много всего происходит, мы знаем! Переменная age существует в родительском классе Animal и недоступна напрямую в 
дочернем классе Lion. Он косвенно доступен через метод setAge(). Переменная name protected, поэтому она наследуется в 
классе Lion и доступна напрямую. Мы создаем экземпляр Lion в методе main() и используем setProperties() для установки 
переменных экземпляра. Наконец, мы вызываем метод roar(), который выводит следующее:

```
kion, age 3, says: Roar!
```

Давайте посмотрим на членов класса Lion. Переменная экземпляра age помечена как private и недоступна напрямую из 
подкласса Lion. Следовательно, следующее не будет компилироваться:

```
public class Lion extends Animal {
   public void roar() {
      System.out.print("Lions age: " + age);  // DOES NOT COMPILE
   }
}
```

При работе с подклассами помните, что private члены никогда не наследуются, а члены пакета наследуются только в том 
случае, если два класса находятся в одном пакете. Если вам нужно освежить в памяти модификаторы доступа, вам стоит ещё 
раз прочитать главу 5.

### Применение модификаторов доступа к классу

Подобно переменным и методам, к классам можно применять модификаторы доступа. Как вы, возможно, помните из главы 1, 
класс верхнего уровня не определен внутри другого класса. Также помните, что файл .java может иметь не 
более одного класса верхнего уровня.

Хотя у вас может быть только один класс верхнего уровня, вы можете иметь столько классов (в любом порядке) с доступом к 
пакету, сколько захотите. На самом деле вам даже не нужно объявлять публичный класс! Далее объявляются три класса, 
каждый из которых имеет доступ к пакету:

```
// Bear.java
class Bird {}
class Bear {}
class Fish {}
```

Однако попытка объявить класс верхнего уровня с protected или private классом приведет к ошибке компилятора:

```
// ClownFish.java
protected class ClownFish{} // DOES NOT COMPILE

// BlueTang.java
private class BlueTang {} // DOES NOT COMPILE
```

Означает ли это, что класс нельзя объявить protected или private? Не совсем. В главе 7 мы представим вложенные типы и 
покажем, что, когда вы определяете класс внутри другого, он может использовать любой модификатор доступа.

### Доступ к this ссылке







`