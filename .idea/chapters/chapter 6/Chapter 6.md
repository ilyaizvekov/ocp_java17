`# Дизайн класса (or Проектирование класса)

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Создавать классы и записи, а также определять и использовать: экземпляры объекта, статические поля и методы,
  конструкторы, а также экземпляры объекта и статические инициализаторы
+ Понимать области видимости переменных, использовать вывод типа локальной переменной, применять инкапсуляцию и делать 
  объекты неизменяемыми
+ Реализуйте полиморфизм и различайте тип объекта по сравнению с ссылочным типом. Выполнение приведения типов, 
   идентификация типов объектов с помощью оператора instanceof и сопоставления с образцом

---

В главе 1 «Строительные блоки» мы представили базовое определение класса в Java. В главе 5 «Методы» мы подробно 
рассмотрели методы и модификаторы и показали, как их можно использовать для создания более структурированных классов. 
В этой главе мы пойдем еще дальше и покажем, что структура классов и наследование — одна из самых мощных функций языка 
Java.

По своей сути правильный дизайн классов Java связан с повторным использованием кода, расширенной функциональностью и 
стандартизацией. Например, создав новый класс, который расширяет существующий класс, вы можете получить доступ к 
множеству унаследованных примитивов, объектов и методов, что увеличивает повторное использование кода.

Эта глава является кульминацией некоторых из наиболее важных тем в Java, включая наследование, проектирование классов, 
конструкторы, порядок инициализации, методы переопределения, абстрактные классы и неизменяемые объекты. Внимательно 
прочитайте эту главу и убедитесь, что вы хорошо понимаете все темы. Эта глава составляет основу главы 7 
«Помимо классов», в которой мы расширяем обсуждение типов, включив в него другие высокоуровневые и вложенные типы.

## Понимание наследования

При создании нового класса в Java вы можете определить класс как унаследованный от существующего класса. 
Наследование — это процесс, посредством которого подкласс автоматически включает определенные члены класса, включая 
примитивы, объекты или методы, определенные в родительском классе.

В иллюстративных целях мы называем любой класс, наследуемый от другого класса, _подклассом_ или _дочерним классом_, 
поскольку он считается потомком этого класса. В качестве альтернативы мы называем класс, от которого наследует потомок, 
_суперклассом_ или _родительским_ классом, поскольку он считается предком класса.

_При работе с другими типами, такими как интерфейсы, мы обычно используем общие термины подтип и супертип. Подробнее об 
этом вы узнаете в следующей главе._

### Объявление подкласса

Начнем с объявления класса и его подкласса. На рис. 6.1 показан пример суперкласса Mammal и подкласса Rhinoceros.

#### Рис. 6.1 - Объявление подкласса и суперкласса


Мы указываем, что класс является подклассом, объявляя его с помощью ключевого слова extends. Нам не нужно ничего 
объявлять в суперклассе, кроме как убедиться, что он не помечен как final. Подробнее об этом в ближайшее время.

Одним из ключевых аспектов наследования является его транзитивность. Для трех классов [X, Y, Z], если X расширяет Y, а 
Y расширяет Z, то X считается подклассом или потомком Z. Точно так же Z является суперклассом или предком X. 
Иногда мы используем термин прямой подкласс или потомок, чтобы указать, что класс напрямую расширяет родительский класс.
Например, X является прямым потомком только класса Y, а не Z.

В предыдущей главе вы узнали, что существует четыре уровня доступа: public, protected, package и private. Когда один 
класс наследуется от родительского класса, все public и protected члены автоматически становятся частью дочернего 
класса. Если два класса находятся в одном пакете, члены пакета доступны дочернему классу. И последнее, но не менее 
важное: private члены ограничены классом, в котором они определены, и никогда не доступны через наследование. 
Это не означает, что родительский класс не может иметь private членов, которые могут хранить данные или изменять объект; 
это просто означает, что подкласс не имеет к ним прямого доступа.

Давайте рассмотрим простой пример:

```
public class BigCat {
   protected double size;
}

public class Jaguar extends BigCat {
   public Jaguar() {
      size = 10.2;
   }
   public void printDetails() {
      System.out.print(size);
   }
}

public class Spider {
   public void printDetails() {
      System.out.println(size);     // DOES NOT COMPILE
   }
}
```

Jaguar является подклассом или потомком BigCat, что делает BigCat надклассом или родителем Jaguar. В классе Jaguar 
size доступен, потому что он помечен как protected. С помощью наследования подкласс Jaguar может читать или 
записывать size, как если бы он был его собственным членом. Сравните это с классом Spider, у которого нет доступа к 
size, поскольку он не наследуется.

### Модификаторы класса

Подобно методам и переменным, объявление класса может иметь различные модификаторы. В Таблице 6.1 перечислены 
модификаторы, которые вы должны знать для экзамена.

#### Таблица 6.1 - Модификаторы класса

|    Модификатор    | Описание                                                                                                                  | Охваченная глава |  
|:-----------------:|:--------------------------------------------------------------------------------------------------------------------------|:----------------:|
|       final       | Класс не может быть расширен.                                                                                             |     Глава 6      |                                     
|     abstract      | Класс является абстрактным, может содержать абстрактные методы<br/>  и требует создания экземпляра конкретного подкласса. |     Глава 6      |                                        
|      sealed       | Класс может быть расширен только определенным списком классов.                                                                                                                      |     Глава 7      |                                   
|    non-sealed     | Подкласс закрытого класса допускает потенциально неназванные подклассы.                                                                                                                       |     Глава 7      |
|      static       | Используется для static вложенных классов, определенных внутри класса.                                                                                                             |     Глава 7      |

Мы рассмотрим abstract классы позже в этой главе. В следующей главе мы рассмотрим sealed и non-sealed классы, а также 
static вложенные классы.

А пока давайте поговорим об отметке final класса. Модификатор final предотвращает дальнейшее расширение класса. 
Например, следующее не компилируется:

```
public final class Rhinoceros extends Mammal { }

public class Clara extends Rhinoceros { } // DOES NOT COMPILE
```

На экзамене обратите внимание на любой класс с пометкой final. Если вы видите другой класс, расширяющий его, вы сразу 
понимаете, что код не компилируется.

### Одиночное и множественное наследование

Java поддерживает _одиночное наследование_, при котором класс может наследовать только от одного прямого родительского 
класса. Java также поддерживает несколько уровней наследования, посредством которых один класс может расширять другой 
класс, который, в свою очередь, расширяет другой класс. Вы можете иметь любое количество уровней наследования, позволяя 
каждому потомку получить доступ к членам своего предка.

Чтобы по-настоящему понять одиночное наследование, полезно сравнить его с множественным наследованием, при котором у 
класса может быть несколько прямых родителей. Java не поддерживает множественное наследование в языке, потому что 
множественное наследование может привести к сложным, часто трудным для сопровождения моделям данных. Java допускает 
одно исключение из правила единственного наследования, которое вы видите в главе 7 — класс может реализовывать несколько
интерфейсов.

На рис. 6.2 показаны различные типы моделей наследования. Элементы слева считаются одиночным наследованием, поскольку у 
каждого потомка есть только один родитель. Вы можете заметить, что одиночное наследование не мешает родителям иметь 
несколько детей. Справа показаны элементы, имеющие множественное наследование. Как видите, объект Dog имеет несколько 
родительских обозначений.

#### Рис. 6.2 - Типы наследования


Часть того, что усложняет множественное наследование, — это определение того, от какого родителя наследовать значения в 
случае конфликта. Например, если у вас есть объект или метод, определенный во всех родителях, какой из них наследует 
потомок? В этом примере нет естественного порядка для родителей, поэтому Java избегает этих проблем, полностью запрещая 
множественное наследование.

### Наследование объекта 

При обсуждении Java в этой книге мы много раз использовали слово «объект» — и не без оснований. В Java все классы 
наследуются от одного класса: java.lang.Object или для краткости Object. Кроме того, Object — единственный класс, у 
которого нет родительского класса.

Вы можете задаться вопросом: «Ни один из классов, которые я написал до сих пор, не расширяет Object, так как же все 
классы наследуют от него?» Ответ заключается в том, что компилятор автоматически вставляет код в любой написанный вами 
класс, который не расширяет конкретный класс. Например, следующие два эквивалентны:

```
public class Zoo { }

public class Zoo extends java.lang.Object { }
```

Суть в том, что когда Java видит, что вы определяете класс, который не расширяет другой класс, компилятор автоматически 
добавляет синтаксис extends java.lang.Object в определение класса. В результате каждый класс получает доступ к любым 
доступным методам класса Object. Например, методы toString() и equals() доступны в Object; следовательно, они доступны 
во всех классах. Однако без переопределения в подклассе они могут быть не особенно полезны. Мы рассмотрим методы 
переопределения позже в этой главе.

С другой стороны, когда вы определяете новый класс, который расширяет существующий класс, Java не расширяет 
автоматически класс Object. Поскольку все классы наследуются от Object, расширение существующего класса означает, что 
дочерний класс уже наследуется от Object по определению. Если вы посмотрите на структуру наследования любого класса, 
она всегда будет заканчиваться Object в верхней части дерева, как показано на рис. 6.3.

#### Рис. 6.3 - Наследование объектов Java


Примитивные типы, такие как int и boolean, не наследуются от Object, поскольку они не являются классами. Как вы узнали 
из главы 5, с помощью автоупаковки они могут быть назначены или переданы как экземпляр объекта связанного 
класса-оболочки, который наследует Object.

## Создание классов

Теперь, когда мы поняли, как работает наследование в Java, мы можем использовать его для определения и создания сложных
отношений между классами. В этом разделе мы рассмотрим основы создания классов и работы с ними.

### Расширение класса

Давайте создадим два файла в одном пакете, Animal.java и Lion.java.

```
// Animal.java
public class Animal {
   private int age;
   protected String name;
   public int getAge() {
      return age;
   }
   public void setAge(int newAge) {
      age = newAge;
   }
}

// Lion.java
public class Lion extends Animal {
   protected void setProperties(int age, String n) {
      setAge(age);
      name = n;
   }
   public void roar() {
      System.out.print(name + ", age " + getAge() + ", says: Roar!");
   }
   public static void main(String[] args) {
      var lion = new Lion();
      lion.setProperties(3, "kion");
      lion.roar();
   }
}
```

Здесь много всего происходит, мы знаем! Переменная age существует в родительском классе Animal и недоступна напрямую в 
дочернем классе Lion. Он косвенно доступен через метод setAge(). Переменная name protected, поэтому она наследуется в 
классе Lion и доступна напрямую. Мы создаем экземпляр Lion в методе main() и используем setProperties() для установки 
переменных экземпляра. Наконец, мы вызываем метод roar(), который выводит следующее:

```
kion, age 3, says: Roar!
```

Давайте посмотрим на членов класса Lion. Переменная экземпляра age помечена как private и недоступна напрямую из 
подкласса Lion. Следовательно, следующее не будет компилироваться:

```
public class Lion extends Animal {
   public void roar() {
      System.out.print("Lions age: " + age);  // DOES NOT COMPILE
   }
}
```

При работе с подклассами помните, что private члены никогда не наследуются, а члены пакета наследуются только в том 
случае, если два класса находятся в одном пакете. Если вам нужно освежить в памяти модификаторы доступа, вам стоит ещё 
раз прочитать главу 5.

### Применение модификаторов доступа к классу

Подобно переменным и методам, к классам можно применять модификаторы доступа. Как вы, возможно, помните из главы 1, 
класс верхнего уровня не определен внутри другого класса. Также помните, что файл .java может иметь не 
более одного класса верхнего уровня.

Хотя у вас может быть только один класс верхнего уровня, вы можете иметь столько классов (в любом порядке) с доступом к 
пакету, сколько захотите. На самом деле вам даже не нужно объявлять публичный класс! Далее объявляются три класса, 
каждый из которых имеет доступ к пакету:

```
// Bear.java
class Bird {}
class Bear {}
class Fish {}
```

Однако попытка объявить класс верхнего уровня с protected или private классом приведет к ошибке компилятора:

```
// ClownFish.java
protected class ClownFish{} // DOES NOT COMPILE

// BlueTang.java
private class BlueTang {} // DOES NOT COMPILE
```

Означает ли это, что класс нельзя объявить protected или private? Не совсем. В главе 7 мы представим вложенные типы и 
покажем, что, когда вы определяете класс внутри другого, он может использовать любой модификатор доступа.

### Доступ к this ссылке

Что происходит, когда параметр метода имеет то же имя, что и существующая переменная экземпляра? Давайте посмотрим на 
пример. Как вы думаете, что выводит следующая программа?

```
public class Flamingo {
   private String color = null;
   public void setColor(String color) {
      color = color;
   }
   public static void main(String... unused) {
      var f = new Flamingo();
      f.setColor("PINK");
      System.out.print(f.color);
   }
}
```

Если бы вы сказали null, то вы были бы правы. Java использует наиболее детальную область видимости, поэтому, когда он 
видит color = color, он думает, что вы присваиваете значение параметра метода самому себе (а не переменной экземпляра). 
Присвоение завершается успешно внутри метода, но значение переменной экземпляра color никогда не изменяется и равно null
при печати в методе main().

Если у вас есть локальная переменная с тем же именем, что и у переменной экземпляра, исправление заключается в 
использовании ссылки или ключевого слова this. Ссылка this относится к текущему экземпляру класса и может использоваться
для доступа к любому члену класса, включая унаследованные члены. Его можно использовать в любом методе экземпляра, 
конструкторе или блоке инициализатора экземпляра. Его нельзя использовать, когда нет неявного экземпляра класса, 
например, в статическом методе или статическом блоке инициализатора. Применим это к нашей предыдущей реализации метода 
следующим образом:

```
public void setColor(String color) {
   this.color = color;     // Sets the instance variable with method parameter
}
```

Исправленный код теперь будет печатать цвет PINK, как и ожидалось. Во многих случаях ссылка this является 
необязательной. Если Java встречает переменную или метод, который не может найти, он проверяет иерархию классов, чтобы 
узнать, доступны ли они.

Теперь давайте рассмотрим несколько примеров, которые встречаются нечасто, но которые вы можете увидеть на экзамене.

```
1: public class Duck {
2:    private String color;
3:    private int height;
4:    private int length;
5:
6:    public void setData(int length, int theHeight) {
7:       length = this.length;      // Backwards -- no good!
8:       height = theHeight;        // Fine, because a different name
9:       this.color = "white";      // Fine, but this. reference not necessary
10:   }
11:
12:   public static void main(String[] args) {
13:      Duck b = new Duck();
14:      b.setData(1,2);
15:      System.out.print(b.length + " " + b.height + " " + b.color);
16:   } }
```

Этот код компилирует и печатает следующее:

```
0 2 white
```

Хотя, возможно, это не то, что вы ожидали. Строка 7 неверна, и вы должны следить за ней на экзамене. Переменная 
экземпляра length начинается со значения 0. Этот 0 присваивается параметру метода length. Переменная экземпляра остается
равной 0. Строка 8 более прямолинейна. Параметр theHeight и переменная экземпляра height имеют разные имена. Поскольку 
конфликта имён нет, this не требуется. Наконец, строка 9 показывает, что при присвоении переменной разрешено 
использовать ссылку this, даже если имена переменных не дублируются.

### Calling the super Reference (Вызов суперссылки)

В Java переменную или метод можно определить как в родительском, так и в дочернем классе. Это означает, что экземпляр 
объекта фактически содержит две копии одной и той же переменной с одним и тем же базовым именем. Когда это происходит, 
как нам ссылаться на версию в родительском классе, а не на текущий класс? Давайте посмотрим на пример.

```
// Reptile.java
1: public class Reptile {
2:    protected int speed = 10;
3: }

// Crocodile.java
1: public class Crocodile extends Reptile {
2:    protected int speed = 20;
3:    public int getSpeed() {
4:       return speed;
5:    }
6:    public static void main(String[] data) {
7:       var croc = new Crocodile();
8:       System.out.println(croc.getSpeed()); // 20
9:    } }
```

Одна из самых важных вещей, которые следует помнить об этом коде, заключается в том, что экземпляр Crocodile хранит два 
отдельных значения speed: одно на уровне Reptile и одно на уровне Crocodile. В строке 4 Java сначала проверяет наличие 
локальной переменной или параметра метода с именем speed. Так как нет, то проверяется this.speed; и поскольку он 
существует, программа печатает 20.

_Объявление переменной с тем же именем, что и унаследованная переменная, называется скрытием переменной и обсуждается 
далее в этой главе._

Но что, если мы хотим, чтобы программа напечатала значение в классе Reptile? Вместо этого внутри класса Crocodile мы 
можем получить доступ к родительскому значению speed, используя ссылку super или ключевое слово. Ссылка super похожа на 
ссылку this, за исключением того, что она исключает все члены, найденные в текущем классе. Другими словами, член должен 
быть доступен через наследование.

```
3:    public int getSpeed() {
4:       return super.speed; // Causes the program to now print 10
5:    }
```

Посмотрим, усвоили ли вы this и super. Что выводит следующая программа?

```
1:   class Insect {
2:      protected int numberOfLegs = 4;
3:      String label = "buggy";
4:   }
5:
6:   public class Beetle extends Insect {
7:      protected int numberOfLegs = 6;
8:      short age = 3;
9:      public void printData() {
10:        System.out.println(this.label);
11:        System.out.println(super.label);
12:        System.out.println(this.age);
13:        System.out.println(super.age);
14:        System.out.println(numberOfLegs);
15:     }
16:     public static void main(String []n) {
17:        new Beetle().printData();
18:     }
19: }
```

Это был вопрос с подвохом — этот программный код не компилировался! Давайте рассмотрим каждую строку метода printData().
Поскольку label определена в родительском классе, она доступна как через this, так и через super ссылки. По этой причине
строки 10 и 11 компилируются и обе выведут buggy, если класс скомпилируется. С другой стороны, переменная age определена
только в текущем классе, что делает её доступной через this, но не через super. По этой причине строка 12 компилируется 
(и выводит 3), а строка 13 — нет. Помните, что в то время как this включает текущие и унаследованные элементы, super 
включает только унаследованные элементы.

И последнее, но не менее важное: что будет напечатано в строке 14, если строка 13 будет закомментирована? Несмотря на 
то, что обе переменные numberOfLegs доступны в Beetle, Java выполняет проверку снаружи, начиная с самой узкой области 
видимости. По этой причине используется значение numberOfLegs в классе Beetle, и печатается 6. В этом примере 
this.numberOfLegs и super.numberOfLegs ссылаются на разные переменные с разными значениями.

Поскольку this включает в себя унаследованные члены, вы часто используете super только тогда, когда у вас возникает 
конфликт имен из-за наследования. Например, у вас есть метод или переменная, определенные в текущем классе, которые 
соответствуют методу или переменной в родительском классе. Обычно это возникает при переопределении методов и сокрытии 
переменных, которые обсуждаются далее в этой главе.

Фу, это было много! К использованию this и super может потребоваться некоторое время, чтобы привыкнуть. Поскольку мы 
будем часто использовать их в следующих разделах, убедитесь, что вы действительно хорошо понимаете последний пример, 
прежде чем двигаться дальше.

## Объявление конструкторов

Как вы узнали из главы 1, конструктор — это специальный метод, который соответствует имени класса и не имеет 
возвращаемого типа. Он вызывается при создании нового экземпляра класса. Для экзамена вам нужно знать много правил о 
конструкторах. В этом разделе мы покажем, как создать конструктор. Затем мы рассмотрим конструкторы по умолчанию, 
перегрузку конструкторы, вызов родительских конструкторов, конечные поля и порядок инициализации в классе.

### Создание конструктора

Давайте начнем с простого конструктора:

```
public class Bunny {
   public Bunny() {
      System.out.print("hop");
   }
}
```

Имя конструктора Bunny совпадает с именем класса Bunny, а тип возвращаемого значения отсутствует, даже void. Это делает 
его конструктором. Можете ли вы сказать, почему эти два конструктора недопустимы для класса Bunny?

```
public class Bunny {
   public bunny() {} // DOES NOT COMPILE
   public void Bunny() {}
}
```

Первый не соответствует имени класса, потому что Java чувствителен к регистру. Поскольку он не совпадает, Java знает, 
что он не может быть конструктором и должен быть обычным методом. Однако в нем отсутствует возвращаемый тип, и он не 
компилируется. Второй метод — очень хороший метод, но он не является конструктором, поскольку имеет возвращаемый тип.

Как и параметры метода, параметры конструктора могут быть любым допустимым классом, массивом или примитивным типом, 
включая дженерики, но не могут включать var. Например, следующее не компилируется:

```
public class Bonobo {
   public Bonobo(var food) {  // DOES NOT COMPILE
   }
}
```

Класс может иметь несколько конструкторов, если каждый конструктор имеет уникальную сигнатуру конструктора. В данном 
случае это означает, что параметры конструктора должны быть разными. Подобно методам с одинаковым именем, но разными 
сигнатурами, объявление нескольких конструкторов с разными сигнатурами называется _перегрузкой конструктора_. Следующий 
класс Turtle имеет четыре различных перегруженных конструктора:

```
public class Turtle {
   private String name;
   public Turtle() {
      name = "John Doe";
   }
   public Turtle(int age) {}
   public Turtle(long age) {}
   public Turtle(String newName, String... favoriteFoods) {
      name = newName;
   }
}
```

Конструкторы используются при создании нового объекта. Этот процесс называется _созданием экземпляра_, поскольку он 
создает новый экземпляр класса. Конструктор вызывается, когда мы пишем new, за которым следует имя класса, который мы 
хотим создать. Вот пример:

```
new Turtle(15)
```

Когда Java видит ключевое слово new, она выделяет память для нового объекта. Затем он ищет конструктор с соответствующей
сигнатурой и вызывает его.

### Конструктор по умолчанию

У каждого класса в Java есть конструктор, независимо от того, пишете вы его или нет. Если вы не включите конструкторы в 
класс, Java создаст его без каких-либо параметров.

Этот созданный Java конструктор называется _конструктором по умолчанию_ и добавляется каждый раз, когда класс 
объявляется без каких-либо конструкторов. Для ясности мы часто называем его конструктором без аргументов по умолчанию. 
Вот пример:

```
public class Rabbit {
   public static void main(String[] args) {
      new Rabbit();       // Calls the default constructor
   }
}
```

В классе Rabbit Java видит, что конструктор не был закодирован, и создает его. Предыдущий класс эквивалентен следующему, 
в котором предоставляется конструктор по умолчанию и, следовательно, не вставляется компилятором:

```
public class Rabbit {
   public Rabbit() {}
   public static void main(String[] args) {
      new Rabbit();       // Calls the user-defined constructor
   }
}
```

Конструктор по умолчанию имеет пустой список параметров и пустое тело. Это нормально, если вы напечатаете это сами. 
Однако, поскольку он ничего не делает, Java с радостью сгенерирует его для вас и избавит вас от необходимости печатать.

Мы продолжаем говорить сгенерировано. Это происходит на этапе компиляции. Если вы посмотрите на файл с расширением 
.java, конструктор всё равно будет отсутствовать. Он появляется только в скомпилированном файле с расширением .class.

Для экзамена одно из самых важных правил, которое вам нужно знать, заключается в том, что компилятор вставляет 
конструктор по умолчанию только тогда, когда конструкторы не определены. Как вы думаете, у какого из этих классов есть 
конструктор по умолчанию?

```
public class Rabbit1 {}

public class Rabbit2 {
   public Rabbit2() {}
}

public class Rabbit3 {
   public Rabbit3(boolean b) {}
}

public class Rabbit4 {
   private Rabbit4() {}
}
```

Только Rabbit1 получает конструктор без аргументов по умолчанию. У него нет закодированного конструктора, поэтому Java 
генерирует конструктор по умолчанию без аргументов. У Rabbit2 и Rabbit3 уже есть общедоступные конструкторы. Rabbit4 
имеет private конструктор. Поскольку для этих трёх классов определен конструктор, конструктор без аргументов по 
умолчанию не вставляется.

Давайте кратко рассмотрим, как вызывать эти конструкторы:

```
1: public class RabbitsMultiply {
2:    public static void main(String[] args) {
3:       var r1 = new Rabbit1();
4:       var r2 = new Rabbit2();
5:       var r3 = new Rabbit3(true);
6:       var r4 = new Rabbit4();   // DOES NOT COMPILE
7:    } }
```

Строка 3 вызывает сгенерированный по умолчанию конструктор без аргументов. Строки 4 и 5 вызывают предоставленные 
пользователем конструкторы. Строка 6 не компилируется. Rabbit4 сделал конструктор private, чтобы другие классы не могли 
его вызвать.

_Наличие в классе только private конструкторов указывает компилятору не предоставлять конструктор по умолчанию без 
аргументов. Это также предотвращает создание экземпляра класса другими классами. Это полезно, когда класс имеет только 
static методы или разработчик хочет иметь полный контроль над всеми вызовами для создания новых экземпляров класса._

### Calling Overloaded Constructors with this()










