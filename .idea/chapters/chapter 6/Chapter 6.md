# Дизайн класса (or Проектирование класса)

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Создавать классы и записи, а также определять и использовать: экземпляры объекта, статические поля и методы,
  конструкторы, а также экземпляры объекта и статические инициализаторы
+ Понимать области видимости переменных, использовать вывод типа локальной переменной, применять инкапсуляцию и делать 
  объекты неизменяемыми
+ Реализуйте полиморфизм и различайте тип объекта по сравнению с ссылочным типом. Выполнение приведения типов, 
   идентификация типов объектов с помощью оператора instanceof и сопоставления с образцом

---

В главе 1 «Строительные блоки» мы представили базовое определение класса в Java. В главе 5 «Методы» мы подробно 
рассмотрели методы и модификаторы и показали, как их можно использовать для создания более структурированных классов. 
В этой главе мы пойдем еще дальше и покажем, что структура классов и наследование — одна из самых мощных функций языка 
Java.

По своей сути правильный дизайн классов Java связан с повторным использованием кода, расширенной функциональностью и 
стандартизацией. Например, создав новый класс, который расширяет существующий класс, вы можете получить доступ к 
множеству унаследованных примитивов, объектов и методов, что увеличивает повторное использование кода.

Эта глава является кульминацией некоторых из наиболее важных тем в Java, включая наследование, проектирование классов, 
конструкторы, порядок инициализации, методы переопределения, абстрактные классы и неизменяемые объекты. Внимательно 
прочитайте эту главу и убедитесь, что вы хорошо понимаете все темы. Эта глава составляет основу главы 7 
«Помимо классов», в которой мы расширяем обсуждение типов, включив в него другие высокоуровневые и вложенные типы.

## Понимание наследования

При создании нового класса в Java вы можете определить класс как унаследованный от существующего класса. 
Наследование — это процесс, посредством которого подкласс автоматически включает определенные члены класса, включая 
примитивы, объекты или методы, определенные в родительском классе.

В иллюстративных целях мы называем любой класс, наследуемый от другого класса, _подклассом_ или _дочерним классом_, 
поскольку он считается потомком этого класса. В качестве альтернативы мы называем класс, от которого наследует потомок, 
_суперклассом_ или _родительским_ классом, поскольку он считается предком класса.

_При работе с другими типами, такими как интерфейсы, мы обычно используем общие термины подтип и супертип. Подробнее об 
этом вы узнаете в следующей главе._

### Объявление подкласса

Начнем с объявления класса и его подкласса. На рис. 6.1 показан пример суперкласса Mammal и подкласса Rhinoceros.

#### Рис. 6.1 - Объявление подкласса и суперкласса


Мы указываем, что класс является подклассом, объявляя его с помощью ключевого слова extends. Нам не нужно ничего 
объявлять в суперклассе, кроме как убедиться, что он не помечен как final. Подробнее об этом в ближайшее время.

Одним из ключевых аспектов наследования является его транзитивность. Для трех классов [X, Y, Z], если X расширяет Y, а 
Y расширяет Z, то X считается подклассом или потомком Z. Точно так же Z является суперклассом или предком X. 
Иногда мы используем термин прямой подкласс или потомок, чтобы указать, что класс напрямую расширяет родительский класс.
Например, X является прямым потомком только класса Y, а не Z.

В предыдущей главе вы узнали, что существует четыре уровня доступа: public, protected, package и private. Когда один 
класс наследуется от родительского класса, все public и protected члены автоматически становятся частью дочернего 
класса. Если два класса находятся в одном пакете, члены пакета доступны дочернему классу. И последнее, но не менее 
важное: private члены ограничены классом, в котором они определены, и никогда не доступны через наследование. 
Это не означает, что родительский класс не может иметь private членов, которые могут хранить данные или изменять объект; 
это просто означает, что подкласс не имеет к ним прямого доступа.

Давайте рассмотрим простой пример:

```
public class BigCat {
   protected double size;
}

public class Jaguar extends BigCat {
   public Jaguar() {
      size = 10.2;
   }
   public void printDetails() {
      System.out.print(size);
   }
}

public class Spider {
   public void printDetails() {
      System.out.println(size);     // DOES NOT COMPILE
   }
}
```

Jaguar является подклассом или потомком BigCat, что делает BigCat надклассом или родителем Jaguar. В классе Jaguar 
size доступен, потому что он помечен как protected. С помощью наследования подкласс Jaguar может читать или 
записывать size, как если бы он был его собственным членом. Сравните это с классом Spider, у которого нет доступа к 
size, поскольку он не наследуется.

### Модификаторы класса

Подобно методам и переменным, объявление класса может иметь различные модификаторы. В Таблице 6.1 перечислены 
модификаторы, которые вы должны знать для экзамена.

#### Таблица 6.1 - Модификаторы класса

|    Модификатор    | Описание                                                                                                                  | Охваченная глава |  
|:-----------------:|:--------------------------------------------------------------------------------------------------------------------------|:----------------:|
|       final       | Класс не может быть расширен.                                                                                             |     Глава 6      |                                     
|     abstract      | Класс является абстрактным, может содержать абстрактные методы<br/>  и требует создания экземпляра конкретного подкласса. |     Глава 6      |                                        
|      sealed       | Класс может быть расширен только определенным списком классов.                                                                                                                      |     Глава 7      |                                   
|    non-sealed     | Подкласс закрытого класса допускает потенциально неназванные подклассы.                                                                                                                       |     Глава 7      |
|      static       | Используется для static вложенных классов, определенных внутри класса.                                                                                                             |     Глава 7      |

Мы рассмотрим abstract классы позже в этой главе. В следующей главе мы рассмотрим sealed и non-sealed классы, а также 
static вложенные классы.

А пока давайте поговорим об отметке final класса. Модификатор final предотвращает дальнейшее расширение класса. 
Например, следующее не компилируется:

```
public final class Rhinoceros extends Mammal { }

public class Clara extends Rhinoceros { } // DOES NOT COMPILE
```

На экзамене обратите внимание на любой класс с пометкой final. Если вы видите другой класс, расширяющий его, вы сразу 
понимаете, что код не компилируется.

### Одиночное и множественное наследование

Java поддерживает _одиночное наследование_, при котором класс может наследовать только от одного прямого родительского 
класса. Java также поддерживает несколько уровней наследования, посредством которых один класс может расширять другой 
класс, который, в свою очередь, расширяет другой класс. Вы можете иметь любое количество уровней наследования, позволяя 
каждому потомку получить доступ к членам своего предка.

Чтобы по-настоящему понять одиночное наследование, полезно сравнить его с множественным наследованием, при котором у 
класса может быть несколько прямых родителей. Java не поддерживает множественное наследование в языке, потому что 
множественное наследование может привести к сложным, часто трудным для сопровождения моделям данных. Java допускает 
одно исключение из правила единственного наследования, которое вы видите в главе 7 — класс может реализовывать несколько
интерфейсов.







