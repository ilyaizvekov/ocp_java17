# За пределами классов

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Объявляйте и создавайте экземпляры объектов Java, включая объекты вложенного класса, и объясняйте жизненный цикл 
объекта, включая создание, переназначение ссылок и сборку мусора
+ Создавайте классы и записи, а также определяйте и используйте экземпляры и статические поля и методы, конструкторы, а 
также экземпляры и статические инициализаторы
+ Понимайте области видимости переменных, используйте вывод типа локальной переменной, применяйте инкапсуляцию и 
делайте объекты неизменяемыми
+ Реализуйте полиморфизм и отличайте тип объекта от ссылочного типа. Выполняйте приведение типов, идентифицируйте типы 
объектов с помощью оператора instanceof и сопоставления с образцом
+ Создавайте и используйте интерфейсы, определяйте функциональные интерфейсы и используйте частные, статические методы 
интерфейса и методы интерфейса по умолчанию
+ Создавайте и используйте перечисления с полями, методами и конструкторами

---

В главе 6 «Проектирование классов» мы показали, как создавать, инициализировать и расширять как абстрактные, так и 
конкретные классы. В этой главе мы переходим от классов к другим типам, доступным в Java, включая интерфейсы, 
перечисления, закрытые классы и записи. Многие из основных правил, о которых вы узнали в главе 5 «Методы», по-прежнему 
применяются, например, модификаторы доступа и статические члены, хотя для каждого типа существуют дополнительные 
правила. Мы также рассмотрим инкапсуляцию и то, как правильно защитить элементы экземпляра. Наконец, мы завершаем эту 
главу обсуждением вложенных типов и полиморфного наследования.

В этой главе помните, что файл Java может иметь не более одного общедоступного типа верхнего уровня, и он должен 
совпадать с именем файла. Это относится к классам, перечислениям, записям и так далее. Кроме того, помните, что тип 
верхнего уровня может быть объявлен только с общедоступным доступом или доступом к пакету.

---

Другим типом верхнего уровня, доступным в Java, являются аннотации. Знание того, как создавать пользовательские 
аннотации, может быть полезным навыком на практике, хотя это и не требуется для сдачи экзамена. Вы все равно должны 
знать, как использовать определенные аннотации для экзамена, такие как @Override.

---

## Реализация интерфейсов

В главе 6 вы узнали об абстрактных классах, в частности о том, как их создавать и расширять. Поскольку классы могут 
расширять только один класс, они имели ограниченное применение для наследования. С другой стороны, класс может 
реализовывать любое количество интерфейсов. Интерфейс - это абстрактный тип данных, который объявляет список 
абстрактных методов, которые должен предоставлять любой класс, реализующий интерфейс.

Со временем точное определение интерфейса изменилось, поскольку теперь поддерживаются новые типы методов. В этой главе 
мы начнем с элементарного определения интерфейса и расширим его, чтобы охватить все поддерживаемые элементы.

### Объявление и использование интерфейса

В Java интерфейс определяется с помощью ключевого слова interface, аналогичного ключевому слову class, используемому при
определении класса. См. рис. 7.1 для правильного объявление интерфейса.


#### Рис. 7.1 - Определение интерфейса

На рис. 7.1 объявление нашего интерфейса включает абстрактный метод и постоянную переменную. Переменные интерфейса 
называются константами, поскольку предполагается, что они public, static и final. Они 
инициализируются постоянным значением при объявлении. Поскольку они являются public и static, их можно 
использовать вне объявления интерфейса, не требуя экземпляра интерфейса. Рисунок 7.1 также включает абстрактный метод, 
который, как и переменная интерфейса, считается public.

_Для краткости мы часто используем фразу “экземпляр интерфейса” в этой главе имею в виду экземпляр класса, который 
реализует интерфейс._

Что это значит для переменной или метода, чтобы считаться чем-то? Один аспект объявления интерфейса, который отличается 
от абстрактного класса, состоит в том, что он содержит неявные модификаторы. Неявное модификатор-модификатор, который 
компилятор автоматически вставляет в код. Например, интерфейс, всегда считается абстрактным, даже если он не отмечен 
таким образом. Вскоре мы рассмотрим правила и примеры неявных модификаторов более подробно.

Начнем с простого примера. Представьте, что у нас есть интерфейс WalksOnTwoLegs, определенный следующим образом:

```
public abstract interface WalksOnTwoLegs {}
```

Он компилируется, потому что интерфейсы не требуются для определения каких-либо методов. Модификатор abstract в этом 
примере является необязательным для интерфейсов, и компилятор вставляет его, если он не указан. Теперь рассмотрим 
следующие два примера, которые не компилируются:

```
public class Biped {
   public static void main(String[] args) {
      var e = new WalksOnTwoLegs();         // DOES NOT COMPILE
   }
}

public final interface WalksOnEightLegs {}  // DOES NOT COMPILE
```

Первый пример не компилируется, так как WalksOnTwoLegs является интерфейсом и не может быть создан. Второй пример, 
WalksOnEightLegs, не компилируется, потому что интерфейсы не могут быть помечены как final по той же причине, по которой
abstract классы не могут быть помечены как final. Другими словами, пометка интерфейса как final подразумевает, что ни 
один класс не сможет его реализовать.

Как вы используете интерфейс? Допустим, у нас есть интерфейс Climb, определенный следующим образом:

```
public interface Climb {
   Number getSpeed(int age);
}
```

Затем у нас есть конкретный класс FieldMouse, который вызывает интерфейс Climb, используя ключевое слово implements в 
объявлении своего класса, как показано на рис. 7.2.

#### Рис. 7.2 - Реализации интерфейса

Класс FieldMouse объявляет, что он реализует интерфейс Climb и включает переопределенную версию getSpeed(), 
унаследованную от интерфейса Climb. Сигнатура метода getSpeed() точно совпадает, а возвращаемый тип является 
ковариантным, поскольку Float может быть неявно приведен к Number. Модификатор доступа метода интерфейса неявно public в
Climb, хотя конкретный класс FieldMouse должен явно объявить его.

Как показано на рис. 7.2, класс может реализовывать несколько интерфейсов, разделенных запятой (,). Если какой-либо из 
интерфейсов определяет abstract методы, то для их переопределения требуется конкретный класс. В этом случае FieldMouse 
реализует интерфейс CanBurrow, который мы видели на рис. 7.1. Таким образом, класс переопределяет два абстрактных метода
одновременно с одним объявлением метода. В этой главе вы узнаете больше о повторяющихся и совместимых методах 
интерфейса.

### Расширение интерфейса

Как и класс, интерфейс может расширять другой интерфейс с помощью ключевого слова extends.

```
public interface Nocturnal {}

public interface HasBigEyes extends Nocturnal {}
```

В отличие от класса, который может расширять только один класс, интерфейс может расширять несколько интерфейсов.

```
public interface Nocturnal {
   public int hunt();
}

public interface CanFly {
   public void flap();
}

public interface HasBigEyes extends Nocturnal, CanFly {}

public class Owl implements HasBigEyes {
   public int hunt() { return 5; }
   public void flap() { System.out.println("Flap!"); }
}
```

В этом примере класс Owl реализует интерфейс HasBigEyes и должен реализовывать методы hunt() и flap(). Расширение двух 
интерфейсов разрешено, поскольку интерфейсы не инициализируются как часть иерархии классов. В отличие от абстрактных 
классов, они не содержат конструкторов и не являются частью инициализации экземпляра. Интерфейсы просто определяют набор
правил и методов, которым должен следовать реализующий их класс.

### Наследование интерфейса

Как и в случае с абстрактным классом, когда конкретный класс наследует интерфейс, должны быть реализованы все 
унаследованные абстрактные методы. Мы иллюстрируем этот принцип на рис. 7.3. Сколько абстрактных методов наследует 
конкретный класс Swan?

#### Рис. 7.3 - Наследование интерфейса


Сдаться? Конкретный класс Swan наследует четыре абстрактных метода, которые он должен реализовать: getType(), 
canSwoop(), fly() и swim(). Давайте взглянем на другой пример с абстрактным классом, реализующим интерфейс:

```
public interface HasTail {
   public int getTailLength();
}

public interface HasWhiskers {
   public int getNumberOfWhiskers();
}

public abstract class HarborSeal implements HasTail, HasWhiskers {}

public class CommonSeal extends HarborSeal {}    // DOES NOT COMPILE
```

Класс HarborSeal компилируется, поскольку он является abstract и не требует реализации каких-либо abstract методов, 
которые он наследует. Однако конкретный класс CommonSeal должен переопределять все унаследованные abstract методы.

#### Смешивание ключевых слов класса и интерфейса

Создатели экзамена любят вопросы, в которых смешаны терминология классов и интерфейсов. Хотя класс может реализовать 
интерфейс, класс не может расширять интерфейс. Аналогично, хотя интерфейс может расширять другой интерфейс, интерфейс 
не может реализовать другой интерфейс. Следующие примеры иллюстрируют эти принципы:

```
public interface CanRun {}
public class Cheetah extends CanRun {} // DOES NOT COMPILE

public class Hyena {}
public interface HasFur extends Hyena {} // DOES NOT COMPILE
```

В первом примере показан класс, который пытается расширить интерфейс и не компилируется. Во втором примере показан 
интерфейс, пытающийся расширить класс, который также не компилируется. Будьте осторожны с примерами на экзамене, которые
смешивают объявления классов и интерфейсов.

#### Наследование повторяющихся абстрактных методов

Java поддерживает наследование двух абстрактных методов, которые имеют совместимые объявления методов.

```
public interface Herbivore { public void eatPlants(); }

public interface Omnivore { public void eatPlants(); }

public class Bear implements Herbivore, Omnivore {

public void eatPlants() {
   System.out.println("Eating plants");
} }
```

Под совместимостью мы подразумеваем, что метод может быть написан таким образом, чтобы правильно переопределять оба 
унаследованных метода: например, с помощью ковариантных возвращаемых типов, о которых вы узнали в главе 6.

Ниже приведен пример несовместимого объявления:

```
public interface Herbivore { public void eatPlants(); }

public interface Omnivore { public int eatPlants(); }

public class Tiger implements Herbivore, Omnivore { // DOES NOT COMPILE
...
}
```

Невозможно написать версию Tiger, удовлетворяющую обоим унаследованным abstract методам. Код не компилируется независимо
от того, что объявлено внутри класса Tiger.

#### Вставка неявных модификаторов

Как упоминалось ранее, неявный модификатор — это модификатор, который автоматически вставляется компилятором. Это 
напоминает компилятор, вставляющий конструктор по умолчанию без аргументов, если вы не определили конструктор, о котором
вы узнали в главе 6. Вы можете вставить эти неявные модификаторы самостоятельно или позволить компилятору вставить их за
вас.

Следующий список включает неявные модификаторы для интерфейсов, которые вам необходимо знать для экзамена:

+ Интерфейсы неявно abstract.
+ Переменные интерфейса неявно являются public, static и final.
+ Методы интерфейса без тела неявно abstract.
+ Методы интерфейса без модификатора private неявно являются public.

Последнее правило применяется к abstract, default и static методам интерфейса, которые мы рассмотрим в 
следующем разделе.

Давайте посмотрим на пример. Следующие два определения интерфейса эквивалентны, так как компилятор преобразует их оба во
второе объявление:

```
public interface Soar {
   int MAX_HEIGHT = 10;
   final static boolean UNDERWATER = true;
   void fly(int speed);
   abstract void takeoff();
   public abstract double dive();
}

public abstract interface Soar {
   public static final int MAX_HEIGHT = 10;
   public final static boolean UNDERWATER = true;
   public abstract void fly(int speed);
   public abstract void takeoff();
   public abstract double dive();
}
```

В этом примере мы выделили жирным шрифтом неявные модификаторы, которые автоматически вставляет компилятор. Во-первых, 
в объявление интерфейса добавляется ключевое слово abstract. Затем к переменным интерфейса добавляются ключевые слова 
public, static и final, если они не существуют. Наконец, каждому абстрактному методу предшествуют ключевые слова 
abstract и public, если они еще не содержатся.

#### Конфликтующие модификаторы

Что произойдет, если разработчик пометит метод или переменную модификатором, который конфликтует с неявным 
модификатором? Например, если абстрактный метод неявно public, может ли он быть явно помечен как protected или private?

```
public interface Dance {
   private int count = 4; // DOES NOT COMPILE
   protected void step(); // DOES NOT COMPILE
}
```

Ни одно из этих объявлений члена интерфейса не компилируется, так как компилятор применит модификатор public к обоим, 
что приведет к конфликту.

#### Различия между интерфейсами и абстрактными классами

Несмотря на то, что абстрактные классы и интерфейсы считаются абстрактными типами, только интерфейсы используют неявные 
модификаторы. Чем отличаются методы play() в следующих двух определениях?

```
abstract class Husky {    // abstract required in class declaration
   abstract void play();  // abstract required in method declaration
}

interface Poodle {       // abstract optional in interface declaration
   void play();          // abstract optional in method declaration
}
```

Оба эти определения метода считаются абстрактными. Тем не менее, класс Husky не будет компилироваться, если метод play()
не помечен как abstract, тогда как метод в интерфейсе Poodle будет компилироваться с модификатором abstract или без 
него.

Как насчет уровня доступа метода play()? Можете ли вы заметить что-нибудь неправильное в следующих определениях классов,
использующих наши абстрактные типы?

```
public class Webby extends Husky {
void play() {} // OK -play() is declared with package access in Husky
}

public class Georgette implements Poodle {
void play() {} // DOES NOT COMPILE -play() is public in Poodle
}
```

Класс Webby компилируется, а класс Georgette — нет. Несмотря на то, что реализации двух методов идентичны, метод в 
классе Georgette уменьшает модификатор доступа к методу с public до пакетного доступа.

#### Объявление конкретных методов интерфейса

Хотя интерфейсы начинались с абстрактных методов и констант, они расширились и теперь включают гораздо больше. В 
таблице 7.1 перечислены шесть типов элементов интерфейса, которые вам необходимо знать для экзамена. Мы уже рассмотрели 
абстрактные методы и константы, поэтому сосредоточимся на оставшихся четырех конкретных методах в этом разделе.

#### Таблица 7.1 - Типы членов интерфейса

|                       | Тип члена | Требуемые модификаторы |    Неявные модификаторы     | Имеет значение или тело? |  
|:---------------------:|:---------:|:----------------------:|:---------------------------:|--------------------------|
| Постоянные переменные |   Класс   |           -            | public<br/>static<br/>final |            Да            |
|    abstract метод     | Интерфейс |           -            |     public<br/>abstract     |           Нет            |                                     
|     default метод     | Интерфейс |        default         |           public            |            Да            |
|     static метод      |   Класс   |         static         |           public            |            Да            |
|     private метод     | Интерфейс |        private         |              -              |            Да            |
| private static метод  |   Класс   |   private<br/>static   |              -              |            Да            |

В таблице 7.1 тип членства определяет, как к нему можно получить доступ. Метод с типом принадлежности класса является 
общим для всех экземпляров интерфейса, тогда как метод с типом принадлежности экземпляра связан с конкретным экземпляром
интерфейса.

_**Как насчет защищенных (protected) или пакетных элементов (Package Members) интерфейса?**_

Наряду с public методами интерфейсы теперь поддерживают private методы. Однако они не поддерживают protected доступ, 
поскольку класс не может расширять интерфейс. Они также не поддерживают пакетный доступ, хотя, скорее всего, по причинам
синтаксиса и обратной совместимости. Поскольку методы интерфейса без модификатора доступа считаются неявно 
public, изменение этого поведения на доступ к пакету нарушит работу многих существующих программ!

#### Написание метода интерфейса по умолчанию

Первый тип конкретного метода, с которым вы должны быть знакомы на экзамене, — это метод по умолчанию. Метод по 
умолчанию (default method) — это метод, определенный в интерфейсе с ключевым словом default и включающий в себя тело 
метода. При необходимости он может быть переопределен классом, реализующим интерфейс.

Одним из способов использования методов default является обратная совместимость. Вы можете добавить в интерфейс новый 
метод default без необходимости изменять все существующие классы, реализующие интерфейс. Старые классы будут просто 
использовать реализацию метода default, определенную в интерфейсе. Вот откуда взялось название метода по 
умолчанию (default)!

Ниже приведен пример метода default, определенного в интерфейсе:

```
public interface IsColdBlooded {
   boolean hasScales();
   default double getTemperature() {
      return 10.0;
   } }
```

В этом примере определяются два метода интерфейса, один abstract и один default. Следующий класс Snake, который 
реализует IsColdBlooded, должен реализовать hasScales(). Он может полагаться на реализацию getTemperature() по 
умолчанию или переопределить метод своей собственной версией:

```
public class Snake implements IsColdBlooded {
   public boolean hasScales() {       // Required override
      return true;
   }
   
   public double getTemperature() {   // Optional override
      return 12;
   }
}
```

_Обратите внимание, что модификатор метода интерфейса default не совпадает с меткой default, используемой в операторе 
или выражении switch. Аналогичным образом, несмотря на то, что доступ к пакету иногда называют доступом по умолчанию, 
эта функция реализована путем пропуска модификатора доступа. Извините, если это сбивает с толку! Мы согласны с тем, 
что в течение многих лет Java злоупотребляла словом default!_

Для экзамена вы должны быть знакомы с различными правилами объявления методов default.

**Правила определения метода интерфейса по умолчанию**

1. default метод может быть объявлен только внутри интерфейса.
2. default метод должен быть помечен ключевым словом default и включать тело метода.
3. default метод неявно public.
4. default метод не может быть помечен как abstract, final или static.
5. default метод может быть переопределен классом, реализующим интерфейс.
6. Если класс наследует два или более default метода с одной и той же сигнатурой метода, то класс должен переопределить 
метод.

Первое правило должно дать вам некоторое утешение в том, что вы будете видеть только default методы в интерфейсах. 
Если вы видите их в классе или перечисляете на экзамене, значит, что-то не так. Второе правило просто обозначает 
синтаксис, поскольку default методы должны использовать ключевое слово default. Например, следующие фрагменты кода не
будут скомпилированы, поскольку в них смешиваются конкретные и абстрактные методы интерфейса:

```
public interface Carnivore {
   public default void eatMeat();        // DOES NOT COMPILE
   public int getRequiredFoodAmount() {  // DOES NOT COMPILE
      return 13;
   } }
```

Следующие три правила для default методов следуют из отношений с абстрактными методами интерфейса. Как и методы 
абстрактного интерфейса, default методы неявно public. Однако, в отличие от абстрактных методов, default методы 
интерфейса не могут быть помечены как abstract, поскольку они предоставляют тело. Они также не могут быть помечены как 
final, потому что они спроектированы таким образом, что могут быть переопределены в классах, реализующих интерфейс, 
точно так же, как и абстрактные методы. Наконец, их нельзя пометить как static, поскольку они связаны с экземпляром 
класса, реализующего интерфейс.

**Наследование повторяющихся _default_ методов**

Последнее правило для создания default метода интерфейса требует некоторых пояснений. Например, какое значение выведет 
следующий код?

```
public interface Walk {
   public default int getSpeed() { return 5; }
}

public interface Run {
   public default int getSpeed() { return 10; }
}

public class Cat implements Walk, Run {}  // DOES NOT COMPILE
```

В этом примере Cat наследует два default метода для getSpeed(), так что же он использует? Поскольку Walk и Run считаются
братьями и сестрами с точки зрения того, как они используются в классе Cat, неясно, должен ли код выводить 5 или 10.
В этом случае компилятор разводит руками и говорит: “Слишком сложно, я сдаюсь!” и терпит неудачу.

Однако ещё не все потеряно. Если класс, реализующий интерфейсы, переопределяет дублирующий default метод, код 
будет скомпилирован без проблем. Переопределив конфликтующий метод, была устранена двусмысленность в отношении того, 
какую версию метода вызывать. Например, следующая модифицированная реализация Cat будет скомпилирована:

```
public class Cat implements Walk, Run {
   public int getSpeed() { return 1; }
}
```

**Вызов скрытого default метода**

В последнем разделе мы показали, как наш класс Cat может переопределить пару конфликтующих default методов, но что, если
класс Cat захочет получить доступ к версии getSpeed() в Walk или Run? Доступен ли он по-прежнему?

Да, но для этого требуется особый синтаксис.

```
public class Cat implements Walk, Run {
   public int getSpeed() {
      return 1;
}

public int getWalkSpeed() {
   return Walk.super.getSpeed();
} }
```

Это область, в которой default метод демонстрирует свойства как static метода, так и метода экземпляра. Мы используем 
имя интерфейса, чтобы указать, какой метод мы хотим вызвать, но мы используем ключевое слово super, чтобы показать, что 
мы следуем наследованию экземпляра, а не наследованию класса. Обратите внимание, что вызов Walk.getSpeed() или 
Walk.this.getSpeed() не сработает. Мы знаем, что это немного сбивает с толку, но вы должны быть знакомы с этим 
синтаксисом для экзамена.

#### Объявление static методов интерфейса

Интерфейсы также объявляются со static методами. Эти методы явно определены с помощью ключевого слова static и по 
большей части ведут себя точно так же, как static методы, определенные в классах.

**Правила определения static метода интерфейса**

1. static метод должен быть помечен ключевым словом static и включать тело метода.
2. static метод без модификатора доступа неявно является public.
3. static метод не может быть помечен как abstract или final.
4. static метод не наследуется и не может быть доступен в классе, реализующем интерфейс, без ссылки на имя интерфейса.

Эти правила должны следовать из того, что вы уже знаете о классах, интерфейсах и static методах. Например, в классах 
тоже нельзя объявлять static методы без тела. Подобно default и abstract методам интерфейса, static методы интерфейса 
неявно public, если они объявлены без модификатора доступа. Как вы вскоре увидите, вы можете использовать модификатор 
доступа private со static методами.

Давайте взглянем на метод static интерфейса:

```
public interface Hop {
   static int getJumpHeight() {
      return 8;
} }
```

Поскольку метод определен без модификатора доступа, компилятор автоматически вставит модификатор public доступа. 
Метод getJumpHeight() работает так же, как static метод, определенный в классе. Другими словами, к нему можно получить 
доступ без экземпляра класса.

```
public class Skip {
   public int skip() {
      return Hop.getJumpHeight();
} }
```

Последнее правило о наследовании может немного сбить с толку, поэтому давайте рассмотрим пример. Ниже приведен пример 
класса Bunny, который реализует Hop и не компилируется:

```
public class Bunny implements Hop {
   public void printDetails() {
      System.out.println(getJumpHeight());   // DOES NOT COMPILE
} }
```

Без явной ссылки на имя интерфейса код не скомпилируется, даже несмотря на то, что Bunny реализует Hop. Это можно легко 
исправить, используя имя интерфейса:

```
public class Bunny implements Hop {
   public void printDetails() {
      System.out.println(Hop.getJumpHeight());
} }
```

Обратите внимание, что у нас нет той проблемы, которая была у нас, когда мы унаследовали два default метода интерфейса
с одной и той же сигнатурой. Java «решила» проблему множественного наследования static методов интерфейса, запретив их 
наследование!

#### Повторное использование кода с private методами интерфейса

Последние два типа конкретных методов, которые можно добавить к интерфейсам, — это private и private static методы 
интерфейса. Поскольку оба типа методов являются private, их можно использовать только в объявлении интерфейса, в котором
они объявлены. По этой причине они были добавлены в первую очередь для уменьшения дублирования кода. Например, 
рассмотрим следующий пример кода:

```
public interface Schedule {
   default void wakeUp()        { checkTime(7); }
   private void haveBreakfast() { checkTime(9); }
   static void workOut()        { checkTime(18); }
   private static void checkTime(int hour) {
      if (hour> 17) {
         System.out.println("You're late!");
      } else {
         System.out.println("You have "+(17-hour) + " hours left "
               + "to make the appointment");
} } }
```

Вы можете написать этот интерфейс без использования private метода, скопировав содержимое метода checkTime() в те места,
где он используется. Это намного короче и легче читать, если вы этого не сделаете. Поскольку авторы Java были достаточно
любезны, чтобы добавить эту функцию для нашего удобства, мы могли бы также использовать ее!

---

Мы могли бы также объявить checkTime() как public в предыдущем примере, но это сделало бы метод открытым для 
использования за пределами интерфейса. Один из важных принципов инкапсуляции — не раскрывать внутреннюю работу класса 
или интерфейса, когда это не требуется. Мы рассмотрим инкапсуляцию позже в этой главе.

---

Разница между нестатическим закрытым методом и статическим аналогична разнице между экземпляром и статическим методом, 
объявленным внутри класса. В частности, все дело в том, из каких методов каждый из них может быть вызван.

**Правила определения метода private интерфейса**

1. Метод private интерфейса должен быть помечен модификатором private и включать тело метода.
2. Метод private static интерфейса может быть вызван любым методом в определении интерфейса.
3. Метод private интерфейса может быть вызван только default и другими private нестатическими методами в определении 
интерфейса.

Другой способ думать об этом состоит в том, что метод private интерфейса доступен только для нестатических методов, 
определенных в интерфейсе. С другой стороны, к private static методу интерфейса может получить доступ любой метод в 
интерфейсе. Для обоих типов private методов класс, наследующий интерфейс, не может вызывать их напрямую.

#### Вызов абстрактных методов

Мы много говорили о новых типах интерфейсных методов, но как насчет abstract методов? Оказывается, default и private 
нестатические методы могут обращаться к abstract методам, объявленным в интерфейсе. Это основная причина, по которой мы 
связываем эти методы с членством экземпляра. Когда они вызываются, существует экземпляр интерфейса.

```
public interface ZooRenovation {
   public String projectName();
   abstract String status();
   default void printStatus() {
      System.out.print("The " + projectName() + " project " + status());
} }
```

В этом примере как projectName(), так и status() имеют одинаковые модификаторы (abstract и public являются неявными) и 
могут быть вызваны методом printStatus() по умолчанию.

#### Просмотр элементов интерфейса

Мы завершаем обсуждение элементов интерфейса таблицей 7.2, в которой показаны правила доступа для элементов внутри и вне
интерфейса.

#### Таблица 7.2 - Доступ к элементу интерфейса

|                       | Доступен из default и private<br/>  методов в интерфейсе? | Доступен из static методов в интерфейсе? | Доступен из методов в классах, наследующих интерфейс? | Доступен без экземпляра интерфейса? |  
|:---------------------:|:---------------------------------------------------------:|:----------------------------------------:|:-----------------------------------------------------:|:-----------------------------------:|
| Постоянные переменные |                            Да                             |                    Да                    |                          Да                           |                 Да                  |
|    abstract метод     |                            Да                             |                   Нет                    |                          Да                           |                 Нет                 |                                     
|     default метод     |                            Да                             |                   Нет                    |                          Да                           |                 Нет                 |
|     static метод      |                            Да                             |                    Да                    |            Да (требуется имя интерфейса)              |   Да (требуется имя интерфейса)     |
|     private метод     |                            Да                             |                   Нет                    |                          Нет                          |                 Нет                 |
| private static метод  |                            Да                             |                    Да                    |                          Нет                          |                 Нет                 |

Хотя таблица 7.2 может показаться сложной для запоминания, вот несколько быстрых советов для экзамена:

+ Рассматривайте abstract, default и нестатические private методы как принадлежащие экземпляру интерфейса.
+ Рассматривайте static методы и переменные как принадлежащие объекту класса интерфейса.
+ Все типы методов private интерфейса доступны только в объявлении интерфейса.

Используя эти правила, какие из следующих методов не компилируются?

```
public interface ZooTrainTour {
   abstract int getTrainName();
   private static void ride() {}
   default void playHorn() { getTrainName(); ride(); }
   public static void slowDown() { playHorn(); }
   static void speedUp() { ride(); }
}
```

Метод ride() является private и static, поэтому к нему можно получить доступ любым методом по default или static методом
в объявлении интерфейса. getTrainName() является abstract, поэтому к нему можно получить доступ с помощью default 
метода, связанного с экземпляром. Однако метод slowDown() является static и не может вызывать default метод или private 
метод, такой как playHorn(), без явного объекта ссылки. Поэтому метод slowDown() не компилируется.

Похлопайте себя по спине! Вы только что многое узнали об интерфейсах, возможно, даже больше, чем вы думали. Теперь 
сделайте глубокий вдох. Готовы? Следующий тип, который мы рассмотрим, это перечисления.

### Работа с перечислениями 427

В программировании обычно используется тип, который может иметь только конечный набор значений, таких как дни недели, 
времена года, основные цвета и т.д. Перечисление, или сокращенно enum, похоже на фиксированный набор констант.

Использование перечисления намного лучше, чем использование набора констант, потому что оно обеспечивает безопасную 
проверку типов. С числовыми или String константами вы можете передать недопустимое значение и не узнать его до времени 
выполнения. С перечислениями невозможно создать недопустимое значение перечисления без возникновения ошибки компилятора.

Перечисления появляются всякий раз, когда у вас есть набор элементов, типы которых известны во время компиляции. Общие 
примеры включают направления по компасу, месяцы года, планеты в Солнечной системе и карты в колоде (ну, может быть, не 
планеты в Солнечной системе, учитывая, что Плутон лишился планетарного статуса).

#### Создание простых перечислений

Чтобы создать перечисление, объявите тип с ключевым словом enum, именем и списком значений, как показано на рис. 7.4.

#### Рис. 7.4 - Определение простого перечисления

Мы называем перечисление, которое содержит только список значений, простым перечислением. При работе с простыми 
перечислениями точка с запятой в конце списка необязательна. Держите перечисление Season под рукой, так как мы 
используем его в этом разделе.

---

Значения Enum считаются константами и обычно записываются с использованием змеиного регистра. Например, перечисление, 
объявляющее список вкусов мороженого, может включать такие значения, как VANILLA, ROCKY_ROAD, MINT_CHOCOLATE_CHIP и т.д.

---

Использовать enum очень просто.

```
var s = Season.SUMMER;
System.out.println(Season.SUMMER);       // SUMMER
System.out.println(s == Season.SUMMER);  // true
```

Как видите, перечисления печатают имя перечисления при вызове toString(). Их можно сравнивать с помощью ==, потому что 
они похожи на static final константы. Другими словами, вы можете использовать equals() или == для сравнения 
перечислений, поскольку каждое значение перечисления инициализируется только один раз в виртуальной машине Java (JVM).

Одна вещь, которую вы не можете сделать, это расширить перечисление.

```
public enum ExtendedSeason extends Season {} // DOES NOT COMPILE
```

Значения в перечислении фиксированы. Вы не можете добавить больше, расширив перечисление.

#### Calling the values(), name(), and ordinal() Methods

Перечисление предоставляет метод values() для получения массива всех значений. Вы можете использовать это как любой 
обычный массив, в том числе в цикле for-each:

```
for (var season : Season.values()) {
   System.out.println(season.name() + " " + season.ordinal());
}
```

Вывод показывает, что каждое значение перечисления имеет соответствующее значение int, и значения перечислены в том 
порядке, в котором они объявлены:

```
WINTER 0
SPRING 1
SUMMER 2
FALL 3
```

Значение int останется неизменным во время выполнения вашей программы, но программу будет легче читать, если вы будете 
придерживаться понятного человеку значения enum.

В любом случае вы не можете напрямую сравнивать значение int и enum, поскольку перечисление — это тип, как и класс Java,
а не примитивное целое число.

```
if ( Season.SUMMER == 2) {} // DOES NOT COMPILE
```

#### Вызов метода valueOf()

Другой полезной функцией является извлечение значения enum из строки с помощью метода valueOf(). Это полезно при работе 
со старым кодом или разборе пользовательского ввода. Однако передаваемая строка должна точно соответствовать значению 
enum.

```
Season s = Season.valueOf("SUMMER"); // SUMMER

Season t = Season.valueOf("summer"); // IllegalArgumentException
```

Первый оператор работает и присваивает s правильное значение enum. Обратите внимание, что эта строка не создает значение
enum, по крайней мере, не напрямую. Каждое значение enum создается один раз при первой загрузке enum. Как только enum 
загружен, он извлекает единственное значение enum с соответствующим именем.

Второе утверждение наталкивается на проблему. Нет значения enum с именем summer в нижнем регистре. Java разводит руками 
в знак поражения и выдает исключение IllegalArgumentException.

```
Exception in thread "main" java.lang.IllegalArgumentException:
   No enum constant enums.Season.summer
```

### Использование перечислений в операторах switch

Перечисления можно использовать в операторах и выражениях switch. Обратите внимание на значения case в этом коде:

```
Season summer = Season.SUMMER;
switch(summer) {
   case WINTER:
      System.out.print("Get out the sled!");
      break;
   case SUMMER:
      System.out.print("Time for the pool!");
      break;
   default:
      System.out.print("Is it summer yet?");
}
```

Код выводит "Время для бассейна!", поскольку он соответствует SUMMER периоду. В каждом операторе case мы просто вводили 
значение перечисления, а не писали Season.WINTER. В конце концов, компилятор уже знает, что единственными возможными 
совпадениями могут быть значения enum. Java обрабатывает тип enum как неявный. На самом деле, если бы вы набрали case 
Season.WINTER он не скомпилировался бы. Не верите нам? Взгляните на этот эквивалентный пример, использующий выражение 
switch:

```
Season summer = Season.SUMMER;
var message = switch(summer) {
   case Season.WINTER -> "Get out the sled!";  // DOES NOT COMPILE
   case 0 -> "Time for the pool!";             // DOES NOT COMPILE
   default -> "Is it summer yet?";
};
System.out.print(message); 
```

Первый оператор case не компилируется, так как в значении case используется Season. Если бы мы изменили Season.FALL на 
просто FALL, тогда строка скомпилировалась бы. А как насчет второго оператора case? Так же, как ранее мы сказали, что 
вы не можете сравнивать перечисления со значениями int, вы не можете использовать их в операторе switch со значениями 
int. На экзамене обратите особое внимание при работе с перечислениями, чтобы они использовались только как перечисления.

### Добавление конструкторов, полей и методов

В то время как простое перечисление состоит только из списка значений, мы можем определить сложное перечисление с 
дополнительными элементами. Допустим, наш зоопарк хочет отслеживать маршруты движения, чтобы определить, в какие сезоны 
посетителей больше всего.

```
1: public enum Season {
2:    WINTER("Low"), SPRING("Medium"), SUMMER("High"), FALL("Medium");
3:    private final String expectedVisitors;
4:    private Season(String expectedVisitors) {
5:       this.expectedVisitors = expectedVisitors;
6:    }
7:    public void printExpectedVisitors() {
8:       System.out.println(expectedVisitors);
9:    } }
```

Здесь есть несколько вещей, на которые стоит обратить внимание. В строке 2 список значений перечисления заканчивается 
точкой с запятой (;). Хотя это необязательно, когда наше перечисление состоит исключительно из списка значений, оно 
необходимо, если в перечислении есть что-то помимо значений.

Строки 3–9 представляют собой обычный код Java. У нас есть переменная экземпляра, конструктор и метод. Мы помечаем 
переменную экземпляра как private и final в строке 3, чтобы наши свойства перечисления нельзя было изменить.

---
Хотя можно создать перечисление с переменными экземпляра, которые можно изменить, это очень плохая практика, поскольку 
они совместно используются в JVM. При разработке перечисления значения должны быть неизменяемыми.
---

Все конструкторы перечисления являются неявно private, а модификатор является необязательным. Это разумно, так как вы 
не можете расширить перечисление, а конструкторы можно вызывать только внутри самого перечисления. На самом деле 
конструктор перечисления не будет компилироваться, если он содержит модификатор public или protected.

Как насчет скобок в строке 2? Это вызовы конструктора, но без нового ключевого слова, обычно используемого для объектов. 
В первый раз, когда мы запрашиваем какое-либо из значений перечисления, Java создает все значения перечисления. После 
этого Java просто возвращает уже созданные значения перечисления. Учитывая это объяснение, вы можете понять, почему 
конструктор вызывается только один раз:

```
public enum OnlyOne {
   ONCE(true);
   private OnlyOne(boolean b) {
      System.out.print("constructing,");
   }
}

public class PrintTheOne {
   public static void main(String[] args) {
      System.out.print("begin,");
      OnlyOne firstCall = OnlyOne.ONCE; // Prints constructing,
      OnlyOne secondCall = OnlyOne.ONCE; // Doesn't print anything
      System.out.print("end");
   }
}
```

Этот класс печатает следующее:

```
begin,constructing,end
```

Если бы перечисление OnlyOne использовалось в программе ранее и, следовательно, инициализировалось раньше, то строка, 
объявляющая переменную firstCall, ничего бы не печатала.

Как мы вызываем метод перечисления? Это тоже просто: мы просто используем значение перечисления, за которым следует 
вызов метода.

```
Season.SUMMER.printExpectedVisitors();
```

Иногда вы хотите определить разные методы для каждого перечисления. Например, в нашем зоопарке разные сезонные часы. 
Зимой холодно и рано темнеет. Мы можем отслеживать часы через переменные экземпляра или позволить каждому значению 
перечисления управлять часами самостоятельно.

```
public enum Season {
   WINTER {
      public String getHours() { return "10am-3pm"; }
   },
   SPRING {
      public String getHours() { return "9am-5pm"; }
   },
   SUMMER {
      public String getHours() { return "9am-7pm"; }
   },
   FALL {
      public String getHours() { return "9am-5pm"; }
   };
   public abstract String getHours();
}
```

Что тут происходит? Похоже, мы создали абстрактный класс и кучу крошечных подклассов. В некотором смысле, мы сделали. 
Само перечисление имеет абстрактный метод. Это означает, что для реализации этого метода требуется каждое значение 
перечисления. Если мы забудем реализовать метод для одного из значений, получим ошибку компилятора:

```
The enum constant WINTER must implement the abstract method getHours()
```

Но что, если мы не хотим, чтобы каждое значение перечисления имело метод? Без проблем. Мы можем создать реализацию для 
всех значений и переопределить ее только для особых случаев.

```
public enum Season {
   WINTER {
      public String getHours() { return "10am-3pm"; }
   },
   SUMMER {
      public String getHours() { return "9am-7pm"; }
   },
   SPRING, FALL;
   public String getHours() { return "9am-5pm"; }
}
```

Это выглядит лучше. Мы кодируем только особые случаи и позволяем остальным использовать реализацию, предоставленную 
enum. Перечисление может даже реализовать интерфейс, так как для этого нужно просто переопределить абстрактные 
методы:

```
public interface Weather { int getAverageTemperature(); }

public enum Season implements Weather {
   WINTER, SPRING, SUMMER, FALL;
   public int getAverageTemperature() { return 30; }
}
```

То, что у перечисления может быть много методов, не означает, что оно должно быть. Старайтесь, чтобы ваши перечисления 
были простыми. Если ваше перечисление больше одной или двух страниц, вероятно, оно слишком длинное. Когда перечисления 
становятся слишком длинными или слишком сложными, их трудно читать.


---
Вы могли заметить, что в каждом из этих примеров перечисления список значений стоит первым. Это не было случайностью. 
Независимо от того, является ли перечисление простым или сложным, список значений всегда идет первым.
---

## Запечатанные классы (Sealing Classes)

Перечисление с множеством конструкторов, полей и методов может начать напоминать полнофункциональный класс. Что, если бы
мы могли создать класс, но ограничить прямые подклассы фиксированным набором классов? Входите в запечатанные классы! 
Запечатанный класс — это класс, который ограничивает, какие другие классы могут его непосредственно расширять. Это 
новинка для Java 17, поэтому ожидайте увидеть хотя бы один вопрос о них на экзамене.

---
Вы случайно не заметили, что мы сказали "непосредственно расширять" в определении закрытого класса? Как вы вскоре 
увидите, для класса, не указанного в объявлении закрытого класса, есть способ расширить его косвенно. Однако, если 
мы не скажем иначе, предположим, что мы имеем в виду подклассы, которые непосредственно расширяют класс sealed.
---

### Объявление запечатанного класса

Начнем с простого примера. Запечатанный класс объявляет список классов, которые могут его расширить, а подклассы 
объявляют, что они расширяют запечатанный класс. На рис. 7.5 объявлен запечатанный класс с двумя прямыми подклассами.

#### Рис. 7.5 - Определение запечатанного класса

Заметили что-нибудь новое? Java 17 включает три новых ключевых слова, с которыми вы должны быть знакомы к экзамену. Мы 
часто используем final с запечатанными подклассами, но рассмотрим каждый из них после того, как рассмотрим основы.

**Ключевые слова запечатанного класса**

+ sealed: Указывает, что класс или интерфейс могут быть расширены/реализованы только именованными классами или интерфейсами.
+ permits: Используется с запечатанным (sealed) ключевым словом для перечисления разрешенных классов и интерфейсов.
+ non-sealed: Применяется к классу или интерфейсу, который расширяет запечатанный класс, указывая, что он может быть 
расширен неопределенными классами.

Пока довольно легко, верно? Экзамен также может проверить вас на то, для чего закрытые классы не могут быть 
использованы. Например, вы видите, почему каждый из этих наборов объявлений не компилируется?

```
public class sealed Frog permits GlassFrog {} // DOES NOT COMPILE
public final class GlassFrog extends Frog {}

public abstract sealed class Wolf permits Timber {}
public final class Timber extends Wolf {}
public final class MyWolf extends Wolf {} // DOES NOT COMPILE
```

Первый пример не компилируется, потому что модификаторы класса и запечатывания расположены в неправильном порядке. 
Модификатор должен стоять перед типом класса. Второй пример не компилируется, потому что MyWolf не указан в 
объявлении Wolf.

_Запечатанные классы обычно объявляются с модификатором abstract, хотя это, конечно, не требуется._

Объявление запечатанного класса с помощью запечатанного модификатора — это простая часть. В большинстве случаев, если вы
видите на экзамене вопрос о запечатанных классах, они проверяют ваши знания о том, правильно ли подкласс расширяет 
запечатанный класс. Существует ряд важных правил, которые необходимо знать перед экзаменом, поэтому внимательно 
прочитайте следующие разделы.

### Компиляция запечатанных классов

Допустим, мы создаем класс Penguin и компилируем его в новый пакет без какого-либо другого исходного кода. Имея это в 
виду, компилируется ли следующее?

```
// Penguin.java
package zoo;
public sealed class Penguin permits Emperor {}
```

Нет! Почему? Ответ заключается в том, что запечатанный класс необходимо объявить (и скомпилировать) в том же пакете, 
что и его непосредственные подклассы. Но как насчет самих подклассов? Каждый из них должен расширять запечатанный класс. 
Например, следующее не компилируется.

```
// Penguin.java
package zoo;
public sealed class Penguin permits Emperor {} // DOES NOT COMPILE

// Emperor.java
package zoo;
public final class Emperor {}
```

Несмотря на то, что класс Emperor объявлен, он не расширяет класс Penguin.

_Но подождите, это еще не все! В главе 12 «Модули» вы узнаете об именованных модулях, которые позволяют запечатывать 
классы и их прямые подклассы в разных пакетах при условии, что они находятся в одном и том же именованном модуле._

### Указание модификатора подкласса

Хотя некоторые типы, например интерфейсы, имеют определенное количество неявных модификаторов, запечатанные классы их не
имеют. Каждый класс, который непосредственно расширяет запечатанный класс, должен указывать только один из следующих 
трех модификаторов: final, sealed, или non-sealed. Запомните это правило на экзамене!

#### Подкласс final

Первый модификатор, который мы рассмотрим и который можно применить к прямому подклассу закрытого класса, — это 
модификатор final.

```
public sealed class Antelope permits Gazelle {}

public final class Gazelle extends Antelope {}

public class George extends Gazelle {} // DOES NOT COMPILE
```

Как и в случае с обычным классом, модификатор final предотвращает дальнейшее расширение подкласса Gazelle.

#### Подкласс sealed

Далее, давайте рассмотрим пример с использованием запечатанного модификатора:

```
public sealed class Mammal permits Equine {}

public sealed class Equine extends Mammal permits Zebra {}

public final class Zebra extends Equine {}
```

Модификатор sealed, примененный к подклассу Equine, означает, что должны присутствовать те же правила, которые мы 
применили к родительскому классу Mammal. А именно, Equine определяет свой собственный список разрешенных подклассов. 
Обратите внимание в этом примере, что Zebra является косвенным подклассом Mammal, но не названа в классе Mammal.

Несмотря на разрешение косвенных подклассов, не названных в Mammal, список классов, которые могут наследовать Mammal, 
по-прежнему фиксирован. Если у вас есть ссылка на объект Mammal, это должно быть Mammal, Equine или Zebra.

#### Подкласс non-sealed

Модификатор non-seal используется, чтобы открыть запечатанный родительский класс для потенциально неизвестных 
подклассов. Давайте изменим наш предыдущий пример, чтобы MyWolf мог компилироваться без изменения объявления Wolf:

```
public sealed class Wolf permits Timber {}

public non-sealed class Timber extends Wolf {}

public class MyWolf extends Timber {}
```

В этом примере мы можем создать непрямой подкласс Wolf с именем MyWolf, имя которого не указано в объявлении Wolf. 
Также обратите внимание, что MyWolf не является окончательным, поэтому он может быть расширен любым подклассом, таким 
как MyFurryWolf.

```
public class MyFurryWolf extends MyWolf {}
```

На первый взгляд это может показаться немного нелогичным. Ведь мы смогли создать подклассы Wolf, которые не были 
объявлены в Wolf. Так Wolf все еще запечатан? Да, но это благодаря полиморфизму. Любой экземпляр MyWolf или MyFurryWolf 
также является экземпляром Timber, имя которого указано в объявлении Wolf. Мы обсудим полиморфизм ближе к концу этой 
главы.

---
Если вы все еще беспокоитесь о том, что слишком часто открываете sealed класс с помощью non-sealed подкласса, 
помните, что человек, пишущий запечатанный класс, может видеть объявление всех прямых подклассов во время компиляции. 
Они могут решить, разрешать ли поддержку non-sealed подкласса.
---

### Пункт об исключении разрешений (Omitting the permits Clause)

До сих пор во всех примерах, которые вы видели, требовалось предложение permits при объявлении закрытого класса, но это 
не всегда так. Представьте, что у вас есть Snake.java-файл с двумя классами верхнего уровня, определенными внутри него:

```
// Snake.java
public sealed class Snake permits Cobra {}
final class Cobra extends Snake {}
```

В этом случае предложение о разрешениях (permits) является необязательным и может быть опущено. Однако ключевое слово 
extends по-прежнему требуется в подклассе:

```
// Snake.java
public sealed class Snake {}
final class Cobra extends Snake {}
```

Если бы эти классы были в отдельных файлах, этот код не скомпилировался бы! Это правило также применяется к запечатанным
классам с вложенными подклассами.

```
// Snake.java
public sealed class Snake {
final class Cobra extends Snake {}
}
```

---

##### Ссылки на вложенные подклассы

Хотя это облегчает чтение кода, если вы опустите предложение permits для вложенных подклассов, вы можете присвоить им 
имена. Однако синтаксис может отличаться от того, что вы ожидаете.

```
public sealed class Snake permits Cobra { // DOES NOT COMPILE
   final class Cobra extends Snake {}
}
```

Этот код не компилируется, поскольку Cobra требует ссылки на пространство имен Snake. Следующее устраняет эту проблему:

```
public sealed class Snake permits Snake.Cobra {
   final class Cobra extends Snake {}
}
```

Когда все ваши подклассы вложены, мы настоятельно рекомендуем опустить класс permits.

---

Вскоре мы рассмотрим вложенные классы. На данный момент вам просто нужно знать, что вложенный класс — это класс, 
определенный внутри другого класса, и что правило пропуска также применяется к вложенным классам.

Табл. 7.3 является удобной ссылкой на эти случаи.

#### Таблица 7.3 - Использование положения о permits в sealed классах

|     Расположение прямых подклассов     |         пункт permits         |  
|:--------------------------------------:|:-----------------------------:|
| В другом файле из запечатанного класса |           Требуется           |
|  В том же файле, что и закрытый класс  | Разрешено, но не обязательно  |                                     
|    Вложен внутри закрытого класса      | Разрешено, но не обязательно  |

### Запечатанные интерфейсы

Помимо классов, интерфейсы также могут быть запечатаны. Идея аналогична классам, и применяются многие из тех же правил. 
Например, запечатанный интерфейс должен находиться в том же пакете или именованном модуле, что и классы или интерфейсы, 
которые непосредственно расширяют или реализуют его.

Одной из отличительных особенностей закрытого интерфейса является то, что список разрешений (permits) может применяться 
к классу, который реализует интерфейс, или к интерфейсу, который расширяет интерфейс.

```
// Sealed interface
public sealed interface Swims permits Duck, Swan, Floats {}

// Classes permitted to implement sealed interface
public final class Duck implements Swims {}
public final class Swan implements Swims {}

// Interface permitted to extend sealed interface
public non-sealed interface Floats extends Swims {}
```

Как насчет модификатора, применяемого к интерфейсам, которые расширяют закрытый интерфейс? Что ж, помните, что 
интерфейсы неявно abstract и не могут быть помечены как final. По этой причине интерфейсы, которые расширяют закрытый 
интерфейс, могут быть помечены только как sealed или non-sealed. Они не могут быть помечены как final.

### Просмотр правил закрытого класса

Каждый раз, когда вы видите запечатанный класс на экзамене, обратите пристальное внимание на объявление подкласса и 
модификаторы.

**Правила запечатаного класса**

+ Запечатанные классы объявляются с модификаторами sealed и permits.
+ Запечатанные классы должны быть объявлены в том же пакете или именованном модуле, что и их непосредственные подклассы.
+ Прямые подклассы запечатанных классов должны быть помечены как final, sealed или non-sealed.
+ Предложение permits является необязательным, если запечатанный класс и его прямые подклассы объявлены в одном и том же
файле или подклассы вложены в запечатанный класс.
+ Интерфейсы могут быть запечатаны, чтобы ограничить классы, которые их реализуют, или интерфейсы, которые их расширяют.

---

_Сценарий реального мира_

**Зачем нужны запечатанные классы?**

В главе 3 «Принятие решений» вы узнали о выражениях switch и сопоставлении с образцом. Представьте, если бы мы 
могли обращаться с запечатанным классом как с перечислением в выражении switch, применяя сопоставление с образцом. Для 
запечатанного класса Fish с двумя прямыми подклассами это может выглядеть примерно так:

```
public void printName(Fish fish) {
   System.out.println(switch(fish) {
      case Trout t -> t.getTroutName();
      case Bass b -> b.getBassName();
   });
}
```

Если бы Fish не был запечатан, для выражения switch потребовалась бы default ветвь, иначе код не скомпилировался бы. 
Поскольку он запечатан, компилятор знает все варианты! Хорошая новость заключается в том, что эта функция находится в 
разработке, но плохая новость заключается в том, что она все еще находится в предварительной версии в Java 17 и 
официально не выпущена. Мы просто хотели дать вам представление о том, куда направляются некоторые из этих новых 
функций.

---

## Инкапсуляция данных с помощью записей

Мы оставили лучший новый тип Java напоследок! Если вы слышали что-нибудь о новых функциях Java, вы, вероятно, слышали о 
записях. Записи интересны, потому что они удаляют тонны стандартного кода. Прежде чем мы перейдем к записям, полезно 
иметь некоторый контекст того, почему они были добавлены в язык, поэтому мы начнем с инкапсуляции.

### Понимание инкапсуляции

POJO, что означает Plain Old Java Object, представляет собой класс, используемый для моделирования и передачи данных, 
часто с небольшим количеством сложных методов или вообще без них (отсюда и «простая» часть определения).
Возможно, вы также слышали о JavaBean, то есть о POJO, к которому применяются некоторые дополнительные правила.

Давайте создадим простой POJO с двумя полями:

```
public class Crane {
   int numberEggs;
   String name;
   public Crane(int numberEggs, String name) {
      this.numberEggs = numberEggs;
      this.name = name;
   }
}
```

О, поля — это пакетный доступ. Почему мы заботимся? Это означает, что кто-то за пределами класса в том же пакете может 
изменить эти значения и создать неверные данные, например:

```
public class Poacher {
   public void badActor() {
      var mother = new Crane(5, "Cathy");
      mother.numberEggs = -100;
   }
}
```

Это явно никуда не годится. Мы не хотим, чтобы у матери Crane было отрицательное количество яиц! Инкапсуляция приходит 
на помощь. Инкапсуляция - это способ защитить членов класса путем ограничения доступа к ним. В Java это обычно 
реализуется путем объявления всех переменных экземпляра private. Вызывающие должны использовать методы для извлечения 
или изменения переменных экземпляра.

Инкапсуляция — это защита класса от неожиданного использования. Это также позволяет нам позже изменять методы и 
поведение класса без того, чтобы кто-то уже имел прямой доступ к переменной экземпляра в классе. Например, мы можем 
изменить тип данных переменной экземпляра, но сохранить те же сигнатуры методов. Таким образом, мы сохраняем полный 
контроль над внутренней работой класса.

Давайте взглянем на недавно инкапсулированный (и неизменяемый) класс Crane:

```
1: public final class Crane {
2:    private final int numberEggs;
3:    private final String name;
4:    public Crane(int numberEggs, String name) {
5:       if (numberEggs >= 0) this.numberEggs = numberEggs; // guard condition
6:       else throw new IllegalArgumentException();
7:       this.name = name;
8:    }
9:    public int getNumberEggs() { // getter
10:      return numberEggs;
11:   }
12:   public String getName() { // getter
13:      return name;
14:   }
15: }
```

Обратите внимание, что переменные экземпляра теперь закрыты в строках 2 и 3. Это означает, что только код внутри класса 
может читать или записывать их значения. Поскольку мы написали класс, мы знаем, что лучше не устанавливать отрицательное 
количество яиц. В строках 9–11 мы добавили метод для чтения значения, который называется _методом доступа_ или геттером.

Вы могли заметить, что мы пометили класс и его переменные экземпляра как final, и у нас нет никаких методов-мутаторов 
(mutator methods) или сеттеров для изменения значения переменных экземпляра. Это потому, что мы хотим, чтобы наш класс 
был неизменяемым в дополнение к хорошей инкапсуляции. Как вы видели в главе 6, шаблон неизменяемых объектов — это шаблон 
объектно-ориентированного проектирования, в котором объект не может быть изменен после его создания. Вместо изменения 
неизменяемого объекта вы создаете новый объект, содержащий любые свойства исходного объекта, который вы хотите 
скопировать.

Чтобы просмотреть, помните, что данные (переменная экземпляра) являются private, а геттеры/сеттеры public для 
инкапсуляции. Вам даже не нужно предоставлять геттеры и сеттеры. Пока переменные экземпляра private, все в порядке. 
Например, следующий класс хорошо инкапсулирован, хотя и не очень полезен, так как не объявляет никаких private 
методов:

```
public class Vet {
   private String name = "Dr Rogers";
   private int yearsExperience = 25;
}
```

Вы должны опустить сеттеры, чтобы класс был неизменяемым. Просмотрите главу 6, чтобы узнать о дополнительных правилах 
создания неизменяемых объектов.

### Применение записей

Наш класс Crane состоял из 15 строк. Мы можем записать это намного короче, как показано на рис. 7.6. Если на мгновение 
отложить в сторону предложение защиты для numberEggs в конструкторе, эта запись эквивалентна и неизменяема!

#### Рис. 7.6 - Определение записи


Ух ты! Это всего одна строка! Запись (record) — это особый тип класса, ориентированного на данные, в который компилятор 
вставляет за вас шаблонный код.

На самом деле компилятор вставляет гораздо больше, чем 14 строк, которые мы написали ранее. В качестве бонуса компилятор
вставляет полезные реализации методов Object equals(), hashCode() и toString(). Мы рассмотрели многое в одной строке 
кода!

Теперь представьте, что у нас было 10 полей данных вместо 2. Это множество методов, которые избавляют нас от 
необходимости писать. И мы даже не говорили о конструкторах! Хуже того, каждый раз, когда кто-то изменяет поле, может 
потребоваться обновление десятков строк связанного с ним кода. Например, name может использоваться в конструкторе, 
методе toString(), equals() и так далее. Если у нас есть приложение с сотнями POJO, запись может сэкономить нам 
драгоценное время.

Создать экземпляр Crane и напечатать некоторые поля очень просто:

```
var mommy = new Crane(4, "Cammy");
System.out.println(mommy.numberEggs());   // 4
System.out.println(mommy.name());         // Cammy
```

Здесь следует выделить несколько вещей. Во-первых, мы никогда не определяли никаких конструкторов или методов в нашем 
объявлении Crane. Откуда компилятор знает, что делать? В фоновом режиме он создает для вас конструктор с параметрами в 
том же порядке, в котором они появляются в объявлении записи. Отсутствие или изменение порядка типов приведет к ошибкам 
компилятора:

```
var mommy1 = new Crane("Cammy", 4);  // DOES NOT COMPILE
var mommy2 = new Crane("Cammy");     // DOES NOT COMPILE
```

Для каждого поля также создается метод доступа в виде имени поля и набора скобок. В отличие от традиционных POJO или 
JavaBeans, методы не имеют префикса get или is. Всего несколько символов, которые записывают, избавят вас от 
необходимости печатать! Наконец, записи переопределяют для вас ряд методов в Object.

**Участники автоматически добавляются в записи**

+ Конструктор: конструктор с параметрами в том же порядке, что и объявление записи
+ Метод доступа: один метод доступа для каждого поля
+ equals(): метод сравнения двух элементов, который возвращает true, если каждое поле равно с точки зрения equals()
+ hashCode(): согласованный метод hashCode(), использующий все поля
+ toString(): Реализация toString(), которая печатает каждое поле записи в удобном для чтения формате

Ниже приведены примеры новых методов. Помните, что метод println() будет автоматически вызывать метод toString() для 
любого переданного ему объекта.

```
var father = new Crane(0, "Craig");
System.out.println(father);              // Crane[numberEggs=0, name=Craig]

var copy = new Crane(0, "Craig");
System.out.println(copy);                // Crane[numberEggs=0, name=Craig]
System.out.println(father.equals(copy)); // true
System.out.println(father.hashCode() + ", " + copy.hashCode()); // 1007, 1007
```

Это основы записи. Мы говорим «основы», потому что с ними можно делать гораздо больше, как вы увидите в следующих 
разделах.

_Учитывая наше однострочное объявление Crane, представьте, сколько кода и работы потребуется для написания 
эквивалентного класса. Это может легко занять 40+ строк! Было бы забавно попытаться написать все методы, которые 
регистрируют предложение._

Забавный факт: вполне законно иметь запись без полей. Он просто объявляется с помощью ключевого слова record и круглых 
скобок:

```
public record Crane() {}
```

Не то, что вы бы использовали в своем собственном коде, но это может появиться на экзамене.

### Понимание неизменности записи

Как вы видели, у записей нет сеттеров. Каждое поле по своей сути является final и не может быть изменено после того, 
как оно было записано в конструкторе. Чтобы «изменить» запись, вам нужно создать новый объект и скопировать все данные, 
которые вы хотите сохранить.

```
var cousin = new Crane(3, "Jenny");
var friend = new Crane(cousin.numberEggs(), "Janeice");
```

Точно так же, как интерфейсы неявно abstract, записи также неявно окончательны. Модификатор final является 
необязательным, но предполагается.

```
public final record Crane(int numberEggs, String name) {}
```

Как и в случае с перечислениями, это означает, что вы не можете расширять или наследовать запись.

```
public record BlueCrane() extends Crane {} // DOES NOT COMPILE
```

Как и перечисления, запись может реализовывать обычный или запечатанный интерфейс при условии, что она реализует все 
абстрактные методы.

```
public interface Bird {}
public record Crane(int numberEggs, String name) implements Bird {}
```

_Хотя это выходит далеко за рамки этой книги, есть несколько веских причин сделать классы, ориентированные на данные, 
неизменяемыми. Это может привести к менее подверженному ошибкам коду, поскольку новый объект создается каждый раз при 
изменении данных. Это также делает их по своей сути потокобезопасными и пригодными для использования в параллельных 
средах._

### Объявление конструкторов

Что, если вам нужно объявить рекорд с некоторыми охранниками, как мы это делали ранее? В этом разделе мы рассмотрим два 
способа достижения этого с помощью записей.

#### Длинный конструктор

Во-первых, мы можем просто объявить конструктор, который компилятор обычно вставляет автоматически, и который мы 
называем длинным конструктором.

```
public record Crane(int numberEggs, String name) {
   public Crane(int numberEggs, String name) {
      if (numberEggs < 0) throw new IllegalArgumentException();
      this.numberEggs = numberEggs;
      this.name = name;
   }
}
```

Компилятор не вставит конструктор, если вы определите его с тем же списком параметров в том же порядке. Поскольку 
каждое поле является final, конструктор должен установить каждое поле. Например, эта запись не компилируется:

```
public record Crane(int numberEggs, String name) {
   public Crane(int numberEggs, String name) {}     // DOES NOT COMPILE
}
```

Хотя возможность объявлять конструктор является приятной особенностью записей, это также проблематично. Если у нас есть 
20 полей, нам нужно будет объявить назначения для каждого из них, введя шаблон, который мы стремились удалить. О, 
черт возьми!

#### Компактные конструкторы

К счастью, авторы Java добавили возможность определять компактный конструктор для записей. Компактный конструктор — это 
специальный тип конструктора, используемый для записи, чтобы кратко обрабатывать проверку и преобразование. Он не 
принимает никаких параметров и неявно устанавливает все поля. На рис. 7.7 показан пример компактного конструктора.

#### Рис. 7.7 - Объявление компактного конструктора


Отлично! Теперь мы можем проверить нужные нам значения, и нам не нужно перечислять все параметры конструктора и 
тривиальные присваивания. Java выполнит полный конструктор после компактного конструктора. Вы также должны помнить, что 
компактный конструктор объявляется без круглых скобок, так как экзамен может попытаться вас обмануть. Как показано на 
рис. 7.7, мы можем даже преобразовывать параметры конструктора, как мы обсудим в следующем разделе.

_Вы можете подумать, что вам нужны специальные методы для каждого поля в записи, например отрицательная проверка, которую
мы сделали с помощью setNumberEggs(). На практике многие POJO создаются для общего использования с небольшой проверкой._

#### Преобразование параметров

Компактные конструкторы дают вам возможность применять преобразования к любому входному значению. Посмотрите, сможете 
ли вы понять, что делает следующий компактный конструктор:

```
public record Crane(int numberEggs, String name) {
   public Crane {
      if (name == null || name.length() < 1)
         throw new IllegalArgumentException();
      name = name.substring(0,1).toUpperCase()
         + name.substring(1).toLowerCase();
   }
}
```

Сдаваться? Он проверяет строку, а затем форматирует ее так, чтобы только первая буква была заглавной. Как и прежде, Java
вызывает полный конструктор после компактного конструктора, но с измененными параметрами конструктора.

Хотя компактные конструкторы могут изменять параметры конструктора, они не могут изменять поля записи. Например, это не 
компилируется:

```
public record Crane(int numberEggs, String name) {
   public Crane {
      this.numberEggs = 10; // DOES NOT COMPILE
   }
}
```

Удаление ссылки this позволяет скомпилировать код, поскольку вместо этого изменяется параметр конструктора.

_Хотя в этом разделе мы рассмотрели как длинную, так и компактную формы конструкторов записей, настоятельно 
рекомендуется придерживаться компактной формы, если у вас нет веских причин не делать этого._

#### Перегруженные конструкторы
