# За пределами классов

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Объявляйте и создавайте экземпляры объектов Java, включая объекты вложенного класса, и объясняйте жизненный цикл 
объекта, включая создание, переназначение ссылок и сборку мусора
+ Создавайте классы и записи, а также определяйте и используйте экземпляры и статические поля и методы, конструкторы, а 
также экземпляры и статические инициализаторы
+ Понимайте области видимости переменных, используйте вывод типа локальной переменной, применяйте инкапсуляцию и 
делайте объекты неизменяемыми
+ Реализуйте полиморфизм и отличайте тип объекта от ссылочного типа. Выполняйте приведение типов, идентифицируйте типы 
объектов с помощью оператора instanceof и сопоставления с образцом
+ Создавайте и используйте интерфейсы, определяйте функциональные интерфейсы и используйте частные, статические методы 
интерфейса и методы интерфейса по умолчанию
+ Создавайте и используйте перечисления с полями, методами и конструкторами

---

В главе 6 «Проектирование классов» мы показали, как создавать, инициализировать и расширять как абстрактные, так и 
конкретные классы. В этой главе мы переходим от классов к другим типам, доступным в Java, включая интерфейсы, 
перечисления, закрытые классы и записи. Многие из основных правил, о которых вы узнали в главе 5 «Методы», по-прежнему 
применяются, например, модификаторы доступа и статические члены, хотя для каждого типа существуют дополнительные 
правила. Мы также рассмотрим инкапсуляцию и то, как правильно защитить элементы экземпляра. Наконец, мы завершаем эту 
главу обсуждением вложенных типов и полиморфного наследования.

В этой главе помните, что файл Java может иметь не более одного общедоступного типа верхнего уровня, и он должен 
совпадать с именем файла. Это относится к классам, перечислениям, записям и так далее. Кроме того, помните, что тип 
верхнего уровня может быть объявлен только с общедоступным доступом или доступом к пакету.

---

Другим типом верхнего уровня, доступным в Java, являются аннотации. Знание того, как создавать пользовательские 
аннотации, может быть полезным навыком на практике, хотя это и не требуется для сдачи экзамена. Вы все равно должны 
знать, как использовать определенные аннотации для экзамена, такие как @Override.

---

## Реализация интерфейсов

В главе 6 вы узнали об абстрактных классах, в частности о том, как их создавать и расширять. Поскольку классы могут 
расширять только один класс, они имели ограниченное применение для наследования. С другой стороны, класс может 
реализовывать любое количество интерфейсов. Интерфейс - это абстрактный тип данных, который объявляет список 
абстрактных методов, которые должен предоставлять любой класс, реализующий интерфейс.

Со временем точное определение интерфейса изменилось, поскольку теперь поддерживаются новые типы методов. В этой главе 
мы начнем с элементарного определения интерфейса и расширим его, чтобы охватить все поддерживаемые элементы.

### Объявление и использование интерфейса

В Java интерфейс определяется с помощью ключевого слова interface, аналогичного ключевому слову class, используемому при
определении класса. См. рис. 7.1 для правильного объявление интерфейса.


#### Рис. 7.1 - Определение интерфейса

На рис. 7.1 объявление нашего интерфейса включает абстрактный метод и постоянную переменную. Переменные интерфейса 
называются константами, поскольку предполагается, что они public, static и final. Они 
инициализируются постоянным значением при объявлении. Поскольку они являются public и static, их можно 
использовать вне объявления интерфейса, не требуя экземпляра интерфейса. Рисунок 7.1 также включает абстрактный метод, 
который, как и переменная интерфейса, считается public.

_Для краткости мы часто используем фразу “экземпляр интерфейса” в этой главе имею в виду экземпляр класса, который 
реализует интерфейс._

Что это значит для переменной или метода, чтобы считаться чем-то? Один аспект объявления интерфейса, который отличается 
от абстрактного класса, состоит в том, что он содержит неявные модификаторы. Неявное модификатор-модификатор, который 
компилятор автоматически вставляет в код. Например, интерфейс, всегда считается абстрактным, даже если он не отмечен 
таким образом. Вскоре мы рассмотрим правила и примеры неявных модификаторов более подробно.

Начнем с простого примера. Представьте, что у нас есть интерфейс WalksOnTwoLegs, определенный следующим образом:

```
public abstract interface WalksOnTwoLegs {}
```

Он компилируется, потому что интерфейсы не требуются для определения каких-либо методов. Модификатор abstract в этом 
примере является необязательным для интерфейсов, и компилятор вставляет его, если он не указан. Теперь рассмотрим 
следующие два примера, которые не компилируются:

```
public class Biped {
   public static void main(String[] args) {
      var e = new WalksOnTwoLegs();         // DOES NOT COMPILE
   }
}

public final interface WalksOnEightLegs {}  // DOES NOT COMPILE
```

Первый пример не компилируется, так как WalksOnTwoLegs является интерфейсом и не может быть создан. Второй пример, 
WalksOnEightLegs, не компилируется, потому что интерфейсы не могут быть помечены как final по той же причине, по которой
abstract классы не могут быть помечены как final. Другими словами, пометка интерфейса как final подразумевает, что ни 
один класс не сможет его реализовать.

Как вы используете интерфейс? Допустим, у нас есть интерфейс Climb, определенный следующим образом:

```
public interface Climb {
   Number getSpeed(int age);
}
```

Затем у нас есть конкретный класс FieldMouse, который вызывает интерфейс Climb, используя ключевое слово implements в 
объявлении своего класса, как показано на рис. 7.2.

#### Рис. 7.2 - Реализации интерфейса

Класс FieldMouse объявляет, что он реализует интерфейс Climb и включает переопределенную версию getSpeed(), 
унаследованную от интерфейса Climb. Сигнатура метода getSpeed() точно совпадает, а возвращаемый тип является 
ковариантным, поскольку Float может быть неявно приведен к Number. Модификатор доступа метода интерфейса неявно public в
Climb, хотя конкретный класс FieldMouse должен явно объявить его.

Как показано на рис. 7.2, класс может реализовывать несколько интерфейсов, разделенных запятой (,). Если какой-либо из 
интерфейсов определяет abstract методы, то для их переопределения требуется конкретный класс. В этом случае FieldMouse 
реализует интерфейс CanBurrow, который мы видели на рис. 7.1. Таким образом, класс переопределяет два абстрактных метода
одновременно с одним объявлением метода. В этой главе вы узнаете больше о повторяющихся и совместимых методах 
интерфейса.

### Расширение интерфейса

Как и класс, интерфейс может расширять другой интерфейс с помощью ключевого слова extends.

```
public interface Nocturnal {}

public interface HasBigEyes extends Nocturnal {}
```

В отличие от класса, который может расширять только один класс, интерфейс может расширять несколько интерфейсов.

```
public interface Nocturnal {
   public int hunt();
}

public interface CanFly {
   public void flap();
}

public interface HasBigEyes extends Nocturnal, CanFly {}

public class Owl implements HasBigEyes {
   public int hunt() { return 5; }
   public void flap() { System.out.println("Flap!"); }
}
```

В этом примере класс Owl реализует интерфейс HasBigEyes и должен реализовывать методы hunt() и flap(). Расширение двух 
интерфейсов разрешено, поскольку интерфейсы не инициализируются как часть иерархии классов. В отличие от абстрактных 
классов, они не содержат конструкторов и не являются частью инициализации экземпляра. Интерфейсы просто определяют набор
правил и методов, которым должен следовать реализующий их класс.

### Наследование интерфейса

Как и в случае с абстрактным классом, когда конкретный класс наследует интерфейс, должны быть реализованы все 
унаследованные абстрактные методы. Мы иллюстрируем этот принцип на рис. 7.3. Сколько абстрактных методов наследует 
конкретный класс Swan?

#### Рис. 7.3 - Наследование интерфейса


Сдаться? Конкретный класс Swan наследует четыре абстрактных метода, которые он должен реализовать: getType(), 
canSwoop(), fly() и swim(). Давайте взглянем на другой пример с абстрактным классом, реализующим интерфейс:

```
public interface HasTail {
   public int getTailLength();
}

public interface HasWhiskers {
   public int getNumberOfWhiskers();
}

public abstract class HarborSeal implements HasTail, HasWhiskers {}

public class CommonSeal extends HarborSeal {}    // DOES NOT COMPILE
```

Класс HarborSeal компилируется, поскольку он является abstract и не требует реализации каких-либо abstract методов, 
которые он наследует. Однако конкретный класс CommonSeal должен переопределять все унаследованные abstract методы.

#### Смешивание ключевых слов класса и интерфейса

Создатели экзамена любят вопросы, в которых смешаны терминология классов и интерфейсов. Хотя класс может реализовать 
интерфейс, класс не может расширять интерфейс. Аналогично, хотя интерфейс может расширять другой интерфейс, интерфейс 
не может реализовать другой интерфейс. Следующие примеры иллюстрируют эти принципы:

```
public interface CanRun {}
public class Cheetah extends CanRun {} // DOES NOT COMPILE

public class Hyena {}
public interface HasFur extends Hyena {} // DOES NOT COMPILE
```

В первом примере показан класс, который пытается расширить интерфейс и не компилируется. Во втором примере показан 
интерфейс, пытающийся расширить класс, который также не компилируется. Будьте осторожны с примерами на экзамене, которые
смешивают объявления классов и интерфейсов.

#### Наследование повторяющихся абстрактных методов

Java поддерживает наследование двух абстрактных методов, которые имеют совместимые объявления методов.

```
public interface Herbivore { public void eatPlants(); }

public interface Omnivore { public void eatPlants(); }

public class Bear implements Herbivore, Omnivore {

public void eatPlants() {
   System.out.println("Eating plants");
} }
```

Под совместимостью мы подразумеваем, что метод может быть написан таким образом, чтобы правильно переопределять оба 
унаследованных метода: например, с помощью ковариантных возвращаемых типов, о которых вы узнали в главе 6.

Ниже приведен пример несовместимого объявления:

```
public interface Herbivore { public void eatPlants(); }

public interface Omnivore { public int eatPlants(); }

public class Tiger implements Herbivore, Omnivore { // DOES NOT COMPILE
...
}
```

Невозможно написать версию Tiger, удовлетворяющую обоим унаследованным abstract методам. Код не компилируется независимо
от того, что объявлено внутри класса Tiger.

#### Вставка неявных модификаторов

Как упоминалось ранее, неявный модификатор — это модификатор, который автоматически вставляется компилятором. Это 
напоминает компилятор, вставляющий конструктор по умолчанию без аргументов, если вы не определили конструктор, о котором
вы узнали в главе 6. Вы можете вставить эти неявные модификаторы самостоятельно или позволить компилятору вставить их за
вас.

Следующий список включает неявные модификаторы для интерфейсов, которые вам необходимо знать для экзамена:

+ Интерфейсы неявно abstract.
+ Переменные интерфейса неявно являются public, static и final.
+ Методы интерфейса без тела неявно abstract.
+ Методы интерфейса без модификатора private неявно являются public.

Последнее правило применяется к abstract, default и static методам интерфейса, которые мы рассмотрим в 
следующем разделе.

Давайте посмотрим на пример. Следующие два определения интерфейса эквивалентны, так как компилятор преобразует их оба во
второе объявление:

```
public interface Soar {
   int MAX_HEIGHT = 10;
   final static boolean UNDERWATER = true;
   void fly(int speed);
   abstract void takeoff();
   public abstract double dive();
}

public abstract interface Soar {
   public static final int MAX_HEIGHT = 10;
   public final static boolean UNDERWATER = true;
   public abstract void fly(int speed);
   public abstract void takeoff();
   public abstract double dive();
}
```

В этом примере мы выделили жирным шрифтом неявные модификаторы, которые автоматически вставляет компилятор. Во-первых, 
в объявление интерфейса добавляется ключевое слово abstract. Затем к переменным интерфейса добавляются ключевые слова 
public, static и final, если они не существуют. Наконец, каждому абстрактному методу предшествуют ключевые слова 
abstract и public, если они еще не содержатся.

#### Конфликтующие модификаторы

Что произойдет, если разработчик пометит метод или переменную модификатором, который конфликтует с неявным 
модификатором? Например, если абстрактный метод неявно public, может ли он быть явно помечен как protected или private?

```
public interface Dance {
   private int count = 4; // DOES NOT COMPILE
   protected void step(); // DOES NOT COMPILE
}
```

Ни одно из этих объявлений члена интерфейса не компилируется, так как компилятор применит модификатор public к обоим, 
что приведет к конфликту.

#### Различия между интерфейсами и абстрактными классами

Несмотря на то, что абстрактные классы и интерфейсы считаются абстрактными типами, только интерфейсы используют неявные 
модификаторы. Чем отличаются методы play() в следующих двух определениях?

```
abstract class Husky {    // abstract required in class declaration
   abstract void play();  // abstract required in method declaration
}

interface Poodle {       // abstract optional in interface declaration
   void play();          // abstract optional in method declaration
}
```

Оба эти определения метода считаются абстрактными. Тем не менее, класс Husky не будет компилироваться, если метод play()
не помечен как abstract, тогда как метод в интерфейсе Poodle будет компилироваться с модификатором abstract или без 
него.

Как насчет уровня доступа метода play()? Можете ли вы заметить что-нибудь неправильное в следующих определениях классов,
использующих наши абстрактные типы?

```
public class Webby extends Husky {
void play() {} // OK -play() is declared with package access in Husky
}

public class Georgette implements Poodle {
void play() {} // DOES NOT COMPILE -play() is public in Poodle
}
```

Класс Webby компилируется, а класс Georgette — нет. Несмотря на то, что реализации двух методов идентичны, метод в 
классе Georgette уменьшает модификатор доступа к методу с public до пакетного доступа.

#### Объявление конкретных методов интерфейса

Хотя интерфейсы начинались с абстрактных методов и констант, они расширились и теперь включают гораздо больше. В 
таблице 7.1 перечислены шесть типов элементов интерфейса, которые вам необходимо знать для экзамена. Мы уже рассмотрели 
абстрактные методы и константы, поэтому сосредоточимся на оставшихся четырех конкретных методах в этом разделе.

#### Таблица 7.1 - Типы членов интерфейса

|                       | Тип члена | Требуемые модификаторы |    Неявные модификаторы     | Имеет значение или тело? |  
|:---------------------:|:---------:|:----------------------:|:---------------------------:|--------------------------|
| Постоянные переменные |   Класс   |           -            | public<br/>static<br/>final |            Да            |
|    abstract метод     | Интерфейс |           -            |     public<br/>abstract     |           Нет            |                                     
|     default метод     | Интерфейс |        default         |           public            |            Да            |
|     static метод      |   Класс   |         static         |           public            |            Да            |
|     private метод     | Интерфейс |        private         |              -              |            Да            |
| private static метод  |   Класс   |   private<br/>static   |              -              |            Да            |

В таблице 7.1 тип членства определяет, как к нему можно получить доступ. Метод с типом принадлежности класса является 
общим для всех экземпляров интерфейса, тогда как метод с типом принадлежности экземпляра связан с конкретным экземпляром
интерфейса.

_**Как насчет защищенных (protected) или пакетных элементов (Package Members) интерфейса?**_

Наряду с public методами интерфейсы теперь поддерживают private методы. Однако они не поддерживают protected доступ, 
поскольку класс не может расширять интерфейс. Они также не поддерживают пакетный доступ, хотя, скорее всего, по причинам
синтаксиса и обратной совместимости. Поскольку методы интерфейса без модификатора доступа считаются неявно 
public, изменение этого поведения на доступ к пакету нарушит работу многих существующих программ!

#### Написание метода интерфейса по умолчанию

Первый тип конкретного метода, с которым вы должны быть знакомы на экзамене, — это метод по умолчанию. Метод по 
умолчанию (default method) — это метод, определенный в интерфейсе с ключевым словом default и включающий в себя тело 
метода. При необходимости он может быть переопределен классом, реализующим интерфейс.

Одним из способов использования методов default является обратная совместимость. Вы можете добавить в интерфейс новый 
метод default без необходимости изменять все существующие классы, реализующие интерфейс. Старые классы будут просто 
использовать реализацию метода default, определенную в интерфейсе. Вот откуда взялось название метода по 
умолчанию (default)!

Ниже приведен пример метода default, определенного в интерфейсе:

```
public interface IsColdBlooded {
   boolean hasScales();
   default double getTemperature() {
      return 10.0;
   } }
```

В этом примере определяются два метода интерфейса, один abstract и один default. Следующий класс Snake, который 
реализует IsColdBlooded, должен реализовать hasScales(). Он может полагаться на реализацию getTemperature() по 
умолчанию или переопределить метод своей собственной версией:

```
public class Snake implements IsColdBlooded {
   public boolean hasScales() {       // Required override
      return true;
   }
   
   public double getTemperature() {   // Optional override
      return 12;
   }
}
```

_Обратите внимание, что модификатор метода интерфейса default не совпадает с меткой default, используемой в операторе 
или выражении switch. Аналогичным образом, несмотря на то, что доступ к пакету иногда называют доступом по умолчанию, 
эта функция реализована путем пропуска модификатора доступа. Извините, если это сбивает с толку! Мы согласны с тем, 
что в течение многих лет Java злоупотребляла словом default!_

Для экзамена вы должны быть знакомы с различными правилами объявления методов default.

**Правила определения метода интерфейса по умолчанию**

1. default метод может быть объявлен только внутри интерфейса.
2. default метод должен быть помечен ключевым словом default и включать тело метода.
3. default метод неявно public.
4. default метод не может быть помечен как abstract, final или static.
5. default метод может быть переопределен классом, реализующим интерфейс.
6. Если класс наследует два или более default метода с одной и той же сигнатурой метода, то класс должен переопределить 
метод.

Первое правило должно дать вам некоторое утешение в том, что вы будете видеть только default методы в интерфейсах. 
Если вы видите их в классе или перечисляете на экзамене, значит, что-то не так. Второе правило просто обозначает 
синтаксис, поскольку default методы должны использовать ключевое слово default. Например, следующие фрагменты кода не
будут скомпилированы, поскольку в них смешиваются конкретные и абстрактные методы интерфейса:

```
public interface Carnivore {
   public default void eatMeat();        // DOES NOT COMPILE
   public int getRequiredFoodAmount() {  // DOES NOT COMPILE
      return 13;
   } }
```

Следующие три правила для default методов следуют из отношений с абстрактными методами интерфейса. Как и методы 
абстрактного интерфейса, default методы неявно public. Однако, в отличие от абстрактных методов, default методы 
интерфейса не могут быть помечены как abstract, поскольку они предоставляют тело. Они также не могут быть помечены как 
final, потому что они спроектированы таким образом, что могут быть переопределены в классах, реализующих интерфейс, 
точно так же, как и абстрактные методы. Наконец, их нельзя пометить как static, поскольку они связаны с экземпляром 
класса, реализующего интерфейс.

**Наследование повторяющихся _default_ методов**

Последнее правило для создания default метода интерфейса требует некоторых пояснений. Например, какое значение выведет 
следующий код?

```
public interface Walk {
   public default int getSpeed() { return 5; }
}

public interface Run {
   public default int getSpeed() { return 10; }
}

public class Cat implements Walk, Run {}  // DOES NOT COMPILE
```

В этом примере Cat наследует два default метода для getSpeed(), так что же он использует? Поскольку Walk и Run считаются
братьями и сестрами с точки зрения того, как они используются в классе Cat, неясно, должен ли код выводить 5 или 10.
В этом случае компилятор разводит руками и говорит: “Слишком сложно, я сдаюсь!” и терпит неудачу.

Однако ещё не все потеряно. Если класс, реализующий интерфейсы, переопределяет дублирующий default метод, код 
будет скомпилирован без проблем. Переопределив конфликтующий метод, была устранена двусмысленность в отношении того, 
какую версию метода вызывать. Например, следующая модифицированная реализация Cat будет скомпилирована:

```
public class Cat implements Walk, Run {
   public int getSpeed() { return 1; }
}
```

**Вызов скрытого default метода**

В последнем разделе мы показали, как наш класс Cat может переопределить пару конфликтующих default методов, но что, если
класс Cat захочет получить доступ к версии getSpeed() в Walk или Run? Доступен ли он по-прежнему?

Да, но для этого требуется особый синтаксис.

```
public class Cat implements Walk, Run {
   public int getSpeed() {
      return 1;
}

public int getWalkSpeed() {
   return Walk.super.getSpeed();
} }
```

Это область, в которой default метод демонстрирует свойства как static метода, так и метода экземпляра. Мы используем 
имя интерфейса, чтобы указать, какой метод мы хотим вызвать, но мы используем ключевое слово super, чтобы показать, что 
мы следуем наследованию экземпляра, а не наследованию класса. Обратите внимание, что вызов Walk.getSpeed() или 
Walk.this.getSpeed() не сработает. Мы знаем, что это немного сбивает с толку, но вы должны быть знакомы с этим 
синтаксисом для экзамена.

#### Объявление static методов интерфейса

Интерфейсы также объявляются со static методами. Эти методы явно определены с помощью ключевого слова static и по 
большей части ведут себя точно так же, как static методы, определенные в классах.

**Правила определения static метода интерфейса**

1. static метод должен быть помечен ключевым словом static и включать тело метода.
2. static метод без модификатора доступа неявно является public.
3. static метод не может быть помечен как abstract или final.
4. static метод не наследуется и не может быть доступен в классе, реализующем интерфейс, без ссылки на имя интерфейса.

Эти правила должны следовать из того, что вы уже знаете о классах, интерфейсах и static методах. Например, в классах 
тоже нельзя объявлять static методы без тела. Подобно default и abstract методам интерфейса, static методы интерфейса 
неявно public, если они объявлены без модификатора доступа. Как вы вскоре увидите, вы можете использовать модификатор 
доступа private со static методами.

Давайте взглянем на метод static интерфейса:

```
public interface Hop {
   static int getJumpHeight() {
      return 8;
} }
```

Поскольку метод определен без модификатора доступа, компилятор автоматически вставит модификатор public доступа. 
Метод getJumpHeight() работает так же, как static метод, определенный в классе. Другими словами, к нему можно получить 
доступ без экземпляра класса.

```
public class Skip {
   public int skip() {
      return Hop.getJumpHeight();
} }
```

Последнее правило о наследовании может немного сбить с толку, поэтому давайте рассмотрим пример. Ниже приведен пример 
класса Bunny, который реализует Hop и не компилируется:

```
public class Bunny implements Hop {
   public void printDetails() {
      System.out.println(getJumpHeight());   // DOES NOT COMPILE
} }
```

Без явной ссылки на имя интерфейса код не скомпилируется, даже несмотря на то, что Bunny реализует Hop. Это можно легко 
исправить, используя имя интерфейса:

```
public class Bunny implements Hop {
   public void printDetails() {
      System.out.println(Hop.getJumpHeight());
} }
```

Обратите внимание, что у нас нет той проблемы, которая была у нас, когда мы унаследовали два default метода интерфейса
с одной и той же сигнатурой. Java «решила» проблему множественного наследования static методов интерфейса, запретив их 
наследование!

#### Повторное использование кода с private методами интерфейса

Последние два типа конкретных методов, которые можно добавить к интерфейсам, — это private и private static методы 
интерфейса. Поскольку оба типа методов являются private, их можно использовать только в объявлении интерфейса, в котором
они объявлены. По этой причине они были добавлены в первую очередь для уменьшения дублирования кода. Например, 
рассмотрим следующий пример кода:

```
public interface Schedule {
   default void wakeUp()        { checkTime(7); }
   private void haveBreakfast() { checkTime(9); }
   static void workOut()        { checkTime(18); }
   private static void checkTime(int hour) {
      if (hour> 17) {
         System.out.println("You're late!");
      } else {
         System.out.println("You have "+(17-hour) + " hours left "
               + "to make the appointment");
} } }
```

Вы можете написать этот интерфейс без использования private метода, скопировав содержимое метода checkTime() в те места,
где он используется. Это намного короче и легче читать, если вы этого не сделаете. Поскольку авторы Java были достаточно
любезны, чтобы добавить эту функцию для нашего удобства, мы могли бы также использовать ее!

---

Мы могли бы также объявить checkTime() как public в предыдущем примере, но это сделало бы метод открытым для 
использования за пределами интерфейса. Один из важных принципов инкапсуляции — не раскрывать внутреннюю работу класса 
или интерфейса, когда это не требуется. Мы рассмотрим инкапсуляцию позже в этой главе.

---

Разница между нестатическим закрытым методом и статическим аналогична разнице между экземпляром и статическим методом, 
объявленным внутри класса. В частности, все дело в том, из каких методов каждый из них может быть вызван.

**Правила определения метода private интерфейса**

1. Метод private интерфейса должен быть помечен модификатором private и включать тело метода.
2. Метод private static интерфейса может быть вызван любым методом в определении интерфейса.
3. Метод private интерфейса может быть вызван только default и другими private нестатическими методами в определении 
интерфейса.

Другой способ думать об этом состоит в том, что метод private интерфейса доступен только для нестатических методов, 
определенных в интерфейсе. С другой стороны, к private static методу интерфейса может получить доступ любой метод в 
интерфейсе. Для обоих типов private методов класс, наследующий интерфейс, не может вызывать их напрямую.

#### Вызов абстрактных методов

Мы много говорили о новых типах интерфейсных методов, но как насчет abstract методов? Оказывается, default и private 
нестатические методы могут обращаться к abstract методам, объявленным в интерфейсе. Это основная причина, по которой мы 
связываем эти методы с членством экземпляра. Когда они вызываются, существует экземпляр интерфейса.

```
public interface ZooRenovation {
   public String projectName();
   abstract String status();
   default void printStatus() {
      System.out.print("The " + projectName() + " project " + status());
} }
```

В этом примере как projectName(), так и status() имеют одинаковые модификаторы (abstract и public являются неявными) и 
могут быть вызваны методом printStatus() по умолчанию.

#### Просмотр элементов интерфейса

Мы завершаем обсуждение элементов интерфейса таблицей 7.2, в которой показаны правила доступа для элементов внутри и вне
интерфейса.

#### Таблица 7.2 - Доступ к элементу интерфейса

|                       | Доступен из default и private<br/>  методов в интерфейсе? | Доступен из static методов в интерфейсе? | Доступен из методов в классах, наследующих интерфейс? | Доступен без экземпляра интерфейса? |  
|:---------------------:|:---------------------------------------------------------:|:----------------------------------------:|:-----------------------------------------------------:|:-----------------------------------:|
| Постоянные переменные |                            Да                             |                    Да                    |                          Да                           |                 Да                  |
|    abstract метод     |                            Да                             |                   Нет                    |                          Да                           |                 Нет                 |                                     
|     default метод     |                            Да                             |                   Нет                    |                          Да                           |                 Нет                 |
|     static метод      |                            Да                             |                    Да                    |            Да (требуется имя интерфейса)              |   Да (требуется имя интерфейса)     |
|     private метод     |                            Да                             |                   Нет                    |                          Нет                          |                 Нет                 |
| private static метод  |                            Да                             |                    Да                    |                          Нет                          |                 Нет                 |

Хотя таблица 7.2 может показаться сложной для запоминания, вот несколько быстрых советов для экзамена:

+ Рассматривайте abstract, default и нестатические private методы как принадлежащие экземпляру интерфейса.
+ Рассматривайте static методы и переменные как принадлежащие объекту класса интерфейса.
+ Все типы методов private интерфейса доступны только в объявлении интерфейса.

Используя эти правила, какие из следующих методов не компилируются?

```
public interface ZooTrainTour {
   abstract int getTrainName();
   private static void ride() {}
   default void playHorn() { getTrainName(); ride(); }
   public static void slowDown() { playHorn(); }
   static void speedUp() { ride(); }
}
```

Метод ride() является private и static, поэтому к нему можно получить доступ любым методом по default или static методом
в объявлении интерфейса. getTrainName() является abstract, поэтому к нему можно получить доступ с помощью default 
метода, связанного с экземпляром. Однако метод slowDown() является static и не может вызывать default метод или private 
метод, такой как playHorn(), без явного объекта ссылки. Поэтому метод slowDown() не компилируется.

Похлопайте себя по спине! Вы только что многое узнали об интерфейсах, возможно, даже больше, чем вы думали. Теперь 
сделайте глубокий вдох. Готовы? Следующий тип, который мы рассмотрим, это перечисления.

### Работа с перечислениями 427

