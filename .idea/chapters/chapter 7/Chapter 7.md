# За пределами классов

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Объявляйте и создавайте экземпляры объектов Java, включая объекты вложенного класса, и объясняйте жизненный цикл 
объекта, включая создание, переназначение ссылок и сборку мусора
+ Создавайте классы и записи, а также определяйте и используйте экземпляры и статические поля и методы, конструкторы, а 
также экземпляры и статические инициализаторы
+ Понимайте области видимости переменных, используйте вывод типа локальной переменной, применяйте инкапсуляцию и 
делайте объекты неизменяемыми
+ Реализуйте полиморфизм и отличайте тип объекта от ссылочного типа. Выполняйте приведение типов, идентифицируйте типы 
объектов с помощью оператора instanceof и сопоставления с образцом
+ Создавайте и используйте интерфейсы, определяйте функциональные интерфейсы и используйте частные, статические методы 
интерфейса и методы интерфейса по умолчанию
+ Создавайте и используйте перечисления с полями, методами и конструкторами

---

В главе 6 «Проектирование классов» мы показали, как создавать, инициализировать и расширять как абстрактные, так и 
конкретные классы. В этой главе мы переходим от классов к другим типам, доступным в Java, включая интерфейсы, 
перечисления, закрытые классы и записи. Многие из основных правил, о которых вы узнали в главе 5 «Методы», по-прежнему 
применяются, например, модификаторы доступа и статические члены, хотя для каждого типа существуют дополнительные 
правила. Мы также рассмотрим инкапсуляцию и то, как правильно защитить элементы экземпляра. Наконец, мы завершаем эту 
главу обсуждением вложенных типов и полиморфного наследования.

В этой главе помните, что файл Java может иметь не более одного общедоступного типа верхнего уровня, и он должен 
совпадать с именем файла. Это относится к классам, перечислениям, записям и так далее. Кроме того, помните, что тип 
верхнего уровня может быть объявлен только с общедоступным доступом или доступом к пакету.

---

Другим типом верхнего уровня, доступным в Java, являются аннотации. Знание того, как создавать пользовательские 
аннотации, может быть полезным навыком на практике, хотя это и не требуется для сдачи экзамена. Вы все равно должны 
знать, как использовать определенные аннотации для экзамена, такие как @Override.

---

## Реализация интерфейсов

В главе 6 вы узнали об абстрактных классах, в частности о том, как их создавать и расширять. Поскольку классы могут 
расширять только один класс, они имели ограниченное применение для наследования. С другой стороны, класс может 
реализовывать любое количество интерфейсов. Интерфейс - это абстрактный тип данных, который объявляет список 
абстрактных методов, которые должен предоставлять любой класс, реализующий интерфейс.

Со временем точное определение интерфейса изменилось, поскольку теперь поддерживаются новые типы методов. В этой главе 
мы начнем с элементарного определения интерфейса и расширим его, чтобы охватить все поддерживаемые элементы.

### Объявление и использование интерфейса

В Java интерфейс определяется с помощью ключевого слова interface, аналогичного ключевому слову class, используемому при
определении класса. См. рис. 7.1 для правильного объявление интерфейса.


#### Рис. 7.1 - Определение интерфейса

На рис. 7.1 объявление нашего интерфейса включает абстрактный метод и постоянную переменную. Переменные интерфейса 
называются константами, поскольку предполагается, что они public, static и final. Они 
инициализируются постоянным значением при объявлении. Поскольку они являются public и static, их можно 
использовать вне объявления интерфейса, не требуя экземпляра интерфейса. Рисунок 7.1 также включает абстрактный метод, 
который, как и переменная интерфейса, считается public.

_Для краткости мы часто используем фразу “экземпляр интерфейса” в этой главе имею в виду экземпляр класса, который 
реализует интерфейс._

Что это значит для переменной или метода, чтобы считаться чем-то? Один аспект объявления интерфейса, который отличается 
от абстрактного класса, состоит в том, что он содержит неявные модификаторы. Неявное модификатор-модификатор, который 
компилятор автоматически вставляет в код. Например, интерфейс, всегда считается абстрактным, даже если он не отмечен 
таким образом. Вскоре мы рассмотрим правила и примеры неявных модификаторов более подробно.

Начнем с простого примера. Представьте, что у нас есть интерфейс WalksOnTwoLegs, определенный следующим образом:

```
public abstract interface WalksOnTwoLegs {}
```

Он компилируется, потому что интерфейсы не требуются для определения каких-либо методов. Модификатор abstract в этом 
примере является необязательным для интерфейсов, и компилятор вставляет его, если он не указан. Теперь рассмотрим 
следующие два примера, которые не компилируются:

```
public class Biped {
   public static void main(String[] args) {
      var e = new WalksOnTwoLegs();         // DOES NOT COMPILE
   }
}

public final interface WalksOnEightLegs {}  // DOES NOT COMPILE
```

Первый пример не компилируется, так как WalksOnTwoLegs является интерфейсом и не может быть создан. Второй пример, 
WalksOnEightLegs, не компилируется, потому что интерфейсы не могут быть помечены как final по той же причине, по которой
abstract классы не могут быть помечены как final. Другими словами, пометка интерфейса как final подразумевает, что ни 
один класс не сможет его реализовать.

Как вы используете интерфейс? Допустим, у нас есть интерфейс Climb, определенный следующим образом:

```
public interface Climb {
   Number getSpeed(int age);
}
```

Затем у нас есть конкретный класс FieldMouse, который вызывает интерфейс Climb, используя ключевое слово implements в 
объявлении своего класса, как показано на рис. 7.2.

#### Рис. 7.2 - Реализации интерфейса

Класс FieldMouse объявляет, что он реализует интерфейс Climb и включает переопределенную версию getSpeed(), 
унаследованную от интерфейса Climb. Сигнатура метода getSpeed() точно совпадает, а возвращаемый тип является 
ковариантным, поскольку Float может быть неявно приведен к Number. Модификатор доступа метода интерфейса неявно public в
Climb, хотя конкретный класс FieldMouse должен явно объявить его.

Как показано на рис. 7.2, класс может реализовывать несколько интерфейсов, разделенных запятой (,). Если какой-либо из 
интерфейсов определяет abstract методы, то для их переопределения требуется конкретный класс. В этом случае FieldMouse 
реализует интерфейс CanBurrow, который мы видели на рис. 7.1. Таким образом, класс переопределяет два абстрактных метода
одновременно с одним объявлением метода. В этой главе вы узнаете больше о повторяющихся и совместимых методах 
интерфейса.

### Расширение интерфейса

Как и класс, интерфейс может расширять другой интерфейс с помощью ключевого слова extends.

```
public interface Nocturnal {}

public interface HasBigEyes extends Nocturnal {}
```

В отличие от класса, который может расширять только один класс, интерфейс может расширять несколько интерфейсов.

```
public interface Nocturnal {
   public int hunt();
}

public interface CanFly {
   public void flap();
}

public interface HasBigEyes extends Nocturnal, CanFly {}

public class Owl implements HasBigEyes {
   public int hunt() { return 5; }
   public void flap() { System.out.println("Flap!"); }
}
```

В этом примере класс Owl реализует интерфейс HasBigEyes и должен реализовывать методы hunt() и flap(). Расширение двух 
интерфейсов разрешено, поскольку интерфейсы не инициализируются как часть иерархии классов. В отличие от абстрактных 
классов, они не содержат конструкторов и не являются частью инициализации экземпляра. Интерфейсы просто определяют набор
правил и методов, которым должен следовать реализующий их класс.

### Наследование интерфейса

Как и в случае с абстрактным классом, когда конкретный класс наследует интерфейс, должны быть реализованы все 
унаследованные абстрактные методы. Мы иллюстрируем этот принцип на рис. 7.3. Сколько абстрактных методов наследует 
конкретный класс Swan?

#### Рис. 7.3 - Наследование интерфейса


Сдаться? Конкретный класс Swan наследует четыре абстрактных метода, которые он должен реализовать: getType(), 
canSwoop(), fly() и swim(). Давайте взглянем на другой пример с абстрактным классом, реализующим интерфейс:

```
public interface HasTail {
   public int getTailLength();
}

public interface HasWhiskers {
   public int getNumberOfWhiskers();
}

public abstract class HarborSeal implements HasTail, HasWhiskers {}

public class CommonSeal extends HarborSeal {}    // DOES NOT COMPILE
```

Класс HarborSeal компилируется, поскольку он является abstract и не требует реализации каких-либо abstract методов, 
которые он наследует. Однако конкретный класс CommonSeal должен переопределять все унаследованные abstract методы.

#### Смешивание ключевых слов класса и интерфейса

Создатели экзамена любят вопросы, в которых смешаны терминология классов и интерфейсов. Хотя класс может реализовать 
интерфейс, класс не может расширять интерфейс. Аналогично, хотя интерфейс может расширять другой интерфейс, интерфейс 
не может реализовать другой интерфейс. Следующие примеры иллюстрируют эти принципы:

```
public interface CanRun {}
public class Cheetah extends CanRun {} // DOES NOT COMPILE

public class Hyena {}
public interface HasFur extends Hyena {} // DOES NOT COMPILE
```

В первом примере показан класс, который пытается расширить интерфейс и не компилируется. Во втором примере показан 
интерфейс, пытающийся расширить класс, который также не компилируется. Будьте осторожны с примерами на экзамене, которые
смешивают объявления классов и интерфейсов.

#### Наследование повторяющихся абстрактных методов

Java поддерживает наследование двух абстрактных методов, которые имеют совместимые объявления методов.

```
public interface Herbivore { public void eatPlants(); }

public interface Omnivore { public void eatPlants(); }

public class Bear implements Herbivore, Omnivore {

public void eatPlants() {
   System.out.println("Eating plants");
} }
```

Под совместимостью мы подразумеваем, что метод может быть написан таким образом, чтобы правильно переопределять оба 
унаследованных метода: например, с помощью ковариантных возвращаемых типов, о которых вы узнали в главе 6.

Ниже приведен пример несовместимого объявления:

```
public interface Herbivore { public void eatPlants(); }

public interface Omnivore { public int eatPlants(); }

public class Tiger implements Herbivore, Omnivore { // DOES NOT COMPILE
...
}
```

Невозможно написать версию Tiger, удовлетворяющую обоим унаследованным abstract методам. Код не компилируется независимо
от того, что объявлено внутри класса Tiger.

#### Вставка неявных модификаторов

Как упоминалось ранее, неявный модификатор — это модификатор, который автоматически вставляется компилятором. Это 
напоминает компилятор, вставляющий конструктор по умолчанию без аргументов, если вы не определили конструктор, о котором
вы узнали в главе 6. Вы можете вставить эти неявные модификаторы самостоятельно или позволить компилятору вставить их за
вас.

Следующий список включает неявные модификаторы для интерфейсов, которые вам необходимо знать для экзамена:

+ Интерфейсы неявно abstract.
+ Переменные интерфейса неявно являются public, static и final.
+ Методы интерфейса без тела неявно abstract.
+ Методы интерфейса без модификатора private неявно являются public.

Последнее правило применяется к abstract, default и static методам интерфейса, которые мы рассмотрим в 
следующем разделе.

Давайте посмотрим на пример. Следующие два определения интерфейса эквивалентны, так как компилятор преобразует их оба во
второе объявление:

```
public interface Soar {
   int MAX_HEIGHT = 10;
   final static boolean UNDERWATER = true;
   void fly(int speed);
   abstract void takeoff();
   public abstract double dive();
}

public abstract interface Soar {
   public static final int MAX_HEIGHT = 10;
   public final static boolean UNDERWATER = true;
   public abstract void fly(int speed);
   public abstract void takeoff();
   public abstract double dive();
}
```

В этом примере мы выделили жирным шрифтом неявные модификаторы, которые автоматически вставляет компилятор. Во-первых, 
в объявление интерфейса добавляется ключевое слово abstract. Затем к переменным интерфейса добавляются ключевые слова 
public, static и final, если они не существуют. Наконец, каждому абстрактному методу предшествуют ключевые слова 
abstract и public, если они еще не содержатся.

#### Конфликтующие модификаторы

Что произойдет, если разработчик пометит метод или переменную модификатором, который конфликтует с неявным 
модификатором? Например, если абстрактный метод неявно public, может ли он быть явно помечен как protected или private?

```
public interface Dance {
   private int count = 4; // DOES NOT COMPILE
   protected void step(); // DOES NOT COMPILE
}
```

Ни одно из этих объявлений члена интерфейса не компилируется, так как компилятор применит модификатор public к обоим, 
что приведет к конфликту.

#### Различия между интерфейсами и абстрактными классами

Несмотря на то, что абстрактные классы и интерфейсы считаются абстрактными типами, только интерфейсы используют неявные 
модификаторы. Чем отличаются методы play() в следующих двух определениях?

```
abstract class Husky {    // abstract required in class declaration
   abstract void play();  // abstract required in method declaration
}

interface Poodle {       // abstract optional in interface declaration
   void play();          // abstract optional in method declaration
}
```

Оба эти определения метода считаются абстрактными. Тем не менее, класс Husky не будет компилироваться, если метод play()
не помечен как abstract, тогда как метод в интерфейсе Poodle будет компилироваться с модификатором abstract или без 
него.

Как насчет уровня доступа метода play()? Можете ли вы заметить что-нибудь неправильное в следующих определениях классов,
использующих наши абстрактные типы?

```
public class Webby extends Husky {
void play() {} // OK -play() is declared with package access in Husky
}

public class Georgette implements Poodle {
void play() {} // DOES NOT COMPILE -play() is public in Poodle
}
```

Класс Webby компилируется, а класс Georgette — нет. Несмотря на то, что реализации двух методов идентичны, метод в 
классе Georgette уменьшает модификатор доступа к методу с public до пакетного доступа.

#### Объявление конкретных методов интерфейса

Хотя интерфейсы начинались с абстрактных методов и констант, они расширились и теперь включают гораздо больше. В 
таблице 7.1 перечислены шесть типов элементов интерфейса, которые вам необходимо знать для экзамена. Мы уже рассмотрели 
абстрактные методы и константы, поэтому сосредоточимся на оставшихся четырех конкретных методах в этом разделе.

#### Таблица 7.1 - Типы членов интерфейса

|                       | Тип члена | Требуемые модификаторы |    Неявные модификаторы     | Имеет значение или тело? |  
|:---------------------:|:---------:|:----------------------:|:---------------------------:|--------------------------|
| Постоянные переменные |   Класс   |           -            | public<br/>static<br/>final |            Да            |
|    abstract метод     | Интерфейс |           -            |     public<br/>abstract     |           Нет            |                                     
|     default метод     | Интерфейс |        default         |           public            |            Да            |
|     static метод      |   Класс   |         static         |           public            |            Да            |
|     private метод     | Интерфейс |        private         |              -              |            Да            |
| private static метод  |   Класс   |   private<br/>static   |              -              |            Да            |

В таблице 7.1 тип членства определяет, как к нему можно получить доступ. Метод с типом принадлежности класса является 
общим для всех экземпляров интерфейса, тогда как метод с типом принадлежности экземпляра связан с конкретным экземпляром
интерфейса.

_**Как насчет защищенных (protected) или пакетных элементов (Package Members) интерфейса?**_

Наряду с public методами интерфейсы теперь поддерживают private методы. Однако они не поддерживают protected доступ, 
поскольку класс не может расширять интерфейс. Они также не поддерживают пакетный доступ, хотя, скорее всего, по причинам
синтаксиса и обратной совместимости. Поскольку методы интерфейса без модификатора доступа считаются неявно 
public, изменение этого поведения на доступ к пакету нарушит работу многих существующих программ!

#### Написание метода интерфейса по умолчанию

Первый тип конкретного метода, с которым вы должны быть знакомы на экзамене, — это метод по умолчанию. Метод по 
умолчанию (default method) — это метод, определенный в интерфейсе с ключевым словом default и включающий в себя тело 
метода. При необходимости он может быть переопределен классом, реализующим интерфейс.

Одним из способов использования методов default является обратная совместимость. Вы можете добавить в интерфейс новый 
метод default без необходимости изменять все существующие классы, реализующие интерфейс. Старые классы будут просто 
использовать реализацию метода default, определенную в интерфейсе. Вот откуда взялось название метода по 
умолчанию (default)!

Ниже приведен пример метода default, определенного в интерфейсе:

```
public interface IsColdBlooded {
   boolean hasScales();
   default double getTemperature() {
      return 10.0;
   } }
```

В этом примере определяются два метода интерфейса, один abstract и один default. Следующий класс Snake, который 
реализует IsColdBlooded, должен реализовать hasScales(). Он может полагаться на реализацию getTemperature() по 
умолчанию или переопределить метод своей собственной версией:

```
public class Snake implements IsColdBlooded {
   public boolean hasScales() {       // Required override
      return true;
   }
   
   public double getTemperature() {   // Optional override
      return 12;
   }
}
```

_Обратите внимание, что модификатор метода интерфейса default не совпадает с меткой default, используемой в операторе 
или выражении switch. Аналогичным образом, несмотря на то, что доступ к пакету иногда называют доступом по умолчанию, 
эта функция реализована путем пропуска модификатора доступа. Извините, если это сбивает с толку! Мы согласны с тем, 
что в течение многих лет Java злоупотребляла словом default!_

Для экзамена вы должны быть знакомы с различными правилами объявления методов default.

**Правила определения метода интерфейса по умолчанию**

1. default метод может быть объявлен только внутри интерфейса.
2. default метод должен быть помечен ключевым словом default и включать тело метода.
3. default метод неявно public.
4. default метод не может быть помечен как abstract, final или static.
5. default метод может быть переопределен классом, реализующим интерфейс.
6. Если класс наследует два или более default метода с одной и той же сигнатурой метода, то класс должен переопределить 
метод.

Первое правило должно дать вам некоторое утешение в том, что вы будете видеть только default методы в интерфейсах. 
Если вы видите их в классе или перечисляете на экзамене, значит, что-то не так. Второе правило просто обозначает 
синтаксис, поскольку default методы должны использовать ключевое слово default. Например, следующие фрагменты кода не
будут скомпилированы, поскольку в них смешиваются конкретные и абстрактные методы интерфейса:

```
public interface Carnivore {
   public default void eatMeat();        // DOES NOT COMPILE
   public int getRequiredFoodAmount() {  // DOES NOT COMPILE
      return 13;
   } }
```

Следующие три правила для default методов следуют из отношений с абстрактными методами интерфейса. Как и методы 
абстрактного интерфейса, default методы неявно public. Однако, в отличие от абстрактных методов, default методы 
интерфейса не могут быть помечены как abstract, поскольку они предоставляют тело. Они также не могут быть помечены как 
final, потому что они спроектированы таким образом, что могут быть переопределены в классах, реализующих интерфейс, 
точно так же, как и абстрактные методы. Наконец, их нельзя пометить как static, поскольку они связаны с экземпляром 
класса, реализующего интерфейс.

**Наследование повторяющихся _default_ методов**

Последнее правило для создания default метода интерфейса требует некоторых пояснений. Например, какое значение выведет 
следующий код?

```
public interface Walk {
   public default int getSpeed() { return 5; }
}

public interface Run {
   public default int getSpeed() { return 10; }
}

public class Cat implements Walk, Run {}  // DOES NOT COMPILE
```

В этом примере Cat наследует два default метода для getSpeed(), так что же он использует? Поскольку Walk и Run считаются
братьями и сестрами с точки зрения того, как они используются в классе Cat, неясно, должен ли код выводить 5 или 10.
В этом случае компилятор разводит руками и говорит: “Слишком сложно, я сдаюсь!” и терпит неудачу.

Однако ещё не все потеряно. Если класс, реализующий интерфейсы, переопределяет дублирующий default метод, код 
будет скомпилирован без проблем. Переопределив конфликтующий метод, была устранена двусмысленность в отношении того, 
какую версию метода вызывать. Например, следующая модифицированная реализация Cat будет скомпилирована:

```
public class Cat implements Walk, Run {
   public int getSpeed() { return 1; }
}
```

**Вызов скрытого default метода**

В последнем разделе мы показали, как наш класс Cat может переопределить пару конфликтующих default методов, но что, если
класс Cat захочет получить доступ к версии getSpeed() в Walk или Run? Доступен ли он по-прежнему?

Да, но для этого требуется особый синтаксис.

```
public class Cat implements Walk, Run {
   public int getSpeed() {
      return 1;
}

public int getWalkSpeed() {
   return Walk.super.getSpeed();
} }
```

Это область, в которой default метод демонстрирует свойства как static метода, так и метода экземпляра. Мы используем 
имя интерфейса, чтобы указать, какой метод мы хотим вызвать, но мы используем ключевое слово super, чтобы показать, что 
мы следуем наследованию экземпляра, а не наследованию класса. Обратите внимание, что вызов Walk.getSpeed() или 
Walk.this.getSpeed() не сработает. Мы знаем, что это немного сбивает с толку, но вы должны быть знакомы с этим 
синтаксисом для экзамена.

#### Объявление static методов интерфейса

Интерфейсы также объявляются со static методами. Эти методы явно определены с помощью ключевого слова static и по 
большей части ведут себя точно так же, как static методы, определенные в классах.

**Правила определения static метода интерфейса**

1. static метод должен быть помечен ключевым словом static и включать тело метода.
2. static метод без модификатора доступа неявно является public.
3. static метод не может быть помечен как abstract или final.
4. static метод не наследуется и не может быть доступен в классе, реализующем интерфейс, без ссылки на имя интерфейса.

Эти правила должны следовать из того, что вы уже знаете о классах, интерфейсах и static методах. Например, в классах 
тоже нельзя объявлять static методы без тела. Подобно default и abstract методам интерфейса, static методы интерфейса 
неявно public, если они объявлены без модификатора доступа. Как вы вскоре увидите, вы можете использовать модификатор 
доступа private со static методами.

Давайте взглянем на метод static интерфейса:

```
public interface Hop {
   static int getJumpHeight() {
      return 8;
} }
```

Поскольку метод определен без модификатора доступа, компилятор автоматически вставит модификатор public доступа. 
Метод getJumpHeight() работает так же, как static метод, определенный в классе. Другими словами, к нему можно получить 
доступ без экземпляра класса.

```
public class Skip {
   public int skip() {
      return Hop.getJumpHeight();
} }
```

Последнее правило о наследовании может немного сбить с толку, поэтому давайте рассмотрим пример. Ниже приведен пример 
класса Bunny, который реализует Hop и не компилируется:

```
public class Bunny implements Hop {
   public void printDetails() {
      System.out.println(getJumpHeight());   // DOES NOT COMPILE
} }
```

Без явной ссылки на имя интерфейса код не скомпилируется, даже несмотря на то, что Bunny реализует Hop. Это можно легко 
исправить, используя имя интерфейса:

```
public class Bunny implements Hop {
   public void printDetails() {
      System.out.println(Hop.getJumpHeight());
} }
```

Обратите внимание, что у нас нет той проблемы, которая была у нас, когда мы унаследовали два default метода интерфейса
с одной и той же сигнатурой. Java «решила» проблему множественного наследования static методов интерфейса, запретив их 
наследование!

#### Повторное использование кода с private методами интерфейса

Последние два типа конкретных методов, которые можно добавить к интерфейсам, — это private и private static методы 
интерфейса. Поскольку оба типа методов являются private, их можно использовать только в объявлении интерфейса, в котором
они объявлены. По этой причине они были добавлены в первую очередь для уменьшения дублирования кода. Например, 
рассмотрим следующий пример кода:

```
public interface Schedule {
   default void wakeUp()        { checkTime(7); }
   private void haveBreakfast() { checkTime(9); }
   static void workOut()        { checkTime(18); }
   private static void checkTime(int hour) {
      if (hour> 17) {
         System.out.println("You're late!");
      } else {
         System.out.println("You have "+(17-hour) + " hours left "
               + "to make the appointment");
} } }
```

Вы можете написать этот интерфейс без использования private метода, скопировав содержимое метода checkTime() в те места,
где он используется. Это намного короче и легче читать, если вы этого не сделаете. Поскольку авторы Java были достаточно
любезны, чтобы добавить эту функцию для нашего удобства, мы могли бы также использовать ее!

---

Мы могли бы также объявить checkTime() как public в предыдущем примере, но это сделало бы метод открытым для 
использования за пределами интерфейса. Один из важных принципов инкапсуляции — не раскрывать внутреннюю работу класса 
или интерфейса, когда это не требуется. Мы рассмотрим инкапсуляцию позже в этой главе.

---

Разница между нестатическим закрытым методом и статическим аналогична разнице между экземпляром и статическим методом, 
объявленным внутри класса. В частности, все дело в том, из каких методов каждый из них может быть вызван.

**Правила определения метода private интерфейса**

1. Метод private интерфейса должен быть помечен модификатором private и включать тело метода.
2. Метод private static интерфейса может быть вызван любым методом в определении интерфейса.
3. Метод private интерфейса может быть вызван только default и другими private нестатическими методами в определении 
интерфейса.

Другой способ думать об этом состоит в том, что метод private интерфейса доступен только для нестатических методов, 
определенных в интерфейсе. С другой стороны, к private static методу интерфейса может получить доступ любой метод в 
интерфейсе. Для обоих типов private методов класс, наследующий интерфейс, не может вызывать их напрямую.

#### Вызов абстрактных методов

Мы много говорили о новых типах интерфейсных методов, но как насчет abstract методов? Оказывается, default и private 
нестатические методы могут обращаться к abstract методам, объявленным в интерфейсе. Это основная причина, по которой мы 
связываем эти методы с членством экземпляра. Когда они вызываются, существует экземпляр интерфейса.

```
public interface ZooRenovation {
   public String projectName();
   abstract String status();
   default void printStatus() {
      System.out.print("The " + projectName() + " project " + status());
} }
```

В этом примере как projectName(), так и status() имеют одинаковые модификаторы (abstract и public являются неявными) и 
могут быть вызваны методом printStatus() по умолчанию.

#### Просмотр элементов интерфейса

Мы завершаем обсуждение элементов интерфейса таблицей 7.2, в которой показаны правила доступа для элементов внутри и вне
интерфейса.

#### Таблица 7.2 - Доступ к элементу интерфейса

|                       | Доступен из default и private<br/>  методов в интерфейсе? | Доступен из static методов в интерфейсе? | Доступен из методов в классах, наследующих интерфейс? | Доступен без экземпляра интерфейса? |  
|:---------------------:|:---------------------------------------------------------:|:----------------------------------------:|:-----------------------------------------------------:|:-----------------------------------:|
| Постоянные переменные |                            Да                             |                    Да                    |                          Да                           |                 Да                  |
|    abstract метод     |                            Да                             |                   Нет                    |                          Да                           |                 Нет                 |                                     
|     default метод     |                            Да                             |                   Нет                    |                          Да                           |                 Нет                 |
|     static метод      |                            Да                             |                    Да                    |            Да (требуется имя интерфейса)              |   Да (требуется имя интерфейса)     |
|     private метод     |                            Да                             |                   Нет                    |                          Нет                          |                 Нет                 |
| private static метод  |                            Да                             |                    Да                    |                          Нет                          |                 Нет                 |

Хотя таблица 7.2 может показаться сложной для запоминания, вот несколько быстрых советов для экзамена:

+ Рассматривайте abstract, default и нестатические private методы как принадлежащие экземпляру интерфейса.
+ Рассматривайте static методы и переменные как принадлежащие объекту класса интерфейса.
+ Все типы методов private интерфейса доступны только в объявлении интерфейса.

Используя эти правила, какие из следующих методов не компилируются?

```
public interface ZooTrainTour {
   abstract int getTrainName();
   private static void ride() {}
   default void playHorn() { getTrainName(); ride(); }
   public static void slowDown() { playHorn(); }
   static void speedUp() { ride(); }
}
```

Метод ride() является private и static, поэтому к нему можно получить доступ любым методом по default или static методом
в объявлении интерфейса. getTrainName() является abstract, поэтому к нему можно получить доступ с помощью default 
метода, связанного с экземпляром. Однако метод slowDown() является static и не может вызывать default метод или private 
метод, такой как playHorn(), без явного объекта ссылки. Поэтому метод slowDown() не компилируется.

Похлопайте себя по спине! Вы только что многое узнали об интерфейсах, возможно, даже больше, чем вы думали. Теперь 
сделайте глубокий вдох. Готовы? Следующий тип, который мы рассмотрим, это перечисления.

### Работа с перечислениями 427

В программировании обычно используется тип, который может иметь только конечный набор значений, таких как дни недели, 
времена года, основные цвета и т.д. Перечисление, или сокращенно enum, похоже на фиксированный набор констант.

Использование перечисления намного лучше, чем использование набора констант, потому что оно обеспечивает безопасную 
проверку типов. С числовыми или String константами вы можете передать недопустимое значение и не узнать его до времени 
выполнения. С перечислениями невозможно создать недопустимое значение перечисления без возникновения ошибки компилятора.

Перечисления появляются всякий раз, когда у вас есть набор элементов, типы которых известны во время компиляции. Общие 
примеры включают направления по компасу, месяцы года, планеты в Солнечной системе и карты в колоде (ну, может быть, не 
планеты в Солнечной системе, учитывая, что Плутон лишился планетарного статуса).

#### Создание простых перечислений

Чтобы создать перечисление, объявите тип с ключевым словом enum, именем и списком значений, как показано на рис. 7.4.

#### Рис. 7.4 - Определение простого перечисления

Мы называем перечисление, которое содержит только список значений, простым перечислением. При работе с простыми 
перечислениями точка с запятой в конце списка необязательна. Держите перечисление Season под рукой, так как мы 
используем его в этом разделе.

---

Значения Enum считаются константами и обычно записываются с использованием змеиного регистра. Например, перечисление, 
объявляющее список вкусов мороженого, может включать такие значения, как VANILLA, ROCKY_ROAD, MINT_CHOCOLATE_CHIP и т.д.

---

Использовать enum очень просто.

```
var s = Season.SUMMER;
System.out.println(Season.SUMMER);       // SUMMER
System.out.println(s == Season.SUMMER);  // true
```

Как видите, перечисления печатают имя перечисления при вызове toString(). Их можно сравнивать с помощью ==, потому что 
они похожи на static final константы. Другими словами, вы можете использовать equals() или == для сравнения 
перечислений, поскольку каждое значение перечисления инициализируется только один раз в виртуальной машине Java (JVM).

Одна вещь, которую вы не можете сделать, это расширить перечисление.

```
public enum ExtendedSeason extends Season {} // DOES NOT COMPILE
```

Значения в перечислении фиксированы. Вы не можете добавить больше, расширив перечисление.

#### Calling the values(), name(), and ordinal() Methods

Перечисление предоставляет метод values() для получения массива всех значений. Вы можете использовать это как любой 
обычный массив, в том числе в цикле for-each:

```
for (var season : Season.values()) {
   System.out.println(season.name() + " " + season.ordinal());
}
```

Вывод показывает, что каждое значение перечисления имеет соответствующее значение int, и значения перечислены в том 
порядке, в котором они объявлены:

```
WINTER 0
SPRING 1
SUMMER 2
FALL 3
```

Значение int останется неизменным во время выполнения вашей программы, но программу будет легче читать, если вы будете 
придерживаться понятного человеку значения enum.

В любом случае вы не можете напрямую сравнивать значение int и enum, поскольку перечисление — это тип, как и класс Java,
а не примитивное целое число.

```
if ( Season.SUMMER == 2) {} // DOES NOT COMPILE
```

#### Вызов метода valueOf()

Другой полезной функцией является извлечение значения enum из строки с помощью метода valueOf(). Это полезно при работе 
со старым кодом или разборе пользовательского ввода. Однако передаваемая строка должна точно соответствовать значению 
enum.

```
Season s = Season.valueOf("SUMMER"); // SUMMER

Season t = Season.valueOf("summer"); // IllegalArgumentException
```

Первый оператор работает и присваивает s правильное значение enum. Обратите внимание, что эта строка не создает значение
enum, по крайней мере, не напрямую. Каждое значение enum создается один раз при первой загрузке enum. Как только enum 
загружен, он извлекает единственное значение enum с соответствующим именем.

Второе утверждение наталкивается на проблему. Нет значения enum с именем summer в нижнем регистре. Java разводит руками 
в знак поражения и выдает исключение IllegalArgumentException.

```
Exception in thread "main" java.lang.IllegalArgumentException:
   No enum constant enums.Season.summer
```

### Использование перечислений в операторах switch

Перечисления можно использовать в операторах и выражениях switch. Обратите внимание на значения case в этом коде:

```
Season summer = Season.SUMMER;
switch(summer) {
   case WINTER:
      System.out.print("Get out the sled!");
      break;
   case SUMMER:
      System.out.print("Time for the pool!");
      break;
   default:
      System.out.print("Is it summer yet?");
}
```

Код выводит "Время для бассейна!", поскольку он соответствует SUMMER периоду. В каждом операторе case мы просто вводили 
значение перечисления, а не писали Season.WINTER. В конце концов, компилятор уже знает, что единственными возможными 
совпадениями могут быть значения enum. Java обрабатывает тип enum как неявный. На самом деле, если бы вы набрали case 
Season.WINTER он не скомпилировался бы. Не верите нам? Взгляните на этот эквивалентный пример, использующий выражение 
switch:

```
Season summer = Season.SUMMER;
var message = switch(summer) {
   case Season.WINTER -> "Get out the sled!";  // DOES NOT COMPILE
   case 0 -> "Time for the pool!";             // DOES NOT COMPILE
   default -> "Is it summer yet?";
};
System.out.print(message); 
```

Первый оператор case не компилируется, так как в значении case используется Season. Если бы мы изменили Season.FALL на 
просто FALL, тогда строка скомпилировалась бы. А как насчет второго оператора case? Так же, как ранее мы сказали, что 
вы не можете сравнивать перечисления со значениями int, вы не можете использовать их в операторе switch со значениями 
int. На экзамене обратите особое внимание при работе с перечислениями, чтобы они использовались только как перечисления.

### Добавление конструкторов, полей и методов

В то время как простое перечисление состоит только из списка значений, мы можем определить сложное перечисление с 
дополнительными элементами. Допустим, наш зоопарк хочет отслеживать маршруты движения, чтобы определить, в какие сезоны 
посетителей больше всего.

```
1: public enum Season {
2:    WINTER("Low"), SPRING("Medium"), SUMMER("High"), FALL("Medium");
3:    private final String expectedVisitors;
4:    private Season(String expectedVisitors) {
5:       this.expectedVisitors = expectedVisitors;
6:    }
7:    public void printExpectedVisitors() {
8:       System.out.println(expectedVisitors);
9:    } }
```

Здесь есть несколько вещей, на которые стоит обратить внимание. В строке 2 список значений перечисления заканчивается 
точкой с запятой (;). Хотя это необязательно, когда наше перечисление состоит исключительно из списка значений, оно 
необходимо, если в перечислении есть что-то помимо значений.

Строки 3–9 представляют собой обычный код Java. У нас есть переменная экземпляра, конструктор и метод. Мы помечаем 
переменную экземпляра как private и final в строке 3, чтобы наши свойства перечисления нельзя было изменить.

---
Хотя можно создать перечисление с переменными экземпляра, которые можно изменить, это очень плохая практика, поскольку 
они совместно используются в JVM. При разработке перечисления значения должны быть неизменяемыми.
---

Все конструкторы перечисления являются неявно private, а модификатор является необязательным. Это разумно, так как вы 
не можете расширить перечисление, а конструкторы можно вызывать только внутри самого перечисления. На самом деле 
конструктор перечисления не будет компилироваться, если он содержит модификатор public или protected.

Как насчет скобок в строке 2? Это вызовы конструктора, но без нового ключевого слова, обычно используемого для объектов. 
В первый раз, когда мы запрашиваем какое-либо из значений перечисления, Java создает все значения перечисления. После 
этого Java просто возвращает уже созданные значения перечисления. Учитывая это объяснение, вы можете понять, почему 
конструктор вызывается только один раз:

```
public enum OnlyOne {
   ONCE(true);
   private OnlyOne(boolean b) {
      System.out.print("constructing,");
   }
}

public class PrintTheOne {
   public static void main(String[] args) {
      System.out.print("begin,");
      OnlyOne firstCall = OnlyOne.ONCE; // Prints constructing,
      OnlyOne secondCall = OnlyOne.ONCE; // Doesn't print anything
      System.out.print("end");
   }
}
```

Этот класс печатает следующее:

```
begin,constructing,end
```

Если бы перечисление OnlyOne использовалось в программе ранее и, следовательно, инициализировалось раньше, то строка, 
объявляющая переменную firstCall, ничего бы не печатала.

Как мы вызываем метод перечисления? Это тоже просто: мы просто используем значение перечисления, за которым следует 
вызов метода.

```
Season.SUMMER.printExpectedVisitors();
```

Иногда вы хотите определить разные методы для каждого перечисления. Например, в нашем зоопарке разные сезонные часы. 
Зимой холодно и рано темнеет. Мы можем отслеживать часы через переменные экземпляра или позволить каждому значению 
перечисления управлять часами самостоятельно.

```
public enum Season {
   WINTER {
      public String getHours() { return "10am-3pm"; }
   },
   SPRING {
      public String getHours() { return "9am-5pm"; }
   },
   SUMMER {
      public String getHours() { return "9am-7pm"; }
   },
   FALL {
      public String getHours() { return "9am-5pm"; }
   };
   public abstract String getHours();
}
```

Что тут происходит? Похоже, мы создали абстрактный класс и кучу крошечных подклассов. В некотором смысле, мы сделали. 
Само перечисление имеет абстрактный метод. Это означает, что для реализации этого метода требуется каждое значение 
перечисления. Если мы забудем реализовать метод для одного из значений, получим ошибку компилятора:

```
The enum constant WINTER must implement the abstract method getHours()
```

Но что, если мы не хотим, чтобы каждое значение перечисления имело метод? Без проблем. Мы можем создать реализацию для 
всех значений и переопределить ее только для особых случаев.

```
public enum Season {
   WINTER {
      public String getHours() { return "10am-3pm"; }
   },
   SUMMER {
      public String getHours() { return "9am-7pm"; }
   },
   SPRING, FALL;
   public String getHours() { return "9am-5pm"; }
}
```

Это выглядит лучше. Мы кодируем только особые случаи и позволяем остальным использовать реализацию, предоставленную 
enum. Перечисление может даже реализовать интерфейс, так как для этого нужно просто переопределить абстрактные 
методы:

```
public interface Weather { int getAverageTemperature(); }

public enum Season implements Weather {
   WINTER, SPRING, SUMMER, FALL;
   public int getAverageTemperature() { return 30; }
}
```

То, что у перечисления может быть много методов, не означает, что оно должно быть. Старайтесь, чтобы ваши перечисления 
были простыми. Если ваше перечисление больше одной или двух страниц, вероятно, оно слишком длинное. Когда перечисления 
становятся слишком длинными или слишком сложными, их трудно читать.


---
Вы могли заметить, что в каждом из этих примеров перечисления список значений стоит первым. Это не было случайностью. 
Независимо от того, является ли перечисление простым или сложным, список значений всегда идет первым.
---

## Запечатанные классы (Sealing Classes)

Перечисление с множеством конструкторов, полей и методов может начать напоминать полнофункциональный класс. Что, если бы
мы могли создать класс, но ограничить прямые подклассы фиксированным набором классов? Входите в запечатанные классы! 
Запечатанный класс — это класс, который ограничивает, какие другие классы могут его непосредственно расширять. Это 
новинка для Java 17, поэтому ожидайте увидеть хотя бы один вопрос о них на экзамене.

---
Вы случайно не заметили, что мы сказали "непосредственно расширять" в определении закрытого класса? Как вы вскоре 
увидите, для класса, не указанного в объявлении закрытого класса, есть способ расширить его косвенно. Однако, если 
мы не скажем иначе, предположим, что мы имеем в виду подклассы, которые непосредственно расширяют класс sealed.
---

### Объявление запечатанного класса

Начнем с простого примера. Запечатанный класс объявляет список классов, которые могут его расширить, а подклассы 
объявляют, что они расширяют запечатанный класс. На рис. 7.5 объявлен запечатанный класс с двумя прямыми подклассами.

#### Рис. 7.5 - Определение запечатанного класса

Заметили что-нибудь новое? Java 17 включает три новых ключевых слова, с которыми вы должны быть знакомы к экзамену. Мы 
часто используем final с запечатанными подклассами, но рассмотрим каждый из них после того, как рассмотрим основы.

**Ключевые слова запечатанного класса**

+ sealed: Указывает, что класс или интерфейс могут быть расширены/реализованы только именованными классами или интерфейсами.
+ permits: Используется с запечатанным (sealed) ключевым словом для перечисления разрешенных классов и интерфейсов.
+ non-sealed: Применяется к классу или интерфейсу, который расширяет запечатанный класс, указывая, что он может быть 
расширен неопределенными классами.

Пока довольно легко, верно? Экзамен также может проверить вас на то, для чего закрытые классы не могут быть 
использованы. Например, вы видите, почему каждый из этих наборов объявлений не компилируется?

```
public class sealed Frog permits GlassFrog {} // DOES NOT COMPILE
public final class GlassFrog extends Frog {}

public abstract sealed class Wolf permits Timber {}
public final class Timber extends Wolf {}
public final class MyWolf extends Wolf {} // DOES NOT COMPILE
```

Первый пример не компилируется, потому что модификаторы класса и запечатывания расположены в неправильном порядке. 
Модификатор должен стоять перед типом класса. Второй пример не компилируется, потому что MyWolf не указан в 
объявлении Wolf.

_Запечатанные классы обычно объявляются с модификатором abstract, хотя это, конечно, не требуется._

Объявление запечатанного класса с помощью запечатанного модификатора — это простая часть. В большинстве случаев, если вы
видите на экзамене вопрос о запечатанных классах, они проверяют ваши знания о том, правильно ли подкласс расширяет 
запечатанный класс. Существует ряд важных правил, которые необходимо знать перед экзаменом, поэтому внимательно 
прочитайте следующие разделы.

### Компиляция запечатанных классов

Допустим, мы создаем класс Penguin и компилируем его в новый пакет без какого-либо другого исходного кода. Имея это в 
виду, компилируется ли следующее?

```
// Penguin.java
package zoo;
public sealed class Penguin permits Emperor {}
```

Нет! Почему? Ответ заключается в том, что запечатанный класс необходимо объявить (и скомпилировать) в том же пакете, 
что и его непосредственные подклассы. Но как насчет самих подклассов? Каждый из них должен расширять запечатанный класс. 
Например, следующее не компилируется.

```
// Penguin.java
package zoo;
public sealed class Penguin permits Emperor {} // DOES NOT COMPILE

// Emperor.java
package zoo;
public final class Emperor {}
```

Несмотря на то, что класс Emperor объявлен, он не расширяет класс Penguin.

_Но подождите, это еще не все! В главе 12 «Модули» вы узнаете об именованных модулях, которые позволяют запечатывать 
классы и их прямые подклассы в разных пакетах при условии, что они находятся в одном и том же именованном модуле._

### Указание модификатора подкласса

Хотя некоторые типы, например интерфейсы, имеют определенное количество неявных модификаторов, запечатанные классы их не
имеют. Каждый класс, который непосредственно расширяет запечатанный класс, должен указывать только один из следующих 
трех модификаторов: final, sealed, или non-sealed. Запомните это правило на экзамене!

#### Подкласс final

Первый модификатор, который мы рассмотрим и который можно применить к прямому подклассу закрытого класса, — это 
модификатор final.

```
public sealed class Antelope permits Gazelle {}

public final class Gazelle extends Antelope {}

public class George extends Gazelle {} // DOES NOT COMPILE
```

Как и в случае с обычным классом, модификатор final предотвращает дальнейшее расширение подкласса Gazelle.

#### Подкласс sealed

Далее, давайте рассмотрим пример с использованием запечатанного модификатора:

```
public sealed class Mammal permits Equine {}

public sealed class Equine extends Mammal permits Zebra {}

public final class Zebra extends Equine {}
```

Модификатор sealed, примененный к подклассу Equine, означает, что должны присутствовать те же правила, которые мы 
применили к родительскому классу Mammal. А именно, Equine определяет свой собственный список разрешенных подклассов. 
Обратите внимание в этом примере, что Zebra является косвенным подклассом Mammal, но не названа в классе Mammal.

Несмотря на разрешение косвенных подклассов, не названных в Mammal, список классов, которые могут наследовать Mammal, 
по-прежнему фиксирован. Если у вас есть ссылка на объект Mammal, это должно быть Mammal, Equine или Zebra.

#### Подкласс non-sealed

Модификатор non-seal используется, чтобы открыть запечатанный родительский класс для потенциально неизвестных 
подклассов. Давайте изменим наш предыдущий пример, чтобы MyWolf мог компилироваться без изменения объявления Wolf:

```
public sealed class Wolf permits Timber {}

public non-sealed class Timber extends Wolf {}

public class MyWolf extends Timber {}
```

В этом примере мы можем создать непрямой подкласс Wolf с именем MyWolf, имя которого не указано в объявлении Wolf. 
Также обратите внимание, что MyWolf не является окончательным, поэтому он может быть расширен любым подклассом, таким 
как MyFurryWolf.

```
public class MyFurryWolf extends MyWolf {}
```

На первый взгляд это может показаться немного нелогичным. Ведь мы смогли создать подклассы Wolf, которые не были 
объявлены в Wolf. Так Wolf все еще запечатан? Да, но это благодаря полиморфизму. Любой экземпляр MyWolf или MyFurryWolf 
также является экземпляром Timber, имя которого указано в объявлении Wolf. Мы обсудим полиморфизм ближе к концу этой 
главы.

---
Если вы все еще беспокоитесь о том, что слишком часто открываете sealed класс с помощью non-sealed подкласса, 
помните, что человек, пишущий запечатанный класс, может видеть объявление всех прямых подклассов во время компиляции. 
Они могут решить, разрешать ли поддержку non-sealed подкласса.
---

### Пункт об исключении разрешений (Omitting the permits Clause)

До сих пор во всех примерах, которые вы видели, требовалось предложение permits при объявлении закрытого класса, но это 
не всегда так. Представьте, что у вас есть Snake.java-файл с двумя классами верхнего уровня, определенными внутри него:

```
// Snake.java
public sealed class Snake permits Cobra {}
final class Cobra extends Snake {}
```

В этом случае предложение о разрешениях (permits) является необязательным и может быть опущено. Однако ключевое слово 
extends по-прежнему требуется в подклассе:

```
// Snake.java
public sealed class Snake {}
final class Cobra extends Snake {}
```

Если бы эти классы были в отдельных файлах, этот код не скомпилировался бы! Это правило также применяется к запечатанным
классам с вложенными подклассами.

```
// Snake.java
public sealed class Snake {
final class Cobra extends Snake {}
}
```

---

##### Ссылки на вложенные подклассы

Хотя это облегчает чтение кода, если вы опустите предложение permits для вложенных подклассов, вы можете присвоить им 
имена. Однако синтаксис может отличаться от того, что вы ожидаете.

```
public sealed class Snake permits Cobra { // DOES NOT COMPILE
   final class Cobra extends Snake {}
}
```

Этот код не компилируется, поскольку Cobra требует ссылки на пространство имен Snake. Следующее устраняет эту проблему:

```
public sealed class Snake permits Snake.Cobra {
   final class Cobra extends Snake {}
}
```

Когда все ваши подклассы вложены, мы настоятельно рекомендуем опустить класс permits.

---

Вскоре мы рассмотрим вложенные классы. На данный момент вам просто нужно знать, что вложенный класс — это класс, 
определенный внутри другого класса, и что правило пропуска также применяется к вложенным классам.

Табл. 7.3 является удобной ссылкой на эти случаи.

#### Таблица 7.3 - Использование положения о permits в sealed классах

|     Расположение прямых подклассов     |         пункт permits         |  
|:--------------------------------------:|:-----------------------------:|
| В другом файле из запечатанного класса |           Требуется           |
|  В том же файле, что и закрытый класс  | Разрешено, но не обязательно  |                                     
|    Вложен внутри закрытого класса      | Разрешено, но не обязательно  |

### Запечатанные интерфейсы

Помимо классов, интерфейсы также могут быть запечатаны. Идея аналогична классам, и применяются многие из тех же правил. 
Например, запечатанный интерфейс должен находиться в том же пакете или именованном модуле, что и классы или интерфейсы, 
которые непосредственно расширяют или реализуют его.

Одной из отличительных особенностей закрытого интерфейса является то, что список разрешений (permits) может применяться 
к классу, который реализует интерфейс, или к интерфейсу, который расширяет интерфейс.

```
// Sealed interface
public sealed interface Swims permits Duck, Swan, Floats {}

// Classes permitted to implement sealed interface
public final class Duck implements Swims {}
public final class Swan implements Swims {}

// Interface permitted to extend sealed interface
public non-sealed interface Floats extends Swims {}
```

Как насчет модификатора, применяемого к интерфейсам, которые расширяют закрытый интерфейс? Что ж, помните, что 
интерфейсы неявно abstract и не могут быть помечены как final. По этой причине интерфейсы, которые расширяют закрытый 
интерфейс, могут быть помечены только как sealed или non-sealed. Они не могут быть помечены как final.

### Просмотр правил закрытого класса

Каждый раз, когда вы видите запечатанный класс на экзамене, обратите пристальное внимание на объявление подкласса и 
модификаторы.

**Правила запечатаного класса**

+ Запечатанные классы объявляются с модификаторами sealed и permits.
+ Запечатанные классы должны быть объявлены в том же пакете или именованном модуле, что и их непосредственные подклассы.
+ Прямые подклассы запечатанных классов должны быть помечены как final, sealed или non-sealed.
+ Предложение permits является необязательным, если запечатанный класс и его прямые подклассы объявлены в одном и том же
файле или подклассы вложены в запечатанный класс.
+ Интерфейсы могут быть запечатаны, чтобы ограничить классы, которые их реализуют, или интерфейсы, которые их расширяют.

---

_Сценарий реального мира_

**Зачем нужны запечатанные классы?**

В главе 3 «Принятие решений» вы узнали о выражениях switch и сопоставлении с образцом. Представьте, если бы мы 
могли обращаться с запечатанным классом как с перечислением в выражении switch, применяя сопоставление с образцом. Для 
запечатанного класса Fish с двумя прямыми подклассами это может выглядеть примерно так:

```
public void printName(Fish fish) {
   System.out.println(switch(fish) {
      case Trout t -> t.getTroutName();
      case Bass b -> b.getBassName();
   });
}
```

Если бы Fish не был запечатан, для выражения switch потребовалась бы default ветвь, иначе код не скомпилировался бы. 
Поскольку он запечатан, компилятор знает все варианты! Хорошая новость заключается в том, что эта функция находится в 
разработке, но плохая новость заключается в том, что она все еще находится в предварительной версии в Java 17 и 
официально не выпущена. Мы просто хотели дать вам представление о том, куда направляются некоторые из этих новых 
функций.

---

## Инкапсуляция данных с помощью записей

Мы оставили лучший новый тип Java напоследок! Если вы слышали что-нибудь о новых функциях Java, вы, вероятно, слышали о 
записях. Записи интересны, потому что они удаляют тонны стандартного кода. Прежде чем мы перейдем к записям, полезно 
иметь некоторый контекст того, почему они были добавлены в язык, поэтому мы начнем с инкапсуляции.

### Понимание инкапсуляции

POJO, что означает Plain Old Java Object, представляет собой класс, используемый для моделирования и передачи данных, 
часто с небольшим количеством сложных методов или вообще без них (отсюда и «простая» часть определения).
Возможно, вы также слышали о JavaBean, то есть о POJO, к которому применяются некоторые дополнительные правила.

Давайте создадим простой POJO с двумя полями:

```
public class Crane {
   int numberEggs;
   String name;
   public Crane(int numberEggs, String name) {
      this.numberEggs = numberEggs;
      this.name = name;
   }
}
```

О, поля — это пакетный доступ. Почему мы заботимся? Это означает, что кто-то за пределами класса в том же пакете может 
изменить эти значения и создать неверные данные, например:

```
public class Poacher {
   public void badActor() {
      var mother = new Crane(5, "Cathy");
      mother.numberEggs = -100;
   }
}
```

Это явно никуда не годится. Мы не хотим, чтобы у матери Crane было отрицательное количество яиц! Инкапсуляция приходит 
на помощь. Инкапсуляция - это способ защитить членов класса путем ограничения доступа к ним. В Java это обычно 
реализуется путем объявления всех переменных экземпляра private. Вызывающие должны использовать методы для извлечения 
или изменения переменных экземпляра.

Инкапсуляция — это защита класса от неожиданного использования. Это также позволяет нам позже изменять методы и 
поведение класса без того, чтобы кто-то уже имел прямой доступ к переменной экземпляра в классе. Например, мы можем 
изменить тип данных переменной экземпляра, но сохранить те же сигнатуры методов. Таким образом, мы сохраняем полный 
контроль над внутренней работой класса.

Давайте взглянем на недавно инкапсулированный (и неизменяемый) класс Crane:

```
1: public final class Crane {
2:    private final int numberEggs;
3:    private final String name;
4:    public Crane(int numberEggs, String name) {
5:       if (numberEggs >= 0) this.numberEggs = numberEggs; // guard condition
6:       else throw new IllegalArgumentException();
7:       this.name = name;
8:    }
9:    public int getNumberEggs() { // getter
10:      return numberEggs;
11:   }
12:   public String getName() { // getter
13:      return name;
14:   }
15: }
```

Обратите внимание, что переменные экземпляра теперь закрыты в строках 2 и 3. Это означает, что только код внутри класса 
может читать или записывать их значения. Поскольку мы написали класс, мы знаем, что лучше не устанавливать отрицательное 
количество яиц. В строках 9–11 мы добавили метод для чтения значения, который называется _методом доступа_ или геттером.

Вы могли заметить, что мы пометили класс и его переменные экземпляра как final, и у нас нет никаких методов-мутаторов 
(mutator methods) или сеттеров для изменения значения переменных экземпляра. Это потому, что мы хотим, чтобы наш класс 
был неизменяемым в дополнение к хорошей инкапсуляции. Как вы видели в главе 6, шаблон неизменяемых объектов — это шаблон 
объектно-ориентированного проектирования, в котором объект не может быть изменен после его создания. Вместо изменения 
неизменяемого объекта вы создаете новый объект, содержащий любые свойства исходного объекта, который вы хотите 
скопировать.

Чтобы просмотреть, помните, что данные (переменная экземпляра) являются private, а геттеры/сеттеры public для 
инкапсуляции. Вам даже не нужно предоставлять геттеры и сеттеры. Пока переменные экземпляра private, все в порядке. 
Например, следующий класс хорошо инкапсулирован, хотя и не очень полезен, так как не объявляет никаких private 
методов:

```
public class Vet {
   private String name = "Dr Rogers";
   private int yearsExperience = 25;
}
```

Вы должны опустить сеттеры, чтобы класс был неизменяемым. Просмотрите главу 6, чтобы узнать о дополнительных правилах 
создания неизменяемых объектов.

### Применение записей

Наш класс Crane состоял из 15 строк. Мы можем записать это намного короче, как показано на рис. 7.6. Если на мгновение 
отложить в сторону предложение защиты для numberEggs в конструкторе, эта запись эквивалентна и неизменяема!

#### Рис. 7.6 - Определение записи


Ух ты! Это всего одна строка! Запись (record) — это особый тип класса, ориентированного на данные, в который компилятор 
вставляет за вас шаблонный код.

На самом деле компилятор вставляет гораздо больше, чем 14 строк, которые мы написали ранее. В качестве бонуса компилятор
вставляет полезные реализации методов Object equals(), hashCode() и toString(). Мы рассмотрели многое в одной строке 
кода!

Теперь представьте, что у нас было 10 полей данных вместо 2. Это множество методов, которые избавляют нас от 
необходимости писать. И мы даже не говорили о конструкторах! Хуже того, каждый раз, когда кто-то изменяет поле, может 
потребоваться обновление десятков строк связанного с ним кода. Например, name может использоваться в конструкторе, 
методе toString(), equals() и так далее. Если у нас есть приложение с сотнями POJO, запись может сэкономить нам 
драгоценное время.

Создать экземпляр Crane и напечатать некоторые поля очень просто:

```
var mommy = new Crane(4, "Cammy");
System.out.println(mommy.numberEggs());   // 4
System.out.println(mommy.name());         // Cammy
```

Здесь следует выделить несколько вещей. Во-первых, мы никогда не определяли никаких конструкторов или методов в нашем 
объявлении Crane. Откуда компилятор знает, что делать? В фоновом режиме он создает для вас конструктор с параметрами в 
том же порядке, в котором они появляются в объявлении записи. Отсутствие или изменение порядка типов приведет к ошибкам 
компилятора:

```
var mommy1 = new Crane("Cammy", 4);  // DOES NOT COMPILE
var mommy2 = new Crane("Cammy");     // DOES NOT COMPILE
```

Для каждого поля также создается метод доступа в виде имени поля и набора скобок. В отличие от традиционных POJO или 
JavaBeans, методы не имеют префикса get или is. Всего несколько символов, которые записывают, избавят вас от 
необходимости печатать! Наконец, записи переопределяют для вас ряд методов в Object.

**Участники автоматически добавляются в записи**

+ Конструктор: конструктор с параметрами в том же порядке, что и объявление записи
+ Метод доступа: один метод доступа для каждого поля
+ equals(): метод сравнения двух элементов, который возвращает true, если каждое поле равно с точки зрения equals()
+ hashCode(): согласованный метод hashCode(), использующий все поля
+ toString(): Реализация toString(), которая печатает каждое поле записи в удобном для чтения формате

Ниже приведены примеры новых методов. Помните, что метод println() будет автоматически вызывать метод toString() для 
любого переданного ему объекта.

```
var father = new Crane(0, "Craig");
System.out.println(father);              // Crane[numberEggs=0, name=Craig]

var copy = new Crane(0, "Craig");
System.out.println(copy);                // Crane[numberEggs=0, name=Craig]
System.out.println(father.equals(copy)); // true
System.out.println(father.hashCode() + ", " + copy.hashCode()); // 1007, 1007
```

Это основы записи. Мы говорим «основы», потому что с ними можно делать гораздо больше, как вы увидите в следующих 
разделах.

_Учитывая наше однострочное объявление Crane, представьте, сколько кода и работы потребуется для написания 
эквивалентного класса. Это может легко занять 40+ строк! Было бы забавно попытаться написать все методы, которые 
регистрируют предложение._

Забавный факт: вполне законно иметь запись без полей. Он просто объявляется с помощью ключевого слова record и круглых 
скобок:

```
public record Crane() {}
```

Не то, что вы бы использовали в своем собственном коде, но это может появиться на экзамене.

### Понимание неизменности записи

Как вы видели, у записей нет сеттеров. Каждое поле по своей сути является final и не может быть изменено после того, 
как оно было записано в конструкторе. Чтобы «изменить» запись, вам нужно создать новый объект и скопировать все данные, 
которые вы хотите сохранить.

```
var cousin = new Crane(3, "Jenny");
var friend = new Crane(cousin.numberEggs(), "Janeice");
```

Точно так же, как интерфейсы неявно abstract, записи также неявно окончательны. Модификатор final является 
необязательным, но предполагается.

```
public final record Crane(int numberEggs, String name) {}
```

Как и в случае с перечислениями, это означает, что вы не можете расширять или наследовать запись.

```
public record BlueCrane() extends Crane {} // DOES NOT COMPILE
```

Как и перечисления, запись может реализовывать обычный или запечатанный интерфейс при условии, что она реализует все 
абстрактные методы.

```
public interface Bird {}
public record Crane(int numberEggs, String name) implements Bird {}
```

_Хотя это выходит далеко за рамки этой книги, есть несколько веских причин сделать классы, ориентированные на данные, 
неизменяемыми. Это может привести к менее подверженному ошибкам коду, поскольку новый объект создается каждый раз при 
изменении данных. Это также делает их по своей сути потокобезопасными и пригодными для использования в параллельных 
средах._

### Объявление конструкторов

Что, если вам нужно объявить рекорд с некоторыми охранниками, как мы это делали ранее? В этом разделе мы рассмотрим два 
способа достижения этого с помощью записей.

#### Длинный конструктор

Во-первых, мы можем просто объявить конструктор, который компилятор обычно вставляет автоматически, и который мы 
называем длинным конструктором.

```
public record Crane(int numberEggs, String name) {
   public Crane(int numberEggs, String name) {
      if (numberEggs < 0) throw new IllegalArgumentException();
      this.numberEggs = numberEggs;
      this.name = name;
   }
}
```

Компилятор не вставит конструктор, если вы определите его с тем же списком параметров в том же порядке. Поскольку 
каждое поле является final, конструктор должен установить каждое поле. Например, эта запись не компилируется:

```
public record Crane(int numberEggs, String name) {
   public Crane(int numberEggs, String name) {}     // DOES NOT COMPILE
}
```

Хотя возможность объявлять конструктор является приятной особенностью записей, это также проблематично. Если у нас есть 
20 полей, нам нужно будет объявить назначения для каждого из них, введя шаблон, который мы стремились удалить. О, 
черт возьми!

#### Компактные конструкторы

К счастью, авторы Java добавили возможность определять компактный конструктор для записей. Компактный конструктор — это 
специальный тип конструктора, используемый для записи, чтобы кратко обрабатывать проверку и преобразование. Он не 
принимает никаких параметров и неявно устанавливает все поля. На рис. 7.7 показан пример компактного конструктора.

#### Рис. 7.7 - Объявление компактного конструктора


Отлично! Теперь мы можем проверить нужные нам значения, и нам не нужно перечислять все параметры конструктора и 
тривиальные присваивания. Java выполнит полный конструктор после компактного конструктора. Вы также должны помнить, что 
компактный конструктор объявляется без круглых скобок, так как экзамен может попытаться вас обмануть. Как показано на 
рис. 7.7, мы можем даже преобразовывать параметры конструктора, как мы обсудим в следующем разделе.

_Вы можете подумать, что вам нужны специальные методы для каждого поля в записи, например отрицательная проверка, которую
мы сделали с помощью setNumberEggs(). На практике многие POJO создаются для общего использования с небольшой проверкой._

#### Преобразование параметров

Компактные конструкторы дают вам возможность применять преобразования к любому входному значению. Посмотрите, сможете 
ли вы понять, что делает следующий компактный конструктор:

```
public record Crane(int numberEggs, String name) {
   public Crane {
      if (name == null || name.length() < 1)
         throw new IllegalArgumentException();
      name = name.substring(0,1).toUpperCase()
         + name.substring(1).toLowerCase();
   }
}
```

Сдаваться? Он проверяет строку, а затем форматирует ее так, чтобы только первая буква была заглавной. Как и прежде, Java
вызывает полный конструктор после компактного конструктора, но с измененными параметрами конструктора.

Хотя компактные конструкторы могут изменять параметры конструктора, они не могут изменять поля записи. Например, это не 
компилируется:

```
public record Crane(int numberEggs, String name) {
   public Crane {
      this.numberEggs = 10; // DOES NOT COMPILE
   }
}
```

Удаление ссылки this позволяет скомпилировать код, поскольку вместо этого изменяется параметр конструктора.

_Хотя в этом разделе мы рассмотрели как длинную, так и компактную формы конструкторов записей, настоятельно 
рекомендуется придерживаться компактной формы, если у вас нет веских причин не делать этого._

#### Перегруженные конструкторы

Вы также можете создавать перегруженные конструкторы, которые принимают совершенно другой список параметров. Они более 
тесно связаны с конструктором полной формы и не используют никаких синтаксических особенностей компактных 
конструкторов.

```
public record Crane(int numberEggs, String name) {
   public Crane(String firstName, String lastName) {
      this(0, firstName + " " + lastName);
   }
}
```

Первая строка перегруженного конструктора должна быть явным вызовом другого конструктора через this(). Если других 
конструкторов нет, должен быть вызван длинный конструктор. Сравните это с тем, что вы узнали из главы 6, где вызов 
super() или this() часто был необязательным в объявлениях конструктора. Кроме того, в отличие от компактных 
конструкторов, вы можете преобразовывать данные только в первой строке. После первой строки все поля уже будут 
назначены, а объект неизменяем.

```
public record Crane(int numberEggs, String name) {
   public Crane(int numberEggs, String firstName, String lastName) {
      this(numberEggs + 1, firstName + " " + lastName);
      numberEggs = 10;       // NO EFFECT (applies to parameter, not instance field)
      this.numberEggs = 20;  // DOES NOT COMPILE
   }
}
```

Как вы видели в главе 6, вы также не можете объявить два конструктора записей, которые вызывают друг друга бесконечно 
или как цикл.

```
public record Crane(int numberEggs, String name) {
   public Crane(String name) {
      this(1);    // DOES NOT COMPILE
   }
   public Crane(int numberEggs) {
      this("");   // DOES NOT COMPILE
   }
}
```

### Настройка записей

Поскольку записи ориентированы на данные, мы сосредоточились на функциях записей, которые вы, вероятно, будете 
использовать. Записи на самом деле поддерживают многие из тех же функций, что и классы. Вот некоторые из членов, 
которые могут быть включены в записи и с которыми вы должны быть знакомы для экзамена:

+ Перегруженные и компактные конструкторы
+ Методы экземпляра, включая переопределение любых предоставленных методов (аксессоры, equals(), hashCode(), toString())
+ Вложенные классы, интерфейсы, аннотации, перечисления и записи

В качестве наглядного примера следующий пример переопределяет два метода экземпляра с помощью необязательной 
аннотации @Override:

```
public record Crane(int numberEggs, String name) {
   @Override public int numberEggs() { return 10; }
   @Override public String toString() { return name; }
}
```

Хотя вы можете добавлять методы, статические поля и другие типы данных, вы не можете добавлять поля экземпляров вне 
объявления записи, даже если они являются private. Это противоречит цели использования записи и может нарушить 
неизменяемость!

```
public record Crane(int numberEggs, String name) {
   private static int type = 10;
   public int size;           // DOES NOT COMPILE
   private boolean friendly;  // DOES NOT COMPILE
}
```

Записи также не поддерживают инициализаторы экземпляров. Вся инициализация полей записи должна происходить в 
конструкторе.

_Несмотря на то, что записи поддерживают многие из тех же элементов, что и класс, это полезная функция, но постарайтесь 
сделать их простыми. Подобно POJO и JavaBeans, из которых они родились, чем сложнее они становятся, тем менее удобными 
они становятся._

Это уже второй раз, когда мы упоминаем вложенные типы, первый раз — с запечатанными классами, а теперь — с записями. 
Не волнуйтесь; мы расскажем о них дальше!

## Создание вложенных классов 382

Вложенный класс — это класс, определенный внутри другого класса. Вложенный класс может иметь одну из четырех 
разновидностей.

+ Внутренний класс: (non-static) нестатический тип, определенный на уровне членов класса.
+ Статический вложенный класс: static тип, определенный на уровне члена класса.
+ Локальный класс: класс, определенный в теле метода.
+ Анонимный класс: особый случай локального класса, у которого нет имени.

Есть много преимуществ использования вложенных классов. Они могут определять вспомогательные классы и ограничивать их 
содержащим классом, тем самым улучшая инкапсуляцию. Они могут упростить создание класса, который будет использоваться 
только в одном месте. Они даже могут сделать код чище и легче для чтения.

Однако при неправильном использовании вложенные классы иногда могут затруднить чтение кода. Они также имеют тенденцию 
тесно связывать вмещающий и внутренний классы, но могут быть случаи, когда вы хотите использовать внутренний класс сам 
по себе. В этом случае вы должны переместить внутренний класс в отдельный класс верхнего уровня.

К сожалению, экзамен проверяет крайние случаи, когда программисты обычно не используют вложенный класс. Это имеет 
тенденцию создавать код, который трудно читать, поэтому, пожалуйста, никогда не делайте этого на практике!

_По соглашению и в этой главе мы часто используем термин вложенный класс для обозначения всех вложенных типов, включая 
вложенные интерфейсы, перечисления, записи и аннотации. Вы можете даже встретить литературу, в которой все они 
называются внутренними классами. Мы согласны, что это может сбивать с толку!_

### Объявление внутреннего класса

Внутренний класс, также называемый внутренним классом-членом, представляет собой нестатический тип, определенный на 
уровне члена класса (на том же уровне, что и методы, переменные экземпляра и конструкторы). Поскольку они не являются 
типами верхнего уровня, они могут использовать любой из четырех уровней доступа, а не только public и пакетный 
доступ.

Внутренние классы обладают следующими свойствами:

+ Может быть объявлен public, protected, пакетным или private
+ Можно расширить класс и реализовать интерфейсы
+ Может быть помечен как abstract или final
+ Может получить доступ к членам внешнего класса, включая private члены

Последнее свойство довольно крутое. Это означает, что внутренний класс может обращаться к переменным внешнего класса без
каких-либо специальных действий. Готовы к сложному способу напечатать Hi три раза?

```
1: public class Home {
2:    private String greeting = "Hi";  // Outer class instance variable
3:
4:    protected class Room {           // Inner class declaration
5:       public int repeat = 3;
6:       public void enter() {
7:          for (int i = 0; i < repeat; i++) greet(greeting);
8:       }
9:       private static void greet(String message) {
10:         System.out.println(message);
11:      }
12:   }
13:
14:   public void enterRoom() {    // Instance method in outer class
15:      var room = new Room();    // Create the inner class instance
16:      room.enter();
17:   }
18:   public static void main(String[] args) {
19:      var home = new Home();     // Create the outer class instance
20:      home.enterRoom();
21: } }
```

Объявление внутреннего класса выглядит так же, как объявление отдельного класса, за исключением того, что оно находится 
внутри другого класса. В строке 7 показано, что внутренний класс просто ссылается на greeting, как если бы оно было 
доступно в классе Room. Это работает, потому что это, по сути, доступно. Несмотря на то, что переменная является 
private, доступ к ней осуществляется внутри того же класса.

Поскольку внутренний класс не является static, его необходимо вызывать с использованием экземпляра внешнего класса.
Это означает, что вам нужно создать два объекта. Строка 19 создает внешний объект Home, а строка 15 создает внутренний 
объект Room. Важно отметить, что строка 15 не требует явного экземпляра Home, потому что это метод экземпляра внутри 
Home. Это работает, потому что enterRoom() — это метод экземпляра в классе Home. И Room, и enterRoom() являются членами 
Home.

**Вложенные классы теперь могут иметь статические члены**

_Внимательные читатели могли заметить, что мы включили статический метод в наш внутренний класс Room в строке 9. В Java 
11 это привело бы к ошибке компилятора. Ранее только статические вложенные классы могли включать статические методы. 
С введением записей в Java 16 существующее правило, запрещающее внутреннему классу иметь какие-либо статические члены 
(кроме статических констант), было удалено. Все четыре типа вложенных классов теперь могут определять статические 
переменные и методы!_

### Создание экземпляра внутреннего класса

Есть еще один способ создать экземпляр Room, который на первый взгляд выглядит странно. Ладно, может быть, не только 
поначалу. Этот синтаксис используется недостаточно часто, чтобы к нему можно было привыкнуть:

```
20: public static void main(String[] args) {
21:    var home = new Home();
22:    Room room = home.new Room();      // Create the inner class instance
23:    room.enter();
24: }
```

Давайте внимательнее посмотрим на строки 21 и 22. Нам нужен экземпляр Home для создания Room. Мы не можем просто вызвать
new Room() внутри static метода main(), потому что Java не будет знать, с каким экземпляром Home он связан. Java решает 
эту проблему, вызывая new, как если бы это был метод переменной room. Мы можем сократить строки 21–23 до одной строки:

```
21:  new Home().new Room().enter(); // Sorry, it looks ugly to us too!
```

**Создание файлов .class для внутренних классов**

_При компиляции класса Home.java, с которым мы работали, создаются два файла классов. Вы должны ожидать файл Home.class. 
Для внутреннего класса компилятор создает Home$Room.class. Вам не нужно знать этот синтаксис для экзамена. Мы упомянули 
об этом, чтобы вы не удивлялись, увидев файлы с $, появляющиеся в ваших каталогах. Вам нужно понимать, что несколько 
файлов классов создаются из одного файла .java._

### Ссылка на члены внутреннего класса

Внутренние классы могут иметь те же имена переменных, что и внешние классы, что немного усложняет область видимости. 
Существует специальный способ вызвать this, чтобы указать, к какой переменной вы хотите получить доступ. Это то, что вы 
могли бы увидеть на экзамене, но, в идеале, не в реальном мире.

На самом деле, вы не ограничены только одним внутренним классом. Хотя на экзамене часто используется следующее, 
пожалуйста, никогда не делайте этого в коде, который вы пишете. Вот как вложить несколько классов и получить доступ к 
переменной с одинаковым именем в каждом из них:

```
1: public class A {
2:    private int x = 10;
3:    class B {
4:       private int x = 20;
5:       class C {
6:          private int x = 30;
7:          public void allTheX() {
8:             System.out.println(x); // 30
9:             System.out.println(this.x); // 30
10:            System.out.println(B.this.x); // 20
11:            System.out.println(A.this.x); // 10
12:   } } }
13:   public static void main(String[] args) {
14:      A a = new A();
15:      A.B b = a.new B();
16:      A.B.C c = b.new C();
17:      c.allTheX();
18: }}
```

Да, этот код тоже заставляет нас съеживаться. Он имеет два вложенных класса. Строка 14 создает экземпляр самого 
внешнего. В строке 15 используется неудобный синтаксис для создания экземпляра B. Обратите внимание, что это тип A.B. 
Мы могли бы написать B как тип, потому что он доступен на уровне члена A. Java знает, где его искать. В строке 16 мы 
создаем экземпляр C. На этот раз необходимо указать тип A.B.C. "C" слишком глубок для Java, чтобы знать, где искать. 
Затем в строке 17 вызывается метод для переменной экземпляра c.

Строки 8 и 9 — это тип кода, который мы привыкли видеть. Они ссылаются на переменную экземпляра текущего класса — если 
быть точным, объявленную в строке 6. В строке 10 this используется особым образом. Нам все еще нужна переменная 
экземпляра. Но на этот раз нам нужна переменная класса B, которая является переменной в строке 4. Строка 11 делает то же
самое для класса A, получая переменную из строки 2.

**Внутренним классам требуется экземпляр** 

_Взгляните на следующее и посмотрите, сможете ли вы понять, почему два из трех вызовов конструктора не компилируются:_

```
public class Fox {
   private class Den {}
   public void goHome() {
      new Den();
   }
   public static void visitFriend() {
      new Den();   // DOES NOT COMPILE
   }
}

public class Squirrel {
   public void visitFox() {
      new Den();   // DOES NOT COMPILE
   }
}
```

_Первый вызов конструктора компилируется, поскольку goHome() является методом экземпляра, и поэтому вызов связан с 
экземпляром this. Второй вызов не компилируется, так как вызывается внутри static метода. Вы по-прежнему можете вызывать
конструктор, но вы должны явно указать ссылку на экземпляр Fox._

_Последний вызов конструктора не компилируется по двум причинам. Несмотря на то, что это метод экземпляра, он не является
методом экземпляра внутри класса Fox. Однако добавление ссылки на Fox не решит проблему полностью. Den является private 
и недоступным в классе Squirrel._

### Создание статического вложенного класса

Статический вложенный класс — это статический тип, определенный на уровне члена. В отличие от внутреннего класса, 
статический вложенный класс может быть создан без экземпляра включающего класса. Компромисс, однако, заключается в том, 
что он не может получить доступ к переменным или методам экземпляра, объявленным во внешнем классе.

Другими словами, это похоже на класс верхнего уровня, за исключением следующего:

+ Вложение создает пространство имен, поскольку для ссылки на него должно использоваться имя вмещающего класса.
+ Его можно дополнительно пометить как private или protected.
+ Охватывающий класс может ссылаться на поля и методы статического вложенного класса.

Давайте посмотрим на пример:

```
1: public class Park {
2:    static class Ride {
3:       private int price = 6;
4:    }
5:    public static void main(String[] args) {
6:       var ride = new Ride();
7:       System.out.println(ride.price);
8: } }
```

Строка 6 создает экземпляр вложенного класса. Поскольку класс является static, вам не нужен экземпляр Park для его 
использования. Вам разрешен доступ к private переменным экземпляра, как показано в строке 7.

### Написание локального класса

Локальный класс — это вложенный класс, определенный внутри метода. Как и локальные переменные, объявление локального 
класса не существует до тех пор, пока метод не будет вызван, и выходит за пределы области видимости, когда метод 
возвращается. Это означает, что вы можете создавать экземпляры только внутри метода. Эти экземпляры все еще могут быть 
возвращены из метода. Именно так работают локальные переменные.

_Локальные классы не ограничиваются объявлением только внутри методов. Например, они могут быть объявлены внутри 
конструкторов и инициализаторов. Для простоты мы ограничим наше обсуждение методами в этой главе._

Локальные классы обладают следующими свойствами:

+ У них нет модификатора доступа.
+ Они могут быть объявлены final или abstract.
+ У них есть доступ ко всем полям и методам окружающего класса (если они определены в методе экземпляра).
+ Они могут получить доступ к final и эффективно final локальным переменным.

_Помните, когда мы представляли эффективный final в главе 5? Что ж, мы сказали, что это пригодится позже, и это позже! 
Если вам нужно освежить информацию о final и фактически final, вернитесь к главе 5 прямо сейчас. Не волнуйтесь, мы 
подождем!_

Готовы к примеру? Вот сложный способ умножения двух чисел:

```
1: public class PrintNumbers {
2:    private int length = 5;
3:    public void calculate() {
4:       final int width = 20;
5:       class Calculator {
6:          public void multiply() {
7:             System.out.print(length * width);
8:          }
9:       }
10:      var calculator = new Calculator();
11:      calculator.multiply();
12:   }
13:   public static void main(String[] args) {
14:      var printer = new PrintNumbers();
15:      printer.calculate(); // 100
16:   }
17: }
```

Строки 5–9 — местный класс. Область действия этого класса заканчивается в строке 12, где заканчивается метод. Строка 7 
ссылается на переменную экземпляра и final локальную переменную, поэтому ссылки на обе переменные разрешены внутри 
локального класса.

Ранее мы заявили, что ссылки на локальные переменные разрешены, если они являются final или эффективно final. 
В качестве наглядного примера рассмотрим следующее:

```
public void processData() {
   final int length = 5;
   int width = 10;
   int height = 2;
   class VolumeCalculator {
      public int multiply() {
         return length * width * height; // DOES NOT COMPILE
      }
   }
   width = 2;
}
```

Переменные length и height являются final и эффективно final, соответственно, поэтому ни одна из них не вызывает 
проблем при компиляции. С другой стороны, переменная width переназначается во время метода, поэтому он не может быть
эффективно final. По этой причине объявление локального класса не компилируется.

**Почему локальные классы могут обращаться только к final или эффективно final переменным?**

_Ранее мы упоминали, что компилятор создает отдельный файл .class для каждого внутреннего класса. Отдельный класс не 
может ссылаться на локальную переменную. Однако, если локальная переменная является final или эффективно final, Java 
может обработать ее, передав копию значения или ссылочной переменной конструктору локального класса. Если бы оно не было
final или эффективно final, эти приемы не сработали бы, потому что значение могло бы измениться после того, как была 
сделана копия._

### Определение анонимного класса

Анонимный класс — это специализированная форма локального класса, не имеющая имени. Он объявляется и создается в одном 
операторе с использованием ключевого слова new, имени типа в круглых скобках и набора фигурных скобок {}. Анонимные 
классы должны расширять существующий класс или реализовывать существующий интерфейс. Они полезны, когда у вас есть 
короткая реализация, которая больше нигде не будет использоваться. Вот пример:

```
1: public class ZooGiftShop {
2:    abstract class SaleTodayOnly {
3:       abstract int dollarsOff();
4:    }
5:    public int admission(int basePrice) {
6:       SaleTodayOnly sale = new SaleTodayOnly() {
7:          int dollarsOff() { return 3; }
8:       };       // Don't forget the semicolon!
9:       return basePrice -sale.dollarsOff();
10: } }
```

Строки 2–4 определяют abstract класс. Строки 6–8 определяют анонимный класс. Обратите внимание, что у этого 
анонимного класса нет имени. В коде сказано создать экземпляр нового объекта SaleTodayOnly. Но подождите: SaleTodayOnly 
является abstract. Это нормально, потому что мы предоставляем тело класса прямо здесь — анонимно. В этом примере 
написание анонимного класса эквивалентно написанию локального класса с неуказанным именем, который расширяет 
SaleTodayOnly и немедленно его использует.

Обратите особое внимание на точку с запятой в строке 8. В этих строках мы объявляем локальную переменную. Объявления 
локальных переменных должны заканчиваться точкой с запятой, как и другие операторы Java, даже если они длинные и 
содержат анонимный класс.

Теперь мы преобразуем этот же пример для реализации interface вместо расширения abstract класса:

```
1: public class ZooGiftShop {
2:    interface SaleTodayOnly {
3:      int dollarsOff();
4:    }
5:    public int admission(int basePrice) {
6:       SaleTodayOnly sale = new SaleTodayOnly() {
7:          public int dollarsOff() { return 3; }
8:       };
9:       return basePrice - sale.dollarsOff();
10: } }
```

Самое интересное здесь то, как мало что изменилось. Строки 2–4 объявляют interface вместо abstract класса. Строка 7 
является public, а не использует доступ по умолчанию, поскольку интерфейсы требуют public методов. И это 
все. Анонимный класс один и тот же, реализуете ли вы интерфейс или расширяете класс! Java автоматически определяет, 
какой из них вам нужен. Просто помните, что во втором примере в строке 6 создается экземпляр класса, а не интерфейс.

Но что, если мы хотим одновременно реализовать interface и расширить класс? Вы не можете сделать это с анонимным 
классом, если класс для расширения не является java.lang.Object. Класс Object не учитывается в правиле. Помните, что 
анонимный класс — это просто безымянный локальный класс. Вы можете написать локальный класс и дать ему имя, если у вас 
есть эта проблема. Затем вы можете расширить класс и реализовать столько интерфейсов, сколько захотите. Если ваш код 
настолько сложен, локальный класс, вероятно, не самый читаемый вариант.

Вы даже можете определить анонимные классы вне тела метода. Следующее может выглядеть так, как будто мы создаем 
интерфейс как переменную экземпляра, но {} после имени интерфейса указывает, что это анонимный класс, реализующий 
интерфейс:

```
public class Gorilla {
   interface Climb {}
   Climb climbing = new Climb() {};
}
```

---

**Анонимные классы и лямбда-выражения**

До Java 8 анонимные классы часто использовались для асинхронных задач и обработчиков событий. Например, ниже показан 
анонимный класс, используемый в качестве обработчика событий в приложении JavaFX:

```
var redButton = new Button();
redButton.setOnAction(new EventHandler<ActionEvent>() {
   public void handle(ActionEvent e) {
      System.out.println("Red button pressed!");
   }
});
```

С момента появления лямбда-выражений анонимные классы теперь часто заменяются гораздо более короткими реализациями:

```
Button redButton = new Button();
redButton.setOnAction(e -> System.out.println("Red button pressed!"));
```

Мы подробно рассмотрим лямбда-выражения в следующей главе.

---

### Просмотр вложенных классов

Для экзамена убедитесь, что вы знаете информацию из таблицы 7.4 о том, какие правила синтаксиса разрешены в Java.

#### Таблица 7.4 - Модификаторы во вложенных классах

| Разрешенные модификаторы | Внутренний класс | static вложенный класс | Локальный класс | Анонимный класс |  
|:------------------------:|:----------------:|:----------------------:|:---------------:|:---------------:|
|   Модификаторы доступа   |       Все        |          Все           |   отсутствуют   |   отсутствуют   |
|         abstract         |        Да        |           Да           |       Да        |       Нет       |                                     
|          final           |        Да        |           Да           |       Да        |       Нет       |

Вы также должны знать информацию в таблице 7.5 о типах доступа. Например, экзамен может попытаться обмануть вас, 
предоставив статическому классу доступ к переменной экземпляра внешнего класса без ссылки на внешний класс.

#### Таблица 7.5 - Правила доступа к вложенным классам

|                                                                          |  Внутренний класс  | static вложенный класс |                            Локальный класс                             |                      Анонимный класс                       |  
|:------------------------------------------------------------------------:|:------------------:|:----------------------:|:----------------------------------------------------------------------:|:----------------------------------------------------------:|
| Можно расширить класс или реализовать<br/> любое количество интерфейсов? |         Да         |           Да           |                                   Да                                   | Нет — должен быть ровно один суперкласс или один интерфейс |
|  Может ли получить доступ к членам <br/> экземпляра окружающего класса?  |         Да         |          Нет           |                Да (если объявлено в методе экземпляра)                 |          Да (если объявлено в методе экземпляра)           |                                     
| Может ли получить доступ к локальным<br/>  переменным метода включения?  | данные отсутствуют |  данные отсутствуют    |                  Да (Если final или эффективно final)                  |            Да (Если final или эффективно final)            |

## Понимание полиморфизма

Мы завершаем эту главу обсуждением полиморфизма, свойства объекта принимать различные формы. Точнее говоря, к объекту 
Java можно получить доступ, используя:

+ Ссылка того же типа, что и объект
+ Ссылка, которая является суперклассом объекта
+ Ссылка, определяющая интерфейс, который объект реализует или наследует

Кроме того, приведение не требуется, если объект переназначается супертипу или интерфейсу объекта. Фу, это много! Не 
волнуйся; вскоре это будет иметь смысл.

Давайте проиллюстрируем это свойство полиморфизма на следующем примере:

```
public class Primate {
   public boolean hasHair() {
      return true;
   }
}

public interface HasTail {
   public abstract boolean isTailStriped();
}

public class Lemur extends Primate implements HasTail {
   public boolean isTailStriped() {
      return false;
   }
   public int age = 10;
   public static void main(String[] args) {
      Lemur lemur = new Lemur();
      System.out.println(lemur.age);
      
     HasTail hasTail = lemur;
     System.out.println(hasTail.isTailStriped());
     
     Primate primate = lemur;
     System.out.println(primate.hasHair());
} }
```

Этот код компилирует и печатает следующий вывод:

```
10
false
true
```

Самое важное, что следует отметить в этом примере, это то, что создается только один объект, Lemur. Полиморфизм 
позволяет переназначить экземпляр Lemur или передать его методу, использующему один из его супертипов, например 
Primate или HasTail.

После того как объект был назначен новому ссылочному типу, только методы и переменные, доступные для этого ссылочного 
типа, могут быть вызваны для объекта без явного приведения. Например, следующие фрагменты кода не будут 
компилироваться:

```
HasTail hasTail = new Lemur();
System.out.println(hasTail.age);              // DOES NOT COMPILE

Primate primate = new Lemur();
System.out.println(primate.isTailStriped());  // DOES NOT COMPILE
```

В этом примере ссылка hasTail имеет прямой доступ только к методам, определенным с интерфейсом HasTail; следовательно, 
он не знает, что переменная age является частью объекта. Точно так же ссылочный primate имеет доступ только к методам, 
определенным в классе Primate, и не имеет прямого доступа к методу isTailStriped().

### Объект против Ссылки

В Java доступ ко всем объектам осуществляется по ссылке, поэтому как разработчик вы никогда не имеете прямого доступа к 
самому объекту. Концептуально, однако, вы должны рассматривать объект как объект, который существует в памяти, 
выделенной средой выполнения Java. Независимо от типа ссылки на объект в памяти, сам объект не меняется. Например, 
поскольку все объекты наследуют java.lang.Object, все они могут быть переназначены java.lang.Object, как показано в 
следующем примере:

```
Lemur lemur = new Lemur();
Object lemurAsObject = lemur;
```

Несмотря на то, что объекту Lemur присвоена ссылка другого типа, сам объект не изменился и по-прежнему существует в 
памяти как объект Lemur. Что изменилось, так это наша возможность доступа к методам в классе Lemur с помощью ссылки 
lemurAsObject. Без явного приведения к Lemur, как вы увидите в следующем разделе, у нас больше нет доступа к свойствам 
Lemur объекта.

Мы можем обобщить этот принцип с помощью следующих двух правил:

1. Тип объекта определяет, какие свойства существуют внутри объекта в памяти.
2. Тип ссылки на объект определяет, какие методы и переменные доступны программе на Java.

Из этого следует, что успешное изменение ссылки объекта на новый тип ссылки может дать вам доступ к новым свойствам 
объекта; но помните, что эти свойства существовали до того, как произошло изменение ссылки.

Используя пример Lemur, мы проиллюстрируем это свойство на рис. 7.8.

#### Рис. 7.8 - Объект против Ссылки


Как видно на рисунке, один и тот же объект существует в памяти независимо от того, какая ссылка на него указывает. В 
зависимости от типа ссылки у нас может быть доступ только к определенным методам. Например, ссылка hasTail имеет доступ 
к методу isTailStriped(), но не имеет доступа к переменной age, определенной в классе Lemur. Как вы узнаете из 
следующего раздела, можно восстановить доступ к переменной age, явно приведя ссылку hasTail к ссылке типа Lemur.

**Использование ссылок интерфейса**

_При работе с группой объектов, реализующих общий интерфейс, считается хорошей практикой кодирования использовать 
интерфейс в качестве ссылочного типа. Это особенно характерно для коллекций, о которых вы узнаете из главы 9 «Коллекции 
и обобщения». Рассмотрим следующий метод:_

```
public void sortAndPrintZooAnimals(List<String> animals) {
   Collections.sort(animals);
   for(String a : animals) System.out.println(a);
}
```

_Этот метод сортирует и печатает animals в алфавитном порядке. Ни в коем случае этот класс не интересуется тем, что 
является реальным базовым объектом для animals. Это может быть ArrayList или другой тип. Дело в том, что наш код 
работает с любым из этих типов, потому что мы использовали ссылочный тип интерфейса, а не тип класса._

### Кастинг/приведение объектов

В предыдущем примере мы создали один экземпляр объекта Lemur и получили к нему доступ через ссылки на суперкласс и 
интерфейс. Однако как только мы изменили ссылочный тип, мы потеряли доступ к более конкретным членам, определенным в 
подклассе, которые все еще существуют в объекте. Мы можем восстановить эти ссылки, вернув объект обратно к конкретному 
подклассу, из которого он был получен:

```
Lemur lemur = new Lemur();

Primate primate = lemur; // Implicit Cast to supertype

Lemur lemur2 = (Lemur)primate; // Explicit Cast to subtype

Lemur lemur3 = primate; // DOES NOT COMPILE (missing cast)
```

В этом примере мы сначала создаем объект Lemur и неявно приводим его к ссылке Primate. Поскольку Lemur является подтипом
Primate, это можно сделать без оператора приведения. Затем мы приводим его обратно к объекту Lemur, используя явное 
приведение, получая доступ ко всем методам и полям в классе Lemur. Последняя строка не компилируется, так как требуется 
явное приведение типов. Несмотря на то, что объект хранится в памяти как объект Lemur, нам нужно явное приведение, 
чтобы присвоить его Lemur.

Приведение объектов похоже на приведение примитивов, как вы видели в главе 2, «Операторы». При приведении объектов вам 
не нужен оператор приведения, если вы выполняете приведение к унаследованному супертипу.
Это называется неявным приведением и применяется к классам или интерфейсам, которые наследует объект. В качестве 
альтернативы, если вы хотите получить доступ к подтипу текущей ссылки, вам необходимо выполнить явное приведение к 
совместимому типу. Если базовый объект несовместим с типом, во время выполнения будет выдано исключение 
ClassCastException.

При рассмотрении вопроса на экзамене, связанного с приведением типов и полиморфизмом, обязательно помните, что на самом 
деле представляет собой экземпляр объекта. Затем сосредоточьтесь на том, позволит ли компилятор ссылаться на объект с 
явным приведением или без него.

Мы обобщаем эти понятия в набор правил, которые вы должны запомнить для экзамена:

1. Приведение ссылки из подтипа в супертип не требует явного приведения.
2. Приведение ссылки из супертипа к подтипу требует явного приведения.
3. Во время выполнения недопустимое приведение ссылки к несовместимому типу приводит к возникновению ClassCastException.
4. Компилятор запрещает приведение к несвязанным типам.

### Запрещенные трансляции

Первые три правила — это всего лишь обзор того, что мы уже сказали. Последнее правило немного сложнее. Экзамен может 
попытаться обмануть вас с помощью приведения типов, которые, как известно компилятору, не разрешены (т. е. невозможны). 
В предыдущем примере мы смогли привести ссылку Primate к ссылке Lemur, потому что Lemur является подклассом Primate и, 
следовательно, связан. Вместо этого рассмотрим этот пример:

```
public class Bird {}

public class Fish {
   public static void main(String[] args) {
      Fish fish = new Fish();
      Bird bird = (Bird)fish;  // DOES NOT COMPILE
   }
}
```

В этом примере классы Fish и Bird не связаны через какую-либо иерархию классов, о которой знает компилятор; поэтому код 
не будет компилироваться. Хотя они оба неявно расширяют Object, они считаются несвязанными типами, поскольку один не 
может быть подтипом другого.

### Кастинг/приведение интерфейсов

Хотя компилятор может применять правила приведения к несвязанным типам для классов, он не всегда может сделать то же 
самое для интерфейсов. Помните, что экземпляры поддерживают множественное наследование, что ограничивает возможности 
компилятора в отношении них. Хотя данный класс может не реализовывать интерфейс, возможно, что какой-то подкласс может 
реализовать этот интерфейс. При хранении ссылки на конкретный класс компилятор не знает, какой конкретный подтип он 
содержит.

Попробуем на примере. Как вы думаете, компилируется ли следующая программа?

```
1: interface Canine {}
2: interface Dog {}
3: class Wolf implements Canine {}
4:
5: public class BadCasts {
6:    public static void main(String[] args) {
7:       Wolf wolfy = new Wolf();
8:       Dog badWolf = (Dog)wolfy;
9: } }
```

В этой программе создается объект Wolf, который затем назначается ссылочному типу Wolf в строке 7. С интерфейсами 
компилятор имеет ограниченные возможности для применения многих правил, потому что даже если ссылочный тип может не 
реализовывать интерфейс, один из его подклассов может. Таким образом, допускается недопустимое приведение к ссылочному 
типу Dog в строке 8, даже если Dog и Wolf не связаны между собой. Не бойтесь, даже если код компилируется, во время 
выполнения он все равно генерирует исключение ClassCastException.

Помимо этого ограничения, компилятор может применить одно правило в отношении приведения интерфейсов. Компилятор не 
допускает приведения ссылки на интерфейс к ссылке на объект, если тип объекта не может реализовать интерфейс, например, 
если класс помечен как final. Например, если интерфейс Wolf помечен как final в строке 3, то строка 8 больше не 
компилируется. Компилятор распознает отсутствие возможных подклассов Wolf, способных реализовать интерфейс Dog.

### Оператор instanceof

В главе 3 мы представили оператор instanceof с сопоставлением с образцом. Оператор instanceof можно использовать для 
проверки принадлежности объекта к определенному классу или интерфейсу, а также для предотвращения возникновения 
ClassCastException во время выполнения. Рассмотрим следующий пример:

```
1: class Rodent {}
2:
3: public class Capybara extends Rodent {
4:    public static void main(String[] args) {
5:       Rodent rodent = new Rodent();
6:       var capybara = (Capybara)rodent;    // ClassCastException
7:    }
8: }
```

Эта программа выдает исключение в строке 6. Мы можем заменить строку 6 на следующую.

```
6:   if(rodent instanceof Capybara c) {
7:      // Do stuff
8:    }
```

Теперь фрагмент кода не генерирует исключение во время выполнения и выполняет приведение только в случае успешного 
выполнения оператора instanceof.

Точно так же, как компилятор не позволяет приводить объект к несвязанным типам, он также не позволяет использовать 
instanceof с несвязанными типами. Мы можем продемонстрировать это с помощью наших несвязанных классов Bird и Fish:

```
public class Bird {}

public class Fish {
   public static void main(String[] args) {
      Fish fish = new Fish();
      if (fish instanceof Bird b) {  // DOES NOT COMPILE
         // Do stuff
      }
   }
}
```

### Полиморфизм и переопределение методов

В Java полиморфизм утверждает, что когда вы переопределяете метод, вы заменяете все его вызовы, даже те, которые 
определены в родительском классе. Например, как вы думаете, что выводит следующий фрагмент кода?

```
class Penguin {
   public int getHeight() { return 3; }
   public void printInfo() {
      System.out.print(this.getHeight());
   }
}

public class EmperorPenguin extends Penguin {
   public int getHeight() { return 8; }
   public static void main(String []fish) {
      new EmperorPenguin().printInfo();
   }
}
```

Если вы сказали 8, то вы уже на пути к пониманию полиморфизма. В этом примере объектом, над которым выполняются 
операции в памяти, является EmperorPenguin. Метод getHeight() переопределен в подклассе, что означает, что все вызовы к 
нему заменяются во время выполнения. Несмотря на то, что printInfo() определена в классе Penguin, вызов getHeight() для 
объекта вызывает метод, связанный с конкретным объектом в памяти, а не с текущим ссылочным типом, в котором он 
вызывается. Даже использование ссылки this, которая в этом примере является необязательной, не вызывает родительскую 
версию, поскольку метод был заменен.

_Способность полиморфизма заменять методы во время выполнения посредством переопределения — одно из наиболее важных 
свойств Java._ Он позволяет создавать сложные модели наследования с подклассами, которые имеют собственную реализацию 
переопределенных методов. Это также означает, что родительский класс не нужно обновлять для использования 
пользовательского или переопределенного метода. Если метод правильно переопределен, то переопределенная версия будет 
использоваться во всех местах, где он вызывается.

Помните, что вы можете ограничить полиморфное поведение, пометив методы как final, что предотвратит их переопределение 
подклассом.

**Вызов родительской версии переопределенного метода**

Тот факт, что метод переопределен, не означает, что родительский метод полностью недоступен. Мы можем использовать 
суперссылку, о которой вы узнали в главе 6, чтобы получить к ней доступ. Как можно изменить наш предыдущий пример, 
чтобы напечатать 3 вместо 8? Вы можете попробовать вызвать super.getHeight() в родительском классе Penguin:

```
class Penguin {
   public int getHeight() { return 3; }
   public void printInfo() {
      System.out.print(super.getHeight()); // DOES NOT COMPILE
   }
}
```

К сожалению, это не компилируется, так как super относится к суперклассу Penguin; в данном случае Object. Решение 
состоит в том, чтобы переопределить printInfo() в дочернем классе EmperorPenguin и использовать там super.

```
public class EmperorPenguin extends Penguin {
   public int getHeight() { return 8; }
   public void printInfo() {
      System.out.print(super.getHeight());
   }
   public static void main(String []fish) {
      new EmperorPenguin().printInfo();    // 3
   }
}
```

### Переопределение и сокрытие членов (Overriding vs. Hiding Members)

В то время как переопределение метода заменяет метод везде, где он вызывается, static метод и скрытие переменных — нет. 
Строго говоря, скрытие элементов не является формой полиморфизма, поскольку методы и переменные сохраняют свои 
индивидуальные свойства. В отличие от переопределения метода, скрытие членов очень чувствительно к типу ссылки и 
местоположению, где используется член.

Давайте посмотрим на пример:

```
class Penguin {
   public static int getHeight() { return 3; }
   public void printInfo() {
      System.out.println(this.getHeight());
   }
}

public class CrestedPenguin extends Penguin {
   public static int getHeight() { return 8; }
   public static void main(String... fish) {
      new CrestedPenguin().printInfo();
   }
}
```

Пример CrestedPenguin почти идентичен нашему предыдущему примеру EmperorPenguin, хотя, как вы, наверное, уже догадались, 
он печатает 3 вместо 8. Метод getHeight() является static и поэтому скрыт, а не переопределен. В результате вызов 
getHeight() в CrestedPenguin возвращает другое значение, чем вызов в Penguin, даже если базовый объект тот же. 
Сравните это с переопределением метода, когда он возвращает одно и то же значение для объекта независимо от того, в 
каком классе он вызывается.

А как насчет того, что мы использовали this для доступа к static методу в this.getHeight()? Как обсуждалось в главе 5, 
хотя вам разрешено использовать ссылку на экземпляр для доступа к static переменной или методу, делать это часто не 
рекомендуется. Компилятор предупредит вас, когда вы получите доступ к static членам нестатическим способом. В этом 
случае эта ссылка не повлияла на вывод программы.

Помимо расположения, тип ссылки также может определять значение, которое вы получаете при работе со скрытыми элементами. 
Готовый? Давайте попробуем более сложный пример:

```
class Marsupial {
   protected int age = 2;
   public static boolean isBiped() {
      return false;
   } }

public class Kangaroo extends Marsupial {
   protected int age = 6;
   public static boolean isBiped() {
      return true;
   }

public static void main(String[] args) {
   Kangaroo joey = new Kangaroo();
   Marsupial moey = joey;
   System.out.println(joey.isBiped());
   System.out.println(moey.isBiped());
   System.out.println(joey.age);
   System.out.println(moey.age);
} }
```

Программа печатает следующее:

```
true
false
6
2
```

В этом примере создается и сохраняется в памяти только один объект (типа Kangaroo)! Поскольку static методы можно 
только скрыть, но не переопределить, Java использует ссылочный тип, чтобы определить, какую версию isBiped() следует
вызывать, в результате чего joey.isBiped() выводит true, а moey.isBiped() выводит false.

Точно так же переменная age скрыта, а не переопределена, поэтому ссылочный тип используется для определения того, какое 
значение выводить. Это приводит к тому, что joey.age возвращает 6, а moey.age возвращает 2.

Перед экзаменом убедитесь, что вы понимаете эти примеры, так как они показывают, насколько принципиально различаются 
скрытые и переопределенные методы. На практике переопределение методов является краеугольным камнем полиморфизма и 
чрезвычайно мощной функцией.

**Не скрывайте членов на практике**

_Хотя Java позволяет скрывать переменные и static методы, это считается крайне плохой практикой кодирования. Как вы 
видели в предыдущем примере, значение переменной или метода может меняться в зависимости от того, какая ссылка 
используется, что делает ваш код очень запутанным, трудным для понимания и сложным для сопровождения другими. Это еще 
больше усугубляется, когда вы начинаете изменять значение переменной как в родительском, так и в дочернем методе, 
поскольку может быть неясно, какую переменную вы обновляете._

_Когда вы определяете новую переменную или static метод в дочернем классе, хорошей практикой кодирования считается выбор 
имени, которое еще не используется унаследованным членом. Однако повторное объявление private методов и переменных 
считается менее проблематичным, поскольку дочерний класс изначально не имеет доступа к переменной в родительском классе._

## Резюме

В этой главе мы представили многочисленные темы расширенного объектно-ориентированного проектирования, охватывающие 
многие типы верхнего уровня, помимо классов. Мы начали с интерфейсов и описали, как они могут поддерживать множественное
наследование. Помните, что интерфейсы и их элементы могут включать ряд неявных модификаторов, вставляемых компилятором 
автоматически. Затем мы рассмотрели все шесть типов элементов интерфейса, которые вам необходимо знать для экзамена: 
abstract методы, static константы, default методы, static методы, private методы и private static методы.

Затем мы перешли к перечислениям, которые являются постоянными свойствами времени компиляции. Простые перечисления 
состоят из списка значений, а сложные перечисления могут включать конструкторы, методы и поля. Перечисления также можно 
использовать в операторах и выражениях switch. Когда метод перечисления помечен как abstract, каждое значение 
перечисления должно обеспечивать реализацию.

Переходя к новым темам в Java, мы рассмотрели запечатанные классы и то, как они позволяют классам функционировать как 
перечисляемые типы, в которых разрешены только определенные подклассы. Для экзамена важно помнить, что подклассы 
запечатанного класса должны быть помечены как final, sealed или незапечатанные. Если подклассы запечатанного класса 
определены в одном и том же файле, то в объявлении permits класса может быть опущено предложение с разрешениями. 
Наконец, запечатанные интерфейсы могут использоваться для ограничения того, какие классы могут реализовывать интерфейс, 
какие интерфейсы могут расширять интерфейс или и то, и другое.

Записи — еще одна новая функция, доступная в Java. Записи — это компактный способ объявления неизменяемого и 
инкапсулированного POJO, в который компилятор добавляет за вас много стандартного кода. Помните, что инкапсуляция — это 
практика предотвращения доступа внешних вызывающих объектов к внутренним компонентам объекта. Записи включают 
автоматическое создание методов доступа, длинный конструктор и полезные реализации equals(), hashCode() и toString(). 
Записи могут включать перегруженные и компактные конструкторы для поддержки проверки и преобразования данных. Записи не 
допускают переменных экземпляров, так как это может нарушить неизменяемость, но разрешают методы, static члены и 
вложенные типы.

Затем мы перешли к вложенным типам. Для простоты мы сосредоточились на вложенных классах и рассмотрели каждый из 
четырех типов. Внутренний класс требует использования экземпляра внешнего класса, а static вложенный класс — нет. 
Локальный класс обычно определяется внутри метода или блока. Локальные классы могут обращаться только к локальным 
переменным, которые являются final и фактически окончательными. Анонимные классы — это особый тип локального класса, у 
которого нет имени. Анонимные классы необходимы для расширения ровно одного класса или реализации одного интерфейса. 
Внутренние, локальные и анонимные классы могут обращаться к private членам класса, в котором они определены, при 
условии, что последние два используются внутри метода экземпляра.

Мы завершили эту главу обсуждением полиморфизма, занимающего центральное место в языке Java, и показали, как можно 
получить доступ к объектам в различных формах. Убедитесь, что вы понимаете, когда приведения необходимы для доступа к 
объектам, и сможете определить разницу между проблемами приведения во время компиляции и во время выполнения.

## Основы экзамена

**Уметь писать код, который создает, расширяет и реализует интерфейсы.** Интерфейсы — это специализированные абстрактные
типы, ориентированные на абстрактные методы и постоянные переменные. Интерфейс может расширять любое количество 
интерфейсов и при этом наследовать их абстрактные методы. Интерфейс не может расширять класс, а класс не может расширять
интерфейс. Класс может реализовывать любое количество интерфейсов.

**Знайте, на какие методы интерфейса может ссылаться метод интерфейса.** Нестатические private методы, default методы 
и abstract методы интерфейса связаны с экземпляром интерфейса. Нестатические private методы и default методы интерфейса 
могут ссылаться на любой метод в объявлении интерфейса. Кроме того, static методы интерфейса связаны с членством в 
классе и могут ссылаться только на другие static члены. Наконец, на private методы можно ссылаться только в объявлении 
интерфейса.

**Уметь создавать и использовать типы enum.** Перечисление — это структура данных, определяющая список значений. Если 
перечисление не содержит других элементов, точка с запятой (;) после значений необязательна. Перечисление может 
использоваться в операторах switch и содержать переменные экземпляра, конструкторы и методы. Конструкторы Enum неявно 
private. Перечисления могут включать методы как в качестве членов, так и в пределах отдельных значений перечисления. 
Если перечисление объявляет abstract метод, каждое значение перечисления должно его реализовывать.

**Уметь распознавать правильное использование закрытых классов.** Закрытый класс — это класс, который определяет список 
разрешенных подклассов, которые его расширяют. Уметь использовать правильный модификатор (final, sealed, или non-sealed) 
с запечатанными классами. Поймите, когда пункт о permits может быть исключен.

**Определите правильно инкапсулированные классы.** Переменные экземпляра в инкапсулированных классах являются private. 
Весь код, который извлекает значение или обновляет его, использует методы. Инкапсулированные классы могут включать 
методы доступа (геттеры) или мутаторы (сеттеры), хотя это не обязательно.

**Понимать записи и знать, какие элементы компилятор добавляет автоматически.** Записи представляют собой 
инкапсулированные и неизменяемые типы, в которые компилятор вставляет длинный конструктор, методы доступа и полезные 
реализации equals(), hashCode() и toString(). Каждый из этих элементов может быть переопределен. Уметь распознавать 
компактные конструкторы и знать, что они используются только для проверки и преобразования параметров конструктора, а не
для доступа к полям. Учтите, что когда запись объявляется с членом-экземпляром, она не компилируется.

**Уметь объявлять и использовать вложенные классы.** Существует четыре типа вложенных типов: внутренние классы, static 
классы, локальные классы и анонимные классы. Для создания внутреннего класса требуется экземпляр внешнего класса. С 
другой стороны, static вложенные классы можно создавать без ссылки на внешний класс. Локальные и анонимные классы не 
могут быть объявлены с модификатором доступа. Анонимные классы ограничены расширением одного класса или реализацией 
одного интерфейса.

**Понимание полиморфизма.** Объект может принимать различные формы, называемые полиморфизмом.
Объект рассматривается как существующий в памяти в одной конкретной форме, но доступный во многих формах через 
ссылочные переменные. Изменение ссылочного типа объекта может предоставить доступ к новым членам, но эти члены всегда 
существуют в памяти.








