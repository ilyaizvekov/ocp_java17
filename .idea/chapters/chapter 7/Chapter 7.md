# За пределами классов

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Объявляйте и создавайте экземпляры объектов Java, включая объекты вложенного класса, и объясняйте жизненный цикл 
объекта, включая создание, переназначение ссылок и сборку мусора
+ Создавайте классы и записи, а также определяйте и используйте экземпляры и статические поля и методы, конструкторы, а 
также экземпляры и статические инициализаторы
+ Понимайте области видимости переменных, используйте вывод типа локальной переменной, применяйте инкапсуляцию и 
делайте объекты неизменяемыми
+ Реализуйте полиморфизм и отличайте тип объекта от ссылочного типа. Выполняйте приведение типов, идентифицируйте типы 
объектов с помощью оператора instanceof и сопоставления с образцом
+ Создавайте и используйте интерфейсы, определяйте функциональные интерфейсы и используйте частные, статические методы 
интерфейса и методы интерфейса по умолчанию
+ Создавайте и используйте перечисления с полями, методами и конструкторами

---

В главе 6 «Проектирование классов» мы показали, как создавать, инициализировать и расширять как абстрактные, так и 
конкретные классы. В этой главе мы переходим от классов к другим типам, доступным в Java, включая интерфейсы, 
перечисления, закрытые классы и записи. Многие из основных правил, о которых вы узнали в главе 5 «Методы», по-прежнему 
применяются, например, модификаторы доступа и статические члены, хотя для каждого типа существуют дополнительные 
правила. Мы также рассмотрим инкапсуляцию и то, как правильно защитить элементы экземпляра. Наконец, мы завершаем эту 
главу обсуждением вложенных типов и полиморфного наследования.

В этой главе помните, что файл Java может иметь не более одного общедоступного типа верхнего уровня, и он должен 
совпадать с именем файла. Это относится к классам, перечислениям, записям и так далее. Кроме того, помните, что тип 
верхнего уровня может быть объявлен только с общедоступным доступом или доступом к пакету.

---

Другим типом верхнего уровня, доступным в Java, являются аннотации. Знание того, как создавать пользовательские 
аннотации, может быть полезным навыком на практике, хотя это и не требуется для сдачи экзамена. Вы все равно должны 
знать, как использовать определенные аннотации для экзамена, такие как @Override.

---

## Реализация интерфейсов

В главе 6 вы узнали об абстрактных классах, в частности о том, как их создавать и расширять. Поскольку классы могут 
расширять только один класс, они имели ограниченное применение для наследования. С другой стороны, класс может 
реализовывать любое количество интерфейсов. Интерфейс - это абстрактный тип данных, который объявляет список 
абстрактных методов, которые должен предоставлять любой класс, реализующий интерфейс.

Со временем точное определение интерфейса изменилось, поскольку теперь поддерживаются новые типы методов. В этой главе 
мы начнем с элементарного определения интерфейса и расширим его, чтобы охватить все поддерживаемые элементы.

### Объявление и использование интерфейса

В Java интерфейс определяется с помощью ключевого слова interface, аналогичного ключевому слову class, используемому при
определении класса. См. рис. 7.1 для правильного объявление интерфейса.


#### Рис. 7.1 - Определение интерфейса

На рис. 7.1 объявление нашего интерфейса включает абстрактный метод и постоянную переменную. Переменные интерфейса 
называются константами, поскольку предполагается, что они public, static и final. Они 
инициализируются постоянным значением при объявлении. Поскольку они являются public и static, их можно 
использовать вне объявления интерфейса, не требуя экземпляра интерфейса. Рисунок 7.1 также включает абстрактный метод, 
который, как и переменная интерфейса, считается public.

_Для краткости мы часто используем фразу “экземпляр интерфейса” в этой главе имею в виду экземпляр класса, который 
реализует интерфейс._

Что это значит для переменной или метода, чтобы считаться чем-то? Один аспект объявления интерфейса, который отличается 
от абстрактного класса, состоит в том, что он содержит неявные модификаторы. Неявное модификатор-модификатор, который 
компилятор автоматически вставляет в код. Например, интерфейс, всегда считается абстрактным, даже если он не отмечен 
таким образом. Вскоре мы рассмотрим правила и примеры неявных модификаторов более подробно.

Начнем с простого примера. Представьте, что у нас есть интерфейс WalksOnTwoLegs, определенный следующим образом:

```
public abstract interface WalksOnTwoLegs {}
```

Он компилируется, потому что интерфейсы не требуются для определения каких-либо методов. Модификатор abstract в этом 
примере является необязательным для интерфейсов, и компилятор вставляет его, если он не указан. Теперь рассмотрим 
следующие два примера, которые не компилируются:

```
public class Biped {
   public static void main(String[] args) {
      var e = new WalksOnTwoLegs();         // DOES NOT COMPILE
   }
}

public final interface WalksOnEightLegs {}  // DOES NOT COMPILE
```

Первый пример не компилируется, так как WalksOnTwoLegs является интерфейсом и не может быть создан. Второй пример, 
WalksOnEightLegs, не компилируется, потому что интерфейсы не могут быть помечены как final по той же причине, по которой
abstract классы не могут быть помечены как final. Другими словами, пометка интерфейса как final подразумевает, что ни 
один класс не сможет его реализовать.

Как вы используете интерфейс? Допустим, у нас есть интерфейс Climb, определенный следующим образом:

```
public interface Climb {
   Number getSpeed(int age);
}
```

Затем у нас есть конкретный класс FieldMouse, который вызывает интерфейс Climb, используя ключевое слово implements в 
объявлении своего класса, как показано на рис. 7.2.

#### Рис. 7.2 - Реализации интерфейса

Класс FieldMouse объявляет, что он реализует интерфейс Climb и включает переопределенную версию getSpeed(), 
унаследованную от интерфейса Climb. Сигнатура метода getSpeed() точно совпадает, а возвращаемый тип является 
ковариантным, поскольку Float может быть неявно приведен к Number. Модификатор доступа метода интерфейса неявно public в
Climb, хотя конкретный класс FieldMouse должен явно объявить его.

Как показано на рис. 7.2, класс может реализовывать несколько интерфейсов, разделенных запятой (,). Если какой-либо из 
интерфейсов определяет abstract методы, то для их переопределения требуется конкретный класс. В этом случае FieldMouse 
реализует интерфейс CanBurrow, который мы видели на рис. 7.1. Таким образом, класс переопределяет два абстрактных метода
одновременно с одним объявлением метода. В этой главе вы узнаете больше о повторяющихся и совместимых методах 
интерфейса.

### Расширение интерфейса

Как и класс, интерфейс может расширять другой интерфейс с помощью ключевого слова extends.

```
public interface Nocturnal {}

public interface HasBigEyes extends Nocturnal {}
```

В отличие от класса, который может расширять только один класс, интерфейс может расширять несколько интерфейсов.

```
public interface Nocturnal {
   public int hunt();
}

public interface CanFly {
   public void flap();
}

public interface HasBigEyes extends Nocturnal, CanFly {}

public class Owl implements HasBigEyes {
   public int hunt() { return 5; }
   public void flap() { System.out.println("Flap!"); }
}
```

В этом примере класс Owl реализует интерфейс HasBigEyes и должен реализовывать методы hunt() и flap(). Расширение двух 
интерфейсов разрешено, поскольку интерфейсы не инициализируются как часть иерархии классов. В отличие от абстрактных 
классов, они не содержат конструкторов и не являются частью инициализации экземпляра. Интерфейсы просто определяют набор
правил и методов, которым должен следовать реализующий их класс.

### Наследование интерфейса

Как и в случае с абстрактным классом, когда конкретный класс наследует интерфейс, должны быть реализованы все 
унаследованные абстрактные методы. Мы иллюстрируем этот принцип на рис. 7.3. Сколько абстрактных методов наследует 
конкретный класс Swan?

#### Рис. 7.3 - Наследование интерфейса


Сдаться? Конкретный класс Swan наследует четыре абстрактных метода, которые он должен реализовать: getType(), 
canSwoop(), fly() и swim(). Давайте взглянем на другой пример с абстрактным классом, реализующим интерфейс:

```
public interface HasTail {
   public int getTailLength();
}

public interface HasWhiskers {
   public int getNumberOfWhiskers();
}

public abstract class HarborSeal implements HasTail, HasWhiskers {}

public class CommonSeal extends HarborSeal {}    // DOES NOT COMPILE
```

Класс HarborSeal компилируется, поскольку он является abstract и не требует реализации каких-либо abstract методов, 
которые он наследует. Однако конкретный класс CommonSeal должен переопределять все унаследованные abstract методы.

#### Mixing Class and Interface Keywords
