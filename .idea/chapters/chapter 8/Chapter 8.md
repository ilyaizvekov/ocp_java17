# Лямбды и Функциональные интерфейсы

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Понимать области действия переменных, использовать вывод типа локальной переменной, применять инкапсуляцию и делать 
объекты неизменяемыми.
+ Создание и использование интерфейсов, определение функциональных интерфейсов и использование частных, статических 
методов и методов интерфейса по умолчанию.

---

В этой главе мы начнем с представления лямбда-выражений, нового элемента синтаксиса. Лямбда-выражения позволяют указать 
код, который будет выполняться позже в программе.

Далее мы вводим понятие функциональных интерфейсов, показывая, как написать свой собственный и определить, является ли 
интерфейс функциональным интерфейсом. После этого мы вводим еще одну новую часть синтаксиса: ссылки на методы. Это 
похоже на более короткую форму лямбда.

Затем мы познакомим вас с функциональными интерфейсами, которые вам нужно знать для экзамена. Наконец, мы подчеркиваем, 
как переменные вписываются в лямбда-выражения.

Лямбда-выражения, ссылки на методы и функциональные интерфейсы довольно часто используются в главе 9 «Коллекции и 
обобщения» и главе 10 «Потоки».

## Написание простых лямбда-выражений

В основе Java лежит объектно-ориентированный язык. Вы уже видели множество объектов. Функциональное программирование — 
это более декларативный способ написания кода. Вы указываете, что вы хотите сделать, а не имеете дело с состоянием 
объектов. Вы больше фокусируетесь на выражениях, чем на циклах.

Функциональное программирование использует лямбда-выражения для написания кода. Лямбда-выражение — это блок кода, 
который передается. Вы можете думать о лямбда-выражении как о безымянном методе, существующем внутри анонимного класса, 
подобных тем, которые вы видели в главе 7 «За пределами классов». У него есть параметры и тело, как и у полноценных 
методов, но у него нет имени, как у настоящего метода. Лямбда-выражения часто для краткости называют лямбда-выражениями. 
Вы также можете знать их как замыкания, если Java не является вашим родным языком. Если у вас был неудачный опыт 
закрытия в прошлом, не волнуйтесь. В Java они намного проще.

Лямбда-выражения позволяют писать мощный код на Java. В этом разделе мы рассмотрим пример того, почему лямбда-выражения 
полезны, и синтаксис лямбда-выражений.

### Смотрим на пример Лямбда-выражений

Наша цель — распечатать список всех животных по некоторым критериям. Мы покажем вам, как это сделать без 
лямбда-выражений, чтобы проиллюстрировать, насколько полезны лямбда-выражения. Начнем с записи Animal:

```
public record Animal(String species, boolean canHop, boolean canSwim) { }
```

Запись Animal имеет три поля. Допустим, у нас есть список животных, и мы хотим обработать данные на основе определенного
атрибута. Например, мы хотим вывести всех животных, которые могут прыгать. Мы можем определить интерфейс, чтобы обобщить
эту концепцию и поддерживать большое количество проверок:

```
public interface CheckTrait {
   boolean test(Animal a);
}
```

Первое, что мы хотим проверить, это может ли Animal прыгать. Мы предоставляем класс, который реализует наш интерфейс:

```
public class CheckIfHopper implements CheckTrait {
   public boolean test(Animal a) {
      return a.canHop();
   }
}
```

Этот класс может показаться простым — и это так. Это часть проблемы, которую решают лямбда-выражения. Просто потерпите 
нас немного. Теперь у нас есть все необходимое для написания кода, чтобы узнать, может ли Animal прыгать:

```
1: import java.util.*;
2: public class TraditionalSearch {
3:    public static void main(String[] args) {
4:
5:       // list of animals
6:       var animals = new ArrayList<Animal>();
7:       animals.add(new Animal("fish", false, true));
8:       animals.add(new Animal("kangaroo", true, false));
9:       animals.add(new Animal("rabbit", true, false));
10:      animals.add(new Animal("turtle", false, true));
11:
12:      // pass class that does check
13:      print(animals, new CheckIfHopper());
14:   }
15:   private static void print(List<Animal> animals, CheckTrait checker) {
16:      for (Animal animal : animals) {
17:
18:         // General check
19:         if (checker.test(animal))
20:            System.out.print(animal + " ");
21:      }
22:      System.out.println();
23:   }
24: }
```

В строке 6 показана настройка ArrayList с определенным типом Animal. Метод print() в строке 15 очень общий — он может 
проверять любой трейт. Это хороший дизайн. Ему не нужно знать, что именно мы ищем, чтобы распечатать список животных.

Что произойдет, если мы захотим напечатать Animals, которые плавают? Вздох. Нам нужно написать еще один класс, 
CheckIfSwims. Конечно, это всего несколько строк, но это совершенно новый файл. Затем нам нужно добавить новую строку 
под строкой 13, которая создает экземпляр этого класса. Это две вещи, чтобы сделать еще одну проверку.

Почему мы не можем указать интересующую нас логику прямо здесь? Оказывается, мы можем, с лямбда-выражениями. Мы могли 
бы повторить весь урок здесь и заставить вас найти одну строку, которая изменилась. Вместо этого мы просто покажем вам, 
что мы можем оставить объявление метода print() без изменений. Давайте заменим строку 13 следующей, в которой 
используется лямбда:

```
13: print(animals, a -> a.canHop());
```

Не беспокойтесь, что синтаксис выглядит немного странно. Вы привыкнете к этому, и мы опишем это в следующем разделе. Мы 
также объясняем биты, которые выглядят как магия. А пока просто сосредоточьтесь на том, насколько легко это читать. Мы 
говорим Java, что нас волнует только то, может ли Animal прыгать.

Не нужно много воображения, чтобы сообразить, как добавить логику, чтобы получить Animals, которые умеют плавать. Нам 
нужно добавить только одну строку кода — нет необходимости в дополнительном классе, чтобы сделать что-то простое. Вот 
еще одна строка:

```
13: print(animals, a -> a.canSwim());
```

Как насчет Animals, которые не умеют плавать?

```
13: print(animals, a -> !a.canSwim());
```

Дело в том, что действительно легко написать код, использующий лямбда-выражения, когда вы разберетесь с основами. В 
этом коде используется концепция, называемая отложенным выполнением. Отложенное выполнение означает, что код указан 
сейчас, но будет выполняться позже. В этом случае «позже» находится внутри тела метода print(), а не при передаче в 
метод.

### Изучение лямбда-синтаксиса

Одно из самых простых лямбда-выражений, которые вы можете написать, — это то, что вы только что видели:

```
a -> a.canHop()
```

Лямбда-выражения работают с интерфейсами, имеющими ровно один абстрактный метод. В этом случае Java смотрит на интерфейс 
CheckTrait, который имеет один метод. Лямбда в нашем примере предполагает, что Java должна вызывать метод с параметром 
Animal, который возвращает boolean значение, являющееся результатом a.canHop(). Мы знаем все это, потому что написали
код. Но откуда Java знает?

Java полагается на контекст при выяснении того, что означают лямбда-выражения. Контекст относится к тому, где и как 
интерпретируется лямбда-выражение. Например, если мы видим кого-то в очереди на вход в зоопарк и он достает свой 
кошелек, справедливо предположить, что он хочет купить билеты в зоопарк. С другой стороны, если они стоят в очереди за 
покупками с вытащенным кошельком, они, вероятно, голодны.

Ссылаясь на наш предыдущий пример, мы передали лямбду в качестве второго параметра печати method():

```
print(animals, a -> a.canHop());
```

Метод print() ожидает CheckTrait в качестве второго параметра:

```
private static void print(List<Animal> animals, CheckTrait checker) { ... }
```

Поскольку вместо этого мы передаем лямбду, Java пытается сопоставить нашу лямбду с объявлением абстрактного метода в 
интерфейсе CheckTrait:

```
boolean test(Animal a);
```

Поскольку метод этого интерфейса принимает Animal, параметр лямбда должен быть Animal. И поскольку метод этого 
интерфейса возвращает boolean значение, мы знаем, что лямбда возвращает boolean значение.

Синтаксис лямбда-выражений сложен, потому что многие части являются необязательными. Эти две строки делают одно и 
то же:

```
a -> a.canHop()

(Animal a) -> { return a.canHop(); }
```

Давайте посмотрим, что здесь происходит. Первый пример, показанный на рис. 8.1, состоит из трех частей:

+ Единственный параметр, указанный с именем a
+ Оператор стрелки (->) для разделения параметра и тела
+ Тело, которое вызывает один метод и возвращает результат этого метода.

#### Рис. 8.1 - Синтаксис лямбды(лямбда-выражения), опускающий необязательные части


Во втором примере показана наиболее подробная форма лямбда-выражения, которая возвращает логическое значение 
(см. рис. 8.2):

+ Единственный параметр, указанный с именем a и указывающий, что тип — Animal
+ Оператор стрелки (->) для разделения параметра и тела
+ Тело, содержащее одну или несколько строк кода, включая точку с запятой и оператор return.

#### Рис. 8.2 - Синтаксис лямбды (лямбда-выражения), включающий необязательные части


Круглые скобки вокруг лямбда-параметров можно опустить только в том случае, если параметр один и его тип явно не указан. 
Java делает это, потому что разработчики обычно используют лямбда-выражения таким образом и могут как можно меньше 
печатать.

Для вас не должно быть новостью, что мы можем опускать фигурные скобки, когда у нас есть только один оператор. Мы уже 
делали это с операторами if и циклами. Java позволяет опускать оператор return и точку с запятой (;), если фигурные 
скобки не используются. Этот специальный ярлык не работает, когда у вас есть два или более операторов. По крайней мере, 
это согласуется с использованием {} для создания блоков кода в другом месте.

Синтаксис на рис. 8.1 и рис. 8.2 можно смешивать и сопоставлять. Например, допустимо следующее:

```
a -> { return a.canHop(); }
(Animal a) -> a.canHop()
```

_Вот забавный факт: s -> {} - допустимое лямбда-выражение. Если в правой части выражения нет кода, вам не нужна точка с 
запятой или оператор return._

В таблице 8.1 показаны примеры допустимых лямбда-выражений, возвращающих boolean значение.

#### Таблица 8.1 - Действительные лямбда-выражения, возвращающие boolean значение

|               Лямбда-выражение                | # параметров |  
|:---------------------------------------------:|:------------:|
|                  () -> true                   |      0       |
|           x -> x.startsWith("test")           |      1       |                                     
|      (String x) -> x.startsWith("test")       |      1       |
|  (x, y) -> { return x.startsWith("test"); }   |      2       |
| (String x, String y) -> x.startsWith("test")  |      2       |

Первая строка принимает нулевые параметры и всегда возвращает логическое значение true. Вторая строка принимает один 
параметр и вызывает метод для него, возвращая результат. Третья строка делает то же самое, за исключением того, что она 
явно определяет тип переменной. Последние две строки принимают два параметра и игнорируют один из них — не существует 
правила, согласно которому вы должны использовать все определенные параметры.

Теперь давайте убедимся, что вы можете определить недопустимый синтаксис для каждой строки в таблице 8.2, где каждое 
лямбда-выражение должна возвращать boolean значение. Убедитесь, что вы понимаете, что с ними не так.

#### Таблица 8.2 - Недопустимые лямбда-выражения, возвращающие boolean значение

|       Недопустимое лямбда-выражение       |                      Причина                      |  
|:-----------------------------------------:|:-------------------------------------------------:|
|       x, y -> x.startsWith("fish")        |              Не хватает скобок слева              |
|      x -> { x.startsWith("camel"); }      |             Не хвататет return справа             |                                     
| x -> { return x.startsWith("giraffe") } ) | Отсутствие точки с запятой внутри фигурных скобок |
|     String x -> x.endsWith("eagle")       |             Не хватает скобок слева               |

Помните, что круглые скобки необязательны только в том случае, если имеется один параметр и для него не объявлен тип. 
Это основы написания лямбда-выражения. В конце главы мы рассмотрим дополнительные правила использования переменных в 
лямбда-выражении.

**Присвоение лямбда-выражений переменной var**

Как вы думаете, почему эта строка кода не компилируется?

```
var invalid = (Animal a) -> a.canHop(); // DOES NOT COMPILE
```

Помните, мы говорили о том, что Java выводит информацию о лямбде из контекста? Ну, var также предполагает тип на основе 
контекста. Здесь не хватает контекста! Ни лямбда, ни var не имеют достаточно информации, чтобы определить, какой тип 
функционального интерфейса следует использовать.

## Программирование функциональных интерфейсов

Ранее в этой главе мы объявили интерфейс CheckTrait, который имеет ровно один метод, который должны написать 
разработчики. Лямбда-выражения имеют особые отношения с такими интерфейсами. На самом деле у этих интерфейсов есть имя. 
Функциональный интерфейс — это интерфейс, содержащий один абстрактный метод. Ваш друг Сэм может помочь вам запомнить 
это, потому что это официально известно как правило _единого абстрактного метода_ (SAM).

### Определение функционального интерфейса

Давайте рассмотрим пример функционального интерфейса и класса, который его реализует:

```
@FunctionalInterface
public interface Sprint {
   public void sprint(int speed);
}

public class Tiger implements Sprint {
   public void sprint(int speed) {
      System.out.println("Animal is sprinting fast! " + speed);
   }
}
```

В этом примере интерфейс Sprint — это функциональный интерфейс, поскольку он содержит ровно один абстрактный метод, а 
класс Tiger — допустимый класс, реализующий этот интерфейс.

---

**Аннотация @FunctionalInterface**

Аннотация @FunctionalInterface сообщает компилятору, что вы хотите, чтобы код был функциональным интерфейсом. Если 
интерфейс не соответствует правилам функционального интерфейса, компилятор выдаст вам ошибку.

```
@FunctionalInterface
public interface Dance {   // DOES NOT COMPILE
   void move();
   void rest();
}
```

Java включает @FunctionalInterface в некоторые, но не во все функциональные интерфейсы. Эта аннотация означает, что 
авторы интерфейса обещают, что в будущем его можно будет безопасно использовать в лямбда-выражениях. Однако то, что вы 
не видите аннотацию, не означает, что это не функциональный интерфейс. Помните, что наличие ровно одного абстрактного 
метода делает его функциональным интерфейсом, а не аннотацией.

---

Рассмотрим следующие четыре интерфейса. Учитывая наш предыдущий функциональный интерфейс Sprint, какие из следующих 
интерфейсов являются функциональными интерфейсами?

```
public interface Dash extends Sprint {}

public interface Skip extends Sprint {
   void skip();
}

public interface Sleep {
   private void snore() {}
   default int getZzz() { return 1; }
}

public interface Climb {
   void reach();
   default void fall() {}
   static int getBackUp() { return 100; }
   private static boolean checkHeight() { return true; }
}
```

Все четыре из них являются допустимыми интерфейсами, но не все из них являются функциональными интерфейсами. Интерфейс 
Dash является функциональным интерфейсом, поскольку он расширяет интерфейс Sprint и наследует единственный абстрактный 
метод sprint(). Интерфейс Skip не является допустимым функциональным интерфейсом, поскольку он имеет два абстрактных 
метода: унаследованный метод sprint() и объявленный метод skip().

Интерфейс Sleep также не является допустимым функциональным интерфейсом. Ни snore(), ни getZzz() не соответствуют 
критериям одного абстрактного метода. Несмотря на то, что default методы функционируют как абстрактные методы, поскольку
они могут быть переопределены в классе, реализующем интерфейс, их недостаточно для удовлетворения требования 
единственного абстрактного метода.

Наконец, интерфейс Climb — это функциональный интерфейс. Несмотря на определение множества методов, он содержит только 
один абстрактный метод:reach().

### Добавление методов объекта

Все классы наследуют определенные методы от Object. Для экзамена вы должны знать следующие сигнатуры методов Object:

+ public String toString()
+ public boolean equals(Object)
+ public int hashCode()

Мы поднимаем этот вопрос сейчас, потому что есть одно исключение из правила единственного абстрактного метода, с 
которым вы должны быть знакомы. Если функциональный интерфейс включает абстрактный метод с той же сигнатурой, что и 
public метод, найденный в Object, эти методы не учитываются при проверке одного абстрактного метода. Мотивация этого 
правила заключается в том, что любой класс, реализующий интерфейс, будет наследоваться от Object, как и все классы, и 
поэтому всегда реализует эти методы.

_Поскольку Java предполагает, что все классы наследуются от Object, вы также не можете объявить метод интерфейса, 
несовместимый с Object. Например, объявление абстрактного метода int toString() в интерфейсе не будет компилироваться, 
поскольку версия метода Object возвращает String._

Давайте посмотрим на пример. Является ли класс Soar функциональным интерфейсом?

```
public interface Soar {
   abstract String toString();
}
```

Это не так. Поскольку toString() — общедоступный метод, реализованный в Object, он не учитывается при проверке одного 
абстрактного метода. С другой стороны, следующая реализация Dive представляет собой функциональный интерфейс:

```
public interface Dive {
   String toString();
   public boolean equals(Object o);
   public abstract int hashCode();
   public void dive();
}
```

Метод drive() является единственным абстрактным методом, в то время как другие не учитываются, поскольку они являются 
public методами, определенными в классе Object.

Будьте осторожны с примерами, которые напоминают методы класса Object, но на самом деле не определены в классе Object. 
Вы понимаете, почему следующее не является допустимым функциональным интерфейсом?

```
public interface Hibernate {
   String toString();
   public boolean equals(Hibernate o);
   public abstract int hashCode();
   public void rest();
}
```

Несмотря на то, что он очень похож на наш интерфейс Dive, интерфейс Hibernate использует equals(Hibernate) вместо 
equals(Object). Поскольку это не соответствует сигнатуре метода equals(Object), определенного в классе Object, этот 
интерфейс считается содержащим два абстрактных метода: equals(Hibernate) и rest().

## Использование ссылок на методы

Ссылки на методы — это еще один способ облегчить чтение кода, например простое упоминание имени метода. Как и в случае с
лямбда-выражениями, требуется время, чтобы привыкнуть к новому синтаксису. В этом разделе мы покажем синтаксис вместе с 
четырьмя типами ссылок на методы. Мы также смешиваем лямбда-выражения со ссылками на методы.

Предположим, мы программируем утенка, который пытается научиться крякать. Сначала у нас есть функциональный интерфейс:

```
public interface LearnToSpeak {
   void speak(String sound);
}
```

Далее мы обнаруживаем, что нашему утёнку повезло. Существует вспомогательный класс, с которым может работать утенок. 
Мы опустили детали обучения утенка крякать и оставили часть, которая вызывает функциональный интерфейс:

```
public class DuckHelper {
   public static void teacher(String name, LearnToSpeak trainer) {
      // Exercise patience (omitted)
      trainer.speak(name);
   }
}
```

Наконец, пришло время собрать все воедино и познакомиться с нашим маленьким Утенком. Этот код реализует функциональный 
интерфейс с помощью лямбда-выражения:

```
public class Duckling {
   public static void makeSound(String sound) {
      LearnToSpeak learner = s -> System.out.println(s);
      DuckHelper.teacher(sound, learner);
   }
}
```

Неплохо. Однако есть небольшая избыточность. Лямбда объявляет один параметр с именем s. Однако он не делает ничего, 
кроме передачи этого параметра другому методу. Ссылка на метод позволяет нам удалить эту избыточность и вместо этого 
написать следующее:

```
LearnToSpeak learner = System.out::println;
```

Оператор :: указывает Java вызвать метод println() позже. Потребуется некоторое время, чтобы привыкнуть к синтаксису. 
Как только вы это сделаете, вы обнаружите, что ваш код стал короче и менее отвлекающим, не написав столько 
лямбда-выражений.

_Помните, что :: подобен лямбда-выражению и используется для отложенного выполнения с функциональным интерфейсом. Вы 
даже можете представить ссылку на метод в виде лямбда-выражения, если это вам поможет._

Ссылка на метод и лямбда-выражение во время выполнения ведут себя одинаково. Вы можете представить, что компилятор 
превращает ваши ссылки на методы в лямбда-выражения для вас.

Существует четыре формата ссылок на методы:

+ static методы
+ Методы экземпляра для определенного объекта
+ Методы экземпляра для параметра, который должен быть определен во время выполнения
+ Конструкторы

Давайте кратко рассмотрим каждый из них по очереди. В каждом примере мы показываем ссылку на метод и его 
лямбда-эквивалент. А пока создадим отдельный функциональный интерфейс для каждого примера. В следующем разделе мы 
представим встроенные функциональные интерфейсы, чтобы вам не пришлось писать свои собственные.

### Вызов static методов

В первом примере мы используем функциональный интерфейс, который преобразует double в long:

```
interface Converter {
   long round(double num);
}
```

Мы можем реализовать этот интерфейс с помощью метода round() в Math. Здесь мы назначаем этому функциональному интерфейсу 
ссылку на метод и лямбда-выражение:

```
14: Converter methodRef = Math::round;
15: Converter lambda = x -> Math.round(x);
16:
17: System.out.println(methodRef.round(100.1)); // 100
```

В строке 14 мы ссылаемся на метод с одним параметром, а Java знает, что это похоже на лямбда-выражение с одним 
параметром. Кроме того, Java знает, как передать этот параметр методу.

Подождите минуту. Возможно, вы знаете, что метод round() перегружен — он может принимать значения типа double или float. 
Как Java узнает, что мы хотим вызвать версию с double? Как с лямбда-выражениями, так и со ссылками на методы Java 
выводит информацию из контекста. В данном случае мы сказали, что объявляем Converter, у которого есть метод, 
принимающий double параметр. Java ищет метод, соответствующий этому описанию. Если он не может найти его или находит 
несколько совпадений, то компилятор сообщит об ошибке. Последнее иногда называют ошибкой неоднозначного типа.

### Вызов методов экземпляра для определенного объекта

В этом примере наш функциональный интерфейс проверяет, начинается ли String с указанного значения:

```
interface StringStart {
   boolean beginningCheck(String prefix);
}
```

Удобно, что класс String имеет метод startWith(), который принимает один параметр и возвращает boolean значение. 
Давайте посмотрим, как использовать ссылки на методы с этим кодом:

```
18: var str = "Zoo";
19: StringStart methodRef = str::startsWith;
20: StringStart lambda = s -> str.startsWith(s);
21:
22: System.out.println(methodRef.beginningCheck("A")); // false
```

Строка 19 показывает, что мы хотим вызвать str.startsWith() и передать один параметр, который будет предоставлен во 
время выполнения. Это был бы хороший способ фильтрации данных в списке.

Ссылка на метод не должна принимать никаких параметров. В этом примере мы создаем функциональный интерфейс с методом, 
который не принимает никаких параметров, но возвращает значение:

```
interface StringChecker {
   boolean check();
}
```

Мы реализуем это, проверяя, пуста ли String:

```
18: var str = "";
19: StringChecker methodRef = str::isEmpty;
20: StringChecker lambda = () -> str.isEmpty();
21:
22: System.out.print(methodRef.check()); // true
```

Поскольку метод для String является методом экземпляра, мы вызываем ссылку на метод для экземпляра класса String.

Хотя все ссылки на методы можно превратить в лямбда-выражения, обратное не всегда верно. Например, рассмотрим этот код:

```
var str = "";
StringChecker lambda = () -> str.startsWith("Zoo");
```

Как мы могли бы записать это как ссылку на метод? Вы можете попробовать одно из следующих действий:

```
StringChecker methodReference = str::startsWith; // DOES NOT COMPILE

StringChecker methodReference = str::startsWith("Zoo"); // DOES NOT COMPILE
```

Ни одна из этих работ! Хотя мы можем передать str как часть ссылки на метод, мы не можем передать вместе с ним 
параметр «Zoo». Поэтому невозможно записать эту лямбду как ссылку на метод.

### Вызов методов экземпляра для параметра

