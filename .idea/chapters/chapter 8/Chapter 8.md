# Лямбды и Функциональные интерфейсы

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Понимать области действия переменных, использовать вывод типа локальной переменной, применять инкапсуляцию и делать 
объекты неизменяемыми.
+ Создание и использование интерфейсов, определение функциональных интерфейсов и использование частных, статических 
методов и методов интерфейса по умолчанию.

---

В этой главе мы начнем с представления лямбда-выражений, нового элемента синтаксиса. Лямбда-выражения позволяют указать 
код, который будет выполняться позже в программе.

Далее мы вводим понятие функциональных интерфейсов, показывая, как написать свой собственный и определить, является ли 
интерфейс функциональным интерфейсом. После этого мы вводим еще одну новую часть синтаксиса: ссылки на методы. Это 
похоже на более короткую форму лямбда.

Затем мы познакомим вас с функциональными интерфейсами, которые вам нужно знать для экзамена. Наконец, мы подчеркиваем, 
как переменные вписываются в лямбда-выражения.

Лямбда-выражения, ссылки на методы и функциональные интерфейсы довольно часто используются в главе 9 «Коллекции и 
обобщения» и главе 10 «Потоки».

## Написание простых лямбда-выражений

В основе Java лежит объектно-ориентированный язык. Вы уже видели множество объектов. Функциональное программирование — 
это более декларативный способ написания кода. Вы указываете, что вы хотите сделать, а не имеете дело с состоянием 
объектов. Вы больше фокусируетесь на выражениях, чем на циклах.

Функциональное программирование использует лямбда-выражения для написания кода. Лямбда-выражение — это блок кода, 
который передается. Вы можете думать о лямбда-выражении как о безымянном методе, существующем внутри анонимного класса, 
подобных тем, которые вы видели в главе 7 «За пределами классов». У него есть параметры и тело, как и у полноценных 
методов, но у него нет имени, как у настоящего метода. Лямбда-выражения часто для краткости называют лямбда-выражениями. 
Вы также можете знать их как замыкания, если Java не является вашим родным языком. Если у вас был неудачный опыт 
закрытия в прошлом, не волнуйтесь. В Java они намного проще.

Лямбда-выражения позволяют писать мощный код на Java. В этом разделе мы рассмотрим пример того, почему лямбда-выражения 
полезны, и синтаксис лямбда-выражений.

### Смотрим на пример Лямбда-выражений

Наша цель — распечатать список всех животных по некоторым критериям. Мы покажем вам, как это сделать без 
лямбда-выражений, чтобы проиллюстрировать, насколько полезны лямбда-выражения. Начнем с записи Animal:

```
public record Animal(String species, boolean canHop, boolean canSwim) { }
```

Запись Animal имеет три поля. Допустим, у нас есть список животных, и мы хотим обработать данные на основе определенного
атрибута. Например, мы хотим вывести всех животных, которые могут прыгать. Мы можем определить интерфейс, чтобы обобщить
эту концепцию и поддерживать большое количество проверок:

```
public interface CheckTrait {
   boolean test(Animal a);
}
```

Первое, что мы хотим проверить, это может ли Animal прыгать. Мы предоставляем класс, который реализует наш интерфейс:

```
public class CheckIfHopper implements CheckTrait {
   public boolean test(Animal a) {
      return a.canHop();
   }
}
```

Этот класс может показаться простым — и это так. Это часть проблемы, которую решают лямбда-выражения. Просто потерпите 
нас немного. Теперь у нас есть все необходимое для написания кода, чтобы узнать, может ли Animal прыгать:

```
1: import java.util.*;
2: public class TraditionalSearch {
3:    public static void main(String[] args) {
4:
5:       // list of animals
6:       var animals = new ArrayList<Animal>();
7:       animals.add(new Animal("fish", false, true));
8:       animals.add(new Animal("kangaroo", true, false));
9:       animals.add(new Animal("rabbit", true, false));
10:      animals.add(new Animal("turtle", false, true));
11:
12:      // pass class that does check
13:      print(animals, new CheckIfHopper());
14:   }
15:   private static void print(List<Animal> animals, CheckTrait checker) {
16:      for (Animal animal : animals) {
17:
18:         // General check
19:         if (checker.test(animal))
20:            System.out.print(animal + " ");
21:      }
22:      System.out.println();
23:   }
24: }
```

В строке 6 показана настройка ArrayList с определенным типом Animal. Метод print() в строке 15 очень общий — он может 
проверять любой трейт. Это хороший дизайн. Ему не нужно знать, что именно мы ищем, чтобы распечатать список животных.

Что произойдет, если мы захотим напечатать Animals, которые плавают? Вздох. Нам нужно написать еще один класс, 
CheckIfSwims. Конечно, это всего несколько строк, но это совершенно новый файл. Затем нам нужно добавить новую строку 
под строкой 13, которая создает экземпляр этого класса. Это две вещи, чтобы сделать еще одну проверку.

Почему мы не можем указать интересующую нас логику прямо здесь? Оказывается, мы можем, с лямбда-выражениями. Мы могли 
бы повторить весь урок здесь и заставить вас найти одну строку, которая изменилась. Вместо этого мы просто покажем вам, 
что мы можем оставить объявление метода print() без изменений. Давайте заменим строку 13 следующей, в которой 
используется лямбда:

```
13: print(animals, a -> a.canHop());
```

Не беспокойтесь, что синтаксис выглядит немного странно. Вы привыкнете к этому, и мы опишем это в следующем разделе. Мы 
также объясняем биты, которые выглядят как магия. А пока просто сосредоточьтесь на том, насколько легко это читать. Мы 
говорим Java, что нас волнует только то, может ли Animal прыгать.

Не нужно много воображения, чтобы сообразить, как добавить логику, чтобы получить Animals, которые умеют плавать. Нам 
нужно добавить только одну строку кода — нет необходимости в дополнительном классе, чтобы сделать что-то простое. Вот 
еще одна строка:

```
13: print(animals, a -> a.canSwim());
```

Как насчет Animals, которые не умеют плавать?

```
13: print(animals, a -> !a.canSwim());
```

Дело в том, что действительно легко написать код, использующий лямбда-выражения, когда вы разберетесь с основами. В 
этом коде используется концепция, называемая отложенным выполнением. Отложенное выполнение означает, что код указан 
сейчас, но будет выполняться позже. В этом случае «позже» находится внутри тела метода print(), а не при передаче в 
метод.

### Изучение лямбда-синтаксиса

Одно из самых простых лямбда-выражений, которые вы можете написать, — это то, что вы только что видели:

```
a -> a.canHop()
```

Лямбда-выражения работают с интерфейсами, имеющими ровно один абстрактный метод. В этом случае Java смотрит на интерфейс 
CheckTrait, который имеет один метод. Лямбда в нашем примере предполагает, что Java должна вызывать метод с параметром 
Animal, который возвращает boolean значение, являющееся результатом a.canHop(). Мы знаем все это, потому что написали
код. Но откуда Java знает?

Java полагается на контекст при выяснении того, что означают лямбда-выражения. Контекст относится к тому, где и как 
интерпретируется лямбда-выражение. Например, если мы видим кого-то в очереди на вход в зоопарк и он достает свой 
кошелек, справедливо предположить, что он хочет купить билеты в зоопарк. С другой стороны, если они стоят в очереди за 
покупками с вытащенным кошельком, они, вероятно, голодны.

Ссылаясь на наш предыдущий пример, мы передали лямбду в качестве второго параметра печати method():

```
print(animals, a -> a.canHop());
```

Метод print() ожидает CheckTrait в качестве второго параметра:

```
private static void print(List<Animal> animals, CheckTrait checker) { ... }
```

Поскольку вместо этого мы передаем лямбду, Java пытается сопоставить нашу лямбду с объявлением абстрактного метода в 
интерфейсе CheckTrait:

```
boolean test(Animal a);
```

Поскольку метод этого интерфейса принимает Animal, параметр лямбда должен быть Animal. И поскольку метод этого 
интерфейса возвращает boolean значение, мы знаем, что лямбда возвращает boolean значение.

Синтаксис лямбда-выражений сложен, потому что многие части являются необязательными. Эти две строки делают одно и 
то же:

```
a -> a.canHop()

(Animal a) -> { return a.canHop(); }
```

Давайте посмотрим, что здесь происходит. Первый пример, показанный на рис. 8.1, состоит из трех частей:

+ Единственный параметр, указанный с именем a
+ Оператор стрелки (->) для разделения параметра и тела
+ Тело, которое вызывает один метод и возвращает результат этого метода.

#### Рис. 8.1 - Синтаксис лямбды(лямбда-выражения), опускающий необязательные части


Во втором примере показана наиболее подробная форма лямбда-выражения, которая возвращает логическое значение 
(см. рис. 8.2):

+ Единственный параметр, указанный с именем a и указывающий, что тип — Animal
+ Оператор стрелки (->) для разделения параметра и тела
+ Тело, содержащее одну или несколько строк кода, включая точку с запятой и оператор return.

#### Рис. 8.2 - Синтаксис лямбды (лямбда-выражения), включающий необязательные части


Круглые скобки вокруг лямбда-параметров можно опустить только в том случае, если параметр один и его тип явно не указан. 
Java делает это, потому что разработчики обычно используют лямбда-выражения таким образом и могут как можно меньше 
печатать.

Для вас не должно быть новостью, что мы можем опускать фигурные скобки, когда у нас есть только один оператор. Мы уже 
делали это с операторами if и циклами. Java позволяет опускать оператор return и точку с запятой (;), если фигурные 
скобки не используются. Этот специальный ярлык не работает, когда у вас есть два или более операторов. По крайней мере, 
это согласуется с использованием {} для создания блоков кода в другом месте.

Синтаксис на рис. 8.1 и рис. 8.2 можно смешивать и сопоставлять. Например, допустимо следующее:

```
a -> { return a.canHop(); }
(Animal a) -> a.canHop()
```

_Вот забавный факт: s -> {} - допустимое лямбда-выражение. Если в правой части выражения нет кода, вам не нужна точка с 
запятой или оператор return._

В таблице 8.1 показаны примеры допустимых лямбда-выражений, возвращающих boolean значение.

#### Таблица 8.1 - Действительные лямбда-выражения, возвращающие boolean значение

|               Лямбда-выражение                | # параметров |  
|:---------------------------------------------:|:------------:|
|                  () -> true                   |      0       |
|           x -> x.startsWith("test")           |      1       |                                     
|      (String x) -> x.startsWith("test")       |      1       |
|  (x, y) -> { return x.startsWith("test"); }   |      2       |
| (String x, String y) -> x.startsWith("test")  |      2       |

Первая строка принимает нулевые параметры и всегда возвращает логическое значение true. Вторая строка принимает один 
параметр и вызывает метод для него, возвращая результат. Третья строка делает то же самое, за исключением того, что она 
явно определяет тип переменной. Последние две строки принимают два параметра и игнорируют один из них — не существует 
правила, согласно которому вы должны использовать все определенные параметры.

Теперь давайте убедимся, что вы можете определить недопустимый синтаксис для каждой строки в таблице 8.2, где каждое 
лямбда-выражение должна возвращать boolean значение. Убедитесь, что вы понимаете, что с ними не так.

#### Таблица 8.2 - Недопустимые лямбда-выражения, возвращающие boolean значение

|       Недопустимое лямбда-выражение       |                      Причина                      |  
|:-----------------------------------------:|:-------------------------------------------------:|
|       x, y -> x.startsWith("fish")        |              Не хватает скобок слева              |
|      x -> { x.startsWith("camel"); }      |             Не хвататет return справа             |                                     
| x -> { return x.startsWith("giraffe") } ) | Отсутствие точки с запятой внутри фигурных скобок |
|     String x -> x.endsWith("eagle")       |             Не хватает скобок слева               |

Помните, что круглые скобки необязательны только в том случае, если имеется один параметр и для него не объявлен тип. 
Это основы написания лямбда-выражения. В конце главы мы рассмотрим дополнительные правила использования переменных в 
лямбда-выражении.

**Присвоение лямбда-выражений переменной var**

Как вы думаете, почему эта строка кода не компилируется?

```
var invalid = (Animal a) -> a.canHop(); // DOES NOT COMPILE
```

Помните, мы говорили о том, что Java выводит информацию о лямбде из контекста? Ну, var также предполагает тип на основе 
контекста. Здесь не хватает контекста! Ни лямбда, ни var не имеют достаточно информации, чтобы определить, какой тип 
функционального интерфейса следует использовать.

## Программирование функциональных интерфейсов

Ранее в этой главе мы объявили интерфейс CheckTrait, который имеет ровно один метод, который должны написать 
разработчики. Лямбда-выражения имеют особые отношения с такими интерфейсами. На самом деле у этих интерфейсов есть имя. 
Функциональный интерфейс — это интерфейс, содержащий один абстрактный метод. Ваш друг Сэм может помочь вам запомнить 
это, потому что это официально известно как правило _единого абстрактного метода_ (SAM).

### Определение функционального интерфейса

Давайте рассмотрим пример функционального интерфейса и класса, который его реализует:

```
@FunctionalInterface
public interface Sprint {
   public void sprint(int speed);
}

public class Tiger implements Sprint {
   public void sprint(int speed) {
      System.out.println("Animal is sprinting fast! " + speed);
   }
}
```

В этом примере интерфейс Sprint — это функциональный интерфейс, поскольку он содержит ровно один абстрактный метод, а 
класс Tiger — допустимый класс, реализующий этот интерфейс.

---

**Аннотация @FunctionalInterface**

Аннотация @FunctionalInterface сообщает компилятору, что вы хотите, чтобы код был функциональным интерфейсом. Если 
интерфейс не соответствует правилам функционального интерфейса, компилятор выдаст вам ошибку.

```
@FunctionalInterface
public interface Dance {   // DOES NOT COMPILE
   void move();
   void rest();
}
```

Java включает @FunctionalInterface в некоторые, но не во все функциональные интерфейсы. Эта аннотация означает, что 
авторы интерфейса обещают, что в будущем его можно будет безопасно использовать в лямбда-выражениях. Однако то, что вы 
не видите аннотацию, не означает, что это не функциональный интерфейс. Помните, что наличие ровно одного абстрактного 
метода делает его функциональным интерфейсом, а не аннотацией.

---

Рассмотрим следующие четыре интерфейса. Учитывая наш предыдущий функциональный интерфейс Sprint, какие из следующих 
интерфейсов являются функциональными интерфейсами?

```
public interface Dash extends Sprint {}

public interface Skip extends Sprint {
   void skip();
}

public interface Sleep {
   private void snore() {}
   default int getZzz() { return 1; }
}

public interface Climb {
   void reach();
   default void fall() {}
   static int getBackUp() { return 100; }
   private static boolean checkHeight() { return true; }
}
```

Все четыре из них являются допустимыми интерфейсами, но не все из них являются функциональными интерфейсами. Интерфейс 
Dash является функциональным интерфейсом, поскольку он расширяет интерфейс Sprint и наследует единственный абстрактный 
метод sprint(). Интерфейс Skip не является допустимым функциональным интерфейсом, поскольку он имеет два абстрактных 
метода: унаследованный метод sprint() и объявленный метод skip().

Интерфейс Sleep также не является допустимым функциональным интерфейсом. Ни snore(), ни getZzz() не соответствуют 
критериям одного абстрактного метода. Несмотря на то, что default методы функционируют как абстрактные методы, поскольку
они могут быть переопределены в классе, реализующем интерфейс, их недостаточно для удовлетворения требования 
единственного абстрактного метода.

Наконец, интерфейс Climb — это функциональный интерфейс. Несмотря на определение множества методов, он содержит только 
один абстрактный метод:reach().

### Добавление методов объекта
