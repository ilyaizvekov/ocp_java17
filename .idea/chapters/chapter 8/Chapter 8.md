# Лямбды и Функциональные интерфейсы

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Понимать области действия переменных, использовать вывод типа локальной переменной, применять инкапсуляцию и делать 
объекты неизменяемыми.
+ Создание и использование интерфейсов, определение функциональных интерфейсов и использование частных, статических 
методов и методов интерфейса по умолчанию.

---

В этой главе мы начнем с представления лямбда-выражений, нового элемента синтаксиса. Лямбда-выражения позволяют указать 
код, который будет выполняться позже в программе.

Далее мы вводим понятие функциональных интерфейсов, показывая, как написать свой собственный и определить, является ли 
интерфейс функциональным интерфейсом. После этого мы вводим еще одну новую часть синтаксиса: ссылки на методы. Это 
похоже на более короткую форму лямбда.

Затем мы познакомим вас с функциональными интерфейсами, которые вам нужно знать для экзамена. Наконец, мы подчеркиваем, 
как переменные вписываются в лямбда-выражения.

Лямбда-выражения, ссылки на методы и функциональные интерфейсы довольно часто используются в главе 9 «Коллекции и 
обобщения» и главе 10 «Потоки».

## Написание простых лямбда-выражений

В основе Java лежит объектно-ориентированный язык. Вы уже видели множество объектов. Функциональное программирование — 
это более декларативный способ написания кода. Вы указываете, что вы хотите сделать, а не имеете дело с состоянием 
объектов. Вы больше фокусируетесь на выражениях, чем на циклах.

Функциональное программирование использует лямбда-выражения для написания кода. Лямбда-выражение — это блок кода, 
который передается. Вы можете думать о лямбда-выражении как о безымянном методе, существующем внутри анонимного класса, 
подобных тем, которые вы видели в главе 7 «За пределами классов». У него есть параметры и тело, как и у полноценных 
методов, но у него нет имени, как у настоящего метода. Лямбда-выражения часто для краткости называют лямбда-выражениями. 
Вы также можете знать их как замыкания, если Java не является вашим родным языком. Если у вас был неудачный опыт 
закрытия в прошлом, не волнуйтесь. В Java они намного проще.

Лямбда-выражения позволяют писать мощный код на Java. В этом разделе мы рассмотрим пример того, почему лямбда-выражения 
полезны, и синтаксис лямбда-выражений.

### Смотрим на пример Лямбда-выражений

Наша цель — распечатать список всех животных по некоторым критериям. Мы покажем вам, как это сделать без 
лямбда-выражений, чтобы проиллюстрировать, насколько полезны лямбда-выражения. Начнем с записи Animal:

```
public record Animal(String species, boolean canHop, boolean canSwim) { }
```

Запись Animal имеет три поля. Допустим, у нас есть список животных, и мы хотим обработать данные на основе определенного
атрибута. Например, мы хотим вывести всех животных, которые могут прыгать. Мы можем определить интерфейс, чтобы обобщить
эту концепцию и поддерживать большое количество проверок:

```
public interface CheckTrait {
   boolean test(Animal a);
}
```

Первое, что мы хотим проверить, это может ли Animal прыгать. Мы предоставляем класс, который реализует наш интерфейс:

```
public class CheckIfHopper implements CheckTrait {
   public boolean test(Animal a) {
      return a.canHop();
   }
}
```

Этот класс может показаться простым — и это так. Это часть проблемы, которую решают лямбда-выражения. Просто потерпите 
нас немного. Теперь у нас есть все необходимое для написания кода, чтобы узнать, может ли Animal прыгать:

```
1: import java.util.*;
2: public class TraditionalSearch {
3:    public static void main(String[] args) {
4:
5:       // list of animals
6:       var animals = new ArrayList<Animal>();
7:       animals.add(new Animal("fish", false, true));
8:       animals.add(new Animal("kangaroo", true, false));
9:       animals.add(new Animal("rabbit", true, false));
10:      animals.add(new Animal("turtle", false, true));
11:
12:      // pass class that does check
13:      print(animals, new CheckIfHopper());
14:   }
15:   private static void print(List<Animal> animals, CheckTrait checker) {
16:      for (Animal animal : animals) {
17:
18:         // General check
19:         if (checker.test(animal))
20:            System.out.print(animal + " ");
21:      }
22:      System.out.println();
23:   }
24: }
```

В строке 6 показана настройка ArrayList с определенным типом Animal. Метод print() в строке 15 очень общий — он может 
проверять любой трейт. Это хороший дизайн. Ему не нужно знать, что именно мы ищем, чтобы распечатать список животных.

Что произойдет, если мы захотим напечатать Animals, которые плавают? Вздох. Нам нужно написать еще один класс, 
CheckIfSwims. Конечно, это всего несколько строк, но это совершенно новый файл. Затем нам нужно добавить новую строку 
под строкой 13, которая создает экземпляр этого класса. Это две вещи, чтобы сделать еще одну проверку.

Почему мы не можем указать интересующую нас логику прямо здесь? Оказывается, мы можем, с лямбда-выражениями. Мы могли 
бы повторить весь урок здесь и заставить вас найти одну строку, которая изменилась. Вместо этого мы просто покажем вам, 
что мы можем оставить объявление метода print() без изменений. Давайте заменим строку 13 следующей, в которой 
используется лямбда:

```
13: print(animals, a -> a.canHop());
```

Не беспокойтесь, что синтаксис выглядит немного странно. Вы привыкнете к этому, и мы опишем это в следующем разделе. Мы 
также объясняем биты, которые выглядят как магия. А пока просто сосредоточьтесь на том, насколько легко это читать. Мы 
говорим Java, что нас волнует только то, может ли Animal прыгать.

Не нужно много воображения, чтобы сообразить, как добавить логику, чтобы получить Animals, которые умеют плавать. Нам 
нужно добавить только одну строку кода — нет необходимости в дополнительном классе, чтобы сделать что-то простое. Вот 
еще одна строка:

```
13: print(animals, a -> a.canSwim());
```

Как насчет Animals, которые не умеют плавать?

```
13: print(animals, a -> !a.canSwim());
```

Дело в том, что действительно легко написать код, использующий лямбда-выражения, когда вы разберетесь с основами. В 
этом коде используется концепция, называемая отложенным выполнением. Отложенное выполнение означает, что код указан 
сейчас, но будет выполняться позже. В этом случае «позже» находится внутри тела метода print(), а не при передаче в 
метод.

### Изучение лямбда-синтаксиса

Одно из самых простых лямбда-выражений, которые вы можете написать, — это то, что вы только что видели:

```
a -> a.canHop()
```

Лямбда-выражения работают с интерфейсами, имеющими ровно один абстрактный метод. В этом случае Java смотрит на интерфейс 
CheckTrait, который имеет один метод. Лямбда в нашем примере предполагает, что Java должна вызывать метод с параметром 
Animal, который возвращает boolean значение, являющееся результатом a.canHop(). Мы знаем все это, потому что написали
код. Но откуда Java знает?

Java полагается на контекст при выяснении того, что означают лямбда-выражения. Контекст относится к тому, где и как 
интерпретируется лямбда-выражение. Например, если мы видим кого-то в очереди на вход в зоопарк и он достает свой 
кошелек, справедливо предположить, что он хочет купить билеты в зоопарк. С другой стороны, если они стоят в очереди за 
покупками с вытащенным кошельком, они, вероятно, голодны.

Ссылаясь на наш предыдущий пример, мы передали лямбду в качестве второго параметра печати method():

```
print(animals, a -> a.canHop());
```

Метод print() ожидает CheckTrait в качестве второго параметра:

```
private static void print(List<Animal> animals, CheckTrait checker) { ... }
```

Поскольку вместо этого мы передаем лямбду, Java пытается сопоставить нашу лямбду с объявлением абстрактного метода в 
интерфейсе CheckTrait:

```
boolean test(Animal a);
```

Поскольку метод этого интерфейса принимает Animal, параметр лямбда должен быть Animal. И поскольку метод этого 
интерфейса возвращает boolean значение, мы знаем, что лямбда возвращает boolean значение.

Синтаксис лямбда-выражений сложен, потому что многие части являются необязательными. Эти две строки делают одно и 
то же:

```
a -> a.canHop()

(Animal a) -> { return a.canHop(); }
```

Давайте посмотрим, что здесь происходит. Первый пример, показанный на рис. 8.1, состоит из трех частей:

+ Единственный параметр, указанный с именем a
+ Оператор стрелки (->) для разделения параметра и тела
+ Тело, которое вызывает один метод и возвращает результат этого метода.

#### Рис. 8.1 - Синтаксис лямбды(лямбда-выражения), опускающий необязательные части


  