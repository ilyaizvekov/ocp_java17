# Лямбды и Функциональные интерфейсы

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Использование объектно-ориентированного подхода Java

+ Понимать области действия переменных, использовать вывод типа локальной переменной, применять инкапсуляцию и делать 
объекты неизменяемыми.
+ Создание и использование интерфейсов, определение функциональных интерфейсов и использование частных, статических 
методов и методов интерфейса по умолчанию.

---

В этой главе мы начнем с представления лямбда-выражений, нового элемента синтаксиса. Лямбда-выражения позволяют указать 
код, который будет выполняться позже в программе.

Далее мы вводим понятие функциональных интерфейсов, показывая, как написать свой собственный и определить, является ли 
интерфейс функциональным интерфейсом. После этого мы вводим еще одну новую часть синтаксиса: ссылки на методы. Это 
похоже на более короткую форму лямбда.

Затем мы познакомим вас с функциональными интерфейсами, которые вам нужно знать для экзамена. Наконец, мы подчеркиваем, 
как переменные вписываются в лямбда-выражения.

Лямбда-выражения, ссылки на методы и функциональные интерфейсы довольно часто используются в главе 9 «Коллекции и 
обобщения» и главе 10 «Потоки».

## Написание простых лямбда-выражений

В основе Java лежит объектно-ориентированный язык. Вы уже видели множество объектов. Функциональное программирование — 
это более декларативный способ написания кода. Вы указываете, что вы хотите сделать, а не имеете дело с состоянием 
объектов. Вы больше фокусируетесь на выражениях, чем на циклах.

Функциональное программирование использует лямбда-выражения для написания кода. Лямбда-выражение — это блок кода, 
который передается. Вы можете думать о лямбда-выражении как о безымянном методе, существующем внутри анонимного класса, 
подобных тем, которые вы видели в главе 7 «За пределами классов». У него есть параметры и тело, как и у полноценных 
методов, но у него нет имени, как у настоящего метода. Лямбда-выражения часто для краткости называют лямбда-выражениями. 
Вы также можете знать их как замыкания, если Java не является вашим родным языком. Если у вас был неудачный опыт 
закрытия в прошлом, не волнуйтесь. В Java они намного проще.

Лямбда-выражения позволяют писать мощный код на Java. В этом разделе мы рассмотрим пример того, почему лямбда-выражения 
полезны, и синтаксис лямбда-выражений.

### Смотрим на пример Лямбда-выражений

Наша цель — распечатать список всех животных по некоторым критериям. Мы покажем вам, как это сделать без 
лямбда-выражений, чтобы проиллюстрировать, насколько полезны лямбда-выражения. Начнем с записи Animal:

```
public record Animal(String species, boolean canHop, boolean canSwim) { }
```

Запись Animal имеет три поля. Допустим, у нас есть список животных, и мы хотим обработать данные на основе определенного
атрибута. Например, мы хотим вывести всех животных, которые могут прыгать. Мы можем определить интерфейс, чтобы обобщить
эту концепцию и поддерживать большое количество проверок:

```
public interface CheckTrait {
   boolean test(Animal a);
}
```

Первое, что мы хотим проверить, это может ли Animal прыгать. Мы предоставляем класс, который реализует наш интерфейс:

```
public class CheckIfHopper implements CheckTrait {
   public boolean test(Animal a) {
      return a.canHop();
   }
}
```

Этот класс может показаться простым — и это так. Это часть проблемы, которую решают лямбда-выражения. Просто потерпите 
нас немного. Теперь у нас есть все необходимое для написания кода, чтобы узнать, может ли Animal прыгать:

```
1: import java.util.*;
2: public class TraditionalSearch {
3:    public static void main(String[] args) {
4:
5:       // list of animals
6:       var animals = new ArrayList<Animal>();
7:       animals.add(new Animal("fish", false, true));
8:       animals.add(new Animal("kangaroo", true, false));
9:       animals.add(new Animal("rabbit", true, false));
10:      animals.add(new Animal("turtle", false, true));
11:
12:      // pass class that does check
13:      print(animals, new CheckIfHopper());
14:   }
15:   private static void print(List<Animal> animals, CheckTrait checker) {
16:      for (Animal animal : animals) {
17:
18:         // General check
19:         if (checker.test(animal))
20:            System.out.print(animal + " ");
21:      }
22:      System.out.println();
23:   }
24: }
```

В строке 6 показана настройка ArrayList с определенным типом Animal. Метод print() в строке 15 очень общий — он может 
проверять любой трейт. Это хороший дизайн. Ему не нужно знать, что именно мы ищем, чтобы распечатать список животных.

Что произойдет, если мы захотим напечатать Animals, которые плавают? Вздох. Нам нужно написать еще один класс, 
CheckIfSwims. Конечно, это всего несколько строк, но это совершенно новый файл. Затем нам нужно добавить новую строку 
под строкой 13, которая создает экземпляр этого класса. Это две вещи, чтобы сделать еще одну проверку.

Почему мы не можем указать интересующую нас логику прямо здесь? Оказывается, мы можем, с лямбда-выражениями. Мы могли 
бы повторить весь урок здесь и заставить вас найти одну строку, которая изменилась. Вместо этого мы просто покажем вам, 
что мы можем оставить объявление метода print() без изменений. Давайте заменим строку 13 следующей, в которой 
используется лямбда:

```
13: print(animals, a -> a.canHop());
```

Не беспокойтесь, что синтаксис выглядит немного странно. Вы привыкнете к этому, и мы опишем это в следующем разделе. Мы 
также объясняем биты, которые выглядят как магия. А пока просто сосредоточьтесь на том, насколько легко это читать. Мы 
говорим Java, что нас волнует только то, может ли Animal прыгать.

Не нужно много воображения, чтобы сообразить, как добавить логику, чтобы получить Animals, которые умеют плавать. Нам 
нужно добавить только одну строку кода — нет необходимости в дополнительном классе, чтобы сделать что-то простое. Вот 
еще одна строка:

```
13: print(animals, a -> a.canSwim());
```

Как насчет Animals, которые не умеют плавать?

```
13: print(animals, a -> !a.canSwim());
```

Дело в том, что действительно легко написать код, использующий лямбда-выражения, когда вы разберетесь с основами. В 
этом коде используется концепция, называемая отложенным выполнением. Отложенное выполнение означает, что код указан 
сейчас, но будет выполняться позже. В этом случае «позже» находится внутри тела метода print(), а не при передаче в 
метод.

### Изучение лямбда-синтаксиса

Одно из самых простых лямбда-выражений, которые вы можете написать, — это то, что вы только что видели:

```
a -> a.canHop()
```

Лямбда-выражения работают с интерфейсами, имеющими ровно один абстрактный метод. В этом случае Java смотрит на интерфейс 
CheckTrait, который имеет один метод. Лямбда в нашем примере предполагает, что Java должна вызывать метод с параметром 
Animal, который возвращает boolean значение, являющееся результатом a.canHop(). Мы знаем все это, потому что написали
код. Но откуда Java знает?

Java полагается на контекст при выяснении того, что означают лямбда-выражения. Контекст относится к тому, где и как 
интерпретируется лямбда-выражение. Например, если мы видим кого-то в очереди на вход в зоопарк и он достает свой 
кошелек, справедливо предположить, что он хочет купить билеты в зоопарк. С другой стороны, если они стоят в очереди за 
покупками с вытащенным кошельком, они, вероятно, голодны.

Ссылаясь на наш предыдущий пример, мы передали лямбду в качестве второго параметра печати method():

```
print(animals, a -> a.canHop());
```

Метод print() ожидает CheckTrait в качестве второго параметра:

```
private static void print(List<Animal> animals, CheckTrait checker) { ... }
```

Поскольку вместо этого мы передаем лямбду, Java пытается сопоставить нашу лямбду с объявлением абстрактного метода в 
интерфейсе CheckTrait:

```
boolean test(Animal a);
```

Поскольку метод этого интерфейса принимает Animal, параметр лямбда должен быть Animal. И поскольку метод этого 
интерфейса возвращает boolean значение, мы знаем, что лямбда возвращает boolean значение.

Синтаксис лямбда-выражений сложен, потому что многие части являются необязательными. Эти две строки делают одно и 
то же:

```
a -> a.canHop()

(Animal a) -> { return a.canHop(); }
```

Давайте посмотрим, что здесь происходит. Первый пример, показанный на рис. 8.1, состоит из трех частей:

+ Единственный параметр, указанный с именем a
+ Оператор стрелки (->) для разделения параметра и тела
+ Тело, которое вызывает один метод и возвращает результат этого метода.

#### Рис. 8.1 - Синтаксис лямбды(лямбда-выражения), опускающий необязательные части


Во втором примере показана наиболее подробная форма лямбда-выражения, которая возвращает логическое значение 
(см. рис. 8.2):

+ Единственный параметр, указанный с именем a и указывающий, что тип — Animal
+ Оператор стрелки (->) для разделения параметра и тела
+ Тело, содержащее одну или несколько строк кода, включая точку с запятой и оператор return.

#### Рис. 8.2 - Синтаксис лямбды (лямбда-выражения), включающий необязательные части


Круглые скобки вокруг лямбда-параметров можно опустить только в том случае, если параметр один и его тип явно не указан. 
Java делает это, потому что разработчики обычно используют лямбда-выражения таким образом и могут как можно меньше 
печатать.

Для вас не должно быть новостью, что мы можем опускать фигурные скобки, когда у нас есть только один оператор. Мы уже 
делали это с операторами if и циклами. Java позволяет опускать оператор return и точку с запятой (;), если фигурные 
скобки не используются. Этот специальный ярлык не работает, когда у вас есть два или более операторов. По крайней мере, 
это согласуется с использованием {} для создания блоков кода в другом месте.

Синтаксис на рис. 8.1 и рис. 8.2 можно смешивать и сопоставлять. Например, допустимо следующее:

```
a -> { return a.canHop(); }
(Animal a) -> a.canHop()
```

_Вот забавный факт: s -> {} - допустимое лямбда-выражение. Если в правой части выражения нет кода, вам не нужна точка с 
запятой или оператор return._

В таблице 8.1 показаны примеры допустимых лямбда-выражений, возвращающих boolean значение.

#### Таблица 8.1 - Действительные лямбда-выражения, возвращающие boolean значение

|               Лямбда-выражение                | # параметров |  
|:---------------------------------------------:|:------------:|
|                  () -> true                   |      0       |
|           x -> x.startsWith("test")           |      1       |                                     
|      (String x) -> x.startsWith("test")       |      1       |
|  (x, y) -> { return x.startsWith("test"); }   |      2       |
| (String x, String y) -> x.startsWith("test")  |      2       |

Первая строка принимает нулевые параметры и всегда возвращает логическое значение true. Вторая строка принимает один 
параметр и вызывает метод для него, возвращая результат. Третья строка делает то же самое, за исключением того, что она 
явно определяет тип переменной. Последние две строки принимают два параметра и игнорируют один из них — не существует 
правила, согласно которому вы должны использовать все определенные параметры.

Теперь давайте убедимся, что вы можете определить недопустимый синтаксис для каждой строки в таблице 8.2, где каждое 
лямбда-выражение должна возвращать boolean значение. Убедитесь, что вы понимаете, что с ними не так.

#### Таблица 8.2 - Недопустимые лямбда-выражения, возвращающие boolean значение

|       Недопустимое лямбда-выражение       |                      Причина                      |  
|:-----------------------------------------:|:-------------------------------------------------:|
|       x, y -> x.startsWith("fish")        |              Не хватает скобок слева              |
|      x -> { x.startsWith("camel"); }      |             Не хвататет return справа             |                                     
| x -> { return x.startsWith("giraffe") } ) | Отсутствие точки с запятой внутри фигурных скобок |
|     String x -> x.endsWith("eagle")       |             Не хватает скобок слева               |

Помните, что круглые скобки необязательны только в том случае, если имеется один параметр и для него не объявлен тип. 
Это основы написания лямбда-выражения. В конце главы мы рассмотрим дополнительные правила использования переменных в 
лямбда-выражении.

**Присвоение лямбда-выражений переменной var**

Как вы думаете, почему эта строка кода не компилируется?

```
var invalid = (Animal a) -> a.canHop(); // DOES NOT COMPILE
```

Помните, мы говорили о том, что Java выводит информацию о лямбде из контекста? Ну, var также предполагает тип на основе 
контекста. Здесь не хватает контекста! Ни лямбда, ни var не имеют достаточно информации, чтобы определить, какой тип 
функционального интерфейса следует использовать.

## Программирование функциональных интерфейсов

Ранее в этой главе мы объявили интерфейс CheckTrait, который имеет ровно один метод, который должны написать 
разработчики. Лямбда-выражения имеют особые отношения с такими интерфейсами. На самом деле у этих интерфейсов есть имя. 
Функциональный интерфейс — это интерфейс, содержащий один абстрактный метод. Ваш друг Сэм может помочь вам запомнить 
это, потому что это официально известно как правило _единого абстрактного метода_ (SAM).

### Определение функционального интерфейса

Давайте рассмотрим пример функционального интерфейса и класса, который его реализует:

```
@FunctionalInterface
public interface Sprint {
   public void sprint(int speed);
}

public class Tiger implements Sprint {
   public void sprint(int speed) {
      System.out.println("Animal is sprinting fast! " + speed);
   }
}
```

В этом примере интерфейс Sprint — это функциональный интерфейс, поскольку он содержит ровно один абстрактный метод, а 
класс Tiger — допустимый класс, реализующий этот интерфейс.

---

**Аннотация @FunctionalInterface**

Аннотация @FunctionalInterface сообщает компилятору, что вы хотите, чтобы код был функциональным интерфейсом. Если 
интерфейс не соответствует правилам функционального интерфейса, компилятор выдаст вам ошибку.

```
@FunctionalInterface
public interface Dance {   // DOES NOT COMPILE
   void move();
   void rest();
}
```

Java включает @FunctionalInterface в некоторые, но не во все функциональные интерфейсы. Эта аннотация означает, что 
авторы интерфейса обещают, что в будущем его можно будет безопасно использовать в лямбда-выражениях. Однако то, что вы 
не видите аннотацию, не означает, что это не функциональный интерфейс. Помните, что наличие ровно одного абстрактного 
метода делает его функциональным интерфейсом, а не аннотацией.

---

Рассмотрим следующие четыре интерфейса. Учитывая наш предыдущий функциональный интерфейс Sprint, какие из следующих 
интерфейсов являются функциональными интерфейсами?

```
public interface Dash extends Sprint {}

public interface Skip extends Sprint {
   void skip();
}

public interface Sleep {
   private void snore() {}
   default int getZzz() { return 1; }
}

public interface Climb {
   void reach();
   default void fall() {}
   static int getBackUp() { return 100; }
   private static boolean checkHeight() { return true; }
}
```

Все четыре из них являются допустимыми интерфейсами, но не все из них являются функциональными интерфейсами. Интерфейс 
Dash является функциональным интерфейсом, поскольку он расширяет интерфейс Sprint и наследует единственный абстрактный 
метод sprint(). Интерфейс Skip не является допустимым функциональным интерфейсом, поскольку он имеет два абстрактных 
метода: унаследованный метод sprint() и объявленный метод skip().

Интерфейс Sleep также не является допустимым функциональным интерфейсом. Ни snore(), ни getZzz() не соответствуют 
критериям одного абстрактного метода. Несмотря на то, что default методы функционируют как абстрактные методы, поскольку
они могут быть переопределены в классе, реализующем интерфейс, их недостаточно для удовлетворения требования 
единственного абстрактного метода.

Наконец, интерфейс Climb — это функциональный интерфейс. Несмотря на определение множества методов, он содержит только 
один абстрактный метод:reach().

### Добавление методов объекта

Все классы наследуют определенные методы от Object. Для экзамена вы должны знать следующие сигнатуры методов Object:

+ public String toString()
+ public boolean equals(Object)
+ public int hashCode()

Мы поднимаем этот вопрос сейчас, потому что есть одно исключение из правила единственного абстрактного метода, с 
которым вы должны быть знакомы. Если функциональный интерфейс включает абстрактный метод с той же сигнатурой, что и 
public метод, найденный в Object, эти методы не учитываются при проверке одного абстрактного метода. Мотивация этого 
правила заключается в том, что любой класс, реализующий интерфейс, будет наследоваться от Object, как и все классы, и 
поэтому всегда реализует эти методы.

_Поскольку Java предполагает, что все классы наследуются от Object, вы также не можете объявить метод интерфейса, 
несовместимый с Object. Например, объявление абстрактного метода int toString() в интерфейсе не будет компилироваться, 
поскольку версия метода Object возвращает String._

Давайте посмотрим на пример. Является ли класс Soar функциональным интерфейсом?

```
public interface Soar {
   abstract String toString();
}
```

Это не так. Поскольку toString() — общедоступный метод, реализованный в Object, он не учитывается при проверке одного 
абстрактного метода. С другой стороны, следующая реализация Dive представляет собой функциональный интерфейс:

```
public interface Dive {
   String toString();
   public boolean equals(Object o);
   public abstract int hashCode();
   public void dive();
}
```

Метод drive() является единственным абстрактным методом, в то время как другие не учитываются, поскольку они являются 
public методами, определенными в классе Object.

Будьте осторожны с примерами, которые напоминают методы класса Object, но на самом деле не определены в классе Object. 
Вы понимаете, почему следующее не является допустимым функциональным интерфейсом?

```
public interface Hibernate {
   String toString();
   public boolean equals(Hibernate o);
   public abstract int hashCode();
   public void rest();
}
```

Несмотря на то, что он очень похож на наш интерфейс Dive, интерфейс Hibernate использует equals(Hibernate) вместо 
equals(Object). Поскольку это не соответствует сигнатуре метода equals(Object), определенного в классе Object, этот 
интерфейс считается содержащим два абстрактных метода: equals(Hibernate) и rest().

## Использование ссылок на методы

Ссылки на методы — это еще один способ облегчить чтение кода, например простое упоминание имени метода. Как и в случае с
лямбда-выражениями, требуется время, чтобы привыкнуть к новому синтаксису. В этом разделе мы покажем синтаксис вместе с 
четырьмя типами ссылок на методы. Мы также смешиваем лямбда-выражения со ссылками на методы.

Предположим, мы программируем утенка, который пытается научиться крякать. Сначала у нас есть функциональный интерфейс:

```
public interface LearnToSpeak {
   void speak(String sound);
}
```

Далее мы обнаруживаем, что нашему утёнку повезло. Существует вспомогательный класс, с которым может работать утенок. 
Мы опустили детали обучения утенка крякать и оставили часть, которая вызывает функциональный интерфейс:

```
public class DuckHelper {
   public static void teacher(String name, LearnToSpeak trainer) {
      // Exercise patience (omitted)
      trainer.speak(name);
   }
}
```

Наконец, пришло время собрать все воедино и познакомиться с нашим маленьким Утенком. Этот код реализует функциональный 
интерфейс с помощью лямбда-выражения:

```
public class Duckling {
   public static void makeSound(String sound) {
      LearnToSpeak learner = s -> System.out.println(s);
      DuckHelper.teacher(sound, learner);
   }
}
```

Неплохо. Однако есть небольшая избыточность. Лямбда объявляет один параметр с именем s. Однако он не делает ничего, 
кроме передачи этого параметра другому методу. Ссылка на метод позволяет нам удалить эту избыточность и вместо этого 
написать следующее:

```
LearnToSpeak learner = System.out::println;
```

Оператор :: указывает Java вызвать метод println() позже. Потребуется некоторое время, чтобы привыкнуть к синтаксису. 
Как только вы это сделаете, вы обнаружите, что ваш код стал короче и менее отвлекающим, не написав столько 
лямбда-выражений.

_Помните, что :: подобен лямбда-выражению и используется для отложенного выполнения с функциональным интерфейсом. Вы 
даже можете представить ссылку на метод в виде лямбда-выражения, если это вам поможет._

Ссылка на метод и лямбда-выражение во время выполнения ведут себя одинаково. Вы можете представить, что компилятор 
превращает ваши ссылки на методы в лямбда-выражения для вас.

Существует четыре формата ссылок на методы:

+ static методы
+ Методы экземпляра для определенного объекта
+ Методы экземпляра для параметра, который должен быть определен во время выполнения
+ Конструкторы

Давайте кратко рассмотрим каждый из них по очереди. В каждом примере мы показываем ссылку на метод и его 
лямбда-эквивалент. А пока создадим отдельный функциональный интерфейс для каждого примера. В следующем разделе мы 
представим встроенные функциональные интерфейсы, чтобы вам не пришлось писать свои собственные.

### Вызов static методов

В первом примере мы используем функциональный интерфейс, который преобразует double в long:

```
interface Converter {
   long round(double num);
}
```

Мы можем реализовать этот интерфейс с помощью метода round() в Math. Здесь мы назначаем этому функциональному интерфейсу 
ссылку на метод и лямбда-выражение:

```
14: Converter methodRef = Math::round;
15: Converter lambda = x -> Math.round(x);
16:
17: System.out.println(methodRef.round(100.1)); // 100
```

В строке 14 мы ссылаемся на метод с одним параметром, а Java знает, что это похоже на лямбда-выражение с одним 
параметром. Кроме того, Java знает, как передать этот параметр методу.

Подождите минуту. Возможно, вы знаете, что метод round() перегружен — он может принимать значения типа double или float. 
Как Java узнает, что мы хотим вызвать версию с double? Как с лямбда-выражениями, так и со ссылками на методы Java 
выводит информацию из контекста. В данном случае мы сказали, что объявляем Converter, у которого есть метод, 
принимающий double параметр. Java ищет метод, соответствующий этому описанию. Если он не может найти его или находит 
несколько совпадений, то компилятор сообщит об ошибке. Последнее иногда называют ошибкой неоднозначного типа.

### Вызов методов экземпляра для определенного объекта

В этом примере наш функциональный интерфейс проверяет, начинается ли String с указанного значения:

```
interface StringStart {
   boolean beginningCheck(String prefix);
}
```

Удобно, что класс String имеет метод startWith(), который принимает один параметр и возвращает boolean значение. 
Давайте посмотрим, как использовать ссылки на методы с этим кодом:

```
18: var str = "Zoo";
19: StringStart methodRef = str::startsWith;
20: StringStart lambda = s -> str.startsWith(s);
21:
22: System.out.println(methodRef.beginningCheck("A")); // false
```

Строка 19 показывает, что мы хотим вызвать str.startsWith() и передать один параметр, который будет предоставлен во 
время выполнения. Это был бы хороший способ фильтрации данных в списке.

Ссылка на метод не должна принимать никаких параметров. В этом примере мы создаем функциональный интерфейс с методом, 
который не принимает никаких параметров, но возвращает значение:

```
interface StringChecker {
   boolean check();
}
```

Мы реализуем это, проверяя, пуста ли String:

```
18: var str = "";
19: StringChecker methodRef = str::isEmpty;
20: StringChecker lambda = () -> str.isEmpty();
21:
22: System.out.print(methodRef.check()); // true
```

Поскольку метод для String является методом экземпляра, мы вызываем ссылку на метод для экземпляра класса String.

Хотя все ссылки на методы можно превратить в лямбда-выражения, обратное не всегда верно. Например, рассмотрим этот код:

```
var str = "";
StringChecker lambda = () -> str.startsWith("Zoo");
```

Как мы могли бы записать это как ссылку на метод? Вы можете попробовать одно из следующих действий:

```
StringChecker methodReference = str::startsWith; // DOES NOT COMPILE

StringChecker methodReference = str::startsWith("Zoo"); // DOES NOT COMPILE
```

Ни одна из этих работ! Хотя мы можем передать str как часть ссылки на метод, мы не можем передать вместе с ним 
параметр «Zoo». Поэтому невозможно записать эту лямбду как ссылку на метод.

### Вызов методов экземпляра для параметра

На этот раз мы собираемся вызвать тот же метод экземпляра, который не принимает никаких параметров. Хитрость в том, что 
мы сделаем это, не зная экземпляра заранее. На этот раз нам нужен другой функциональный интерфейс, так как он должен 
знать о String:

```
interface StringParameterChecker {
   boolean check(String text);
}
```

Мы можем реализовать этот функциональный интерфейс следующим образом:

```
23: StringParameterChecker methodRef = String::isEmpty;
24: StringParameterChecker lambda = s -> s.isEmpty();
25:
26: System.out.println(methodRef.check("Zoo")); // false
```

Строка 23 говорит, что метод, который мы хотим вызвать, объявлен в String. Это похоже на static метод, но это не так. 
Вместо этого Java знает, что isEmpty() — это метод экземпляра, не принимающий никаких параметров. Java использует 
параметр, предоставленный во время выполнения, в качестве экземпляра, для которого вызывается метод.

Сравните строки 23 и 24 со строками 19 и 20 нашего примера. Они выглядят одинаково, хотя один ссылается на локальную 
переменную с именем str, а другой ссылается только на параметры функционального интерфейса.

Вы даже можете комбинировать два типа ссылок на методы экземпляра. Опять же, нам нужен новый функциональный интерфейс, 
который принимает два параметра:

```
interface StringTwoParameterChecker {
   boolean check(String text, String prefix);
}
```

Обратите внимание на порядок параметров при чтении реализации:

```
26: StringTwoParameterChecker methodRef = String::startsWith;
27: StringTwoParameterChecker lambda = (s, p) -> s.startsWith(p);
28:
29: System.out.println(methodRef.check("Zoo", "A")); // false
```

Поскольку функциональный интерфейс принимает два параметра, Java должен выяснить, что они представляют. Первый всегда 
будет экземпляром объекта для методов экземпляра. Любые другие должны быть параметрами метода.

Помните, что строка 26 может выглядеть как static метод, но на самом деле это ссылка на метод, объявляющая, что 
экземпляр объекта будет указан позже. В строке 27 показаны некоторые возможности ссылки на метод. На этот раз мы смогли 
заменить два лямбда-параметра.

### Вызов конструкторов

Ссылка на конструктор — это особый тип ссылки на метод, который использует new вместо метода и создает экземпляр 
объекта. В этом примере наш функциональный интерфейс не будет принимать никаких параметров, а будет возвращать String:

```
interface EmptyStringCreator {
   String create();
}
```

Чтобы вызвать это, мы используем new, как если бы это было имя метода:

```
30: EmptyStringCreator methodRef = String::new;
31: EmptyStringCreator lambda = () -> new String();
32:
33: var myString = methodRef.create();
34: System.out.println(myString.equals("Snake")); // false
```

Он расширяется, как ссылки на методы, которые вы видели до сих пор. В предыдущем примере лямбда-выражение не имеет 
параметров.

Ссылки на методы могут быть сложными. На этот раз мы создаем функциональный интерфейс, который принимает один параметр и 
возвращает результат:

```
interface StringCopier {
   String copy(String value);
}
```

Обратите внимание, что в реализации строка 32 в следующем примере имеет ту же ссылку на метод, что и строка 30 в 
предыдущем примере:

```
32: StringCopier methodRef = String::new;
33: StringCopier lambda = x -> new String(x);
34:
35: var myString = methodRef.copy("Zebra");
36: System.out.println(myString.equals("Zebra")); // true
```

Это означает, что вы не всегда можете определить, какой метод можно вызвать, взглянув на ссылку на метод. Вместо этого 
вы должны смотреть на контекст, чтобы увидеть, какие параметры используются и есть ли возвращаемый тип. В этом примере 
Java видит, что мы передаем параметр String, и вызывает конструктор String, который принимает такой параметр.

### Просмотр ссылок на методы

Чтение ссылок на методы полезно для понимания кода. В таблице 8.3 показаны четыре типа ссылок на методы. Если эта 
таблица не имеет смысла, пожалуйста, перечитайте предыдущий раздел. Может потребоваться несколько попыток, прежде чем 
ссылки на методы начнут складываться.

#### Таблица 8.3 - Ссылки на методы

|                     Тип                     |     Перед двоеточием      | После двоеточия | Пример          |  
|:-------------------------------------------:|:-------------------------:|:---------------:|-----------------|
|                static методы                |        Имя класса         |   Имя метода    | Math::random    |
| Методы экземпляра для определенного объекта | Имя переменной экземпляра |   Имя метода    | str::startsWith |                                     
|       Методы экземпляра для параметра       |        Имя класса         |   Имя метода    | String::isEmpty |
|                Конструктор                  |        Имя класса         |       new       | String::new     |


## Работа со встроенными функциональными интерфейсами

Было бы неудобно писать свой собственный функциональный интерфейс каждый раз, когда вы хотите написать лямбда. 
К счастью, вам предоставляется большое количество функциональных интерфейсов общего назначения. Мы рассмотрим их в этом 
разделе.

Основные функциональные интерфейсы в таблице 8.4 предоставляются в пакете java.util.function. Мы рассмотрим дженерики в 
следующей главе, а сейчас вам просто нужно знать, что <T> позволяет интерфейсу принимать объект указанного типа. Если 
необходим параметр второго типа, мы используем следующую букву, U. Если необходим отдельный тип возвращаемого значения, 
мы выбираем R для возвращаемого значения в качестве универсального типа.

#### Таблица 8.4 - Общие функциональные интерфейсы

| Функциональный интерфейс | Тип возвращаемого значения | Имя метода  | Количество параметров |  
|:------------------------:|:--------------------------:|:-----------:|:---------------------:|
|       Supplier<T>        |             T              |    get()    |           0           |
|       Consumer<T>        |            void            |  accept(T)  |         1 (T)         |                                     
|     BiConsumer<T, U>     |            void            | accept(T,U) |       2 (T, U)        |
|       Predicate<T>       |          boolean           |   test(T)   |         1 (T)         |
|    BiPredicate<T, U>     |          boolean           |  test(T,U)  |       2 (T, U)        |
|      Function<T, R>      |             R              |  apply(T)   |         1 (T)         |
|   BiFunction<T, U, R>    |             R              | apply(T,U)  |       2 (T, U)        |
|     UnaryOperator<T>     |             T              |  apply(T)   |         1 (T)         |
|    BinaryOperator<T>     |             T              | apply(T,T)  |       2 (T, T)        |


Для экзамена вам необходимо выучить таблицу 8.4. Мы дадим вам много практики в этом разделе, чтобы сделать его 
запоминающимся. Прежде чем вы спросите, большую часть времени мы не присваиваем реализацию интерфейса переменной. Имя 
интерфейса подразумевается и передается непосредственно в метод, который в нем нуждается. Мы вводим имена, чтобы вы 
могли лучше понять и запомнить, что происходит. К следующей главе мы будем считать, что вы это сделали, и перестанем 
создавать промежуточную переменную.

_Далее в книге вы узнаете о еще нескольких функциональных интерфейсах. В следующей главе мы рассмотрим Comparator. В 
главе 13 «Параллелизм» мы обсуждаем Runnable и Callable. Они могут появиться на экзамене, когда вас попросят распознать 
функциональные интерфейсы._

Давайте посмотрим, как реализовать каждый из этих интерфейсов. Поскольку и лямбда-выражения, и ссылки на методы 
встречаются повсюду в экзамене, мы показываем реализацию, где возможно используются и то, и другое. После представления 
интерфейсов мы также рассмотрим некоторые удобные методы, доступные в этих интерфейсах.

### Реализация Supplier

Supplier используется, когда вы хотите сгенерировать или предоставить значения без каких-либо входных данных. Интерфейс 
Supplier определяется следующим образом:

```
@FunctionalInterface
public interface Supplier<T> {
   T get();
}
```

Вы можете создать объект LocalDate, используя фабричный метод now(). В этом примере показано, как использовать Supplier 
для вызова этой фабрики:

```
Supplier<LocalDate> s1 = LocalDate::now;
Supplier<LocalDate> s2 = () -> LocalDate.now();

LocalDate d1 = s1.get();
LocalDate d2 = s2.get();

System.out.println(d1); // 2022-02-20
System.out.println(d2); // 2022-02-20
```

В этом примере дата печатается дважды. Это также хорошая возможность просмотреть ссылки на static методы. Ссылка на 
метод LocalDate::now используется для создания Supplier для назначения промежуточной переменной s1. Supplier часто 
используется при создании новых объектов. Например, мы можем напечатать два пустых объекта StringBuilder:

```
Supplier<StringBuilder> s1 = StringBuilder::new;
Supplier<StringBuilder> s2 = () -> new StringBuilder();

System.out.println(s1.get()); // Empty string
System.out.println(s2.get()); // Empty string
```

На этот раз мы использовали ссылку на конструктор для создания объекта. Мы использовали дженерики, чтобы объявить, 
какой тип Supplier мы используем. Это может быть немного долго читать. Можете ли вы понять, что делает следующее? 
Просто делайте это по одному шагу за раз:

```
Supplier<ArrayList<String>> s3 = ArrayList::new;
ArrayList<String> a1 = s3.get();
System.out.println(a1); // []
```

У нас есть Supplier определенного типа. Этот тип оказывается ArrayList<String>. Затем вызов get() создает новый 
экземпляр ArrayList<String>, который является универсальным типом Supplier, другими словами, универсальным, 
содержащим другой универсальный тип. Обязательно внимательно посмотрите на код, когда возникнет такая вещь.

Обратите внимание, как мы вызвали get() в функциональном интерфейсе. Что произойдет, если мы попытаемся 
распечатать сам s3?

```
System.out.println(s3);
```

Код печатает примерно следующее:

```
functionalinterface.BuiltIns$$Lambda$1/0x0000000800066840@4909b8da
```

Это результат вызова toString() для лямбды. Фу. Это действительно что-то значит. Наш тестовый класс называется 
BuiltIns, и он находится в созданном нами пакете с именем функциональный интерфейс. Затем идет $$, что означает, что 
класс не существует в файле класса в файловой системе. Он существует только в памяти. Вам не нужно беспокоиться об 
остальном.

### Реализация Consumer и BiConsumer

Вы используете Consumer, когда хотите что-то сделать с параметром, но ничего не возвращать. BiConsumer делает то же 
самое, за исключением того, что принимает два параметра. Интерфейсы определяются следующим образом:

```
@FunctionalInterface
public interface Consumer<T> {
   void accept(T t);
   // omitted default method
}

@FunctionalInterface
public interface BiConsumer<T, U> {
   void accept(T t, U u);
   // omitted default method
}
```

_Вы заметите эту закономерность. Bi означает два. Оно пришло из латыни, но вы можете запомнить его из английских слов, 
таких как двоичный (binary) (0 или 1) или велосипед (bicycle) (два колеса). Всегда добавляйте еще один параметр, 
когда видите Bi._

Печать — это обычное использование интерфейса Consumer:

```
Consumer<String> c1 = System.out::println;
Consumer<String> c2 = x -> System.out.println(x);

c1.accept("Annie"); // Annie
c2.accept("Annie"); // Annie
```

BiConsumer вызывается с двумя параметрами. Они не должны быть одного типа. Например, мы можем поместить ключ и значение 
на карту, используя этот интерфейс:

```
var map = new HashMap<String, Integer>();
BiConsumer<String, Integer> b1 = map::put;
BiConsumer<String, Integer> b2 = (k, v) -> map.put(k, v);

b1.accept("chicken", 7);
b2.accept("chick", 1);

System.out.println(map); // {chicken=7, chick=1}
```

Вывод {chicken=7, chick=1} показывает, что были вызваны обе реализации BiConsumer. При объявлении b1 мы использовали 
ссылку на метод экземпляра объекта, поскольку мы хотим вызвать метод на локальной переменной map. Код для создания 
экземпляра b1 немного короче, чем код для b2. Наверное, поэтому на экзамене так любят ссылки на методы.

В качестве другого примера мы используем один и тот же тип для обоих общих параметров:

```
var map = new HashMap<String, String>();
BiConsumer<String, String> b1 = map::put;
BiConsumer<String, String> b2 = (k, v) -> map.put(k, v);

b1.accept("chicken", "Cluck");
b2.accept("chick", "Tweep");

System.out.println(map); // {chicken=Cluck, chick=Tweep}
```

Это показывает, что BiConsumer может использовать один и тот же тип для общих параметров T и U.

### Реализация Predicate и BiPredicate

Predicate часто используется при фильтрации или сопоставлении. Обе операции являются обычными. BiPredicate похож на 
Predicate, за исключением того, что он принимает два параметра вместо одного. Интерфейсы определяются следующим образом:

```
@FunctionalInterface
public interface Predicate<T> {
boolean test(T t);
// omitted default and static methods
}

@FunctionalInterface
public interface BiPredicate<T, U> {
boolean test(T t, U u);
// omitted default methods
}
```

Вы можете использовать Predicate для проверки условия.

```
Predicate<String> p1 = String::isEmpty;
Predicate<String> p2 = x -> x.isEmpty();

System.out.println(p1.test("")); // true
System.out.println(p2.test("")); // true
```

Это печатает true дважды. Более интересным является BiPredicate. Этот пример также печатает true дважды:

```
BiPredicate<String, String> b1 = String::startsWith;
BiPredicate<String, String> b2 =
   (string, prefix) -> string.startsWith(prefix);

System.out.println(b1.test("chicken", "chick")); // true
System.out.println(b2.test("chicken", "chick")); // true
```

Ссылка на метод включает как переменную экземпляра, так и параметр для startWith(). Это хороший пример того, как ссылки 
на методы экономят много времени. Недостатком является то, что они менее явные, и вам действительно нужно понимать, 
что происходит!

### Реализация Function и BiFunction

Function отвечает за превращение одного параметра в значение потенциально другого типа и его возврат. Точно так же 
BiFunction отвечает за преобразование двух параметров в значение и его возврат. Интерфейсы определяются следующим 
образом:

```
@FunctionalInterface
public interface Function<T, R> {
R apply(T t);
// omitted default and static methods
}

@FunctionalInterface
public interface BiFunction<T, U, R> {
R apply(T t, U u);
// omitted default method
}
```

Например, эта функция преобразует String в длину String:

```
Function<String, Integer> f1 = String::length;
Function<String, Integer> f2 = x -> x.length();

System.out.println(f1.apply("cluck")); // 5
System.out.println(f2.apply("cluck")); // 5
```

Эта функция превращает String в Integer. Ну, технически это превращает String в int, который автоматически упаковывается
в Integer. Типы не должны быть разными. Следующее объединяет два объекта String и создает еще одну строку:

```
BiFunction<String, String, String> b1 = String::concat;
BiFunction<String, String, String> b2 =
(string, toAdd) -> string.concat(toAdd);

System.out.println(b1.apply("baby ", "chick")); // baby chick
System.out.println(b2.apply("baby ", "chick")); // baby chick
```

Первые два типа в BiFunction являются входными типами. Третий тип результата. Для ссылки на метод первый параметр — это 
экземпляр, для которого вызывается concat(), а второй передается в concat().

### Реализация UnaryOperator и BinaryOperator

UnaryOperator и BinaryOperator являются частными случаями Function. Они требуют, чтобы все параметры типа были одного 
типа. UnaryOperator преобразует свое значение в значение того же типа. Например, увеличение на единицу — это унарная 
операция. По сути, UnaryOperator расширяет Function. BinaryOperator объединяет два значения в одно одного типа. Сложение 
двух чисел является бинарной операцией. Точно так же BinaryOperator расширяет BiFunction. Интерфейсы определяются 
следующим образом:

```
@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {
   // omitted static method
}

@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T, T, T> {
   // omitted static methods
}
```

Это означает, что сигнатуры методов выглядят так:

```
T apply(T t); // UnaryOperator

T apply(T t1, T t2); // BinaryOperator
```

В Javadoc вы заметите, что эти методы унаследованы от суперкласса Function/BiFunction. Общие объявления в подклассе 
заставляют тип быть одинаковым. В унарном примере обратите внимание, что тип возвращаемого значения совпадает с типом 
параметра.

```
UnaryOperator<String> u1 = String::toUpperCase;
UnaryOperator<String> u2 = x -> x.toUpperCase();

System.out.println(u1.apply("chirp")); // CHIRP
System.out.println(u2.apply("chirp")); // CHIRP
```

Это печатает CHIRP дважды. Нам не нужно указывать возвращаемый тип в дженериках, потому что UnaryOperator требует, 
чтобы он совпадал с параметром. А теперь бинарный пример:

```
BinaryOperator<String> b1 = String::concat;
BinaryOperator<String> b2 = (string, toAdd) -> string.concat(toAdd);

System.out.println(b1.apply("baby ", "chick")); // baby chick
System.out.println(b2.apply("baby ", "chick")); // baby chick
```

Обратите внимание, что это делает то же самое, что и пример BiFunction. Код стал более лаконичным, что показывает 
важность использования лучшего функционального интерфейса. Удобно иметь один общий тип вместо трех.

### Проверка функциональных интерфейсов

Очень важно знать количество параметров, типов, возвращаемого значения и имени метода для каждого из функциональных 
интерфейсов. Сейчас самое время запомнить таблицу 8.4, если вы еще этого не сделали. Давайте сделаем несколько примеров 
для практики.

Какой функциональный интерфейс вы бы использовали в этих трех ситуациях?

+ Возвращает String без каких-либо параметров
+ Возвращает Boolean значение и принимает String
+ Возвращает Integer и принимает два Integers

Готовы? Подумайте, каковы ваши ответы, прежде чем продолжить. Действительно. Вы должны знать этот холод. Хорошо. 
Первый — это Supplier<String>, поскольку он создает объект и не принимает никаких параметров. Второй — это 
Function<String,Boolean>, поскольку он принимает один параметр и возвращает другой тип. Это немного сложно. 
Вы можете подумать, что это Predicate<String>. Обратите внимание, что Predicate возвращает boolean примитив, а не 
Boolean объект.

Наконец, третий — это либо BinaryOperator<Integer>, либо BiFunction<Integer,Integer,Integer>. Поскольку BinaryOperator 
является частным случаем BiFunction, любой из них является правильным ответом. BinaryOperator<Integer> — лучший ответ 
из двух, поскольку он более конкретен.

Давайте попробуем это упражнение еще раз, но уже с кодом. С кодом сложнее. Первое, что вы делаете, это смотрите, 
сколько параметров принимает лямбда и есть ли возвращаемое значение. Какой функциональный интерфейс вы бы использовали, 
чтобы заполнить пробелы для них?

```
6: ______ <List> ex1 = x -> "".equals(x.get(0));
7: ______ <Long> ex2 = (Long l) -> System.out.println(l);
8: ______ <String, String> ex3 = (s1, s2) -> false;
```

Опять же, подумайте над ответами, прежде чем продолжить. Готовый? Строка 6 передает один параметр List в 
лямбда-выражение и возвращает boolean значение. Это говорит нам, что это Predicate или Function. Поскольку универсальное 
объявление имеет только один параметр, это Predicate.

Строка 7 передает один Long параметр в лямбда-выражение и ничего не возвращает. Это говорит нам о том, что это Consumer. 
Строка 8 принимает два параметра и возвращает boolean значение. Когда вы видите возвращаемое boolean значение, подумайте 
о Predicate, если дженерики не указывают тип возвращаемого значения Boolean. В данном случае есть два параметра, так что 
это BiPredicate.

Вы находите это легким? Если нет, просмотрите Таблицу 8.4 еще раз. Мы не шутим. Таблицу нужно хорошо знать. Теперь, 
когда вы только что изучили таблицу, мы поиграем в «найди ошибку». Они должны быть сложными:

```
6: Function<List<String>> ex1 = x -> x.get(0); // DOES NOT COMPILE
7: UnaryOperator<Long> ex2 = (Long l) -> 3.14; // DOES NOT COMPILE
```

Строка 6 утверждает, что это Function. Function должна указать два универсальных типа: тип входного параметра и тип 
возвращаемого значения. В строке 6 отсутствует тип возвращаемого значения, из-за чего код не компилируется. Строка 7 
представляет собой UnaryOperator, который возвращает тот же тип, что и переданный. Пример возвращает значение типа 
double, а не тип Long, из-за чего код не компилируется.

### Использование удобных методов в функциональных интерфейсах

По определению все функциональные интерфейсы имеют один абстрактный метод. Однако это не означает, что у них может быть 
только один метод. Несколько общих функциональных интерфейсов предоставляют ряд полезных default методов интерфейса.

В таблице 8.5 показаны удобные методы встроенных функциональных интерфейсов, которые вам необходимо знать для экзамена. 
Все это облегчает изменение или объединение функциональных интерфейсов одного типа. Обратите внимание, что в 
таблице 8.5 показаны только основные интерфейсы. Интерфейсы BiConsumer, BiFunction и BiPredicate имеют аналогичные 
доступные методы.

#### Таблица 8.5 - Удобные методы

| Экземпляр интерфейса | Тип возвращаемого значения метода | Имя метода | Параметры метода |  
|:--------------------:|:---------------------------------:|:----------:|:----------------:|
|       Consumer       |             Consumer              | andThen()  |     Consumer     |
|       Function       |             Function              | andThen()  |     Function     |                                     
|       Function       |             Function              | compose()  |     Function     |
|      Predicate       |             Predicate             |   and()    |    Predicate     |
|      Predicate       |             Predicate             |  negate()  |        —         |
|      Predicate       |             Predicate             |   or()     |   Predicate      |

Начнем с этих двух переменных Predicate:

```
Predicate<String> egg = s -> s.contains("egg");
Predicate<String> brown = s -> s.contains("brown");
```

Теперь нам нужен Predicate для коричневых яиц и еще один для яиц всех других цветов. Мы могли бы написать это вручную, 
как показано здесь:

```
Predicate<String> brownEggs = s -> s.contains("egg") && s.contains("brown");
Predicate<String> otherEggs = s -> s.contains("egg") && !s.contains("brown");
```

Это работает, но это не здорово. Это немного длинно для чтения, и оно содержит дублирование. Что, если мы решим, что 
буква «е» должна быть написана с большой буквы в слове «яйцо»? Нам пришлось бы изменить его в трех переменных: egg, 
brownEggs и otherEggs. Лучший способ справиться с этой ситуацией — использовать два default метода в Predicate.

```
Predicate<String> brownEggs = egg.and(brown);
Predicate<String> otherEggs = egg.and(brown.negate());
```

Аккуратный! Теперь мы повторно используем логику исходных переменных Predicate для создания двух новых. Так короче и 
понятнее, какая связь между переменными. Мы также можем изменить написание egg в одном месте, и два других объекта будут 
иметь новую логику, поскольку они ссылаются на него.

Переходя к Consumer, давайте взглянем на метод andThen(), который последовательно запускает два функциональных 
интерфейса:

```
Consumer<String> c1 = x -> System.out.print("1: " + x);
Consumer<String> c2 = x -> System.out.print(",2: " + x);

Consumer<String> combined = c1.andThen(c2);
combined.accept("Annie"); // 1: Annie,2: Annie
```

Обратите внимание, как один и тот же параметр передается как c1, так и c2. Это показывает, что экземпляры Consumer 
запускаются последовательно и не зависят друг от друга. В отличие от этого, метод compose() в Function связывает 
функциональные интерфейсы. Однако он проходит по выходу одного на вход другого.

```
Function<Integer, Integer> before = x -> x + 1;
Function<Integer, Integer> after = x -> x * 2;

Function<Integer, Integer> combined = after.compose(before);
System.out.println(combined.apply(3)); // 8
```

На этот раз сначала запускается метод before, превращая 3 в 4. Затем запускается after, удваивая 4 до 8. Все методы в 
этом разделе полезны для упрощения кода при работе с функциональными интерфейсами.

### Изучение функциональных интерфейсов для примитивов

Помните, мы говорили вам запомнить таблицу 8.4 с общими функциональными интерфейсами? Вы? Если вы этого не сделали, 
сделайте это сейчас. Мы подождем. Мы собираемся сделать его более активным. Также существует большое количество 
специальных функциональных интерфейсов для примитивов. Они пригодятся в главе 10, когда мы будем рассматривать 
потоки и опции.

Большинство из них предназначены для типов double, int и long. Есть одно исключение — BooleanSupplier. Мы рассмотрим 
это, прежде чем представить функциональные интерфейсы для double, int и long.

#### Функциональные интерфейсы для boolean

BooleanSupplier — это отдельный тип. Он имеет один метод для реализации:

```
@FunctionalInterface
public interface BooleanSupplier {
   boolean getAsBoolean();
}
```

Он работает именно так, как вы ожидаете от функциональных интерфейсов. Вот пример:

```
12: BooleanSupplier b1 = () -> true;
13: BooleanSupplier b2 = () -> Math.random()> .5;
14: System.out.println(b1.getAsBoolean()); // true
15: System.out.println(b2.getAsBoolean()); // false
```

Каждая из строк 12 и 13 создает BooleanSupplier, который является единственным функциональным интерфейсом для 
boolean значения. Строка 14 выводит true, так как это результат b1. Строка 15 выводит true или false в зависимости от 
сгенерированного случайного значения.

#### Функциональные интерфейсы для double, int и long

Большинство функциональных интерфейсов предназначены для типов double, int и long. Таблица 8.6 показывает эквивалент 
таблицы 8.4 для этих примитивов. Вы, вероятно, не удивитесь, что вам придется запоминать его. К счастью, вы уже выучили 
таблицу 8.4 и можете применить полученные знания к таблице 8.6.

#### Таблица 8.6 - Общие функциональные интерфейсы для примитивов

|                     Функциональные интерфейсы                      |     Возвращаемый тип     |        Единственный абстрактный метод         |                      # параметров                      |  
|:------------------------------------------------------------------:|:------------------------:|:---------------------------------------------:|:------------------------------------------------------:|
|          DoubleSupplier<br/>IntSupplier<br/>LongSupplier           | double<br/>int<br/>long  |    getAsDouble<br/>getAsInt<br/>getAsLong     |                           0                            |
|          DoubleConsumer<br/>IntConsumer<br/>LongConsumer           |           void           |                    accept                     |          1 (double)<br/>1 (int)<br/>1 (long)           |                                     
|         DoublePredicate<br/>IntPredicate<br/>LongPredicate         |         boolean          |                     test                      |          1 (double)<br/>1 (int)<br/>1 (long)           |
|      DoubleFunction<R><br/>IntFunction<R><br/>LongFunction<R>      |            R             |                     apply                     |          1 (double)<br/>1 (int)<br/>1 (long)           |
|   DoubleUnaryOperator<br/>IntUnaryOperator<br/>LongUnaryOperator   | double<br/>int<br/>long  | applyAsDouble<br/>applyAsInt<br/>applyAsLong  |          1 (double)<br/>1 (int)<br/>1 (long)           |
| DoubleBinaryOperator<br/>IntBinaryOperator<br/>LongBinaryOperator  | double<br/>int<br/>long  | applyAsDouble<br/>applyAsInt<br/>applyAsLong  | 2 (double, double)<br/>2 (int, int)<br/>2 (long, long) |

Обратите внимание на несколько моментов, которые отличаются между таблицей 8.4 и таблицей 8.6:

+ Обобщения исчезли из некоторых интерфейсов, и вместо этого имя типа сообщает нам, какой примитивный тип задействован. 
В других случаях, таких как IntFunction, требуется только возвращаемый тип generic, потому что мы преобразовываем 
примитивное целое в объект.

+ Единственный абстрактный метод часто переименовывается, когда возвращается примитивный тип.

Помимо эквивалентов из таблицы 8.4, некоторые интерфейсы специфичны для примитивов. В таблице 8.7 они перечислены.

Мы уже давно используем функциональные интерфейсы, поэтому вы должны хорошо понимать, как читать таблицу. Давайте 
сделаем один пример, чтобы быть уверенным. Какой функциональный интерфейс вы бы использовали, чтобы заполнить пробел, 
чтобы компилировать следующий код?

```
var d = 1.0;
_____________ f1 = x -> 1;
f1.applyAsInt(d);
```

Когда вы видите подобный вопрос, ищите подсказки. Вы можете видеть, что рассматриваемый функциональный интерфейс 
принимает double параметр и возвращает int. Вы также можете видеть, что у него есть единственный абстрактный метод с 
именем applyAsInt. Функциональные интерфейсы DoubleToIntFunction и ToIntFunction соответствуют всем трем этим критериям.

## Работа с переменными в лямбда-выражениях

Теперь, когда мы узнали о функциональных интерфейсах, мы будем использовать их, чтобы показать различные подходы к 
переменным. Они могут появляться в трех местах по отношению к лямбда-выражениям: список параметров, локальные 
переменные, объявленные внутри тела лямбда-выражения, и переменные, на которые ссылается тело лямбда-выражения. Все три 
из них - возможности для того, чтобы экзамен обманул вас. Мы изучаем каждый из них, чтобы вы были начеку, когда появятся 
трюки!

#### Таблица 8.7 - Функциональные интерфейсы для примитивов

|                                                         Функциональные интерфейсы                                                         |                  Возвращаемый тип                   |                                   Единственный абстрактный метод                                   |                                # параметров                                 |  
|:-----------------------------------------------------------------------------------------------------------------------------------------:|:---------------------------------------------------:|:--------------------------------------------------------------------------------------------------:|:---------------------------------------------------------------------------:|
|                                      ToDoubleFunction<T><br/>ToIntFunction<T><br/>ToLongFunction<T>                                       |               double<br/>int<br/>long               |                            applyAsDouble<br/>applyAsInt<br/>applyAsLong                            |                                    1 (T)                                    |
|                               ToDoubleBiFunction<T, U><br/>ToIntBiFunction<T, U><br/>ToLongBiFunction<T, U>                               |               double<br/>int<br/>long               |                            applyAsDouble<br/>applyAsInt<br/>applyAsLong                            |                                  2 (T, U)                                   |                                     
| DoubleToIntFunction<br/>DoubleToLongFunction<br/>IntToDoubleFunction<br/>IntToLongFunction<br/>LongToDoubleFunction<br/>LongToIntFunction | int<br/>long<br/>double<br/>long<br/>double<br/>int | applyAsInt<br/>applyAsLong<br/>applyAsDouble<br/>applyAsLong<br/>applyAsDouble<br/>applyAsInt<br/> | 1 (double)<br/>1 (double)<br/>1 (int)<br/>1 (int)<br/>1 (long)<br/>1 (long) |
|                                    ObjDoubleConsumer<T><br/>ObjIntConsumer<T><br/>ObjLongConsumer<T>                                      |                        void                         |                                              accept                                                |                2 (T, double)<br/>2 (T, int)<br/>2 (T, long)                 |

### Список параметров

Ранее в этой главе вы узнали, что указывать тип параметров необязательно. Кроме того, вместо определенного типа можно 
использовать var. Это означает, что все три этих утверждения взаимозаменяемы:

```
Predicate<String> p = x -> true;
Predicate<String> p = (var x) -> true;
Predicate<String> p = (String x) -> true;
```

Экзамен может попросить вас указать тип лямбда-параметра. В нашем примере ответом является String. Как мы это поняли? 
Лямбда выводит типы из окружающего контекста. Это означает, что вы можете сделать то же самое.

В этом случае лямбда присваивается Predicate, который принимает String. Еще одно место для поиска типа — сигнатура 
метода. Давайте попробуем другой пример. Можете ли вы определить тип x?

```
public void whatAmI() {
   consume((var x) -> System.out.print(x), 123);
}

public void consume(Consumer<Integer> c, int num) {
   c.accept(num);
}
```

Если вы угадали Integer, вы были правы. Метод whatAmI() создает лямбда-выражение, которое передается методу consume(). 
Поскольку метод consumer() ожидает Integer в качестве универсального, мы знаем, что именно таким будет предполагаемый 
тип x.

Но ждать; есть больше. В некоторых случаях можно определить тип, даже не видя сигнатуры метода. Как вы думаете, какой 
здесь тип x?

```
public void counts(List<Integer> list) {
   list.sort((var x, var y) -> x.compareTo(y));
}
```

Ответ снова Integer. Поскольку мы сортируем список, мы можем использовать тип списка для определения типа параметра 
лямбда.

Поскольку параметры лямбда аналогичны параметрам метода, к ним можно добавлять модификаторы. В частности, вы можете 
добавить модификатор final или аннотацию, как показано в этом примере:

```
public void counts(List<Integer> list) {
   list.sort((final var x, @Deprecated var y) -> x.compareTo(y));
}
```

Хотя это, как правило, редкость в реальной жизни, известно, что подобные модификаторы появляются при сдаче экзамена.

_Форматы списка параметров_

У вас есть три формата для указания типов параметров в лямбде: без типов, с типами и с var. Компилятор требует, чтобы 
все параметры в лямбде использовали один и тот же формат. Вы видите, почему следующее недействительно?

```
5: (var x, y) -> "Hello" // DOES NOT COMPILE
6: (var x, Integer y) -> true // DOES NOT COMPILE
7: (String x, var y, Integer z) -> true // DOES NOT COMPILE
8: (Integer x, y) -> "goodbye" // DOES NOT COMPILE
```

В строках 5 необходимо удалить var из x или добавить его в y. Далее, в строках 6 и 7 необходимо последовательно 
использовать тип или var. Наконец, в строке 8 необходимо удалить Integer из x или добавить тип к y.

### Использование локальных переменных внутри лямбда-выражения

Хотя тело лямбда-выражения чаще всего представляет собой одно выражение, допустимо определить блок. В этом блоке может 
быть все, что допустимо в обычном блоке Java, включая объявления локальных переменных.

Следующий код делает именно это. Он создает локальную переменную с именем c, которая привязана к лямбда-блоку:

```
(a, b) -> { int c = 0; return 5; }
```

Теперь попробуем другой. Вы видите, что здесь не так?

```
(a, b) -> { int a = 0; return 5; } // DOES NOT COMPILE
```

Мы попытались повторно объявить a, что не разрешено. Java не позволяет создавать локальную переменную с тем же именем, 
что и уже объявленная в этой области. Хотя в реальной жизни такие ошибки встречаются реже, известно, что они появляются 
на экзамене!

Теперь попробуем посложнее. Сколько синтаксических ошибок вы видите в этом методе?

```
11: public void variables(int a) {
12:    int b = 1;
13:    Predicate<Integer> p1 = a -> {
14:       int b = 0;
15:       int c = 0;
16:       return b == c; }
17: }
```

Три синтаксических ошибки. Первый находится в строке 13. Переменная a уже использовалась в этой области видимости в 
качестве параметра метода, поэтому ее нельзя использовать повторно. Следующая синтаксическая ошибка возникает в 
строке 14, где код пытается повторно объявить локальную переменную b. Третья синтаксическая ошибка довольно незаметна 
и находится в строке 16. Видите? Посмотрите очень внимательно.

В переменной p1 отсутствует точка с запятой в конце. Перед } стоит точка с запятой, но она находится внутри блока. 
Хотя обычно вам не нужно искать отсутствующие точки с запятой, лямбда-выражения в этом месте сложны, так что 
будьте осторожны!

_Держите ваши лямбда-выражения короткими_

Наличие лямбда-выражения с несколькими строками и оператором return часто является подсказкой о том, что вам следует 
провести рефакторинг и поместить этот код в метод. Например, предыдущий пример можно было бы переписать как

```
Predicate<Integer> p1 = a -> returnSame(a);
```

Эта более простая форма может быть подвергнута дальнейшему рефакторингу для использования ссылки на метод:

```
Predicate<Integer> p1 = this::returnSame;
```

Вам может быть интересно, почему это так важно. В главе 10 лямбда-выражения и ссылки на методы используются в 
цепочках вызовов методов. Чем короче лямбда, тем легче читать код.

### Ссылки на переменные из тела лямбда-выражения

В телах лямбда разрешено ссылаться на некоторые переменные из окружающего кода. Следующий код допустим:

```
public class Crow {
   private String color;
   public void caw(String name) {
      String volume = "loudly";
      Consumer<String> consumer = s ->
            System.out.println(name + " says "
                  + volume + " that she is " + color);
   }
}
```

Это показывает, что лямбда может получить доступ к переменной экземпляра, параметру метода или локальной переменной при 
определенных условиях. Переменные экземпляра (и переменные класса) всегда разрешены.

Единственное, к чему лямбда-выражения не могут получить доступ, — это переменные, которые не являются окончательными 
или фактически окончательными. Если вам нужно освежить в памяти эффективный финал, см. главу 5, «Методы».

Становится еще интереснее, когда вы смотрите на то, где возникают ошибки компилятора, когда переменные не являются 
фактически окончательными.

```
2: public class Crow {
3:    private String color;
4:    public void caw(String name) {
5:       String volume = "loudly";
6:       name = "Caty";
7:       color = "black";
8:
9:       Consumer<String> consumer = s ->
10:         System.out.println(name + " says " // DOES NOT COMPILE
11:            + volume + " that she is " + color); // DOES NOT COMPILE
12:      volume = "softly";
13:   }
14: }
```

В этом примере name параметра метода не является фактически окончательным, поскольку оно установлено в строке 6. Однако 
ошибка компилятора возникает в строке 10. Присвоить значение нефинальной переменной не проблема. Однако, как только 
лямбда попытается его использовать, у нас действительно возникнет проблема. Переменная больше не является 
окончательной, поэтому лямбда не может использовать эту переменную.

Переменная volume также не является окончательной, поскольку она обновляется в строке 12. В этом случае ошибка 
компилятора находится в строке 11. Это до переназначения! Опять же, акт присвоения значения является проблемой только 
с точки зрения лямбды. Следовательно, лямбда должна генерировать ошибку компилятора.

Для повторения убедитесь, что вы запомнили таблицу 8.8.

#### Таблица 8.7 - Функциональные интерфейсы для примитивов

|    Тип переменной     |                      Правило                       |
|:---------------------:|:--------------------------------------------------:|
| Переменная экземпляра |                     Допустимый                     |
|   static переменная   |                     Допустимый                     |
| Локальная переменная  | Разрешено, если final или фактически окончательный |
|    Параметр метода    | Разрешено, если final или фактически окончательный |
|    Лямбда-параметр    |                     Допустимый                     |

## Summary


