# Коллекции и дженерики

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Работа с массивами и коллекциями

+ Создавайте массивы Java, коллекции List, Set, Map и Deque, а также добавляйте, удаляйте, обновляйте, извлекайте и 
сортируйте их элементы.

---

В этой главе мы представляем классы и интерфейсы Java Collections Framework, которые вам необходимо знать для сдачи 
экзамена. Потокобезопасные типы коллекций обсуждаются в главе 13 «Параллелизм». Как вы, возможно, помните из главы 8 
«Лямбды и функциональные интерфейсы», мы рассмотрели лямбды, ссылки на методы и встроенные функциональные интерфейсы. 
Многие из них используются в этой главе. Если функциональные интерфейсы вам незнакомы, вернитесь и просмотрите 
Таблицу 8.4. Далее мы подробно расскажем о Comparator и Comparable. Наконец, мы обсудим, как создавать собственные 
классы и методы, использующие дженерики, чтобы один и тот же класс можно было использовать со многими типами.

## Использование API общей коллекции

Коллекция — это группа объектов, содержащихся в одном объекте. Java Collections Framework — это набор классов в 
java.util для хранения коллекций. В Java Collections Framework имеется четыре основных интерфейса.

+ List (Список): Список представляет собой упорядоченный набор элементов, допускающий дублирование записей. Доступ к 
элементам списка возможен по индексу int.
+ Set (Набор): Set — это коллекция, в которой не допускается дублирование записей.
+ Queue (Очередь): Queue — это коллекция, которая упорядочивает свои элементы в определенном порядке для обработки. 
Deque — это подинтерфейс Queue, который обеспечивает доступ на обоих концах.
+ Map (Карта): Map — это коллекция, которая сопоставляет ключи со значениями, дублирование ключей не допускается. 
Элементы карты представляют собой пары ключ/значение.

На рисунке 9.1 показан интерфейс Collection, его подинтерфейсы и некоторые классы, реализующие интерфейсы, которые 
вам следует знать для экзамена. Интерфейсы показаны в прямоугольниках, а классы — в закругленных прямоугольниках.

Обратите внимание, что Map не реализует интерфейс Collection. Он считается частью Java Collections Framework, хотя 
технически он не является Collection. Однако это коллекция (обратите внимание на строчные буквы), поскольку она содержит 
группу объектов. Причина, по которой карты обрабатываются по-разному, заключается в том, что им нужны разные методы, 
поскольку они представляют собой пары ключ/значение.

#### Рис. 9.1 - Java Collections Framework

В этом разделе мы обсудим общие методы, которые API коллекций предоставляет реализующим классам. Многие из этих методов 
представляют собой _удобные методы_, которые можно реализовать другими способами, но которые упрощают написание и чтение 
кода. Именно поэтому они удобны.

В этом разделе мы используем ArrayList и HashSet в качестве классов реализации, но они могут применяться к любому 
классу, наследующему интерфейс Collection. В следующем разделе мы рассмотрим конкретные свойства каждого класса 
Collection.

### Использование diamond оператора

При создании Java Collections Framework вам необходимо указать тип, который будет входить внутрь. Мы могли бы написать 
код, используя дженерики, подобные следующему:

```
List<Integer> list = new ArrayList<Integer>();
```

У вас могут даже быть дженерики, содержащие другие дженерики, например этот:

```
Map<Long,List<Integer>> mapLists = new HashMap<Long,List<Integer>>();
```

Нужно написать много дублированного кода! К счастью, оператор ромба (diamond operator) (<>) — это сокращенная запись, 
позволяющая опустить общий тип в правой части оператора, когда тип можно вывести. Он называется оператором ромба, потому 
что <> выглядит как ромб. Сравните предыдущие объявления с этими новыми, гораздо более короткими версиями:

```
List<Integer> list = new ArrayList<>(); 
Map<Long,List<Integer>> mapOfLists = new HashMap<>();
```

Для компилятора оба этих объявления и наши предыдущие эквивалентны. Однако для нас последний вариант намного короче и 
его легче читать.

Оператор ромба нельзя использовать в качестве типа в объявлении переменной. Его можно использовать только в правой части 
операции присваивания. Например, ни одно из следующих действий не компилируется:

```
List<> list = new ArrayList<Integer>();      // НЕ КОМПИЛИРУЕТСЯ

class InvalidUse {
    void use(List<> data) {}                 // НЕ КОМПИЛИРУЕТСЯ
}
```

### Добавление данных

Метод add() вставляет новый элемент в коллекцию и возвращает информацию о том, был ли он успешным. Сигнатура метода 
следующая:

```
public boolean add(E element)
```

Помните, что Collections Framework использует дженерики. Вы будете часто видеть, как буква E появляется. Это означает
универсальный тип, который использовался для создания коллекции. Для некоторых типов коллекций add() всегда возвращает 
true. Для других типов существует логика определения того, был ли вызов add() успешным. Ниже показано, как использовать 
этот метод:

```
3: Collection<String> list = new ArrayList<>(); 
4: System.out.println(list.add("Sparrow")); // true 
5: System.out.println(list.add("Sparrow")); // true 
6:
7: Collection<String> set = new HashSet<>(); 
8: System.out.println(set.add("Sparrow")); // true 
9: System.out.println(set.add("Sparrow")); // false
```

List допускает дубликаты, каждый раз возвращая значение true. Set не допускает дубликатов. В строке 9 мы попытались 
добавить дубликат, чтобы Java возвращала false из метода add().

### Удаление данных

Метод remove() удаляет одно совпадающее значение в коллекции и возвращает информацию о том, было ли оно успешным. 
Сигнатура метода следующая:

```
public boolean remove(Object object)
```

На этот раз возвращаемое boolean значение сообщает нам, было ли удалено совпадение. Ниже показано, как использовать этот 
метод:

```
3: Collection<String> birds = new ArrayList<>();
4: birds.add("hawk");                            // [hawk]
5: birds.add("hawk");                            // [hawk, hawk] 
6: System.out.println(birds.remove("cardinal")); // false 
7: System.out.println(birds.remove("hawk"));     // true 
8: System.out.println(birds);                    // [hawk]
```

Строка 6 пытается удалить элемент, которого нет в birds. Он возвращает false, поскольку такой элемент не найден. Строка 
7 пытается удалить элемент, принадлежащий birds, поэтому возвращает true. Обратите внимание: удаляется только одно 
совпадение.

### Подсчет элементов

Методы isEmpty() и size() смотрят, сколько элементов содержится в коллекции. Сигнатуры методов такие:

```
public boolean isEmpty() 
public int size()
```

Ниже показано, как использовать эти методы:

```
Collection<String> birds = new ArrayList<>(); 
System.out.println(birds.isEmpty()); // true 
System.out.println(birds.size());    // 0 
birds.add("hawk");                   // [hawk] 
birds.add("hawk");                   // [hawk, hawk] 
System.out.println(birds.isEmpty()); // false 
System.out.println(birds.size());    // 2
```

В начале, birds имеет размер 0 и пуст. Его емкость больше 0. После того, как мы добавим элементы, размер станет 
положительным, и он больше не будет пустым.

### Очистка коллекции

Метод clear() предоставляет простой способ удалить все элементы коллекции. Сигнатура метода следующая:

```
public void clear()
```

Ниже показано, как использовать этот метод:

```
Collection<String> birds = new ArrayList<>(); 
birds.add("hawk");                   // [hawk] 
birds.add("hawk");                   // [hawk, hawk] 
System.out.println(birds.isEmpty()); // false 
System.out.println(birds.size());    // 2 
birds.clear();                       // []
System.out.println(birds.isEmpty()); // true
System.out.println(birds.size());    // 0
```

После вызова метода clear(), birds снова становится пустым ArrayList размером 0.

### Проверить содержимое

Метод contains() проверяет, присутствует ли определенное значение в коллекции. Сигнатура метода следующая:

```
public boolean contains(Object object)
```

Ниже показано, как использовать этот метод:

```
Collection<String> birds = new ArrayList<>(); 
birds.add("hawk"); // [hawk] 
System.out.println(birds.contains("hawk"));  // true 
System.out.println(birds.contains("robin")); // false
```

Метод contains() вызывает метод equals() для элементов ArrayList, чтобы проверить, есть ли совпадения.

### Удаление с условиями

Метод removeIf() удаляет все элементы, соответствующие условию. Мы можем указать, что следует удалить, используя блок 
кода или даже ссылку на метод.

Сигнатура метода выглядит следующим образом. (Мы объясним, что означает символ ? super, в разделе «Работа с дженериками» 
далее в этой главе.)

```
public boolean removeIf(Predicate<? super E> filter)
```

Он использует Predicate, который принимает один параметр и возвращает логическое значение. Давайте посмотрим на пример:

```
4: Collection<String> list = new ArrayList<>(); 
5: list.add("Magician"); 
6: list.add("Assistant"); 
7: System.out.println(list);     // [Magician, Assistant] 
8: list.removeIf(s -> s.startsWith("A")); 
9: System.out.println(list);     // [Magician]
```

В строке 8 показано, как удалить все String значения, начинающиеся с буквы A. Это позволяет нам исчезнуть с Assistant. 
Давайте попробуем пример со ссылкой на метод:

```
11: Collection<String> set = new HashSet<>(); 
12: set.add("Wand"); 
13: set.add("");
14: set.removeIf(String::isEmpty); // s -> s.isEmpty() 
15: System.out.println(set);       // [Wand]
```

В строке 14 мы удаляем из set все пустые объекты String. Комментарий к этой строке показывает лямбда-эквивалент ссылки 
на метод. В строке 15 показано, что метод removeIf() успешно удалил один элемент из list.

### Итерация (Iterating)

Существует метод forEach(), который вы можете вызывать для коллекции вместо написания цикла. Он использует Consumer, 
который принимает один параметр и ничего не возвращает. Сигнатура метода следующая:

```
public void forEach(Consumer<? super T> action)
```

Cats любят исследовать, поэтому давайте распечатаем два из них, используя как ссылки на методы, так и лямбда-выражения:

```
Collection<String> cats = List.of("Annie", "Ripley"); 
cats.forEach(System.out::println); 
cats.forEach(c -> System.out.println(c));
```

Cats научились писать свои имена. Теперь у них есть больше времени для игры (как и у нас)!

**Другие подходы к итерации**

Есть и другие способы перебирать коллекции. Например, в главе 3 «Принятие решений» вы видели, как перебирать список с 
помощью расширенного цикла for.

```
for (String element: coll)
  System.out.println(element);
```

Вы можете увидеть другой старый подход.

```
Iterator<String> iter = coll.iterator();
while(iter.hasNext()) {
   String string = iter.next();
   System.out.println(string);    
}
```

Обратите внимание на разницу между этими приемами. Метод hasNext() проверяет, существует ли следующее значение. Другими 
словами, он сообщает вам, будет ли выполняться функция next() без выдачи исключения. Метод next() фактически перемещает
Iterator к следующему элементу.

### Определение равенства

Существует специальная реализация метода equals(), поэтому вы можете сравнивать две коллекции, чтобы сравнить их тип и 
содержимое. Реализация будет разной. Например, ArrayList проверяет порядок, а HashSet — нет.

```
boolean equals(Object object)
```

Ниже приведен пример:

```
23: var list1 = List.of(1, 2); 
24: var list2 = List.of(2, 1); 
25: var set1 = Set.of(1, 2); 
26: var set2 = Set.of(2, 1);
27:
28: System.out.println(list1.equals(list2));  // false 
29: System.out.println(set1.equals(set2));    // true 
30: System.out.println(list1.equals(set1));   // false
```

В строке 28 выводится false, потому что элементы расположены в другом порядке, а List заботится о порядке. Напротив, 
строка 29 печатает true, потому что Set не чувствителен к порядку. Наконец, строка 30 выводит false, поскольку типы 
разные.

**Распаковка nulls**

Java защищает нас от многих проблем с коллекциями. Однако написать исключение NullPointerException все же можно:

```
3: var heights = new ArrayList<Integer>();
4: heights.add(null);
5: int h = heights.get(0);          // NullPointerException
```

В строке 4 мы добавляем в список null. Это законно, поскольку null ссылка может быть присвоена любой ссылочной 
переменной. В строке 5 мы пытаемся распаковать этот null в примитив int. Это проблема. Java пытается получить значение 
int, равное null. Поскольку вызов любого метода для значения null приводит к исключению NullPointerException, именно это 
мы и получаем. Будьте осторожны, когда вы видите значение null в отношении автобокса.

## Использование интерфейса List

Теперь, когда вы знакомы с некоторыми распространенными методами интерфейса Collection, давайте перейдем к конкретным 
интерфейсам. Список используется, если вам нужна упорядоченная коллекция, которая может содержать повторяющиеся записи. 
Например, список имен может содержать дубликаты, поскольку у двух животных может быть одно и то же имя. Элементы можно 
извлекать и вставлять в определенные позиции в списке на основе индекса int, аналогично массиву. Однако, в отличие от 
массива, многие реализации List могут изменяться в размере после их объявления.

Списки широко используются, потому что в программировании существует множество ситуаций, когда вам необходимо 
отслеживать список объектов. Например, вы можете составить список того, что вы хотите увидеть в зоопарке: во-первых, 
увидеть львов, потому что они рано ложатся спать; во-вторых, посмотрите на панд, потому что позже в тот же день 
выстраивается длинная очередь; и так далее.

На рис. 9.2 показано, как можно представить список. Каждый элемент списка имеет индекс, и индексы начинаются с нуля.

#### Рис. 9.2 - Пример List



Иногда вам не важен порядок элементов в списке. Список похож на тип данных «go to». Когда мы составляем список покупок 
перед походом в магазин, его порядок совпадает с порядком, в котором мы думали о товарах. Мы, вероятно, не привязаны к 
этому конкретному порядку, но это ничему не повредит.

Хотя классы, реализующие интерфейс List, имеют множество методов, вам необходимо знать только наиболее распространенные 
из них. Удобно, что эти методы одинаковы для всех реализаций, которые могут появиться на экзамене.

Главное, что объединяет все реализации List, — это то, что они упорядочены и допускают дублирование. Помимо этого, 
каждый из них предлагает разные функциональные возможности. Мы рассмотрим реализации, которые вам необходимо знать, и 
доступные методы.

_Обратите особое внимание на то, какие имена являются классами, а какие интерфейсами. На экзамене вас могут спросить, 
какой класс лучше или какой интерфейс лучше всего подходит для конкретного сценария._

### Сравнение реализаций List

ArrayList похож на массив с изменяемым размером. При добавлении элементов ArrayList автоматически увеличивается. Если вы 
не уверены, какую коллекцию использовать, используйте ArrayList.

Основное преимущество ArrayList заключается в том, что вы можете искать любой элемент за постоянное время. Добавление 
или удаление элемента происходит медленнее, чем доступ к элементу. Это делает ArrayList хорошим выбором, когда вы 
читаете чаще (или столько же), сколько записываете в ArrayList.

LinkedList особенный, поскольку он реализует как List, так и Deque. Он имеет все методы List. Он также имеет 
дополнительные методы для облегчения добавления или удаления из начала и/или конца списка.

Основные преимущества LinkedList заключаются в том, что вы можете получать доступ, добавлять и удалять элементы из 
начала и конца списка за постоянное время. Компромисс заключается в том, что работа с произвольным индексом занимает 
линейное время. Это делает LinkedList хорошим выбором, когда вы будете использовать его в качестве Deque. Как вы видели 
на рисунке 9.1, LinkedList реализует интерфейсы List и Deque.

### Создание List с помощью фабрики

Когда вы создаете список типа ArrayList или LinkedList, вы знаете его тип. Существует несколько специальных методов, с 
помощью которых вы возвращаете список, но не знаете его тип. Эти методы позволяют создать список, включающий данные в 
одну строку, используя фабричный метод. Это удобно, особенно при тестировании. Некоторые из этих методов возвращают 
неизменяемый объект. Как мы видели в главе 6 «Проектирование классов», неизменяемый объект нельзя изменить или 
модифицировать. В таблице 9.1 суммированы эти три списка.

TABLE 9.1