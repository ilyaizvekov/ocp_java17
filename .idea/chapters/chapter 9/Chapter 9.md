# Коллекции и дженерики

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Работа с массивами и коллекциями

+ Создавайте массивы Java, коллекции List, Set, Map и Deque, а также добавляйте, удаляйте, обновляйте, извлекайте и 
сортируйте их элементы.

---

В этой главе мы представляем классы и интерфейсы Java Collections Framework, которые вам необходимо знать для сдачи 
экзамена. Потокобезопасные типы коллекций обсуждаются в главе 13 «Параллелизм». Как вы, возможно, помните из главы 8 
«Лямбды и функциональные интерфейсы», мы рассмотрели лямбды, ссылки на методы и встроенные функциональные интерфейсы. 
Многие из них используются в этой главе. Если функциональные интерфейсы вам незнакомы, вернитесь и просмотрите 
Таблицу 8.4. Далее мы подробно расскажем о Comparator и Comparable. Наконец, мы обсудим, как создавать собственные 
классы и методы, использующие дженерики, чтобы один и тот же класс можно было использовать со многими типами.

## Использование API общей коллекции

Коллекция — это группа объектов, содержащихся в одном объекте. Java Collections Framework — это набор классов в 
java.util для хранения коллекций. В Java Collections Framework имеется четыре основных интерфейса.

+ List (Список): Список представляет собой упорядоченный набор элементов, допускающий дублирование записей. Доступ к 
элементам списка возможен по индексу int.
+ Set (Набор): Set — это коллекция, в которой не допускается дублирование записей.
+ Queue (Очередь): Queue — это коллекция, которая упорядочивает свои элементы в определенном порядке для обработки. 
Deque — это подинтерфейс Queue, который обеспечивает доступ на обоих концах.
+ Map (Карта): Map — это коллекция, которая сопоставляет ключи со значениями, дублирование ключей не допускается. 
Элементы карты представляют собой пары ключ/значение.

На рисунке 9.1 показан интерфейс Collection, его подинтерфейсы и некоторые классы, реализующие интерфейсы, которые 
вам следует знать для экзамена. Интерфейсы показаны в прямоугольниках, а классы — в закругленных прямоугольниках.

Обратите внимание, что Map не реализует интерфейс Collection. Он считается частью Java Collections Framework, хотя 
технически он не является Collection. Однако это коллекция (обратите внимание на строчные буквы), поскольку она содержит 
группу объектов. Причина, по которой карты обрабатываются по-разному, заключается в том, что им нужны разные методы, 
поскольку они представляют собой пары ключ/значение.

#### Рис. 9.1 - Java Collections Framework

В этом разделе мы обсудим общие методы, которые API коллекций предоставляет реализующим классам. Многие из этих методов 
представляют собой _удобные методы_, которые можно реализовать другими способами, но которые упрощают написание и чтение 
кода. Именно поэтому они удобны.

В этом разделе мы используем ArrayList и HashSet в качестве классов реализации, но они могут применяться к любому 
классу, наследующему интерфейс Collection. В следующем разделе мы рассмотрим конкретные свойства каждого класса 
Collection.

### Использование diamond оператора

При создании Java Collections Framework вам необходимо указать тип, который будет входить внутрь. Мы могли бы написать 
код, используя дженерики, подобные следующему:

```
List<Integer> list = new ArrayList<Integer>();
```

У вас могут даже быть дженерики, содержащие другие дженерики, например этот:

```
Map<Long,List<Integer>> mapLists = new HashMap<Long,List<Integer>>();
```

Нужно написать много дублированного кода! К счастью, оператор ромба (diamond operator) (<>) — это сокращенная запись, 
позволяющая опустить общий тип в правой части оператора, когда тип можно вывести. Он называется оператором ромба, потому 
что <> выглядит как ромб. Сравните предыдущие объявления с этими новыми, гораздо более короткими версиями:

```
List<Integer> list = new ArrayList<>(); 
Map<Long,List<Integer>> mapOfLists = new HashMap<>();
```

Для компилятора оба этих объявления и наши предыдущие эквивалентны. Однако для нас последний вариант намного короче и 
его легче читать.

Оператор ромба нельзя использовать в качестве типа в объявлении переменной. Его можно использовать только в правой части 
операции присваивания. Например, ни одно из следующих действий не компилируется:

```
List<> list = new ArrayList<Integer>();      // НЕ КОМПИЛИРУЕТСЯ

class InvalidUse {
    void use(List<> data) {}                 // НЕ КОМПИЛИРУЕТСЯ
}
```

### Добавление данных

Метод add() вставляет новый элемент в коллекцию и возвращает информацию о том, был ли он успешным. Сигнатура метода 
следующая:

```
public boolean add(E element)
```

Помните, что Collections Framework использует дженерики. Вы будете часто видеть, как буква E появляется. Это означает
универсальный тип, который использовался для создания коллекции. Для некоторых типов коллекций add() всегда возвращает 
true. Для других типов существует логика определения того, был ли вызов add() успешным. Ниже показано, как использовать 
этот метод:

```
3: Collection<String> list = new ArrayList<>(); 
4: System.out.println(list.add("Sparrow")); // true 
5: System.out.println(list.add("Sparrow")); // true 
6:
7: Collection<String> set = new HashSet<>(); 
8: System.out.println(set.add("Sparrow")); // true 
9: System.out.println(set.add("Sparrow")); // false
```

List допускает дубликаты, каждый раз возвращая значение true. Set не допускает дубликатов. В строке 9 мы попытались 
добавить дубликат, чтобы Java возвращала false из метода add().

### Удаление данных

Метод remove() удаляет одно совпадающее значение в коллекции и возвращает информацию о том, было ли оно успешным. 
Сигнатура метода следующая:

```
public boolean remove(Object object)
```

На этот раз возвращаемое boolean значение сообщает нам, было ли удалено совпадение. Ниже показано, как использовать этот 
метод:

```
3: Collection<String> birds = new ArrayList<>();
4: birds.add("hawk");                            // [hawk]
5: birds.add("hawk");                            // [hawk, hawk] 
6: System.out.println(birds.remove("cardinal")); // false 
7: System.out.println(birds.remove("hawk"));     // true 
8: System.out.println(birds);                    // [hawk]
```

Строка 6 пытается удалить элемент, которого нет в birds. Он возвращает false, поскольку такой элемент не найден. Строка 
7 пытается удалить элемент, принадлежащий birds, поэтому возвращает true. Обратите внимание: удаляется только одно 
совпадение.

### Подсчет элементов

Методы isEmpty() и size() смотрят, сколько элементов содержится в коллекции. Сигнатуры методов такие:

```
public boolean isEmpty() 
public int size()
```

Ниже показано, как использовать эти методы:

```
Collection<String> birds = new ArrayList<>(); 
System.out.println(birds.isEmpty()); // true 
System.out.println(birds.size());    // 0 
birds.add("hawk");                   // [hawk] 
birds.add("hawk");                   // [hawk, hawk] 
System.out.println(birds.isEmpty()); // false 
System.out.println(birds.size());    // 2
```

В начале, birds имеет размер 0 и пуст. Его емкость больше 0. После того, как мы добавим элементы, размер станет 
положительным, и он больше не будет пустым.

### Очистка коллекции

Метод clear() предоставляет простой способ удалить все элементы коллекции. Сигнатура метода следующая:

```
public void clear()
```

Ниже показано, как использовать этот метод:

```
Collection<String> birds = new ArrayList<>(); 
birds.add("hawk");                   // [hawk] 
birds.add("hawk");                   // [hawk, hawk] 
System.out.println(birds.isEmpty()); // false 
System.out.println(birds.size());    // 2 
birds.clear();                       // []
System.out.println(birds.isEmpty()); // true
System.out.println(birds.size());    // 0
```

После вызова метода clear(), birds снова становится пустым ArrayList размером 0.

### Проверить содержимое

Метод contains() проверяет, присутствует ли определенное значение в коллекции. Сигнатура метода следующая:

```
public boolean contains(Object object)
```

Ниже показано, как использовать этот метод:

```
Collection<String> birds = new ArrayList<>(); 
birds.add("hawk"); // [hawk] 
System.out.println(birds.contains("hawk"));  // true 
System.out.println(birds.contains("robin")); // false
```

Метод contains() вызывает метод equals() для элементов ArrayList, чтобы проверить, есть ли совпадения.

### Удаление с условиями

Метод removeIf() удаляет все элементы, соответствующие условию. Мы можем указать, что следует удалить, используя блок 
кода или даже ссылку на метод.

Сигнатура метода выглядит следующим образом. (Мы объясним, что означает символ ? super, в разделе «Работа с дженериками» 
далее в этой главе.)

```
public boolean removeIf(Predicate<? super E> filter)
```

Он использует Predicate, который принимает один параметр и возвращает логическое значение. Давайте посмотрим на пример:

```
4: Collection<String> list = new ArrayList<>(); 
5: list.add("Magician"); 
6: list.add("Assistant"); 
7: System.out.println(list);     // [Magician, Assistant] 
8: list.removeIf(s -> s.startsWith("A")); 
9: System.out.println(list);     // [Magician]
```

В строке 8 показано, как удалить все String значения, начинающиеся с буквы A. Это позволяет нам исчезнуть с Assistant. 
Давайте попробуем пример со ссылкой на метод:

```
11: Collection<String> set = new HashSet<>(); 
12: set.add("Wand"); 
13: set.add("");
14: set.removeIf(String::isEmpty); // s -> s.isEmpty() 
15: System.out.println(set);       // [Wand]
```

В строке 14 мы удаляем из set все пустые объекты String. Комментарий к этой строке показывает лямбда-эквивалент ссылки 
на метод. В строке 15 показано, что метод removeIf() успешно удалил один элемент из list.

### Итерация (Iterating)

Существует метод forEach(), который вы можете вызывать для коллекции вместо написания цикла. Он использует Consumer, 
который принимает один параметр и ничего не возвращает. Сигнатура метода следующая:

```
public void forEach(Consumer<? super T> action)
```

Cats любят исследовать, поэтому давайте распечатаем два из них, используя как ссылки на методы, так и лямбда-выражения:

```
Collection<String> cats = List.of("Annie", "Ripley"); 
cats.forEach(System.out::println); 
cats.forEach(c -> System.out.println(c));
```

Cats научились писать свои имена. Теперь у них есть больше времени для игры (как и у нас)!

**Другие подходы к итерации**

Есть и другие способы перебирать коллекции. Например, в главе 3 «Принятие решений» вы видели, как перебирать список с 
помощью расширенного цикла for.

```
for (String element: coll)
  System.out.println(element);
```

Вы можете увидеть другой старый подход.

```
Iterator<String> iter = coll.iterator();
while(iter.hasNext()) {
   String string = iter.next();
   System.out.println(string);    
}
```

Обратите внимание на разницу между этими приемами. Метод hasNext() проверяет, существует ли следующее значение. Другими 
словами, он сообщает вам, будет ли выполняться функция next() без выдачи исключения. Метод next() фактически перемещает
Iterator к следующему элементу.

### Определение равенства

Существует специальная реализация метода equals(), поэтому вы можете сравнивать две коллекции, чтобы сравнить их тип и 
содержимое. Реализация будет разной. Например, ArrayList проверяет порядок, а HashSet — нет.

```
boolean equals(Object object)
```

Ниже приведен пример:

```
23: var list1 = List.of(1, 2); 
24: var list2 = List.of(2, 1); 
25: var set1 = Set.of(1, 2); 
26: var set2 = Set.of(2, 1);
27:
28: System.out.println(list1.equals(list2));  // false 
29: System.out.println(set1.equals(set2));    // true 
30: System.out.println(list1.equals(set1));   // false
```

В строке 28 выводится false, потому что элементы расположены в другом порядке, а List заботится о порядке. Напротив, 
строка 29 печатает true, потому что Set не чувствителен к порядку. Наконец, строка 30 выводит false, поскольку типы 
разные.

**Распаковка nulls**

Java защищает нас от многих проблем с коллекциями. Однако написать исключение NullPointerException все же можно:

```
3: var heights = new ArrayList<Integer>();
4: heights.add(null);
5: int h = heights.get(0);          // NullPointerException
```

В строке 4 мы добавляем в список null. Это законно, поскольку null ссылка может быть присвоена любой ссылочной 
переменной. В строке 5 мы пытаемся распаковать этот null в примитив int. Это проблема. Java пытается получить значение 
int, равное null. Поскольку вызов любого метода для значения null приводит к исключению NullPointerException, именно это 
мы и получаем. Будьте осторожны, когда вы видите значение null в отношении автобокса.

## Использование интерфейса List

Теперь, когда вы знакомы с некоторыми распространенными методами интерфейса Collection, давайте перейдем к конкретным 
интерфейсам. Список используется, если вам нужна упорядоченная коллекция, которая может содержать повторяющиеся записи. 
Например, список имен может содержать дубликаты, поскольку у двух животных может быть одно и то же имя. Элементы можно 
извлекать и вставлять в определенные позиции в списке на основе индекса int, аналогично массиву. Однако, в отличие от 
массива, многие реализации List могут изменяться в размере после их объявления.

Списки широко используются, потому что в программировании существует множество ситуаций, когда вам необходимо 
отслеживать список объектов. Например, вы можете составить список того, что вы хотите увидеть в зоопарке: во-первых, 
увидеть львов, потому что они рано ложатся спать; во-вторых, посмотрите на панд, потому что позже в тот же день 
выстраивается длинная очередь; и так далее.

На рис. 9.2 показано, как можно представить список. Каждый элемент списка имеет индекс, и индексы начинаются с нуля.

#### Рис. 9.2 - Пример List



Иногда вам не важен порядок элементов в списке. Список похож на тип данных «go to». Когда мы составляем список покупок 
перед походом в магазин, его порядок совпадает с порядком, в котором мы думали о товарах. Мы, вероятно, не привязаны к 
этому конкретному порядку, но это ничему не повредит.

Хотя классы, реализующие интерфейс List, имеют множество методов, вам необходимо знать только наиболее распространенные 
из них. Удобно, что эти методы одинаковы для всех реализаций, которые могут появиться на экзамене.

Главное, что объединяет все реализации List, — это то, что они упорядочены и допускают дублирование. Помимо этого, 
каждый из них предлагает разные функциональные возможности. Мы рассмотрим реализации, которые вам необходимо знать, и 
доступные методы.

_Обратите особое внимание на то, какие имена являются классами, а какие интерфейсами. На экзамене вас могут спросить, 
какой класс лучше или какой интерфейс лучше всего подходит для конкретного сценария._

### Сравнение реализаций List

ArrayList похож на массив с изменяемым размером. При добавлении элементов ArrayList автоматически увеличивается. Если вы 
не уверены, какую коллекцию использовать, используйте ArrayList.

Основное преимущество ArrayList заключается в том, что вы можете искать любой элемент за постоянное время. Добавление 
или удаление элемента происходит медленнее, чем доступ к элементу. Это делает ArrayList хорошим выбором, когда вы 
читаете чаще (или столько же), сколько записываете в ArrayList.

LinkedList особенный, поскольку он реализует как List, так и Deque. Он имеет все методы List. Он также имеет 
дополнительные методы для облегчения добавления или удаления из начала и/или конца списка.

Основные преимущества LinkedList заключаются в том, что вы можете получать доступ, добавлять и удалять элементы из 
начала и конца списка за постоянное время. Компромисс заключается в том, что работа с произвольным индексом занимает 
линейное время. Это делает LinkedList хорошим выбором, когда вы будете использовать его в качестве Deque. Как вы видели 
на рисунке 9.1, LinkedList реализует интерфейсы List и Deque.

### Создание List с помощью фабрики

Когда вы создаете список типа ArrayList или LinkedList, вы знаете его тип. Существует несколько специальных методов, с 
помощью которых вы возвращаете список, но не знаете его тип. Эти методы позволяют создать список, включающий данные в 
одну строку, используя фабричный метод. Это удобно, особенно при тестировании. Некоторые из этих методов возвращают 
неизменяемый объект. Как мы видели в главе 6 «Проектирование классов», неизменяемый объект нельзя изменить или 
модифицировать. В таблице 9.1 суммированы эти три списка.

#### Таблица 9.1 - Фабричные методы для создания List

|          Метод          |                                Описание                                | Можете добавить элементы? |   Можно ли заменить элементы?   |   Можно ли удалять элементы?   |  
|:-----------------------:|:----------------------------------------------------------------------:|:-------------------------:|:-------------------------------:|:------------------------------:|
| Arrays.asList(varargs)  | Возвращает список фиксированного <br/> размера, подкрепленный массивом |            Нет            |               Да                |              Нет               |
|    List.of(varargs)     |                     Возвращает неизменяемый список                     |            Нет            |               Нет               |              Нет               |                                     
| List.copyOf(collection) |  Возвращает неизменяемый список с копией значений исходной коллекции   |            Нет            |               Нет               |              Нет               |

Давайте рассмотрим пример этих трех методов:

```
16: String[] array = new String[] {"a", "b", "c"}; 
17: List<String> asList = Arrays.asList(array); // [a, b, c] 
18: List<String> of = List.of(array);           // [a, b, c] 
19: List<String> copy = List.copyOf(asList);    // [a, b, c]
20:
21: array[0] = "z";
22:
23: System.out.println(asList);                 // [z, b, c] 
24: System.out.println(of);                     // [a, b, c] 
25: System.out.println(copy);                   // [a, b, c]
26:
27: asList.set(0, "x"); 
28: System.out.println(Arrays.toString(array)); // [x, b, c]
29:
30: copy.add("y");            // UnsupportedOperationException
```

Строка 17 создает List, поддерживаемый массивом. Строка 21 изменяет массив, а строка 23 отражает это изменение. 
Строки 27 и 28 показывают другое направление, когда изменение List обновляет базовый массив. Строки 18 и 19 создают 
неизменяемый List. Строка 30 показывает, что он является неизменяемым, выдавая исключение при попытке добавить значение. 
Все три списка выдадут исключение при добавлении или удалении значения. Списки of и copy также выдают ошибку при попытке 
обновления элемента.

### Создание List с помощью конструктора

В большинстве коллекций есть два конструктора, которые вам необходимо знать для экзамена. Ниже показаны их для 
LinkedList:

```
var linked1 = new LinkedList<String>();
var linked2 = new LinkedList<String>(linked1);
```

Первый говорит о создании пустого LinkedList, содержащего все значения по умолчанию. Второй сообщает Java, что мы хотим 
сделать копию другого LinkedList. Конечно, в этом примере linked1 пуст, поэтому он не представляет особого интереса.

В ArrayList есть дополнительный конструктор, о котором вам нужно знать. Теперь мы покажем три конструктора:

```
var list1 = new ArrayList<String>();
var list2 = new ArrayList<String>(list1);
var list3 = new ArrayList<String>(10);
```

Первые два — это общие конструкторы, которые вам нужно знать для всех коллекций. В последнем примере говорится о 
создании ArrayList, содержащего определенное количество слотов, но опять же не назначать их. Вы можете думать об этом 
как о размере базового массива.

**Использование var с ArrayList**

Рассмотрим этот код, в котором сочетаются var и дженерики:

```
var strings = new ArrayList<String>();
strings.add("a");
for (String s: strings) {  }
```

Тип переменной — ArrayList<String>. Это означает, что вы можете добавить String или перебрать объекты String. Что, если 
мы используем diamond оператор с var?

```
var list = new ArrayList<>();
```

Хотите верьте, хотите нет, но это компилируется. Тип переменной var — ArrayList<Object>. Поскольку для универсального 
типа не указан тип, Java должен принять окончательный суперкласс. Это немного глупо и неожиданно, поэтому, пожалуйста, 
не пишите это. Но если вы увидите это на экзамене, вы будете знать, чего ожидать. Теперь вы можете понять, почему это не 
компилируется?

```
var list = new ArrayList<>();
list.add("a");
for (String s: list) { } // НЕ КОМПИЛИРУЕТСЯ
```

Тип переменной var — ArrayList<Object>. Поскольку daimond оператор не имеет типа, Java должен использовать самый общий 
вариант, какой только может. Поэтому он выбирает Object, высший суперкласс. Добавление String в список — это нормально. 
Вы можете добавить любой подкласс Object. Однако в цикле нам нужно использовать тип Object, а не String.

### Работа с методами List

Методы интерфейса List предназначены для работы с индексами. Помимо унаследованных методов Collection, сигнатуры 
методов, которые вам необходимо знать, приведены в таблице 9.2.

#### Таблица 9.2 - Методы List

|                        Метод                        |                                                          Опсиание                                                           | 
|:---------------------------------------------------:|:---------------------------------------------------------------------------------------------------------------------------:|
|            public boolean add(E element)            |                                 Добавляет элемент в конец (доступно во всех API коллекций).                                 |  
|        public void add(int index, E element)        |                             Добавляет элемент по индексу и перемещает оставшуюся часть в конец.                             |                                    
|               public E get(int index)               |                                               Возвращает элемент по индексу.                                                | 
|             public E remove(int index)              |                                  Удаляет элемент по индексу и перемещает остальные вперед.                                  | 
| public default void replaceAll(UnaryOperator<E> op) |                                   Заменяет каждый элемент в списке результатом оператора.                                   | 
|            public E set(int index, E e)             | Заменяет элемент по индексу и возвращает оригинал. Выдает исключение IndexOutOfBoundsException, если индекс недействителен. |
| public default void sort(Comparator<? super E> c)   |                     Сортирует список. Мы рассмотрим это позже в главе, в разделе «Сортировка данных».                       |

Следующие операторы демонстрируют большинство этих методов работы со списком:

```
3:  List<String> list = new ArrayList<>();
4:  list.add("SD");                  // [SD] 
5:  list.add(0, "NY");               // [NY,SD] 
6:  list.set(1, "FL");               // [NY,FL] 
7:  System.out.println(list.get(0)); // NY 
8:  list.remove("NY");               // [FL] 
9:  list.remove(0);                  // [] 
10: list.set(0, "?");                // IndexOutOfBoundsException
```

В строке 3 list начинается пустым. Строка 4 добавляет элемент в конец списка. В строке 5 добавляется элемент с индексом 
0, который увеличивает исходный индекс 0 до индекса 1. Обратите внимание, что ArrayList теперь автоматически 
увеличивается на единицу. В строке 6 элемент с индексом 1 заменяется новым значением.

В строке 7 используется метод get() для печати элемента по определенному индексу. Строка 8 удаляет элемент, 
соответствующий NY. Наконец, строка 9 удаляет элемент с индексом 0, и список снова становится пустым.

В строке 10 выбрасывается исключение IndexOutOfBoundsException, поскольку в List нет элементов. Поскольку элементов для 
замены нет, даже индекс 0 не допускается. Если строку 10 переместить вверх между строками 4 и 5, вызов будет успешным.

Результат будет таким же, если вы попробуете эти примеры с LinkedList. Хотя код будет менее эффективным, это не будет 
заметно, пока у вас не будут очень большие списки.

Теперь давайте взглянем на метод replaceAll(). Он использует UnaryOperator, который принимает один параметр и возвращает 
значение того же типа:

```
var numbers = Arrays.asList(1, 2, 3);
numbers.replaceAll(x -> x*2);
System.out.println(numbers);   // [2, 4, 6]
```

Эта лямбда удваивает значение каждого элемента в списке. Метод replaceAll() вызывает лямбду для каждого элемента списка 
и заменяет значение по этому индексу.

**Перегруженные методы remove()**

Мы рассмотрели два перегруженных метода remove(). Тот, что из коллекции, удаляет объект, соответствующий параметру. 
Напротив, элемент из List удаляет элемент по указанному индексу.

Это становится сложнее, если у вас есть тип Integer. Как вы думаете, что означают следующие печати?

```
31: var list = new LinkedList<Integer>(); 
32: list.add(3); 33: list.add(2); 
34: list.add(1); 35: list.remove(2); 
36: list.remove(Integer.valueOf(2)); 
37: System.out.println(list);
```

Правильный ответ: [3]. Давайте посмотрим, как мы туда попали. В конце строки 34 у нас есть [3, 2, 1]. В строке 35 
передается примитив, что означает, что мы запрашиваем удаление элемента с индексом 2. В результате у нас остается 
[3, 2]. Затем в строке 36 передается объект Integer, что означает, что мы удаляем значение 2. Это подводит нас к 
[3].

Поскольку вызов метода remove() с числом int использует индекс, несуществующий индекс вызовет/выбросит исключение. 
Например, list.remove(100) выдает исключение IndexOutOfBoundsException.

### Преобразование List в массив

Поскольку массив можно передать как vararg, в таблице 9.1 показано, как преобразовать массив в список. Вы также должны 
знать, как сделать обратное. Начнем с преобразования списка в массив:

```
13: List<String> list = new ArrayList<>(); 
14: list.add("hawk"); 
15: list.add("robin"); 
16: Object[] objectArray = list.toArray(); 
17: String[] stringArray = list.toArray(new String[0]); 
18: list.clear(); 
19: System.out.println(objectArray.length);     // 2 
20: System.out.println(stringArray.length);     // 2
```

Строка 16 показывает, что List знает, как преобразовать себя в массив. Единственная проблема заключается в том, что по 
умолчанию используется массив класса Object. Обычно это не то, чего вы хотите. Строка 17 определяет тип массива и делает 
то, что мы хотим. Преимущество указания размера 0 для параметра заключается в том, что Java создаст новый массив 
подходящего размера для возвращаемого значения. Если хотите, вы можете предложить вместо этого использовать больший 
массив. Если List помещается в этот массив, он будет возвращен. В противном случае будет создан новый массив.

Также обратите внимание, что строка 18 очищает исходный List. Это не влияет ни на один массив. Массив представляет собой 
недавно созданный объект, не имеющий отношения к исходному List. Это просто копия.

## Использование интерфейса Set

Вы используете Set, когда не хотите допускать дублирование записей. Например, вы можете отслеживать уникальных животных, 
которых хотите увидеть в зоопарке. Вас не волнует порядок, в котором вы видите этих животных, но у вас нет времени 
видеть их более одного раза. Вам просто нужно убедиться, что вы видите тех, которые важны для вас, и удалить их из 
набора выдающихся животных, чтобы увидеть их после того, как вы их увидите.

На рис. 9.3 показано, как можно представить Set. Главное, что объединяет все реализации Set, — это то, что они не 
допускают дублирования. Мы рассмотрим каждую реализацию, которую вам нужно знать для экзамена, и то, как писать код с 
использованием Set.

#### Рис. 9.3 - Пример Set


### Сравнение реализаций Set

HashSet хранит свои элементы в хеш-таблице, что означает, что ключи представляют собой хэш, а значения — объект. Это 
означает, что HashSet использует метод объектов hashCode() для более эффективного их извлечения. Помните, что 
действительный hashCode() не означает, что каждый объект получит уникальное значение, но метод часто пишется так, что 
хэш-значения распределяются по большому диапазону, чтобы уменьшить коллизии.

Основное преимущество заключается в том, что добавление элементов и проверка наличия элемента в наборе имеют 
постоянное время. Компромисс заключается в том, что вы теряете порядок вставки элементов. В большинстве случаев вас это 
не касается в Set, что делает HashSet наиболее распространенным набором.

TreeSet хранит свои элементы в отсортированной древовидной структуре. Основное преимущество заключается в том, что 
набор всегда находится в отсортированном порядке. Компромисс заключается в том, что добавление и проверка существования 
элемента занимает больше времени, чем при использовании HashSet, особенно по мере того, как дерево становится больше.

На рис. 9.4 показано, как можно представить себе хранение HashSet и TreeSet. На самом деле HashSet сложнее, но для целей 
экзамена этого вполне достаточно.

#### Рис. 9.4 - Примеры HashSet и TreeSet



Для экзамена вам не нужно знать, как создать хэш или набор деревьев (реализация может быть сложной). Уф! Вам просто 
нужно знать, как ими пользоваться!

### Работа с методами Set

Как и в случае с List, вы можете создать неизменяемый Set в одной строке или сделать копию существующего.

```
Set<Character> letters = Set.of('z', 'o', 'o');
Set<Character> copy = Set.copyOf(letters);
```

Это единственные дополнительные методы, которые вам нужно знать для интерфейса Set для экзамена! Вам нужно знать, как 
наборы ведут себя по отношению к традиционным методам Collection. Вы также должны знать различия между типами наборов. 
Начнем с HashSet:

```
3: Set<Integer> set = new HashSet<>(); 
4: boolean b1 = set.add(66);    // true 
5: boolean b2 = set.add(10);    // true 
6: boolean b3 = set.add(66);    // false 
7: boolean b4 = set.add(8);     // true 
8: set.forEach(System.out::println);
```

Этот код печатает три строки:

```
66
8
10
```

Методы add() должны быть понятны. Они возвращают true, если Integer еще не находится в set. Строка 6 возвращает false, 
поскольку в наборе уже есть 66 и набор должен сохранять уникальность. Строка 8 печатает элементы набора в произвольном 
порядке. В данном случае это не порядок сортировки или порядок, в котором мы добавили элементы.

Помните, что метод equals() используется для определения равенства. Метод hashCode() используется, чтобы узнать, в каком
сегменте искать, чтобы Java не приходилось просматривать весь set, чтобы выяснить, есть ли там объект. В лучшем случае 
хеш-коды уникальны, и Java должна вызывать метод equals() только для одного объекта. Худший случай заключается в том, 
что все реализации возвращают один и тот же hashCode(), и Java в любом случае должен вызывать мето eдquals() для каждого 
элемента set.

Теперь давайте посмотрим на тот же пример с TreeSet:

```
3: Set<Integer> set = new TreeSet<>(); 
4: boolean b1 = set.add(66);  // true 
5: boolean b2 = set.add(10);  // true 
6: boolean b3 = set.add(66);  // false 
7: boolean b4 = set.add(8);   // true 
8: set.forEach(System.out::println);
```

На этот раз код печатает следующее:

```
8
10
66
```

Элементы распечатываются в естественном отсортированном порядке. Numbers реализуют интерфейс Comparable в Java, который 
используется для сортировки. Далее в этой главе вы узнаете, как создавать собственные объекты Comparable.

## Использование интерфейсов Queue и Deque

Queue используется, когда элементы добавляются и удаляются в определенном порядке. Вы можете думать об очереди как о 
линии. Например, если вы хотите войти на стадион, а кто-то стоит в очереди, вы встаете в очередь позади этого человека. 
А если вы британец, вы встанете в очередь позади этого человека, и вам будет очень легко запомнить это! Это очередь FIFO 
(первым пришел — первым обслужен).

Deque (двусторонняя очередь), часто произносится как «колода», отличается от обычной очереди тем, что вы можете 
вставлять и удалять элементы как спереди (голова), так и сзади (хвост). Подумайте: «Доктор. Вуди Флауэрс, иди вперед! 
Вы единственный, кто пользуется таким особым отношением. Всем остальным придется начинать с конца очереди».

Вы можете представить двустороннюю очередь, как показано на рисунке 9.5.

#### Рис. 9.5 - Пример Deque


Предположим, мы используем это как очередь FIFO. Ровер первый, а это значит, что он прибыл первым. Белла идет последней, 
а это значит, что она пришла последней и ей осталось ждать дольше всех. У всех очередей есть особые требования к 
добавлению и удалению следующего элемента. Помимо этого, каждый из них предлагает разные функциональные возможности. Мы 
рассмотрим реализации, которые вам необходимо знать, и доступные методы.

### Сравнение реализаций Deque

Вы видели LinkedList ранее в разделе «List». Это не только список, но и Deque. Основное преимущество LinkedList 
заключается в том, что он реализует интерфейсы List и Deque. Компромисс в том, что он не так эффективен, как «чистая» 
очередь. Вы можете использовать класс ArrayDeque, если вам не нужны методы List.

### Работа с методами Queue и Deque

Интерфейс Queue содержит шесть методов, показанных в Таблице 9.3. Существует три части функциональности и версии 
методов, которые создают исключение или используют тип возвращаемого значения, например null, для всей информации. Мы 
выделили жирным шрифтом те, которые выдают исключение, когда что-то идет не так, например, при попытке чтения из пустой 
очереди.

#### Таблица 9.3 - Методы Queue

|                  Функциональность                   |                          Методы                          | 
|:---------------------------------------------------:|:--------------------------------------------------------:|
|                   Добавить назад                    | public boolean add(E e) <br/>  public boolean offer(E e) |  
|                   Читать спереди                    |        public E element () <br/> public E peek()         |                                    
|               Достать и снять спереди               |        public E remove() <br/>  public E poll()          | 

Давайте покажем простой пример очереди:

```
4: Queue<Integer> queue = new LinkedList<>(); 
5: queue.add(10); 
6: queue.add(4); 
7: System.out.println(queue.remove());   // 10 
8: System.out.println(queue.peek());     // 4
```

Строки 5 и 6 добавляют элементы в очередь. В строке 7 запрашивается первый элемент, ожидающий дольше всего, выйти из 
очереди. Строка 8 проверяет наличие следующей записи в очереди, оставляя ее на месте.

Далее переходим к интерфейсу Deque. Поскольку интерфейс Deque поддерживает двойные очереди, он наследует все методы 
Queue и добавляет новые, чтобы было понятно, работаем ли мы с передней или задней частью очереди. В таблице 9.4 показаны 
методы при использовании двусторонней очереди.

#### Таблица 9.4 - Методы Deque

|    Функциональность     |                              Методы                              | 
|:-----------------------:|:----------------------------------------------------------------:|
|     Добавить вперед     | public void addFirst(E e)  <br/>  public boolean offerFirst(E e) |  
|     Добавить назад      |  public void addLast(E e) <br/>  public boolean offerLast(E e)   |
|     Читать спереди      |         public E getFirst() <br/>  public E peekFirst()          |
|      Читать сзади       |           public E getLast() <br/> public E peekLast()           |                                    
| Достать и снять спереди |        public E removeFirst() <br/>  public E pollFirst()        | 
|  Достать и снять сзади  |         public E removeLast() <br/> public E pollLast()          |

Давайте попробуем пример, работающий с обоими концами очереди:

```
Deque<Integer> deque = new LinkedList<>();
```

Это сложнее, поэтому мы используем рисунок 9.6, чтобы показать, как выглядит очередь на каждом этапе кода.

Строки 13 и 14 успешно добавляют элемент в начало и конец очереди соответственно. Некоторые очереди ограничены по 
размеру, что может привести к сбою добавления элемента в очередь. На экзамене вы не встретите такого сценария. Строка 15 
просматривает первый элемент в очереди, но не удаляет его. Строки 16 и 17 удаляют элементы из очереди, по одному с 
каждого конца. В результате получается пустая очередь. Строки 18 и 19 пытаются просмотреть первый элемент очереди, что 
приводит к нулю.

#### Рис. 9.6 - Работа с Deque


Помимо очередей FIFO, существуют очереди LIFO (последний пришел — первый обслужен), которые обычно называют стеками. 
Представьте себе стопку тарелок. Вы всегда добавляете или удаляете сверху стека, чтобы избежать беспорядка. К счастью, 
мы можем использовать те же реализации двусторонних очередей. Для ясности используются разные методы, как показано в 
Таблице 9.5.

#### Таблица 9.5 - Использование Deque в качестве стека

|     Функциональность     |        Методы         | 
|:------------------------:|:---------------------:|
| Добавить спереди/сверху  | public void push(E e) |  
|  Удалить спереди/сверху  |    public E pop()     |
| Получить первый элемент  |   public E peek()     |

Давайте попробуем еще один вариант, используя Deque в качестве стека:

```
Deque<Integer> stack = new ArrayDeque<>();
```

На этот раз на рисунке 9.7 показано, как выглядит стек на каждом шаге кода. Строки 13 и 14 успешно помещают элемент в 
начало/вершину стека. Оставшийся код также отображается спереди.

При использовании Deque действительно важно определить, используется ли он в качестве очереди FIFO, стека LIFO или 
двусторонней очереди. Для сравнения, очередь FIFO похожа на очередь людей. Ты садишься сзади и выходишь спереди. Стопка 
LIFO похожа на стопку тарелок. Вы ставите тарелку на столешницу и снимаете ее с нее. Двусторонняя очередь использует оба 
конца.

#### Рис. 9.7 - Работа со стеком


## Использование интерфейса Map

Вы используете Map, когда хотите идентифицировать значения по ключу. Например, когда вы используете список контактов в 
своем телефоне, вы ищете «George», а не просматриваете каждый номер телефона по очереди.

Вы можете представить Map, как показано на рисунке 9.8. Вам не обязательно знать имена конкретных интерфейсов, 
реализуемых различными картами, но вам необходимо знать, что TreeMap отсортирован.

#### Рис. 9.8 - Пример Map


Главное, что объединяет все классы Map, — это то, что у них есть ключи и значения. Помимо этого, каждый из них 
предлагает разные функциональные возможности. Мы рассмотрим реализации, которые вам необходимо знать, и доступные 
методы.

**Map.of() и Map.copyOf()**

Как и в случае с List и Set, существует фабричный метод создания Map. Вы передаете любое количество пар ключей и 
значений.

```
Map.of("key1", "value1", "key2", "value2");
```

В отличие от List и Set, это далеко не идеально. Передачу ключей и значений труднее читать, потому что вам нужно 
отслеживать, какой параметр является каким. К счастью, есть лучший способ. Map также предоставляет метод, который 
позволяет вам предоставлять пары ключ/значение.

```
Map.ofEntries(
    Map.entry("key1", "value1"),
    Map.entry("key2", "value2"));
```

Теперь мы не можем забыть передать значение. Если мы оставим параметр, метод enter() не скомпилируется. Удобно, что 
Map.copyOf(map) работает так же, как методы copyOf() интерфейса List и Set.

### Сравнение реализаций Map

HashMap хранит ключи в хеш-таблице. Это означает, что он использует метод ключей hashCode() для более эффективного 
получения их значений.

Основное преимущество заключается в том, что добавление элементов и извлечение элемента по ключу имеют постоянное время. 
Компромисс заключается в том, что вы теряете порядок, в котором вы вставляли элементы. В большинстве случаев вас это все 
равно не касается на карте. Если бы это было так, вы могли бы использовать LinkedHashMap, но это не входит в рамки 
экзамена.

TreeMap хранит ключи в отсортированной древовидной структуре. Основное преимущество заключается в том, что ключи всегда 
находятся в отсортированном порядке. Как и в случае с TreeSet, компромисс заключается в том, что добавление и проверка 
наличия ключа занимает больше времени по мере роста дерева.

### Работа с методами Map

Учитывая, что Map не расширяет Collection, в интерфейсе Map указано больше методов. Поскольку существуют как ключи, так 
и значения, нам нужны параметры универсального типа для обоих. Класс использует K для ключа и V для значения. Методы, 
которые вам необходимо знать для сдачи экзамена, приведены в Таблице 9.6. Некоторые сигнатуры методов упрощены, чтобы их 
было легче понять.

#### Таблица 9.6 - Методы Map

|                          Метод                           |                                                                              Опсиание                                                                               | 
|:--------------------------------------------------------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|                   public void clear()                    |                                                               Удаляет все ключи и значения с карты.                                                                 |  
|          public boolean containsKey(Object key)          |                                                             Возвращает, присутствует ли ключ на карте.                                                              |                                    
|        public boolean containsValue(Object value)        |                                                            Возвращает, присутствует ли значение в карте.                                                            | 
|          public Set<Map.Entry<K,V>> entrySet()           |                                                                  Возвращает Set пар ключ/значение.                                                                  | 
|     public void forEach(BiConsumer<K key, V value>)      |                                                              Просматривает каждую пару ключ/значение.                                                               | 
|                 public V get(Object key)                 |                                     Возвращает значение, сопоставленное ключу, или значение null, если ничего не сопоставлено.                                      |
|    public V getOrDefault(Object key, V defaultValue)     |                                 Возвращает значение, сопоставленное ключу, или значение по умолчанию, если ни одно не сопоставлено.                                 |
|                 public boolean isEmpty()                 |                                                                Возвращает, является ли карта пустой.                                                                |
|                  public Set<K> keySet()                  |                                                                    Возвращает набор всех ключей.                                                                    |
| public V merge(K key, V value, Function(<V, V, V> func)) | Устанавливает значение, если ключ не установлен. Запускает функцию, если ключ установлен, <br/> для определения нового значения. Удаляет, если значение равно нулю. |
|               public V put(K key, V value)               |                                         Добавляет или заменяет пару ключ/значение. Возвращает предыдущее значение или null.                                         |
|           public V putIfAbsent(K key, V value)           |                         Добавляет значение, если ключ отсутствует, и возвращает ноль. В противном случае возвращает существующее значение.                          |
|               public V remove(Object key)                |                                         Удаляет и возвращает значение, сопоставленное с ключом. Возвращает null, если нет.                                          |
|             public V replace(K key, V value)             |                           Заменяет значение для данного ключа, если ключ установлен. Возвращает исходное значение или null, если его нет.                           |
|     public void replaceAll(BiFunction<K, V, V> func)     |                                                            Заменяет каждое значение результатом функции.                                                            |
|                    public int size()                     |                                                     Возвращает количество записей (пар ключ/значение) в карте.                                                      |
|              public Collection<V> values()               |                                                                Возвращает Collection всех значений.                                                                 |


Хотя Таблица 9.6 представляет собой довольно длинный список методов, не волнуйтесь; многие из названий просты. Кроме 
того, многие из них существуют для удобства. Например, containsKey() можно заменить вызовом get(), который проверяет, 
является ли результат нулевым. Какой из них вы используете, зависит от вас.

### Вызов основных методов

Давайте начнем со сравнения одного и того же кода с двумя типами карт. Прежде всего, это HashMap:

```
Map<String, String> map = new HashMap<>(); 
map.put("koala", "bamboo"); 
map.put("lion", "meat"); 
map.put("giraffe", "leaf"); 
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
   System.out.print(key + ","); // koala,giraffe,lion,
```

Здесь мы используем метод put() для добавления пар ключ/значение в map и метод get() для получения значения по ключу. 
Мы также используем метод keySet() для получения всех ключей.

Java использует hashCode() ключа для определения порядка. Порядок здесь не является отсортированным порядком или 
порядком, в котором мы вводили значения. Теперь давайте посмотрим на TreeMap:

```
Map<String, String> map = new TreeMap<>();
map.put("koala", "bamboo");
map.put("lion", "meat");
map.put("giraffe", "leaf");
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
   System.out.print(key + ","); // giraffe,koala,lion,
```

TreeMap сортирует ключи так, как мы и ожидали. Если бы мы вызвали values() вместо keySet(), порядок значений 
соответствовал бы порядку ключей.

С нашей той же картой мы можем попробовать некоторые boolean проверки:

```
System.out.println(map.contains("lion")); // НЕ КОМПИЛИРУЕТСЯ
System.out.println(map.containsKey("lion")); // true
System.out.println(map.containsValue("lion")); // false
System.out.println(map.size()); // 3
map.clear(); 
System.out.println(map.size()); // 0 
System.out.println(map.isEmpty()); // true
```

Первая линия немного сложнее. Метод contains() находится в интерфейсе Collection, но не в интерфейсе Map. Следующие две 
строки показывают, что ключи и значения проверяются отдельно. Мы видим, что в map есть три пары ключ/значение. Затем 
очищаем содержимое map и видим, что элементов ноль и она пуста.

В следующих разделах мы покажем методы Map, с которыми вы, возможно, не знакомы.

### Итерация по Map

Ранее в этой главе вы видели метод forEach(). Обратите внимание, что в Map это работает немного по-другому. На этот раз 
лямбда-выражение, используемая методом forEach(), имеет два параметра: ключ и значение. Давайте посмотрим на пример, 
показанный здесь:

```
Map<Integer, Character> map = new HashMap<>();
map.put(1, 'a');
map.put(2, 'b');
map.put(3, 'c');
map.forEach((k, v) -> System.out.println(v));
```

Лямбда-выражение имеет как ключ, так и значение в качестве параметров. Случается, что он выводит значение, но может 
делать что угодно с ключом и / или значением. Интересно, что, поскольку мы не заботимся о ключе, этот конкретный код 
мог бы быть написан с использованием метода values() и ссылки на метод вместо этого.

```
map.values().forEach(System.out::println);
```

Другой способ просмотреть все данные на карте — получить пары ключ/значение в наборе. Java имеет статический интерфейс 
внутри Map, называемый Entry. Он предоставляет методы для получения ключа и значения каждой пары.

```
map.entrySet().forEach(e ->
   System.out.println(e.getKey() + " " + e.getValue()));
```

### Безопасное получение значений

Метод get() возвращает значение null, если запрошенный ключ отсутствует на карте. Иногда вы предпочитаете, чтобы 
возвращалось другое значение. К счастью, метод getOrDefault() упрощает эту задачу. Давайте сравним два метода:

```
3: Map<Character, String> map = new HashMap<>(); 
4: map.put('x', "spot"); 
5: System.out.println("X marks the " + map.get('x')); 
6: System.out.println("X marks the " + map.getOrDefault('x', "")); 
7: System.out.println("Y marks the " + map.get('y')); 
8: System.out.println("Y marks the " + map.getOrDefault('y', ""));
```

Этот код печатает следующее:

```
X marks the spot
X marks the spot
Y marks the null
Y marks the
```

Как видите, строки 5 и 6 имеют одинаковый вывод, поскольку методы get() и getOrDefault() ведут себя одинаково, когда 
присутствует ключ. Они возвращают значение, сопоставленное этим ключом. Строки 7 и 8 дают разные выходные данные, 
показывая, что get() возвращает значение null, когда ключ отсутствует. Напротив, getOrDefault() возвращает пустую 
строку, которую мы передали в качестве параметра.

### Замена значений

Эти методы аналогичны версии List, за исключением того, что используется ключ:

```
21: Map<Integer, Integer> map = new HashMap<>(); 
22: map.put(1, 2); 
23: map.put(2, 4); 
24: Integer original = map.replace(2, 10); // 4 
25: System.out.println(map);    // {1=2, 2=10} 
26: map.replaceAll((k, v) -> k + v); 
27: System.out.println(map);    // {1=3, 2=12}
```

Строка 24 заменяет значение ключа 2 и возвращает исходное значение. Строка 26 вызывает функцию и устанавливает значение 
каждого элемента карты в результат этой функции. В нашем случае мы добавили ключ и значение вместе.

### Ставим, если нет (Putting if Absent)

Метод putIfAbsent() устанавливает значение на карте, но пропускает его, если для этого значения уже установлено 
ненулевое значение.

```
Map<String, String> favorites = new HashMap<>(); 
favorites.put("Jenny", "Bus Tour"); 
favorites.put("Tom", null); 
favorites.putIfAbsent("Jenny", "Tram"); 
favorites.putIfAbsent("Sam", "Tram"); 
favorites.putIfAbsent("Tom", "Tram");
System.out.println(favorites); // {Tom=Tram, Jenny=Bus Tour, Sam=Tram}
```

Как видите, значение Jenny не обновляется, поскольку оно уже присутствовало. Sam там вообще не было, поэтому его 
добавили. Tom присутствовал как ключ, но имел null значение. Поэтому его тоже добавили.

### Слияние данных

Метод merge() добавляет логику выбора. Предположим, мы хотим выбрать поездку с самым длинным именем. Мы можем написать 
код, чтобы выразить это, передав функцию сопоставления методу merge():

```
11: BiFunction<String, String, String> mapper = (v1, v2)
12:    -> v1.length()> v2.length() ? v1: v2;
13:
14: Map<String, String> favorites = new HashMap<>(); 
15: favorites.put("Jenny", "Bus Tour"); 
16: favorites.put("Tom", "Tram"); 
17:
18: String jenny = favorites.merge("Jenny", "Skyride", mapper); 
19: String tom = favorites.merge("Tom", "Skyride", mapper); 
20:
21: System.out.println(favorites); // {Tom=Skyride, Jenny=Bus Tour} 
22: System.out.println(jenny);     // Bus Tour 
23: System.out.println(tom);       // Skyride
```

Код в строках 11 и 12 принимает два параметра и возвращает значение. Наша реализация возвращает имя с самым длинным 
именем. Строка 18 вызывает эту функцию сопоставления и видит, что Bus Tour длиннее, чем Skyride, поэтому оставляет 
значение Bus Tour. Строка 19 снова вызывает эту функцию сопоставления. На этот раз Tram короче Skyride, поэтому карта 
обновлена. Строка 21 распечатывает новое содержимое карты. Строки 22 и 23 показывают, что результат возвращается из 
merge().

Метод merge() также имеет логику того, что произойдет, если задействованы нулевые значения или отсутствующие ключи. В 
этом случае она вообще не вызывает BiFunction, а просто использует новое значение.

```
BiFunction<String, String, String> mapper =
   (v1, v2) -> v1.length()> v2.length() ? v1 : v2;
Map<String, String> favorites = new HashMap<>(); 
favorites.put("Sam", null); 
favorites.merge("Tom", "Skyride", mapper); 
favorites.merge("Sam", "Skyride", mapper); 
System.out.println(favorites);   // {Tom=Skyride, Sam=Skyride}
```

Обратите внимание, что функция сопоставления не вызывается. Если бы это было так, у нас было бы исключение 
NullPointerException. Функция сопоставления используется только тогда, когда есть два фактических значения, между 
которыми нужно выбрать.

Последнее, что нужно знать о merge(), — это то, что происходит, когда функция сопоставления вызывается и возвращает 
значение null. Ключ удаляется с карты, когда это происходит:

```
BiFunction<String, String, String> mapper = (v1, v2) -> null;
Map<String, String> favorites = new HashMap<>();
favorites.put("Jenny", "Bus Tour");
favorites.put("Tom", "Bus Tour");

favorites.merge("Jenny", "Skyride", mapper);
favorites.merge("Sam", "Skyride", mapper);
System.out.println(favorites);   // {Tom=Bus Tour, Sam=Skyride}
```

Tom остался один, поскольку для этого ключа не было вызова merge(). Sam был добавлен, поскольку этого ключа не было в 
исходном списке. Jenny была удалена, поскольку функция сопоставления вернула значение null.

В таблице 9.7 все эти сценарии показаны для справки.

#### Таблица 9.7 - Поведение метода merge()

| Если запрошенный ключ ________ | И функция сопоставления возвращает ________ |                                                   Тогда:                                                   | 
|:------------------------------:|:-------------------------------------------:|:----------------------------------------------------------------------------------------------------------:|
|   Имеет null значение в map    |  N/A (функция сопоставления не вызывается)  |                       Обновить значение ключа на карте с помощью параметра значения.                       |  
| Имеет ненулевое значение в map |                    null                     |                                           Удаление ключа с карты                                           |
| Имеет ненулевое значение в map |             Ненулевое значение              |                            Установить ключ для сопоставления результата функции                            |
|         Нет на карте           | N/A (функция сопоставления не вызывается)   | Добавьте ключ с параметром значения для непосредственного сопоставления без вызова функции сопоставления.  |

## Сравнение типов коллекций

Мы завершаем этот раздел обзором всех классов коллекций. Убедитесь, что вы можете заполнить таблицу 9.8, чтобы сравнить 
четыре типа коллекций по памяти.

#### Таблица 9.8 - Типы Java Collections Framework

|  Тип  | Может ли содержать дубликаты элементов? |     Элементы всегда упорядочены?     | Имеет ключи и значения? | Нужно добавлять/удалять в определенном порядке? | 
|:-----:|:---------------------------------------:|:------------------------------------:|:-----------------------:|:-----------------------------------------------:|
| List  |                   Да                    |           Да (по индексу)            |           Нет           |                       Нет                       |  
|  Map  |            Да (для значений)            |                 Нет                  |           Да            |                       Нет                       |
| Queue |                   Да                    | Да (получено в определенном порядке) |           Нет           |                       Да                        |
|  Set  |                   Нет                   |                 Нет                  |           Нет           |                       Нет                       |

Кроме того, убедитесь, что вы можете заполнить Таблицу 9.9, чтобы описать типы на экзамене.

#### Таблица 9.9 - Атрибуты коллекций

|    Тип     | Интерфейс Java Collections Framework | Сортируется? | Вызывает hashCode ? | Вызывает compareTo? | 
|:----------:|:------------------------------------:|:------------:|:-------------------:|:-------------------:|
| ArrayDeque |                Deque                 |     Нет      |         Нет         |         Нет         |  
| ArrayList  |                 List                 |     Нет      |         Нет         |         Нет         |
|  HashMap   |                 Map                  |     Нет      |         Да          |         Нет         |
|  HashSet   |                 Set                  |     Нет      |         Да          |         Нет         |
| LinkedList |             List, Deque              |     Нет      |         Нет         |         Нет         |
|  TreeMap   |                 Map                  |      Да      |         Нет         |         Да          |
|  TreeSet   |                 Set                  |      Да      |         Нет         |         Да          |

Далее на экзамене ожидается, что вы будете знать, какие структуры данных допускают null значения. Структуры данных, 
включающие сортировку, не допускают null значений.

Наконец, на экзамене ожидается, что вы сможете выбрать правильный тип коллекции с учетом описания проблемы. Мы 
рекомендуем сначала определить, о каком типе коллекции идет речь. Определите, ищете ли вы список, карту, очередь или 
набор. Это позволяет исключить ряд ответов. Затем вы сможете выяснить, какой из оставшихся вариантов является лучшим 
ответом.

**Старые коллекции**

Есть несколько коллекций, которые больше не используются на экзамене, но которые вы можете встретить в старом коде. Все 
три были ранними структурами данных Java, которые можно было использовать с потоками:

+ Vector: Реализует List.
+ Hashtable: Реализует Map.
+ Stack: Реализует Queue.

Эти классы сейчас используются редко, так как существуют гораздо лучшие параллельные альтернативы, которые мы рассмотрим 
в главе 13.

## Сортировка данных

Мы обсудили «порядок» для классов TreeSet и TreeMap. Для чисел порядок очевиден — это числовой порядок. Для объектов 
String порядок определяется в соответствии с сопоставлением символов Юникода.

_При работе со String помните, что числа сортируются перед буквами, а прописные буквы — перед строчными._

Во многих из этих примеров мы используем Collections.sort(). Он возвращает void, потому что сортируется именно параметр 
метода.

Вы также можете сортировать объекты, которые создаете сами. Java предоставляет интерфейс, называемый Comparable. Если 
ваш класс реализует Comparable, его можно использовать в структурах данных, требующих сравнения. Существует также класс 
под названием Comparator, который используется для указания того, что вы хотите использовать порядок, отличный от того, 
который предоставляет сам объект.

Comparable и Comparator достаточно похожи, чтобы быть сложными. На экзамене нужно проверить, удастся ли вам спутать эти 
два понятия. Не путайте! В этом разделе мы сначала обсудим Comparable. Затем, просматривая Comparator, мы указываем на 
все различия.

### Создание класса Comparable

Интерфейс Comparable имеет только один метод. Собственно, это весь интерфейс:

```
public interface Comparable<T> {    
   int compareTo(T o);
}
```

Универсальный T позволяет вам реализовать этот метод и указать тип вашего объекта. Это позволяет избежать приведения при 
реализации compareTo(). Любой объект может быть Comparable. Например, у нас есть куча уток, и мы хотим отсортировать их 
по именам. Сначала мы обновляем объявление класса, чтобы наследовать Comparable<Duck>, а затем реализуем метод 
compareTo():

```
import java.util.*;
public class Duck implements Comparable<Duck> {
   private String name;
   public Duck(String name) {
      this.name = name;
   }
   public String toString() {         // использовать читаемый вывод
      return name;
   }
    public int compareTo(Duck d) {
       return name.compareTo(d.name); // сортирует по возрастанию по имени
    }
    public static void main(String[] args) {
       var ducks = new ArrayList<Duck>();
        ducks.add(new Duck("Quack"));
        ducks.add(new Duck("Puddles"));
        Collections.sort(ducks);       // сортирует по возрастанию по имени
        System.out.println(ducks);     // [Puddles, Quack]
}}
```

Без реализации этого интерфейса все, что у нас есть, — это метод с именем compareTo(), но это не будет объект 
Comparable. Мы также могли бы реализовать Comparable<Object> или какой-либо другой класс для T, но это было бы не так 
полезно для сортировки группы объектов Duck.

_Класс Duck переопределяет метод toString() из Object, который мы описали в главе 8. Это переопределение обеспечивает 
полезный вывод при печати уток. Без этого переопределения выходные данные будут выглядеть примерно 
так: [Duck@70dea4e, Duck@5c647e05] — вряд ли это полезно для определения того, какое имя утки идет первым._

Наконец, класс Duck реализует функцию compareTo(). Поскольку Duck сравнивает объекты типа String, а в классе String уже 
есть метод compareTo(), он может просто делегировать.

Нам по-прежнему нужно знать, что возвращает метод CompareTo(), чтобы мы могли написать свой собственный. 
Необходимо знать три правила:

+ Число 0 возвращается, когда текущий объект эквивалентен аргументу метода compareTo().
+ Отрицательное число (меньше 0) возвращается, если текущий объект меньше аргумента метода compareTo().
+ Положительное число (больше 0) возвращается, когда текущий объект больше, чем аргумент метода compareTo().

Давайте посмотрим на реализацию метода compareTo(), которая сравнивает числа вместо объектов String:

```
1:  public class Animal implements Comparable<Animal> { 
2:     private int id; 
3:     public int compareTo(Animal a) { 
4:        return id - a.id;                       // sorts ascending by id 
5:     }
6:     public static void main(String[] args) { 
7:        var a1 = new Animal();
8:        var a2 = new Animal(); 
9:        a1.id = 5; 
10:       a2.id = 7; 
11:       System.out.println(a1.compareTo(a2));   // -2 
12:       System.out.println(a1.compareTo(a1));   // 0 
13:       System.out.println(a2.compareTo(a1));   // 2 
14:    } }
```

Строки 7 и 8 создают два объекта Animal. Строки 9 и 10 устанавливают значения своих id. Это не лучший способ установки 
переменных экземпляра. Было бы лучше использовать конструктор или метод сеттер. Поскольку на экзамене показан 
нетрадиционный код, чтобы убедиться, что вы понимаете правила, мы также добавляем нетрадиционный код.

В строках 3–5 показан один из способов сравнения двух int значений. Вместо этого мы могли бы использовать 
Integer.compare(id, a.id). Убедитесь, что вы понимаете оба подхода.

_Помните, что id-a.id сортирует в порядке возрастания, а a.id-id — в порядке убывания._

Строки 11–13 подтверждают, что мы правильно реализовали функцию compareTo(). Строка 11 сравнивает меньший id с большим и 
поэтому печатает отрицательное число. В строке 12 сравниваются животные с одинаковым id, поэтому выводится 0. Строка 13 
сравнивает больший id с меньшим и, следовательно, возвращает положительное число.

### Приведение аргумента compareTo()

При работе с устаревшим кодом или кодом, который не использует дженерики, метод compareTo() требует приведения типов, 
поскольку ему передается Object.

```
public class LegacyDuck implements Comparable {
   private String name;
   public int compareTo(Object obj) {
      LegacyDuck d = (LegacyDuck) obj; // кастинг, потому что нет дженериков
      return name.compareTo(d.name);
   }
}      
```

Поскольку мы не указываем общий тип для Comparable, Java предполагает, что нам нужен Object, а это означает, что нам 
нужно выполнить приведение к LegacyDuck, прежде чем получить доступ к переменным экземпляра на нем.

### Проверка на null

Работая с Comparable и Comparator в этой главе, мы склонны предполагать, что данные имеют значения, но это не всегда 
так. При написании собственных методов сравнения вам следует проверять данные перед их сравнением, если они не 
проверены заранее.

```
public class MissingDuck implements Comparable<MissingDuck> {
   private String name;
   public int compareTo(MissingDuck quack) {
       if (quack == null)
          throw new IllegalArgumentException("Poorly formed duck!");
       if (this.name == null && quack.name == null)
          return 0;
       else if (this.name == null) return -1;      
       else if (quack.name == null) return 1;      
       else return name.compareTo(quack.name);
   }
}       
```

### Сохранение согласованности compareTo() и equals()

Если вы пишете класс, реализующий Comparable, вы вводите новую бизнес-логику для определения равенства. Метод 
compareTo() возвращает 0, если два объекта равны, а метод equals() возвращает true, если два объекта равны. 
Говорят, что естественный порядок, использующий функцию compareTo(), соответствует принципу равенства тогда и только 
тогда, когда x.equals(y) true всякий раз, когда x.compareTo(y) равно 0.

Аналогично, x.equals(y) должен быть false, если x.compareTo(y) не равен 0. Настоятельно рекомендуется сделать ваши 
классы Comparable совместимыми с равными, поскольку не все классы коллекций ведут себя предсказуемо, если функции 
compareTo() и equals() методы не однозначны.

Например, следующий класс Product определяет метод compareTo(), который несовместим с методом равенства:

```
public class Product implements Comparable<Product> {
   private int id;   
   private String name;
   
   public int hashCode() { return id; }
   public boolean equals(Object obj) {
      if(!(obj instanceof Product)) return false;
      var other = (Product) obj;
      return this.id == other.id;
   }
   public int compareTo(Product obj) {
      return this.name.compareTo(obj.name);
   } 
}
```

Возможно, вы сортируете объекты Product по имени, но имена не уникальны. Метод compareTo() не обязательно должен быть 
согласован с равными. Один из способов исправить это — использовать компаратор для определения сортировки в другом 
месте.

Теперь, когда вы знаете, как реализовать объекты Comparable, вы можете взглянуть на Comparator и сосредоточиться на 
различиях.

### Сравнение данных с помощью Comparator

Иногда вам нужно отсортировать объект, который не реализовал Comparable, или вы хотите сортировать объекты разными 
способами в разное время. Предположим, мы добавим вес нашему классу Duck. Теперь у нас есть следующее:

```
1:  import java.util.ArrayList; 
2:  import java.util.Collections; 
3:  import java.util.Comparator; 
4:
5:  public class Duck implements Comparable<Duck> { 
6:     private String name; 
7:     private int weight; 
8:
9:     // Предположим, что имеются геттеры/сеттеры/конструкторы
10:
11:    public String toString() { return name; } 
12:
13:    public int compareTo(Duck d) { 
14:       return name.compareTo(d.name); 
15:    }
16:
17:    public static void main(String[] args) { 
18:       Comparator<Duck> byWeight = new Comparator<Duck>() { 
19:          public int compare(Duck d1, Duck d2) { 
20:             return d1.getWeight()-d2.getWeight(); 
21:          }
22:       };
23:       var ducks = new ArrayList<Duck>(); 
24:       ducks.add(new Duck("Quack", 7)); 
25:       ducks.add(new Duck("Puddles", 10)); 
26:       Collections.sort(ducks); 
27:       System.out.println(ducks); // [Puddles, Quack] 
28:       Collections.sort(ducks, byWeight);
29:       System.out.println(ducks); // [Quack, Puddles] 
30:    }
31: }
```

Во-первых, обратите внимание, что эта программа импортирует java.util.Comparator в строке 3. Мы не всегда показываем 
импорт, поскольку вы можете предположить, что он присутствует, если он не показан. Здесь мы показываем импорт, чтобы 
обратить внимание на тот факт, что Comparable и Comparator находятся в разных пакетах: java.lang и java.util 
соответственно. Это означает, что Comparable можно использовать без оператора импорта, а Comparator — нет.

Сам класс Duck может определить только один метод compareTo(). В данном случае было выбрано имя. Если мы хотим выполнить 
сортировку по чему-то другому, нам нужно определить этот порядок сортировки вне метода compareTo(), используя отдельный 
класс или лямбда-выражение.

Строки 18–22 метода main() показывают, как определить Comparator с использованием внутреннего класса. В строках 26–29 мы 
сортируем без использования Comparator, а затем с помощью Comparator, чтобы увидеть разницу в результатах.

Comparator — это функциональный интерфейс, поскольку необходимо реализовать только один абстрактный метод. Это означает, 
что мы можем переписать Comparator в строках 18–22, используя лямбда-выражение, как показано здесь:

```
Comparator<Duck> byWeight = (d1, d2) -> d1.getWeight()-d2.getWeight();
```

Альтернативно, мы можем использовать ссылку на метод и вспомогательный метод, чтобы указать, что мы хотим сортировать по 
весу.

```
Comparator<Duck> byWeight = Comparator.comparing(Duck::getWeight);
```

В этом примере Comparator.comparing() — это метод статического интерфейса, который создает Comparator с учетом 
лямбда-выражения или ссылки на метод. Удобно, не так ли?

**Является ли Comparable функциональным интерфейсом?**

Мы сказали, что Comparator — это функциональный интерфейс, поскольку он имеет единственный абстрактный метод. Comparable 
также является функциональным интерфейсом, поскольку он также имеет единственный абстрактный метод. Однако использовать 
лямбду для Comparable было бы глупо. Цель Comparable — реализовать его внутри сравниваемого объекта.

### Сравнение Comparable и Comparator

Между Comparable и Comparator есть несколько различий. Мы перечислили их для вас в Таблице 9.10.

#### Таблица 9.10 - Сравнение Comparable и Comparator

|                          Разница                          | Comparable  | Comparator | 
|:---------------------------------------------------------:|:-----------:|:----------:|
|                        Имя пакета                         |  java.lang  | java.util  |  
| Интерфейс должен быть реализован путем сравнения классов? |     Да      |    Нет     |
|                  Имя метода в интерфейсе                  | compareTo() | compare()  |
|                   Количество параметров                   |      1      |     2      |
|   Обычно объявляется с использованием лямбда-выражения    |     Нет     |     Да     |

Запомните эту таблицу. Экзамен попытается обмануть вас, перепутав эти два пункта и проверив, сможете ли вы его уловить. 
Вы понимаете, почему это не компилируется?

```
var byWeight = new Comparator<Duck>() { // НЕ КОМПИЛИРУЕТСЯ  
    public int compareTo(Duck d1, Duck d2) {      
    return d1.getWeight()-d2.getWeight();   
    }
};
```

Имя метода неверно. Comparator должен реализовать метод с именем compare(). Обратите особое внимание на имена методов и 
количество параметров, когда вы видите Comparator и Comparable в вопросах.

### Сравнение нескольких полей

При написании Comparator, который сравнивает несколько переменных экземпляра, код становится немного запутанным. 
Предположим, что у нас есть класс Squirrel, как показано здесь:

```
public class Squirrel {
   private int weight;
   private String species;
   // Предположим, что имеются геттеры/сеттеры/конструкторы
```

Мы хотим написать Comparator для сортировки по названию вида. Если две белки принадлежат к одному виду, мы хотим сначала 
отсортировать ту, которая весит меньше всего. Мы могли бы сделать это с помощью кода, который выглядит следующим 
образом:

```
public class MultiFieldComparator implements Comparator<Squirrel> {
   public int compare(Squirrel s1, Squirrel s2) {
      int result = s1.getSpecies().compareTo(s2.getSpecies());
      if (result != 0) return result;
      return s1.getWeight()-s2.getWeight();
   }
}
```

Это работает при условии, что названия видов не являются null. Он проверяет одно поле. Если они не совпадают, то 
сортировку заканчиваем. Если они совпадают, он смотрит на следующее поле. Однако читать это непросто. Также легко 
ошибиться. Изменение != на == полностью нарушает сортировку.

Альтернативно мы можем использовать ссылки на методы и построить компаратор. Этот код представляет логику того же 
сравнения:

```
Comparator<Squirrel> c = Comparator.comparing(Squirrel::getSpecies)    
   .thenComparingInt(Squirrel::getWeight);
```

На этот раз мы объединяем методы. Сначала мы создаем Comparator по возрастанию видов. Затем, если ничья, сортируем по 
весу. Мы также можем сортировать по убыванию. Некоторые методы Comparator, например thenComparingInt(), являются 
методами по умолчанию.

Предположим, мы хотим отсортировать по видам в порядке убывания.

```
var c = Comparator.comparing(Squirrel::getSpecies).reversed();
```

В Таблице 9.11 показаны вспомогательные методы, которые вам следует знать для создания Comparator. Мы опустили типы 
параметров, чтобы вы сосредоточились на методах. Они используют многие функциональные интерфейсы, о которых вы узнали в 
предыдущей главе.

#### Таблица 9.11 - Вспомогательные статические методы для создания Comparator

|           Метод           |                                                          Описание                                                          | 
|:-------------------------:|:--------------------------------------------------------------------------------------------------------------------------:|
|    comparing(function)    | Сравните по результатам функции, которая возвращает любой Object <br/> (или примитив, автоматически упакованный в Object). |  
| comparingDouble(function) |                                Сравните по результатам функции, которая возвращает double.                                 |
|  comparingInt(function)   |                                     Сравнить по результатам функции, возвращающей int.                                     |
|  comparingLong(function)  |                                 Сравните по результатам функции, которая возвращает long.                                  |
|      naturalOrder()       |                         Сортировка в порядке, указанном реализацией Comparable для самого объекта.                         |
|      reverseOrder()       |                    Сортировка в обратном порядке, заданном реализацией Comparable для самого объекта.                      |

В Таблице 9.12 показаны методы, которые вы можете связать с Comparator для дальнейшего определения его поведения.

#### Таблица 9.12 - Вспомогательные методы по умолчанию для создания Comparator

|             Метод             |                                                                                      Описание                                                                                      | 
|:-----------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|          reversed()           |                                                                      Обратный порядок связанного Comparator.                                                                       |  
|    thenComparing(function)    |                Если предыдущий Comparator возвращает 0, используйте этот компаратор, <br/> который возвращает Object или может быть автоматически упакован в него.                 |
| thenComparingDouble(function) |   Если предыдущий компаратор возвращает 0, используйте этот Comparator, который возвращает <br/> значение double. В противном случае верните значение из предыдущего Comparator.   |
|  thenComparingInt(function)   |    Если предыдущий компаратор возвращает 0, используйте этот Comparator, который возвращает <br/> значение int. В противном случае верните значение из предыдущего Comparator.     |
| thenComparingLong(function)   |  Если предыдущий компаратор возвращает 0, используйте этот Comparator, который возвращает <br/> значение long. В противном случае верните значение из предыдущего Comparator.      |

**Вы, наверное, уже заметили, что мы часто игнорируем null значения при проверке равенства и сравнении объектов. Это 
отлично подходит для экзамена. Однако в реальном мире все не так гладко. Вам придется решить, как обрабатывать null 
значения или не допускать их присутствия в вашем объекте.**

### Сортировка и поиск

Теперь, когда вы узнали все о Comparable и Comparator, мы наконец можем сделать с ними что-нибудь полезное, например 
сортировку. Метод Collections.sort() использует для сортировки метод compareTo(). Он ожидает, что объекты, которые будут 
отсортированы, будут Comparable.

```
2: public class SortRabbits { 
3:    static record Rabbit(int id) {} 
4:    public static void main(String[] args) { 
5:       List<Rabbit> rabbits = new ArrayList<>(); 
6:       rabbits.add(new Rabbit(3)); 
7:       rabbits.add(new Rabbit(1)); 
8:       Collections.sort(rabbits); // НЕ КОМПИЛИРУЕТСЯ
9:    } }
```

Java знает, что запись Rabbit не подлежит Comparable. Он знает, что сортировка не удастся, поэтому даже не позволяет 
коду скомпилироваться. Вы можете исправить это, передав Comparator в функцию sort(). Помните, что Comparator полезен, 
когда вы хотите указать порядок сортировки без использования метода compareTo().

```
8:       Comparator<Rabbit> c = (r1, r2) -> r1.id - r2.id; 
9:       Collections.sort(rabbits, c); 
10:      System.out.println(rabbits); // [Rabbit[id=1], Rabbit[id=3]]
```

Предположим, вы хотите отсортировать кроликов в порядке убывания. Вы можете изменить Comparator на r2.id – r1.id. В 
качестве альтернативы вы можете впоследствии перевернуть содержимое списка:

```
8:       Comparator<Rabbit> c = (r1, r2) -> r1.id - r2.id; 
9:       Collections.sort(rabbits, c); 
10:      Collections.reverse(rabbits); 
11:      System.out.println(rabbits); // [Rabbit[id=3], Rabbit[id=1]]
```

Методы sort() и binarySearch() позволяют передавать объект Comparator, когда вы не хотите использовать естественный 
порядок.

**Обзор binarySearch()**

Для метода binarySearch() требуется отсортированный List.

```
11: List<Integer> list = Arrays.asList(6,9,1,8); 
12: Collections.sort(list); // [1, 6, 8, 9] 
13: System.out.println(Collections.binarySearch(list, 6)); // 1 
14: System.out.println(Collections.binarySearch(list, 3)); // -2
```

Строка 12 сортирует List, чтобы мы могли правильно вызвать двоичный поиск. В строке 13 выводится индекс, по которому 
найдено совпадение. В строке 14 выводится на единицу меньше отрицательного индекса того места, куда необходимо вставить 
запрошенное значение. Число 3 необходимо будет вставить в индекс 1 (после числа 1, но перед числом 6). Отрицание этого 
результата дает нам −1, а вычитание 1 дает нам −2.

---

В работе с binarySearch() есть одна хитрость. Как вы думаете, какие следующие результаты?

```
3: var names = Arrays.asList("Fluffy", "Hoppy"); 
4: Comparator<String> c = Comparator.reverseOrder(); 
5: var index = Collections.binarySearch(names, "Hoppy", c); 
6: System.out.println(index);
```

Ответ оказывается -1. Прежде чем впасть в панику, вам не обязательно знать, что ответ -1. Вам нужно знать, что ответ не 
определен. В строке 3 создается список [Fluffy, Hoppy]. Этот список отсортирован по возрастанию. Строка 4 создает 
компаратор, который меняет естественный порядок. Строка 5 запрашивает бинарный поиск в порядке убывания. Поскольку 
список не в таком порядке, мы не удовлетворяем предварительному условию для выполнения поиска.

Хотя результат вызова метода binarySearch() для неправильно отсортированного списка не определен, иногда вам может 
повезти. Например, поиск начинается с середины списка с нечетным номером. Если вы запросите средний элемент, 
возвращаемый индекс будет таким, как вы ожидаете.

Ранее в этой главе мы говорили о коллекциях, которым для реализации Comparable требуются классы. В отличие от 
сортировки, они не проверяют, реализовали ли вы Comparable во время компиляции.

Возвращаясь к нашему Rabbit, который не реализует Comparable, мы пытаемся добавить его в TreeSet:

```
2:  public class UseTreeSet { 
3:     static class Rabbit{ int id; } 
4:     public static void main(String[] args) { 
5:        Set<Duck> ducks = new TreeSet<>(); 
6:        ducks.add(new Duck("Puddles")); 
7:
8:        Set<Rabbit> rabbits = new TreeSet<>(); 
9:        rabbits.add(new Rabbit());  // ClassCastException 
10: } }
```

Строка 6 в порядке. Duck реализует Comparable. TreeSet может отсортировать его в правильное положение в наборе. 
Строка 9 - проблема. Когда TreeSet пытается его отсортировать, Java обнаруживает тот факт, что Rabbit не реализует 
Comparable. Java выдает исключение, которое выглядит следующим образом:

```
Exception in thread "main" java.lang.ClassCastException:
   class Rabbit cannot be cast to class java.lang.Comparable
```

Может показаться странным, что это исключение генерируется при добавлении первого объекта в набор. Ведь сравнивать пока 
не с чем. Java работает таким образом для согласованности.

Точно так же, как при поиске и сортировке, вы можете указать коллекциям, требующим сортировки, что вы хотите 
использовать определенный Comparator. Например:

```
8: Set<Rabbit> rabbits = new TreeSet<>((r1, r2) -> r1.id - r2.id); 
9: rabbits.add(new Rabbit());
```

Теперь Java знает, что вы хотите выполнить сортировку по id, и все в порядке. Comparator — полезный объект. Он позволяет 
отделить порядок сортировки от сортируемого объекта. Обратите внимание, что строка 9 в обоих предыдущих примерах 
одинакова. Изменилось объявление TreeSet.

### Сортировка List

Хотя вы можете вызвать Collections.sort(list), вы также можете сортировать непосредственно объект списка.

```
3: List<String> bunnies = new ArrayList<>(); 
4: bunnies.add("long ear"); 
5: bunnies.add("floppy"); 
6: bunnies.add("hoppy"); 
7: System.out.println(bunnies);     // [long ear, floppy, hoppy] 
8: bunnies.sort((b1, b2) -> b1.compareTo(b2)); 
9: System.out.println(bunnies);     // [floppy, hoppy, long ear]
```

В строке 8 мы сортируем список по алфавиту. Метод sort() принимает Comparator, который обеспечивает порядок сортировки. 
Помните, что Comparator принимает два параметра и возвращает int. Если вам нужно узнать, что означает возвращаемое 
значение операции compare(), обратитесь к разделу Comparator в этой главе или к разделу «Comparing» в главе 4 
«Основные API». Это действительно важно запомнить!

В Set или Map нет метода сортировки. Оба этих типа неупорядочены, поэтому сортировать их не имеет смысла.

## Работа с дженериками

Мы завершаем эту главу одной из самых полезных, а иногда и самых запутанных функций языка Java: обобщениями. 
Фактически, мы широко использовали их в последних двух главах — тип между <>. Зачем нам нужны дженерики? Представьте 
себе, если бы мы не указывали тип наших списков и просто надеялись, что вызывающий абонент не ввел что-то, чего мы не 
ожидали. Это делается следующим образом:

```
14: static void printNames(List list) { 
15:    for (int i = 0; i < list.size(); i++) { 
16:       String name = (String) list.get(i); // ClassCastException 
17:       System.out.println(name); 
18:    }
19: }
20: public static void main(String[] args) { 
21:    List names = new ArrayList(); 
22:    names.add(new StringBuilder("Webby")); 
23:    printNames(names); 
24: }
```

Этот код генерирует исключение ClassCastException. Строка 22 добавляет в list StringBuilder. Это законно, поскольку 
необщий список может содержать что угодно. Однако строка 16 написана с расчетом на то, что там будет определенный класс. 
Он приводит к строке, отражая это предположение. Поскольку предположение неверно, код выдает исключение 
ClassCastException, которое java.lang.StringBuilder не может быть преобразовано в java.lang.String.

Обобщенные типы исправляют эту проблему, позволяя вам писать и использовать параметризованные типы. Поскольку мы 
указываем, что нам нужен ArrayList объектов String, компилятор имеет достаточно информации, чтобы в первую очередь 
предотвратить эту проблему.

```
List<String> names = new ArrayList<String>();
names.add(new StringBuilder("Webby")); // НЕ КОМПИЛИРУЕТСЯ
```

Получить ошибку компилятора — это хорошо. Вы сразу поймете, что что-то не так, вместо того, чтобы надеяться обнаружить 
это позже.

### Создание обобщенных классов

Вы можете добавлять дженерики в свои собственные классы. Синтаксис представления универсального типа заключается в 
объявлении формального параметра типа в угловых скобках. Например, следующий класс с именем Crate имеет переменную 
универсального типа, объявленную после имени класса:

```
public class Crate<T> {    
   private T contents;   
   public T lookInCrate() {      
      return contents;
   }
   public void packCrate(T contents) {      
      this.contents = contents;   
   }
}
```

Общий тип T доступен в любом месте класса Crate. Когда вы создаете экземпляр класса, вы сообщаете компилятору, каким 
должно быть значение T для этого конкретного экземпляра.

**Соглашения об именах для дженериков**

Параметр типа может быть назван как угодно. По соглашению используются одиночные заглавные буквы, чтобы было очевидно, 
что они не являются настоящими именами классов. Ниже приведены общепринятые буквы:

+ E для элемента
+ K для ключа карты
+ V для значения карты
+ N для числа
+ T для общего типа данных
+ S, U, V и т. д. для нескольких универсальных типов

---

Например, предположим, что существует класс Elephant, и мы перемещаем нашего слона в новый, более просторный вольер в 
нашем зоопарке.

```
Elephant elephant = new Elephant(); 
Crate<Elephant> crateForElephant = new Crate<>(); 
crateForElephant.packCrate(elephant); 
Elephant inNewHome = crateForElephant.lookInCrate();
```

Честно говоря, мы не столько упаковали ящик, сколько слон в него вошел. Однако вы можете видеть, что класс Crate 
способен справиться со слоном, ничего о нем не зная.

Вероятно, это не кажется особенно впечатляющим. Мы могли бы просто ввести Elephant вместо T при кодировании Crate. 
Что, если мы захотим создать Crate для другого животного?

```
Crate<Zebra> crateForZebra = new Crate<>();
```

Теперь мы не могли просто жестко запрограммировать Elephant в классе Crate, поскольку Zebra — это не Elephant. Однако 
мы могли бы создать суперкласс или интерфейс Animal и использовать его в Crate.

Универсальные классы становятся полезными, когда классы, используемые в качестве параметра типа, не могут иметь 
абсолютно ничего общего друг с другом. Например, нам нужно отправить нашего 120-фунтового робота в другой город:

```
Robot joeBot = new Robot(); 
Crate<Robot> robotCrate = new Crate<>(); 
robotCrate.packCrate(joeBot);

// отправить в Хьюстон
Robot atDestination = robotCrate.lookInCrate();
```

Теперь это начинает становиться интересным. Класс Crate работает с классами любого типа. До появления дженериков нам 
нужно было бы, чтобы Crate использовал класс Object для своей переменной экземпляра, что возлагало бы на вызывающую 
нагрузку бремя приведения объекта, который он получает при выгрузке ящика.

Помимо того, что Crate не нужно знать об объектах, которые в него входят, этим объектам не нужно знать о Crate. 
Мы не требуем, чтобы объекты реализовывали интерфейс с именем Crateable или что-то подобное. Класс можно поместить в 
Crate вообще без каких-либо изменений.

_Не волнуйтесь, если вы не можете придумать применение собственным обобщенным классам. Если вы не пишете библиотеку для 
повторного использования другими, дженерики вряд ли появятся в определениях классов, которые вы пишете. Вы уже часто 
видели их в вызываемом коде, например, в функциональных интерфейсах и коллекциях._

Универсальные классы не ограничиваются наличием одного параметра типа. Этот класс показывает два общих параметра:

```
public class SizeLimitedCrate<T, U> {    
   private T contents;   
   private U sizeLimit;   
   public SizeLimitedCrate(T contents, U sizeLimit) {      
      this.contents = contents;      
      this.sizeLimit = sizeLimit;   
} }
```

T представляет тип, который мы помещаем в ящик. U представляет собой единицу измерения, которую мы используем для 
измерения максимального размера ящика. Чтобы использовать этот общий класс, мы можем написать следующее:

```
Elephant elephant = new Elephant(); 
Integer numPounds = 15_000; 
SizeLimitedCrate<Elephant, Integer> c1 = new SizeLimitedCrate<>(elephant, numPounds);
```

Здесь мы указываем, что тип — Elephant, а единица измерения — Integer. Мы также напоминаем, что числовые литералы могут 
содержать символы подчеркивания.

### Понимание удаления типа

Указание универсального типа позволяет компилятору обеспечить правильное использование универсального типа. Например, 
указание универсального типа Crate как Robot аналогично замене буквы T в классе Crate на Robot. Однако это только для 
времени компиляции.

Компилятор «за кулисами» заменяет все ссылки на T в Crate на Object. Другими словами, после компиляции кода ваши 
дженерики станут просто типами Object. Класс Crate во время выполнения выглядит следующим образом:

```
public class Crate {       
   private Object contents;       
   public Object lookInCrate() {          
      return contents;       
   }
   public void packCrate(Object contents) {          
      this.contents = contents;       
   }
}
```

Это означает, что существует только один файл класса. Для разных параметризованных типов не существует разных копий. 
(Некоторые другие языки работают таким же образом.) Этот процесс удаления обобщенного синтаксиса из вашего кода 
называется стиранием типа. Стирание типов позволяет вашему коду быть совместимым со старыми версиями Java, не 
содержащими дженериков.

Компилятор добавляет соответствующие приведения для вашего кода для работы с этим типом стертого класса.
Например, вы вводите следующее:

```
Robot r = crate.lookInCrate();
```

Компилятор преобразует это в следующее:

```
Robot r = (Robot) crate.lookInCrate();
```

В следующих разделах мы рассмотрим значение дженериков для объявлений методов.

### Перегрузка обобщенного метода

В классе разрешен только один из этих двух методов, поскольку стирание типа приведет к сокращению обоих наборов 
аргументов до (List input/ввод списка):

```
public class LongTailAnimal {    
   protected void chew(List<Object> input) {}   
   protected void chew(List<Double> input) {}  // НЕ КОМПИЛИРУЕТСЯ
}
```

По той же причине вы также не можете перегрузить универсальный метод из родительского класса.

```
public class LongTailAnimal {    
   protected void chew(List<Object> input) {}
}

public class Anteater extends LongTailAnimal {    
   protected void chew(List<Double> input) {}  // НЕ КОМПИЛИРУЕТСЯ
}
```

Оба этих примера не удалось скомпилировать из-за стирания типа. В скомпилированной форме универсальный тип удаляется и 
отображается как недопустимый перегруженный метод. Теперь давайте посмотрим на подкласс:

```
public class Anteater extends LongTailAnimal {    
   protected void chew(List<Object> input) {}   
   protected void chew(ArrayList<Double> input) {}
}
```

Первый метод chew() компилируется, поскольку он использует в переопределенном методе тот же универсальный тип, что и 
тот, который определен в родительском классе. Второй метод chew() также компилируется.

Однако это перегруженный метод, поскольку одним из аргументов метода является List, а другим — ArrayList. При работе с 
универсальными методами важно учитывать базовый тип.

### Возвращающие обобщенные типы

Когда вы работаете с переопределенными методами, возвращающими дженерики, возвращаемые значения должны быть 
ковариантными. С точки зрения дженериков это означает, что тип возвращаемого значения класса или интерфейса, 
объявленного в переопределяющем методе, должен быть подтипом класса, определенного в родительском классе. Тип 
универсального параметра должен точно соответствовать типу его родительского элемента.

Учитывая следующее объявление класса Mammal, какой из двух подклассов, Monkey и Goat, компилируется?

```
public class Mammal {    
   public List<CharSequence> play() { ... }   
   public CharSequence sleep() { ... }
}

public class Monkey extends Mammal {    
   public ArrayList<CharSequence> play() { ... }
}

public class Goat extends Mammal {    
   public List<String> play() { ... }  // НЕ КОМПИЛИРУЕТСЯ 
   public String sleep() { ... }
}
```

Класс Monkey компилируется, поскольку ArrayList является подтипом List. Однако метод play() в классе Goat не 
компилируется. Чтобы возвращаемые типы были ковариантными, параметр универсального типа должен совпадать. Несмотря на 
то, что String является подтипом CharSequence, он не совсем соответствует универсальному типу, определенному в классе 
Mammal. Таким образом, это считается недопустимым переопределением.

Обратите внимание, что метод sleep() в классе Goat компилируется, поскольку String является подтипом CharSequence. Этот 
пример показывает, что ковариация применяется к возвращаемому типу, а не к универсальному типу параметра.

На экзамене вам может быть полезно применить стирание типов к вопросам, связанным с дженериками, чтобы гарантировать их 
правильную компиляцию. После того как вы определили, какие методы переопределяются, а какие перегружаются, действуйте в 
обратном направлении, убедившись, что универсальные типы соответствуют переопределенным методам. И помните, что 
универсальные методы нельзя перегрузить, изменив только тип универсального параметра.

### Реализация обобщенных интерфейсов

Как и класс, интерфейс может объявлять параметр формального типа. Например, следующий интерфейс Shippable использует 
универсальный тип в качестве аргумента метода ship():

```
public interface Shippable<T> {    
   void ship(T t);
}
```

Класс может реализовать этот интерфейс тремя способами. Первый — указать универсальный тип в классе. Следующий 
конкретный класс говорит, что он имеет дело только с роботами. Это позволяет объявить метод ship() с параметром 
Robot:

```
class ShippableRobotCrate implements Shippable<Robot> {    
   public void ship(Robot t) { }
}
```

Следующий способ — создать общий класс. Следующий конкретный класс позволяет вызывающей стороне указать тип обобщенного 
кода:

```
class ShippableAbstractCrate<U> implements Shippable<U> {    
   public void ship(U t) { }
}
```

В этом примере параметру типа могло быть присвоено любое имя, включая T. В примере мы использовали U, чтобы избежать 
путаницы в отношении того, к чему относится T. Экзаменатор не будет возражать против того, чтобы запутать вас, используя
одно и то же имя параметра типа.

Последний способ — вообще не использовать дженерики. Это старый способ написания кода. Он генерирует предупреждение 
компилятора о том, что Shippable является необработанным типом, но компилируется. Здесь метод ship() имеет параметр 
Object, поскольку универсальный тип не определен:

```
class ShippableCrate implements Shippable {    
   public void ship(Object t) { }
}
```

---

_Сценарий реального мира_

**Что нельзя делать с универсальными типами**

Существуют некоторые ограничения на то, что вы можете делать с универсальным типом. Их нет на экзамене, но будет полезно 
обратиться к этому сценарию, когда вы пишете практические программы и сталкиваетесь с одной из таких ситуаций.

Большинство ограничений связано со стиранием типов. Oracle называет типы, информация о которых полностью доступна во 
время выполнения, ревариабельными. Повторяемые типы могут делать все, что позволяет Java. Неповторяемые типы имеют 
некоторые ограничения.

Вот вещи, которые вы не можете сделать с помощью дженериков (и под «нельзя» мы подразумеваем, не прибегая к искажениям, 
таким как передача объекта класса):

+ **Вызов конструктора:** Запись new T() не разрешена, поскольку во время выполнения это будет new Object().
+ **Создайте массив этого универсального типа:** Этот вариант самый раздражающий, но он имеет смысл, поскольку вы будете 
создавать массив значений Object.
+ **Вызов экземпляра:** Это запрещено, поскольку во время выполнения List<Integer> и List<String> выглядят одинаково для 
Java благодаря стиранию типов.
+ **Используйте примитивный тип в качестве параметра универсального типа:** Это не имеет большого значения, поскольку 
вместо этого вы можете использовать класс-оболочку. Если вам нужен тип int, просто используйте Integer.
+ **Создайте статическую переменную как параметр универсального типа:** Это невозможно, поскольку тип связан с 
экземпляром класса.

---

### Написание обобщенных методов

До этого момента вы видели параметры формального типа, объявленные на уровне класса или интерфейса. Их также можно 
объявить на уровне метода. Это часто полезно для static методов, поскольку они не являются частью экземпляра, 
который может объявить тип. Однако это также разрешено для нестатических методов.

В этом примере оба метода используют общий параметр:

```
public class Handler {
   public static <T> void prepare(T t) {      
      System.out.println("Preparing " + t);   
   }
   public static <T> Crate<T> ship(T t) {      
      System.out.println("Shipping " + t);      
      return new Crate<T>();  
   }
}
```

Параметр метода — это универсальный тип T. Перед типом возвращаемого значения мы объявляем параметр формального 
типа <T>. В методе ship() мы покажем, как можно использовать общий параметр возвращаемого типа Crate<T> для этого 
метода.

Если метод не получает параметр универсального формального типа из класса/интерфейса, он указывается непосредственно 
перед возвращаемым типом метода. Это может привести к созданию интересного кода!

```
2: public class More { 
3:    public static <T> void sink(T t) { }
4:    public static <T> T identity(T t) { return t; } 
5:    public static T noGood(T t) { return t; } // НЕ КОМПИЛИРУЕТСЯ
6: }
```

В строке 3 показан тип формального параметра непосредственно перед типом возвращаемого значения void. В строке 4 
показано, что тип возвращаемого значения является формальным типом параметра. Это выглядит странно, но это правильно. 
В строке 5 опущен тип формального параметра и поэтому она не компилируется.

---

_Сценарий реального мира_

**Опциональный синтаксис для вызова универсального метода**

Вы можете вызвать общий метод обычным способом, и компилятор попытается выяснить, какой из них вам нужен. Альтернативно, 
вы можете указать тип явно, чтобы было очевидно, что это за тип.

```
Box.<String>ship("package"); 
Box.<String[]>ship(args);
```

Это зависит от вас, прояснит ли это ситуацию. По крайней мере, вы должны знать, что такой синтаксис существует.

---

Если у вас есть метод, объявляющий универсальный тип параметра, он не зависит от дженериков класса. Взгляните на этот 
класс, который объявляет общий T на обоих уровнях:

```
1: public class TrickyCrate<T> { 
2:    public <T> T tricky(T t) { 
3:       return t; 
4:    }
5: }
```

Посмотрите, сможете ли вы определить тип T в строках 1 и 2, когда мы вызываем код следующим образом:

```
10: public static String crateName() { 
11:    TrickyCrate<Robot> crate = new TrickyCrate<>(); 
12:    return crate.tricky("bot"); 
13: }
```

Очевидно, что «Т» значит «сложно». Давайте посмотрим, что происходит. В строке 1 T — это робот, потому что именно на 
него ссылаются при построении Crate. В строке 2 T — это String, потому что именно она передается методу. Когда вы 
увидите такой код, сделайте глубокий вдох и запишите, что происходит, чтобы не запутаться.

### Создание обобщенной записи

Дженерики также можно использовать с записями. Эта запись принимает один параметр универсального типа:

```
public record CrateRecord<T>(T contents) {    
   @Override   
   public T contents() {      
      if (contents == null)         
         throw new IllegalStateException("missing contents");      
      return contents;    
   }
}
```

Это работает так же, как классы. Вы можете создать запись робота!

```
Robot robot = new Robot(); 
CrateRecord<Robot> record = new CrateRecord<>(robot);
```

Это удобно. Теперь у нас есть неизменяемая общая запись!

### Ограничивающие обобщенные типы

К настоящему моменту вы, возможно, заметили, что дженерики не кажутся особенно полезными, поскольку они рассматриваются 
как объекты и, следовательно, не имеют большого количества доступных методов. Ограниченные подстановочные знаки решают 
эту проблему, ограничивая типы, которые можно использовать в подстановочных знаках. Тип ограниченного параметра — это 
универсальный тип, который определяет границу универсального параметра. Имейте в виду, что это самый сложный раздел в 
главе, поэтому не расстраивайтесь, если вам придется прочитать его несколько раз.

Универсальный тип с подстановочными знаками — это неизвестный универсальный тип, представленный вопросительным знаком 
(?). Общие подстановочные знаки можно использовать тремя способами, как показано в Таблице 9.13. В этом разделе 
рассматривается каждый из этих трех типов подстановочных знаков.

#### Таблица 9.13 - Типы ограничений

|                   Тип ограничения                    |    Синтаксис    |                              Пример                              | 
|:----------------------------------------------------:|:---------------:|:----------------------------------------------------------------:|
|          Неограниченный подстановочный знак          |        ?        |               List<?> a = new ArrayList<String>();               |  
|        Подстановочный знак с верхней границей        | ? extends type  | List<? extends Exception> a = new ArrayList<RuntimeException>(); |
|        Подстановочный знак с нижней границей         | ? extends type  |      List<? super Exception> a = new ArrayList<Object>();        |

### Создание неограниченных подстановочных знаков

Неограниченный подстановочный знак представляет любой тип данных. Ты используешь ? когда вы хотите указать, что любой 
тип вас устраивает. Предположим, мы хотим написать метод, просматривающий список любого типа.

```
public static void printList(List<Object> list) {    
   for (Object x: list)      
   System.out.println(x);
}
public static void main(String[] args) { 
   List<String> keywords = new ArrayList<>();    
   keywords.add("java");   
   printList(keywords); // НЕ КОМПИЛИРУЕТСЯ
}
```

Подождите. В чем дело? String является подклассом Object. Это верно. Однако List<String> нельзя назначить List<Object>. 
Мы знаем, это звучит нелогично. Этим Java пытается защитить нас от самих себя. Представьте, если бы мы могли написать 
такой код:

```
4: List<Integer> numbers = new ArrayList<>(); 
5: numbers.add(Integer.valueOf(42)); 
6: List<Object> objects = numbers; // НЕ КОМПИЛИРУЕТСЯ 
7: objects.add("forty two"); 8: System.out.println(numbers.get(1));
```

В строке 4 компилятор обещает нам, что в numbers будут отображаться только Integer объекты. Если бы строка 6 была 
скомпилирована, строка 7 нарушила бы это обещание, поместив туда String, поскольку numbers и objects являются ссылками 
на один и тот же объект. Хорошо, что компилятор предотвращает это.

Возвращаясь к печати списка, мы не можем присвоить List<String> элементу List<Object>.
Это нормально; нам не нужен List<Object>. Что нам действительно нужно, так это List «чего угодно». Вот что такое 
List<?>. Следующий код делает то, что мы ожидаем:

```
public static void printList(List<?> list) {    
   for (Object x: list)      
   System.out.println(x);
}
public static void main(String[] args) {    
   List<String> keywords = new ArrayList<>();   
   keywords.add("java");   
   printList(keywords);
}
```

Метод printList() принимает в качестве параметра список любого типа. Переменная keywords имеет тип List<String>. У нас 
есть совпадение! List<String> — это список чего угодно. «Что угодно» здесь просто является String.

Наконец, давайте посмотрим на влияние var. Считаете ли вы, что эти два утверждения эквивалентны?

```
List<?> x1 = new ArrayList<>(); 
var x2 = new ArrayList<>();
```

Это не так. Есть два ключевых различия. Во-первых, x1 имеет тип List, а x2 — тип ArrayList. Кроме того, мы можем 
назначить только x2 List<Object>. У этих двух переменных есть одна общая черта. Оба возвращают тип Object при вызове 
метода get().

### Создание подстановочных знаков с верхним ограничением

Давайте попробуем написать метод, который суммирует сумму списка чисел. Мы установили, что универсальный тип не может 
просто использовать подкласс.

```
ArrayList<Number> list = new ArrayList<Integer>(); // НЕ КОМПИЛИРУЕТСЯ 
```

Вместо этого нам нужно использовать подстановочный знак:

```
List<? extends Number> list = new ArrayList<Integer>();
```

Подстановочный знак, ограниченный сверху, говорит, что любой класс, extends Number или сам Number, может использоваться 
в качестве формального типа параметра:

```
public static long total(List<? extends Number> list) {    
   long count = 0;   
   for (Number number: list)      
      count += number.longValue();   
   return count;
}
```

Помните, как мы говорили, что стирание типа заставляет Java думать, что универсальный тип — это Object? Это все еще 
происходит здесь. Java преобразует предыдущий код во что-то эквивалентное следующему:

```
public static long total(List list) {    
   long count = 0;   
   for (Object obj: list) {      
      Number number = (Number) obj;      
      count += number.longValue();   
   }
   return count;
}
```

Что-то интересное происходит, когда мы работаем с верхними границами или неограниченными подстановочными знаками. 
Список становится логически неизменяемым и, следовательно, не может быть изменен. Технически удалить элементы из списка 
можно, но на экзамене об этом не спросят.

```
2: static class Sparrow extends Bird { } 
3: static class Bird { } 
4:
5: public static void main(String[] args) { 
6:    List<? extends Bird> birds = new ArrayList<Bird>(); 
7:    birds.add(new Sparrow()); // НЕ КОМПИЛИРУЕТСЯ
8:    birds.add(new Bird());    // НЕ КОМПИЛИРУЕТСЯ 
9: }
```

Проблема связана с тем, что Java не знает, какой тип List<? extends Bird> действительно так. Это может быть 
List<Bird> или List<Sparrow> или какой-либо другой универсальный тип, который еще даже не написан. Строка 7 не 
компилируется, потому что мы не можем добавить Sparrow в List<? extends Bird>, а строка 8 не компилируется, потому что 
мы не можем добавить Bird в List<Sparrow>. С точки зрения Java, оба сценария одинаково возможны, поэтому ни один из них 
не допускается.

Теперь давайте попробуем пример с интерфейсом. У нас есть интерфейс и два класса, которые его реализуют.

```
interface Flyer { void fly(); } 
class HangGlider implements Flyer { public void fly() {} } 
class Goose implements Flyer { public void fly() {} }
```

У нас также есть два метода, которые его используют. Один просто перечисляет интерфейс, а другой использует верхнюю 
границу.

```
private void anyFlyer(List<Flyer> flyer) {} 
private void groupOfFlyers(List<? extends Flyer> flyer) {}
```

Обратите внимание, что мы использовали ключевое слово extends, а не implements. Верхние границы подобны анонимным 
классам в том смысле, что они используют extends независимо от того, работаем ли мы с классом или с интерфейсом.

Вы уже узнали, что переменную типа List<Flyer> можно передать любому методу. Переменную типа List<Goose> можно 
передать только той, у которой есть верхняя граница. Это показывает преимущество дженериков. Случайные пассажиры не 
летают вместе. Мы хотим, чтобы наш метод groupOfFlyers() вызывался только с тем же типом. Гуси летают вместе, а на 
дельтапланах не летают.

### Создание подстановочных знаков с нижней границей

Попробуем написать метод, добавляющий строку «quack» в два списка:

```
List<String> strings = new ArrayList<String>(); 
strings.add("tweet");

List<Object> objects = new ArrayList<Object>(strings); 
addSound(strings); 
addSound(objects);
```

Проблема в том, что мы хотим передать List<String> и List<Object> в один и тот же метод. Во-первых, убедитесь, что вы 
понимаете, почему первые три примера в таблице 9.14 не решают эту проблему.

#### Таблица 9.14 - Зачем нужна нижняя граница

| static void addSound(___list) <br/> {list.add("quack");} |                 Метод компилируется                 |             Может передать List<String>              | Может передать List<Object> | 
|:--------------------------------------------------------:|:---------------------------------------------------:|:----------------------------------------------------:|:---------------------------:|
|                         List<?>                          |     Нет (неограниченные дженерики неизменяемы)      |                          Да                          |             Да              |  
|                  List<? extends Object>                  | Нет (дженерики с верхним ограничением неизменяемы)  |                          Да                          |             Да              |
|                       List<Object>                       |                         Да                          | Нет (с дженериками должно пройти точное совпадение)  |             Да              |
|                  List<? super String>                    |                         Да                          |                          Да                          |             Да              |

Чтобы решить эту проблему, нам нужно использовать нижнюю границу.

```
public static void addSound(List<? super String> list) {    
   list.add("quack");
}
```

Используя нижнюю границу, мы сообщаем Java, что список будет списком объектов String или списком некоторых объектов, 
которые являются суперклассом String. В любом случае можно безопасно добавить String в этот список.

Как и в случае с универсальными классами, вы, вероятно, не будете использовать их в своем коде, если только вы не 
пишете код для повторного использования другими. Даже тогда это будет редкостью. Но это на экзамене, так что сейчас 
самое время этому научиться!

**Понимание общих супертипов**

Если у вас есть подклассы и суперклассы, нижняя граница может оказаться сложной.

```
3: List<? super IOException> exceptions = new ArrayList<Exception>(); 
4: exceptions.add(new Exception()); // НЕ КОМПИЛИРУЕТСЯ
5: exceptions.add(new IOException()); 
6: exceptions.add(new FileNotFoundException());
```

Строка 3 ссылается на List, который может быть List<IOException>, List<Exception> или List<Object>. Строка 4 не 
компилируется, потому что у нас может быть List<IOException>, и объект Exception туда не поместится.

Строка 5 в порядке. IOException можно добавить к любому из этих типов. Строка 6 тоже в порядке. FileNotFoundException 
также можно добавить к любому из этих трех типов. Это сложно, поскольку FileNotFoundException является подклассом 
IOException, а ключевое слово говорит super. Java говорит: «Ну, FileNotFoundException также является исключением 
IOException, так что все в порядке».

### Соединяем все это вместе

К этому моменту вы знаете все, что вам нужно знать, чтобы успешно сдать экзаменационные вопросы по дженерикам. Можно 
объединить эти концепции и написать действительно запутанный код, который нравится делать на экзамене.

Этот раздел будет трудно читать. Он содержит самые сложные вопросы, которые вам могут задать о дженериках. 
Экзаменационные вопросы, вероятно, будет легче читать, чем эти. Мы хотим, чтобы вы столкнулись здесь с действительно 
сложными испытаниями, чтобы вы были готовы к экзамену. Другими словами, не паникуйте. Не торопитесь и перечитайте код 
несколько раз. Вы получите это.

### Объединение общих объявлений

Давайте попробуем пример. Сначала мы объявляем три класса, которые будут использоваться в примере:

```
class A {}
class B extends A {}
class C extends B {}
```

Готовы? Можете ли вы понять, почему они компилируются или не компилируются? Кроме того, попытайтесь выяснить, 
что они делают.

```
6: List<?> list1 = new ArrayList<A>(); 
7: List<? extends A> list2 = new ArrayList<A>(); 
8: List<? super A> list3 = new ArrayList<A>();
```

В строке 6 создается ArrayList, который может содержать экземпляры класса A. Он сохраняется в переменной с 
неограниченным подстановочным знаком. На любой универсальный тип можно ссылаться с помощью неограниченного 
подстановочного знака, и это нормально.

В строке 7 делается попытка сохранить список в объявлении переменной с подстановочным знаком, ограниченным сверху. 
Это нормально. В этой ссылке можно хранить ArrayList<A>, ArrayList<B> или ArrayList<C>. Строка 8 тоже подойдет. 
На этот раз у вас есть подстановочный знак с нижней границей. Самый низкий тип, на который вы можете 
ссылаться, — это A. Поскольку это то, что у вас есть, он компилируется.

Вы правильно поняли? Давайте попробуем еще несколько.

```
9:  List<? extends B> list4 = new ArrayList<A>(); // НЕ КОМПИЛИРУЕТСЯ 
10: List<? super B> list5 = new ArrayList<A>(); 
11: List<?> list6 = new ArrayList<? extends A>(); // НЕ КОМПИЛИРУЕТСЯ
```

В строке 9 имеется подстановочный знак, ограниченный сверху, который позволяет ссылаться на ArrayList<B> или 
ArrayList<C>. Поскольку у вас есть ArrayList<A>, на который пытаются ссылаться, код не компилируется. В строке 10 
имеется подстановочный знак, ограниченный снизу, который позволяет ссылаться на ArrayList<A>, ArrayList<B> или 
ArrayList<Object>.

Наконец, строка 11 позволяет ссылаться на любой универсальный тип, поскольку это неограниченный подстановочный знак. 
Проблема в том, что вам нужно знать, каким будет этот тип при создании экземпляра ArrayList. В любом случае это 
было бы бесполезно, поскольку в этот ArrayList нельзя добавлять какие-либо элементы.

### Passing Generic Arguments