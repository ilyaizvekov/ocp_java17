# Коллекции и дженерики

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Работа с массивами и коллекциями

+ Создавайте массивы Java, коллекции List, Set, Map и Deque, а также добавляйте, удаляйте, обновляйте, извлекайте и 
сортируйте их элементы.

---

В этой главе мы представляем классы и интерфейсы Java Collections Framework, которые вам необходимо знать для сдачи 
экзамена. Потокобезопасные типы коллекций обсуждаются в главе 13 «Параллелизм». Как вы, возможно, помните из главы 8 
«Лямбды и функциональные интерфейсы», мы рассмотрели лямбды, ссылки на методы и встроенные функциональные интерфейсы. 
Многие из них используются в этой главе. Если функциональные интерфейсы вам незнакомы, вернитесь и просмотрите 
Таблицу 8.4. Далее мы подробно расскажем о Comparator и Comparable. Наконец, мы обсудим, как создавать собственные 
классы и методы, использующие дженерики, чтобы один и тот же класс можно было использовать со многими типами.

## Использование API общей коллекции

Коллекция — это группа объектов, содержащихся в одном объекте. Java Collections Framework — это набор классов в 
java.util для хранения коллекций. В Java Collections Framework имеется четыре основных интерфейса.

+ List (Список): Список представляет собой упорядоченный набор элементов, допускающий дублирование записей. Доступ к 
элементам списка возможен по индексу int.
+ Set (Набор): Set — это коллекция, в которой не допускается дублирование записей.
+ Queue (Очередь): Queue — это коллекция, которая упорядочивает свои элементы в определенном порядке для обработки. 
Deque — это подинтерфейс Queue, который обеспечивает доступ на обоих концах.
+ Map (Карта): Map — это коллекция, которая сопоставляет ключи со значениями, дублирование ключей не допускается. 
Элементы карты представляют собой пары ключ/значение.

На рисунке 9.1 показан интерфейс Collection, его подинтерфейсы и некоторые классы, реализующие интерфейсы, которые 
вам следует знать для экзамена. Интерфейсы показаны в прямоугольниках, а классы — в закругленных прямоугольниках.

Обратите внимание, что Map не реализует интерфейс Collection. Он считается частью Java Collections Framework, хотя 
технически он не является Collection. Однако это коллекция (обратите внимание на строчные буквы), поскольку она содержит 
группу объектов. Причина, по которой карты обрабатываются по-разному, заключается в том, что им нужны разные методы, 
поскольку они представляют собой пары ключ/значение.

#### Рис. 9.1 - Java Collections Framework

В этом разделе мы обсудим общие методы, которые API коллекций предоставляет реализующим классам. Многие из этих методов 
представляют собой _удобные методы_, которые можно реализовать другими способами, но которые упрощают написание и чтение 
кода. Именно поэтому они удобны.

В этом разделе мы используем ArrayList и HashSet в качестве классов реализации, но они могут применяться к любому 
классу, наследующему интерфейс Collection. В следующем разделе мы рассмотрим конкретные свойства каждого класса 
Collection.

### Использование diamond оператора

При создании Java Collections Framework вам необходимо указать тип, который будет входить внутрь. Мы могли бы написать 
код, используя дженерики, подобные следующему:

```
List<Integer> list = new ArrayList<Integer>();
```

У вас могут даже быть дженерики, содержащие другие дженерики, например этот:

```
Map<Long,List<Integer>> mapLists = new HashMap<Long,List<Integer>>();
```

Нужно написать много дублированного кода! К счастью, оператор ромба (diamond operator) (<>) — это сокращенная запись, 
позволяющая опустить общий тип в правой части оператора, когда тип можно вывести. Он называется оператором ромба, потому 
что <> выглядит как ромб. Сравните предыдущие объявления с этими новыми, гораздо более короткими версиями:

```
List<Integer> list = new ArrayList<>(); 
Map<Long,List<Integer>> mapOfLists = new HashMap<>();
```

Для компилятора оба этих объявления и наши предыдущие эквивалентны. Однако для нас последний вариант намного короче и 
его легче читать.

Оператор ромба нельзя использовать в качестве типа в объявлении переменной. Его можно использовать только в правой части 
операции присваивания. Например, ни одно из следующих действий не компилируется:

```
List<> list = new ArrayList<Integer>();      // НЕ КОМПИЛИРУЕТСЯ

class InvalidUse {
    void use(List<> data) {}                 // НЕ КОМПИЛИРУЕТСЯ
}
```

### Добавление данных

Метод add() вставляет новый элемент в коллекцию и возвращает информацию о том, был ли он успешным. Сигнатура метода 
следующая:

```
public boolean add(E element)
```

Помните, что Collections Framework использует дженерики. Вы будете часто видеть, как буква E появляется. Это означает
универсальный тип, который использовался для создания коллекции. Для некоторых типов коллекций add() всегда возвращает 
true. Для других типов существует логика определения того, был ли вызов add() успешным. Ниже показано, как использовать 
этот метод:

```
3: Collection<String> list = new ArrayList<>(); 
4: System.out.println(list.add("Sparrow")); // true 
5: System.out.println(list.add("Sparrow")); // true 
6:
7: Collection<String> set = new HashSet<>(); 
8: System.out.println(set.add("Sparrow")); // true 
9: System.out.println(set.add("Sparrow")); // false
```

List допускает дубликаты, каждый раз возвращая значение true. Set не допускает дубликатов. В строке 9 мы попытались 
добавить дубликат, чтобы Java возвращала false из метода add().

### Удаление данных

Метод remove() удаляет одно совпадающее значение в коллекции и возвращает информацию о том, было ли оно успешным. 
Сигнатура метода следующая:

```
public boolean remove(Object object)
```

На этот раз возвращаемое boolean значение сообщает нам, было ли удалено совпадение. Ниже показано, как использовать этот 
метод:

```
3: Collection<String> birds = new ArrayList<>();
4: birds.add("hawk");                            // [hawk]
5: birds.add("hawk");                            // [hawk, hawk] 
6: System.out.println(birds.remove("cardinal")); // false 
7: System.out.println(birds.remove("hawk"));     // true 
8: System.out.println(birds);                    // [hawk]
```

Строка 6 пытается удалить элемент, которого нет в birds. Он возвращает false, поскольку такой элемент не найден. Строка 
7 пытается удалить элемент, принадлежащий birds, поэтому возвращает true. Обратите внимание: удаляется только одно 
совпадение.

### Подсчет элементов

Методы isEmpty() и size() смотрят, сколько элементов содержится в коллекции. Сигнатуры методов такие:

```
public boolean isEmpty() 
public int size()
```

Ниже показано, как использовать эти методы:

```
Collection<String> birds = new ArrayList<>(); 
System.out.println(birds.isEmpty()); // true 
System.out.println(birds.size());    // 0 
birds.add("hawk");                   // [hawk] 
birds.add("hawk");                   // [hawk, hawk] 
System.out.println(birds.isEmpty()); // false 
System.out.println(birds.size());    // 2
```

В начале, birds имеет размер 0 и пуст. Его емкость больше 0. После того, как мы добавим элементы, размер станет 
положительным, и он больше не будет пустым.

### Очистка коллекции

Метод clear() предоставляет простой способ удалить все элементы коллекции. Сигнатура метода следующая:

```
public void clear()
```

Ниже показано, как использовать этот метод:

```
Collection<String> birds = new ArrayList<>(); 
birds.add("hawk");                   // [hawk] 
birds.add("hawk");                   // [hawk, hawk] 
System.out.println(birds.isEmpty()); // false 
System.out.println(birds.size());    // 2 
birds.clear();                       // []
System.out.println(birds.isEmpty()); // true
System.out.println(birds.size());    // 0
```

После вызова метода clear(), birds снова становится пустым ArrayList размером 0.

### Проверить содержимое

Метод contains() проверяет, присутствует ли определенное значение в коллекции. Сигнатура метода следующая:

```
public boolean contains(Object object)
```

Ниже показано, как использовать этот метод:

```
Collection<String> birds = new ArrayList<>(); 
birds.add("hawk"); // [hawk] 
System.out.println(birds.contains("hawk"));  // true 
System.out.println(birds.contains("robin")); // false
```

Метод contains() вызывает метод equals() для элементов ArrayList, чтобы проверить, есть ли совпадения.

### Удаление с условиями

Метод removeIf() удаляет все элементы, соответствующие условию. Мы можем указать, что следует удалить, используя блок 
кода или даже ссылку на метод.

Сигнатура метода выглядит следующим образом. (Мы объясним, что означает символ ? super, в разделе «Работа с дженериками» 
далее в этой главе.)

```
public boolean removeIf(Predicate<? super E> filter)
```

Он использует Predicate, который принимает один параметр и возвращает логическое значение. Давайте посмотрим на пример:

```
4: Collection<String> list = new ArrayList<>(); 
5: list.add("Magician"); 
6: list.add("Assistant"); 
7: System.out.println(list);     // [Magician, Assistant] 
8: list.removeIf(s -> s.startsWith("A")); 
9: System.out.println(list);     // [Magician]
```

В строке 8 показано, как удалить все String значения, начинающиеся с буквы A. Это позволяет нам исчезнуть с Assistant. 
Давайте попробуем пример со ссылкой на метод:

```
11: Collection<String> set = new HashSet<>(); 
12: set.add("Wand"); 
13: set.add("");
14: set.removeIf(String::isEmpty); // s -> s.isEmpty() 
15: System.out.println(set);       // [Wand]
```

В строке 14 мы удаляем из set все пустые объекты String. Комментарий к этой строке показывает лямбда-эквивалент ссылки 
на метод. В строке 15 показано, что метод removeIf() успешно удалил один элемент из list.

### Итерация (Iterating)

Существует метод forEach(), который вы можете вызывать для коллекции вместо написания цикла. Он использует Consumer, 
который принимает один параметр и ничего не возвращает. Сигнатура метода следующая:

```
public void forEach(Consumer<? super T> action)
```

Cats любят исследовать, поэтому давайте распечатаем два из них, используя как ссылки на методы, так и лямбда-выражения:

```
Collection<String> cats = List.of("Annie", "Ripley"); 
cats.forEach(System.out::println); 
cats.forEach(c -> System.out.println(c));
```

Cats научились писать свои имена. Теперь у них есть больше времени для игры (как и у нас)!

**Другие подходы к итерации**

Есть и другие способы перебирать коллекции. Например, в главе 3 «Принятие решений» вы видели, как перебирать список с 
помощью расширенного цикла for.

```
for (String element: coll)
  System.out.println(element);
```

Вы можете увидеть другой старый подход.

```
Iterator<String> iter = coll.iterator();
while(iter.hasNext()) {
   String string = iter.next();
   System.out.println(string);    
}
```

Обратите внимание на разницу между этими приемами. Метод hasNext() проверяет, существует ли следующее значение. Другими 
словами, он сообщает вам, будет ли выполняться функция next() без выдачи исключения. Метод next() фактически перемещает
Iterator к следующему элементу.

### Определение равенства

Существует специальная реализация метода equals(), поэтому вы можете сравнивать две коллекции, чтобы сравнить их тип и 
содержимое. Реализация будет разной. Например, ArrayList проверяет порядок, а HashSet — нет.

```
boolean equals(Object object)
```

Ниже приведен пример:

```
23: var list1 = List.of(1, 2); 
24: var list2 = List.of(2, 1); 
25: var set1 = Set.of(1, 2); 
26: var set2 = Set.of(2, 1);
27:
28: System.out.println(list1.equals(list2));  // false 
29: System.out.println(set1.equals(set2));    // true 
30: System.out.println(list1.equals(set1));   // false
```

В строке 28 выводится false, потому что элементы расположены в другом порядке, а List заботится о порядке. Напротив, 
строка 29 печатает true, потому что Set не чувствителен к порядку. Наконец, строка 30 выводит false, поскольку типы 
разные.

**Распаковка nulls**

Java защищает нас от многих проблем с коллекциями. Однако написать исключение NullPointerException все же можно:

```
3: var heights = new ArrayList<Integer>();
4: heights.add(null);
5: int h = heights.get(0);          // NullPointerException
```

В строке 4 мы добавляем в список null. Это законно, поскольку null ссылка может быть присвоена любой ссылочной 
переменной. В строке 5 мы пытаемся распаковать этот null в примитив int. Это проблема. Java пытается получить значение 
int, равное null. Поскольку вызов любого метода для значения null приводит к исключению NullPointerException, именно это 
мы и получаем. Будьте осторожны, когда вы видите значение null в отношении автобокса.

## Использование интерфейса List

Теперь, когда вы знакомы с некоторыми распространенными методами интерфейса Collection, давайте перейдем к конкретным 
интерфейсам. Список используется, если вам нужна упорядоченная коллекция, которая может содержать повторяющиеся записи. 
Например, список имен может содержать дубликаты, поскольку у двух животных может быть одно и то же имя. Элементы можно 
извлекать и вставлять в определенные позиции в списке на основе индекса int, аналогично массиву. Однако, в отличие от 
массива, многие реализации List могут изменяться в размере после их объявления.

Списки широко используются, потому что в программировании существует множество ситуаций, когда вам необходимо 
отслеживать список объектов. Например, вы можете составить список того, что вы хотите увидеть в зоопарке: во-первых, 
увидеть львов, потому что они рано ложатся спать; во-вторых, посмотрите на панд, потому что позже в тот же день 
выстраивается длинная очередь; и так далее.

На рис. 9.2 показано, как можно представить список. Каждый элемент списка имеет индекс, и индексы начинаются с нуля.

#### Рис. 9.2 - Пример List



Иногда вам не важен порядок элементов в списке. Список похож на тип данных «go to». Когда мы составляем список покупок 
перед походом в магазин, его порядок совпадает с порядком, в котором мы думали о товарах. Мы, вероятно, не привязаны к 
этому конкретному порядку, но это ничему не повредит.

Хотя классы, реализующие интерфейс List, имеют множество методов, вам необходимо знать только наиболее распространенные 
из них. Удобно, что эти методы одинаковы для всех реализаций, которые могут появиться на экзамене.

Главное, что объединяет все реализации List, — это то, что они упорядочены и допускают дублирование. Помимо этого, 
каждый из них предлагает разные функциональные возможности. Мы рассмотрим реализации, которые вам необходимо знать, и 
доступные методы.

_Обратите особое внимание на то, какие имена являются классами, а какие интерфейсами. На экзамене вас могут спросить, 
какой класс лучше или какой интерфейс лучше всего подходит для конкретного сценария._

### Сравнение реализаций List

ArrayList похож на массив с изменяемым размером. При добавлении элементов ArrayList автоматически увеличивается. Если вы 
не уверены, какую коллекцию использовать, используйте ArrayList.

Основное преимущество ArrayList заключается в том, что вы можете искать любой элемент за постоянное время. Добавление 
или удаление элемента происходит медленнее, чем доступ к элементу. Это делает ArrayList хорошим выбором, когда вы 
читаете чаще (или столько же), сколько записываете в ArrayList.

LinkedList особенный, поскольку он реализует как List, так и Deque. Он имеет все методы List. Он также имеет 
дополнительные методы для облегчения добавления или удаления из начала и/или конца списка.

Основные преимущества LinkedList заключаются в том, что вы можете получать доступ, добавлять и удалять элементы из 
начала и конца списка за постоянное время. Компромисс заключается в том, что работа с произвольным индексом занимает 
линейное время. Это делает LinkedList хорошим выбором, когда вы будете использовать его в качестве Deque. Как вы видели 
на рисунке 9.1, LinkedList реализует интерфейсы List и Deque.

### Создание List с помощью фабрики

Когда вы создаете список типа ArrayList или LinkedList, вы знаете его тип. Существует несколько специальных методов, с 
помощью которых вы возвращаете список, но не знаете его тип. Эти методы позволяют создать список, включающий данные в 
одну строку, используя фабричный метод. Это удобно, особенно при тестировании. Некоторые из этих методов возвращают 
неизменяемый объект. Как мы видели в главе 6 «Проектирование классов», неизменяемый объект нельзя изменить или 
модифицировать. В таблице 9.1 суммированы эти три списка.

#### Таблица 9.1 - Фабричные методы для создания List

|          Метод          |                                Описание                                | Можете добавить элементы? |   Можно ли заменить элементы?   |   Можно ли удалять элементы?   |  
|:-----------------------:|:----------------------------------------------------------------------:|:-------------------------:|:-------------------------------:|:------------------------------:|
| Arrays.asList(varargs)  | Возвращает список фиксированного <br/> размера, подкрепленный массивом |            Нет            |               Да                |              Нет               |
|    List.of(varargs)     |                     Возвращает неизменяемый список                     |            Нет            |               Нет               |              Нет               |                                     
| List.copyOf(collection) |  Возвращает неизменяемый список с копией значений исходной коллекции   |            Нет            |               Нет               |              Нет               |

Давайте рассмотрим пример этих трех методов:

```
16: String[] array = new String[] {"a", "b", "c"}; 
17: List<String> asList = Arrays.asList(array); // [a, b, c] 
18: List<String> of = List.of(array);           // [a, b, c] 
19: List<String> copy = List.copyOf(asList);    // [a, b, c]
20:
21: array[0] = "z";
22:
23: System.out.println(asList);                 // [z, b, c] 
24: System.out.println(of);                     // [a, b, c] 
25: System.out.println(copy);                   // [a, b, c]
26:
27: asList.set(0, "x"); 
28: System.out.println(Arrays.toString(array)); // [x, b, c]
29:
30: copy.add("y");            // UnsupportedOperationException
```

Строка 17 создает List, поддерживаемый массивом. Строка 21 изменяет массив, а строка 23 отражает это изменение. 
Строки 27 и 28 показывают другое направление, когда изменение List обновляет базовый массив. Строки 18 и 19 создают 
неизменяемый List. Строка 30 показывает, что он является неизменяемым, выдавая исключение при попытке добавить значение. 
Все три списка выдадут исключение при добавлении или удалении значения. Списки of и copy также выдают ошибку при попытке 
обновления элемента.

### Создание List с помощью конструктора

В большинстве коллекций есть два конструктора, которые вам необходимо знать для экзамена. Ниже показаны их для 
LinkedList:

```
var linked1 = new LinkedList<String>();
var linked2 = new LinkedList<String>(linked1);
```

Первый говорит о создании пустого LinkedList, содержащего все значения по умолчанию. Второй сообщает Java, что мы хотим 
сделать копию другого LinkedList. Конечно, в этом примере linked1 пуст, поэтому он не представляет особого интереса.

В ArrayList есть дополнительный конструктор, о котором вам нужно знать. Теперь мы покажем три конструктора:

```
var list1 = new ArrayList<String>();
var list2 = new ArrayList<String>(list1);
var list3 = new ArrayList<String>(10);
```

Первые два — это общие конструкторы, которые вам нужно знать для всех коллекций. В последнем примере говорится о 
создании ArrayList, содержащего определенное количество слотов, но опять же не назначать их. Вы можете думать об этом 
как о размере базового массива.

**Использование var с ArrayList**

Рассмотрим этот код, в котором сочетаются var и дженерики:

```
var strings = new ArrayList<String>();
strings.add("a");
for (String s: strings) {  }
```

Тип переменной — ArrayList<String>. Это означает, что вы можете добавить String или перебрать объекты String. Что, если 
мы используем diamond оператор с var?

```
var list = new ArrayList<>();
```

Хотите верьте, хотите нет, но это компилируется. Тип переменной var — ArrayList<Object>. Поскольку для универсального 
типа не указан тип, Java должен принять окончательный суперкласс. Это немного глупо и неожиданно, поэтому, пожалуйста, 
не пишите это. Но если вы увидите это на экзамене, вы будете знать, чего ожидать. Теперь вы можете понять, почему это не 
компилируется?

```
var list = new ArrayList<>();
list.add("a");
for (String s: list) { } // НЕ КОМПИЛИРУЕТСЯ
```

Тип переменной var — ArrayList<Object>. Поскольку daimond оператор не имеет типа, Java должен использовать самый общий 
вариант, какой только может. Поэтому он выбирает Object, высший суперкласс. Добавление String в список — это нормально. 
Вы можете добавить любой подкласс Object. Однако в цикле нам нужно использовать тип Object, а не String.

### Работа с методами List

Методы интерфейса List предназначены для работы с индексами. Помимо унаследованных методов Collection, сигнатуры 
методов, которые вам необходимо знать, приведены в таблице 9.2.

#### Таблица 9.2 - Методы List

|                        Метод                        |                                                          Опсиание                                                           | 
|:---------------------------------------------------:|:---------------------------------------------------------------------------------------------------------------------------:|
|            public boolean add(E element)            |                                 Добавляет элемент в конец (доступно во всех API коллекций).                                 |  
|        public void add(int index, E element)        |                             Добавляет элемент по индексу и перемещает оставшуюся часть в конец.                             |                                    
|               public E get(int index)               |                                               Возвращает элемент по индексу.                                                | 
|             public E remove(int index)              |                                  Удаляет элемент по индексу и перемещает остальные вперед.                                  | 
| public default void replaceAll(UnaryOperator<E> op) |                                   Заменяет каждый элемент в списке результатом оператора.                                   | 
|            public E set(int index, E e)             | Заменяет элемент по индексу и возвращает оригинал. Выдает исключение IndexOutOfBoundsException, если индекс недействителен. |
| public default void sort(Comparator<? super E> c)   |                     Сортирует список. Мы рассмотрим это позже в главе, в разделе «Сортировка данных».                       |

Следующие операторы демонстрируют большинство этих методов работы со списком:

```
3:  List<String> list = new ArrayList<>();
4:  list.add("SD");                  // [SD] 
5:  list.add(0, "NY");               // [NY,SD] 
6:  list.set(1, "FL");               // [NY,FL] 
7:  System.out.println(list.get(0)); // NY 
8:  list.remove("NY");               // [FL] 
9:  list.remove(0);                  // [] 
10: list.set(0, "?");                // IndexOutOfBoundsException
```

В строке 3 list начинается пустым. Строка 4 добавляет элемент в конец списка. В строке 5 добавляется элемент с индексом 
0, который увеличивает исходный индекс 0 до индекса 1. Обратите внимание, что ArrayList теперь автоматически 
увеличивается на единицу. В строке 6 элемент с индексом 1 заменяется новым значением.

В строке 7 используется метод get() для печати элемента по определенному индексу. Строка 8 удаляет элемент, 
соответствующий NY. Наконец, строка 9 удаляет элемент с индексом 0, и список снова становится пустым.

В строке 10 выбрасывается исключение IndexOutOfBoundsException, поскольку в List нет элементов. Поскольку элементов для 
замены нет, даже индекс 0 не допускается. Если строку 10 переместить вверх между строками 4 и 5, вызов будет успешным.

Результат будет таким же, если вы попробуете эти примеры с LinkedList. Хотя код будет менее эффективным, это не будет 
заметно, пока у вас не будут очень большие списки.

Теперь давайте взглянем на метод replaceAll(). Он использует UnaryOperator, который принимает один параметр и возвращает 
значение того же типа:

```
var numbers = Arrays.asList(1, 2, 3);
numbers.replaceAll(x -> x*2);
System.out.println(numbers);   // [2, 4, 6]
```

Эта лямбда удваивает значение каждого элемента в списке. Метод replaceAll() вызывает лямбду для каждого элемента списка 
и заменяет значение по этому индексу.

**Перегруженные методы remove()**

Мы рассмотрели два перегруженных метода remove(). Тот, что из коллекции, удаляет объект, соответствующий параметру. 
Напротив, элемент из List удаляет элемент по указанному индексу.

Это становится сложнее, если у вас есть тип Integer. Как вы думаете, что означают следующие печати?

```
31: var list = new LinkedList<Integer>(); 
32: list.add(3); 33: list.add(2); 
34: list.add(1); 35: list.remove(2); 
36: list.remove(Integer.valueOf(2)); 
37: System.out.println(list);
```

Правильный ответ: [3]. Давайте посмотрим, как мы туда попали. В конце строки 34 у нас есть [3, 2, 1]. В строке 35 
передается примитив, что означает, что мы запрашиваем удаление элемента с индексом 2. В результате у нас остается 
[3, 2]. Затем в строке 36 передается объект Integer, что означает, что мы удаляем значение 2. Это подводит нас к 
[3].

Поскольку вызов метода remove() с числом int использует индекс, несуществующий индекс вызовет/выбросит исключение. 
Например, list.remove(100) выдает исключение IndexOutOfBoundsException.

### Преобразование List в массив

Поскольку массив можно передать как vararg, в таблице 9.1 показано, как преобразовать массив в список. Вы также должны 
знать, как сделать обратное. Начнем с преобразования списка в массив:

```
13: List<String> list = new ArrayList<>(); 
14: list.add("hawk"); 
15: list.add("robin"); 
16: Object[] objectArray = list.toArray(); 
17: String[] stringArray = list.toArray(new String[0]); 
18: list.clear(); 
19: System.out.println(objectArray.length);     // 2 
20: System.out.println(stringArray.length);     // 2
```

Строка 16 показывает, что List знает, как преобразовать себя в массив. Единственная проблема заключается в том, что по 
умолчанию используется массив класса Object. Обычно это не то, чего вы хотите. Строка 17 определяет тип массива и делает 
то, что мы хотим. Преимущество указания размера 0 для параметра заключается в том, что Java создаст новый массив 
подходящего размера для возвращаемого значения. Если хотите, вы можете предложить вместо этого использовать больший 
массив. Если List помещается в этот массив, он будет возвращен. В противном случае будет создан новый массив.

Также обратите внимание, что строка 18 очищает исходный List. Это не влияет ни на один массив. Массив представляет собой 
недавно созданный объект, не имеющий отношения к исходному List. Это просто копия.

## Использование интерфейса Set

Вы используете Set, когда не хотите допускать дублирование записей. Например, вы можете отслеживать уникальных животных, 
которых хотите увидеть в зоопарке. Вас не волнует порядок, в котором вы видите этих животных, но у вас нет времени 
видеть их более одного раза. Вам просто нужно убедиться, что вы видите тех, которые важны для вас, и удалить их из 
набора выдающихся животных, чтобы увидеть их после того, как вы их увидите.

На рис. 9.3 показано, как можно представить Set. Главное, что объединяет все реализации Set, — это то, что они не 
допускают дублирования. Мы рассмотрим каждую реализацию, которую вам нужно знать для экзамена, и то, как писать код с 
использованием Set.

#### Рис. 9.3 - Пример Set


### Сравнение реализаций Set

HashSet хранит свои элементы в хеш-таблице, что означает, что ключи представляют собой хэш, а значения — объект. Это 
означает, что HashSet использует метод объектов hashCode() для более эффективного их извлечения. Помните, что 
действительный hashCode() не означает, что каждый объект получит уникальное значение, но метод часто пишется так, что 
хэш-значения распределяются по большому диапазону, чтобы уменьшить коллизии.

Основное преимущество заключается в том, что добавление элементов и проверка наличия элемента в наборе имеют 
постоянное время. Компромисс заключается в том, что вы теряете порядок вставки элементов. В большинстве случаев вас это 
не касается в Set, что делает HashSet наиболее распространенным набором.

TreeSet хранит свои элементы в отсортированной древовидной структуре. Основное преимущество заключается в том, что 
набор всегда находится в отсортированном порядке. Компромисс заключается в том, что добавление и проверка существования 
элемента занимает больше времени, чем при использовании HashSet, особенно по мере того, как дерево становится больше.

На рис. 9.4 показано, как можно представить себе хранение HashSet и TreeSet. На самом деле HashSet сложнее, но для целей 
экзамена этого вполне достаточно.

#### Рис. 9.4 - Примеры HashSet и TreeSet



Для экзамена вам не нужно знать, как создать хэш или набор деревьев (реализация может быть сложной). Уф! Вам просто 
нужно знать, как ими пользоваться!

### Работа с методами Set

Как и в случае с List, вы можете создать неизменяемый Set в одной строке или сделать копию существующего.

```
Set<Character> letters = Set.of('z', 'o', 'o');
Set<Character> copy = Set.copyOf(letters);
```

Это единственные дополнительные методы, которые вам нужно знать для интерфейса Set для экзамена! Вам нужно знать, как 
наборы ведут себя по отношению к традиционным методам Collection. Вы также должны знать различия между типами наборов. 
Начнем с HashSet:

```
3: Set<Integer> set = new HashSet<>(); 
4: boolean b1 = set.add(66);    // true 
5: boolean b2 = set.add(10);    // true 
6: boolean b3 = set.add(66);    // false 
7: boolean b4 = set.add(8);     // true 
8: set.forEach(System.out::println);
```

Этот код печатает три строки:

```
66
8
10
```

Методы add() должны быть понятны. Они возвращают true, если Integer еще не находится в set. Строка 6 возвращает false, 
поскольку в наборе уже есть 66 и набор должен сохранять уникальность. Строка 8 печатает элементы набора в произвольном 
порядке. В данном случае это не порядок сортировки или порядок, в котором мы добавили элементы.

Помните, что метод equals() используется для определения равенства. Метод hashCode() используется, чтобы узнать, в каком
сегменте искать, чтобы Java не приходилось просматривать весь set, чтобы выяснить, есть ли там объект. В лучшем случае 
хеш-коды уникальны, и Java должна вызывать метод equals() только для одного объекта. Худший случай заключается в том, 
что все реализации возвращают один и тот же hashCode(), и Java в любом случае должен вызывать мето eдquals() для каждого 
элемента set.

Теперь давайте посмотрим на тот же пример с TreeSet:

```
3: Set<Integer> set = new TreeSet<>(); 
4: boolean b1 = set.add(66);  // true 
5: boolean b2 = set.add(10);  // true 
6: boolean b3 = set.add(66);  // false 
7: boolean b4 = set.add(8);   // true 
8: set.forEach(System.out::println);
```

На этот раз код печатает следующее:

```
8
10
66
```

Элементы распечатываются в естественном отсортированном порядке. Numbers реализуют интерфейс Comparable в Java, который 
используется для сортировки. Далее в этой главе вы узнаете, как создавать собственные объекты Comparable.

## Использование интерфейсов Queue и Deque

Queue используется, когда элементы добавляются и удаляются в определенном порядке. Вы можете думать об очереди как о 
линии. Например, если вы хотите войти на стадион, а кто-то стоит в очереди, вы встаете в очередь позади этого человека. 
А если вы британец, вы встанете в очередь позади этого человека, и вам будет очень легко запомнить это! Это очередь FIFO 
(первым пришел — первым обслужен).

Deque (двусторонняя очередь), часто произносится как «колода», отличается от обычной очереди тем, что вы можете 
вставлять и удалять элементы как спереди (голова), так и сзади (хвост). Подумайте: «Доктор. Вуди Флауэрс, иди вперед! 
Вы единственный, кто пользуется таким особым отношением. Всем остальным придется начинать с конца очереди».

Вы можете представить двустороннюю очередь, как показано на рисунке 9.5.

#### Рис. 9.5 - Пример Deque


Предположим, мы используем это как очередь FIFO. Ровер первый, а это значит, что он прибыл первым. Белла идет последней, 
а это значит, что она пришла последней и ей осталось ждать дольше всех. У всех очередей есть особые требования к 
добавлению и удалению следующего элемента. Помимо этого, каждый из них предлагает разные функциональные возможности. Мы 
рассмотрим реализации, которые вам необходимо знать, и доступные методы.

### Сравнение реализаций Deque

Вы видели LinkedList ранее в разделе «List». Это не только список, но и Deque. Основное преимущество LinkedList 
заключается в том, что он реализует интерфейсы List и Deque. Компромисс в том, что он не так эффективен, как «чистая» 
очередь. Вы можете использовать класс ArrayDeque, если вам не нужны методы List.

### Работа с методами Queue и Deque

Интерфейс Queue содержит шесть методов, показанных в Таблице 9.3. Существует три части функциональности и версии 
методов, которые создают исключение или используют тип возвращаемого значения, например null, для всей информации. Мы 
выделили жирным шрифтом те, которые выдают исключение, когда что-то идет не так, например, при попытке чтения из пустой 
очереди.

#### Таблица 9.3 - Методы Queue

|                  Функциональность                   |                          Методы                          | 
|:---------------------------------------------------:|:--------------------------------------------------------:|
|                   Добавить назад                    | public boolean add(E e) <br/>  public boolean offer(E e) |  
|                   Читать спереди                    |        public E element () <br/> public E peek()         |                                    
|               Достать и снять спереди               |        public E remove() <br/>  public E poll()          | 

Давайте покажем простой пример очереди:

```
4: Queue<Integer> queue = new LinkedList<>(); 
5: queue.add(10); 
6: queue.add(4); 
7: System.out.println(queue.remove());   // 10 
8: System.out.println(queue.peek());     // 4
```

Строки 5 и 6 добавляют элементы в очередь. В строке 7 запрашивается первый элемент, ожидающий дольше всего, выйти из 
очереди. Строка 8 проверяет наличие следующей записи в очереди, оставляя ее на месте.

Далее переходим к интерфейсу Deque. Поскольку интерфейс Deque поддерживает двойные очереди, он наследует все методы 
Queue и добавляет новые, чтобы было понятно, работаем ли мы с передней или задней частью очереди. В таблице 9.4 показаны 
методы при использовании двусторонней очереди.

#### Таблица 9.4 - Методы Deque

|    Функциональность     |                              Методы                              | 
|:-----------------------:|:----------------------------------------------------------------:|
|     Добавить вперед     | public void addFirst(E e)  <br/>  public boolean offerFirst(E e) |  
|     Добавить назад      |  public void addLast(E e) <br/>  public boolean offerLast(E e)   |
|     Читать спереди      |         public E getFirst() <br/>  public E peekFirst()          |
|      Читать сзади       |           public E getLast() <br/> public E peekLast()           |                                    
| Достать и снять спереди |        public E removeFirst() <br/>  public E pollFirst()        | 
|  Достать и снять сзади  |         public E removeLast() <br/> public E pollLast()          |

Давайте попробуем пример, работающий с обоими концами очереди:

```
Deque<Integer> deque = new LinkedList<>();
```

Это сложнее, поэтому мы используем рисунок 9.6, чтобы показать, как выглядит очередь на каждом этапе кода.

Строки 13 и 14 успешно добавляют элемент в начало и конец очереди соответственно. Некоторые очереди ограничены по 
размеру, что может привести к сбою добавления элемента в очередь. На экзамене вы не встретите такого сценария. Строка 15 
просматривает первый элемент в очереди, но не удаляет его. Строки 16 и 17 удаляют элементы из очереди, по одному с 
каждого конца. В результате получается пустая очередь. Строки 18 и 19 пытаются просмотреть первый элемент очереди, что 
приводит к нулю.

#### Рис. 9.6 - Работа с Deque


Помимо очередей FIFO, существуют очереди LIFO (последний пришел — первый обслужен), которые обычно называют стеками. 
Представьте себе стопку тарелок. Вы всегда добавляете или удаляете сверху стека, чтобы избежать беспорядка. К счастью, 
мы можем использовать те же реализации двусторонних очередей. Для ясности используются разные методы, как показано в 
Таблице 9.5.

#### Таблица 9.5 - Использование Deque в качестве стека

|     Функциональность     |        Методы         | 
|:------------------------:|:---------------------:|
| Добавить спереди/сверху  | public void push(E e) |  
|  Удалить спереди/сверху  |    public E pop()     |
| Получить первый элемент  |   public E peek()     |

Давайте попробуем еще один вариант, используя Deque в качестве стека:

```
Deque<Integer> stack = new ArrayDeque<>();
```

На этот раз на рисунке 9.7 показано, как выглядит стек на каждом шаге кода. Строки 13 и 14 успешно помещают элемент в 
начало/вершину стека. Оставшийся код также отображается спереди.

При использовании Deque действительно важно определить, используется ли он в качестве очереди FIFO, стека LIFO или 
двусторонней очереди. Для сравнения, очередь FIFO похожа на очередь людей. Ты садишься сзади и выходишь спереди. Стопка 
LIFO похожа на стопку тарелок. Вы ставите тарелку на столешницу и снимаете ее с нее. Двусторонняя очередь использует оба 
конца.

#### Рис. 9.7 - Работа со стеком


## Использование интерфейса Map

Вы используете Map, когда хотите идентифицировать значения по ключу. Например, когда вы используете список контактов в 
своем телефоне, вы ищете «George», а не просматриваете каждый номер телефона по очереди.

Вы можете представить Map, как показано на рисунке 9.8. Вам не обязательно знать имена конкретных интерфейсов, 
реализуемых различными картами, но вам необходимо знать, что TreeMap отсортирован.

#### Рис. 9.8 - Пример Map


Главное, что объединяет все классы Map, — это то, что у них есть ключи и значения. Помимо этого, каждый из них 
предлагает разные функциональные возможности. Мы рассмотрим реализации, которые вам необходимо знать, и доступные 
методы.

**Map.of() и Map.copyOf()**

Как и в случае с List и Set, существует фабричный метод создания Map. Вы передаете любое количество пар ключей и 
значений.

```
Map.of("key1", "value1", "key2", "value2");
```

В отличие от List и Set, это далеко не идеально. Передачу ключей и значений труднее читать, потому что вам нужно 
отслеживать, какой параметр является каким. К счастью, есть лучший способ. Map также предоставляет метод, который 
позволяет вам предоставлять пары ключ/значение.

```
Map.ofEntries(
    Map.entry("key1", "value1"),
    Map.entry("key2", "value2"));
```

Теперь мы не можем забыть передать значение. Если мы оставим параметр, метод enter() не скомпилируется. Удобно, что 
Map.copyOf(map) работает так же, как методы copyOf() интерфейса List и Set.

### Сравнение реализаций Map

HashMap хранит ключи в хеш-таблице. Это означает, что он использует метод ключей hashCode() для более эффективного 
получения их значений.

Основное преимущество заключается в том, что добавление элементов и извлечение элемента по ключу имеют постоянное время. 
Компромисс заключается в том, что вы теряете порядок, в котором вы вставляли элементы. В большинстве случаев вас это все 
равно не касается на карте. Если бы это было так, вы могли бы использовать LinkedHashMap, но это не входит в рамки 
экзамена.

TreeMap хранит ключи в отсортированной древовидной структуре. Основное преимущество заключается в том, что ключи всегда 
находятся в отсортированном порядке. Как и в случае с TreeSet, компромисс заключается в том, что добавление и проверка 
наличия ключа занимает больше времени по мере роста дерева.

### Работа с методами Map

Учитывая, что Map не расширяет Collection, в интерфейсе Map указано больше методов. Поскольку существуют как ключи, так 
и значения, нам нужны параметры универсального типа для обоих. Класс использует K для ключа и V для значения. Методы, 
которые вам необходимо знать для сдачи экзамена, приведены в Таблице 9.6. Некоторые сигнатуры методов упрощены, чтобы их 
было легче понять.

#### Таблица 9.6 - Методы Map

|                          Метод                           |                                                                              Опсиание                                                                               | 
|:--------------------------------------------------------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|                   public void clear()                    |                                                               Удаляет все ключи и значения с карты.                                                                 |  
|          public boolean containsKey(Object key)          |                                                             Возвращает, присутствует ли ключ на карте.                                                              |                                    
|        public boolean containsValue(Object value)        |                                                            Возвращает, присутствует ли значение в карте.                                                            | 
|          public Set<Map.Entry<K,V>> entrySet()           |                                                                  Возвращает Set пар ключ/значение.                                                                  | 
|     public void forEach(BiConsumer<K key, V value>)      |                                                              Просматривает каждую пару ключ/значение.                                                               | 
|                 public V get(Object key)                 |                                     Возвращает значение, сопоставленное ключу, или значение null, если ничего не сопоставлено.                                      |
|    public V getOrDefault(Object key, V defaultValue)     |                                 Возвращает значение, сопоставленное ключу, или значение по умолчанию, если ни одно не сопоставлено.                                 |
|                 public boolean isEmpty()                 |                                                                Возвращает, является ли карта пустой.                                                                |
|                  public Set<K> keySet()                  |                                                                    Возвращает набор всех ключей.                                                                    |
| public V merge(K key, V value, Function(<V, V, V> func)) | Устанавливает значение, если ключ не установлен. Запускает функцию, если ключ установлен, <br/> для определения нового значения. Удаляет, если значение равно нулю. |
|               public V put(K key, V value)               |                                         Добавляет или заменяет пару ключ/значение. Возвращает предыдущее значение или null.                                         |
|           public V putIfAbsent(K key, V value)           |                         Добавляет значение, если ключ отсутствует, и возвращает ноль. В противном случае возвращает существующее значение.                          |
|               public V remove(Object key)                |                                         Удаляет и возвращает значение, сопоставленное с ключом. Возвращает null, если нет.                                          |
|             public V replace(K key, V value)             |                           Заменяет значение для данного ключа, если ключ установлен. Возвращает исходное значение или null, если его нет.                           |
|     public void replaceAll(BiFunction<K, V, V> func)     |                                                            Заменяет каждое значение результатом функции.                                                            |
|                    public int size()                     |                                                     Возвращает количество записей (пар ключ/значение) в карте.                                                      |
|              public Collection<V> values()               |                                                                Возвращает Collection всех значений.                                                                 |


Хотя Таблица 9.6 представляет собой довольно длинный список методов, не волнуйтесь; многие из названий просты. Кроме 
того, многие из них существуют для удобства. Например, containsKey() можно заменить вызовом get(), который проверяет, 
является ли результат нулевым. Какой из них вы используете, зависит от вас.

### Вызов основных методов

Давайте начнем со сравнения одного и того же кода с двумя типами карт. Прежде всего, это HashMap:

```
Map<String, String> map = new HashMap<>(); 
map.put("koala", "bamboo"); 
map.put("lion", "meat"); 
map.put("giraffe", "leaf"); 
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
   System.out.print(key + ","); // koala,giraffe,lion,
```

Здесь мы используем метод put() для добавления пар ключ/значение в map и метод get() для получения значения по ключу. 
Мы также используем метод keySet() для получения всех ключей.

Java использует hashCode() ключа для определения порядка. Порядок здесь не является отсортированным порядком или 
порядком, в котором мы вводили значения. Теперь давайте посмотрим на TreeMap:

```
Map<String, String> map = new TreeMap<>();
map.put("koala", "bamboo");
map.put("lion", "meat");
map.put("giraffe", "leaf");
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
   System.out.print(key + ","); // giraffe,koala,lion,
```

TreeMap сортирует ключи так, как мы и ожидали. Если бы мы вызвали values() вместо keySet(), порядок значений 
соответствовал бы порядку ключей.

С нашей той же картой мы можем попробовать некоторые boolean проверки:

```
System.out.println(map.contains("lion")); // НЕ КОМПИЛИРУЕТСЯ
System.out.println(map.containsKey("lion")); // true
System.out.println(map.containsValue("lion")); // false
System.out.println(map.size()); // 3
map.clear(); 
System.out.println(map.size()); // 0 
System.out.println(map.isEmpty()); // true
```

Первая линия немного сложнее. Метод contains() находится в интерфейсе Collection, но не в интерфейсе Map. Следующие две 
строки показывают, что ключи и значения проверяются отдельно. Мы видим, что в map есть три пары ключ/значение. Затем 
очищаем содержимое map и видим, что элементов ноль и она пуста.

В следующих разделах мы покажем методы Map, с которыми вы, возможно, не знакомы.

### Итерация по Map

Ранее в этой главе вы видели метод forEach(). Обратите внимание, что в Map это работает немного по-другому. На этот раз 
лямбда-выражение, используемая методом forEach(), имеет два параметра: ключ и значение. Давайте посмотрим на пример, 
показанный здесь:

```
Map<Integer, Character> map = new HashMap<>();
map.put(1, 'a');
map.put(2, 'b');
map.put(3, 'c');
map.forEach((k, v) -> System.out.println(v));
```

Лямбда-выражение имеет как ключ, так и значение в качестве параметров. Случается, что он выводит значение, но может 
делать что угодно с ключом и / или значением. Интересно, что, поскольку мы не заботимся о ключе, этот конкретный код 
мог бы быть написан с использованием метода values() и ссылки на метод вместо этого.

```
map.values().forEach(System.out::println);
```

Другой способ просмотреть все данные на карте — получить пары ключ/значение в наборе. Java имеет статический интерфейс 
внутри Map, называемый Entry. Он предоставляет методы для получения ключа и значения каждой пары.

```
map.entrySet().forEach(e ->
   System.out.println(e.getKey() + " " + e.getValue()));
```

### Безопасное получение значений

Метод get() возвращает значение null, если запрошенный ключ отсутствует на карте. Иногда вы предпочитаете, чтобы 
возвращалось другое значение. К счастью, метод getOrDefault() упрощает эту задачу. Давайте сравним два метода:

```
3: Map<Character, String> map = new HashMap<>(); 
4: map.put('x', "spot"); 
5: System.out.println("X marks the " + map.get('x')); 
6: System.out.println("X marks the " + map.getOrDefault('x', "")); 
7: System.out.println("Y marks the " + map.get('y')); 
8: System.out.println("Y marks the " + map.getOrDefault('y', ""));
```

Этот код печатает следующее:

```
X marks the spot
X marks the spot
Y marks the null
Y marks the
```

Как видите, строки 5 и 6 имеют одинаковый вывод, поскольку методы get() и getOrDefault() ведут себя одинаково, когда 
присутствует ключ. Они возвращают значение, сопоставленное этим ключом. Строки 7 и 8 дают разные выходные данные, 
показывая, что get() возвращает значение null, когда ключ отсутствует. Напротив, getOrDefault() возвращает пустую 
строку, которую мы передали в качестве параметра.

### Замена значений

Эти методы аналогичны версии List, за исключением того, что используется ключ:

```
21: Map<Integer, Integer> map = new HashMap<>(); 
22: map.put(1, 2); 
23: map.put(2, 4); 
24: Integer original = map.replace(2, 10); // 4 
25: System.out.println(map);    // {1=2, 2=10} 
26: map.replaceAll((k, v) -> k + v); 
27: System.out.println(map);    // {1=3, 2=12}
```

Строка 24 заменяет значение ключа 2 и возвращает исходное значение. Строка 26 вызывает функцию и устанавливает значение 
каждого элемента карты в результат этой функции. В нашем случае мы добавили ключ и значение вместе.

### Ставим, если нет (Putting if Absent)

Метод putIfAbsent() устанавливает значение на карте, но пропускает его, если для этого значения уже установлено 
ненулевое значение.

```
Map<String, String> favorites = new HashMap<>(); 
favorites.put("Jenny", "Bus Tour"); 
favorites.put("Tom", null); 
favorites.putIfAbsent("Jenny", "Tram"); 
favorites.putIfAbsent("Sam", "Tram"); 
favorites.putIfAbsent("Tom", "Tram");
System.out.println(favorites); // {Tom=Tram, Jenny=Bus Tour, Sam=Tram}
```

Как видите, значение Jenny не обновляется, поскольку оно уже присутствовало. Sam там вообще не было, поэтому его 
добавили. Tom присутствовал как ключ, но имел null значение. Поэтому его тоже добавили.

### Слияние данных

Метод merge() добавляет логику выбора. Предположим, мы хотим выбрать поездку с самым длинным именем. Мы можем написать 
код, чтобы выразить это, передав функцию сопоставления методу merge():

```
11: BiFunction<String, String, String> mapper = (v1, v2)
12:    -> v1.length()> v2.length() ? v1: v2;
13:
14: Map<String, String> favorites = new HashMap<>(); 
15: favorites.put("Jenny", "Bus Tour"); 
16: favorites.put("Tom", "Tram"); 
17:
18: String jenny = favorites.merge("Jenny", "Skyride", mapper); 
19: String tom = favorites.merge("Tom", "Skyride", mapper); 
20:
21: System.out.println(favorites); // {Tom=Skyride, Jenny=Bus Tour} 
22: System.out.println(jenny);     // Bus Tour 
23: System.out.println(tom);       // Skyride
```

Код в строках 11 и 12 принимает два параметра и возвращает значение. Наша реализация возвращает имя с самым длинным 
именем. Строка 18 вызывает эту функцию сопоставления и видит, что Bus Tour длиннее, чем Skyride, поэтому оставляет 
значение Bus Tour. Строка 19 снова вызывает эту функцию сопоставления. На этот раз Tram короче Skyride, поэтому карта 
обновлена. Строка 21 распечатывает новое содержимое карты. Строки 22 и 23 показывают, что результат возвращается из 
merge().

Метод merge() также имеет логику того, что произойдет, если задействованы нулевые значения или отсутствующие ключи. В 
этом случае она вообще не вызывает BiFunction, а просто использует новое значение.

```
BiFunction<String, String, String> mapper =
   (v1, v2) -> v1.length()> v2.length() ? v1 : v2;
Map<String, String> favorites = new HashMap<>(); 
favorites.put("Sam", null); 
favorites.merge("Tom", "Skyride", mapper); 
favorites.merge("Sam", "Skyride", mapper); 
System.out.println(favorites);   // {Tom=Skyride, Sam=Skyride}
```

Обратите внимание, что функция сопоставления не вызывается. Если бы это было так, у нас было бы исключение 
NullPointerException. Функция сопоставления используется только тогда, когда есть два фактических значения, между 
которыми нужно выбрать.

Последнее, что нужно знать о merge(), — это то, что происходит, когда функция сопоставления вызывается и возвращает 
значение null. Ключ удаляется с карты, когда это происходит:

```
BiFunction<String, String, String> mapper = (v1, v2) -> null;
Map<String, String> favorites = new HashMap<>();
favorites.put("Jenny", "Bus Tour");
favorites.put("Tom", "Bus Tour");

favorites.merge("Jenny", "Skyride", mapper);
favorites.merge("Sam", "Skyride", mapper);
System.out.println(favorites);   // {Tom=Bus Tour, Sam=Skyride}
```

Tom остался один, поскольку для этого ключа не было вызова merge(). Sam был добавлен, поскольку этого ключа не было в 
исходном списке. Jenny была удалена, поскольку функция сопоставления вернула значение null.

В таблице 9.7 все эти сценарии показаны для справки.

#### Таблица 9.7 - Поведение метода merge()

| Если запрошенный ключ ________ | И функция сопоставления возвращает ________ |                                                   Тогда:                                                   | 
|:------------------------------:|:-------------------------------------------:|:----------------------------------------------------------------------------------------------------------:|
|   Имеет null значение в map    |  N/A (функция сопоставления не вызывается)  |                       Обновить значение ключа на карте с помощью параметра значения.                       |  
| Имеет ненулевое значение в map |                    null                     |                                           Удаление ключа с карты                                           |
| Имеет ненулевое значение в map |             Ненулевое значение              |                            Установить ключ для сопоставления результата функции                            |
|         Нет на карте           | N/A (функция сопоставления не вызывается)   | Добавьте ключ с параметром значения для непосредственного сопоставления без вызова функции сопоставления.  |

## Сравнение типов коллекций

Мы завершаем этот раздел обзором всех классов коллекций. Убедитесь, что вы можете заполнить таблицу 9.8, чтобы сравнить 
четыре типа коллекций по памяти.

#### Таблица 9.8 - Типы Java Collections Framework

|  Тип  | Может ли содержать дубликаты элементов? |     Элементы всегда упорядочены?     | Имеет ключи и значения? | Нужно добавлять/удалять в определенном порядке? | 
|:-----:|:---------------------------------------:|:------------------------------------:|:-----------------------:|:-----------------------------------------------:|
| List  |                   Да                    |           Да (по индексу)            |           Нет           |                       Нет                       |  
|  Map  |            Да (для значений)            |                 Нет                  |           Да            |                       Нет                       |
| Queue |                   Да                    | Да (получено в определенном порядке) |           Нет           |                       Да                        |
|  Set  |                   Нет                   |                 Нет                  |           Нет           |                       Нет                       |

Кроме того, убедитесь, что вы можете заполнить Таблицу 9.9, чтобы описать типы на экзамене.

#### Таблица 9.9 - Атрибуты коллекций

|    Тип     | Интерфейс Java Collections Framework | Сортируется? | Вызывает hashCode ? | Вызывает compareTo? | 
|:----------:|:------------------------------------:|:------------:|:-------------------:|:-------------------:|
| ArrayDeque |                Deque                 |     Нет      |         Нет         |         Нет         |  
| ArrayList  |                 List                 |     Нет      |         Нет         |         Нет         |
|  HashMap   |                 Map                  |     Нет      |         Да          |         Нет         |
|  HashSet   |                 Set                  |     Нет      |         Да          |         Нет         |
| LinkedList |             List, Deque              |     Нет      |         Нет         |         Нет         |
|  TreeMap   |                 Map                  |      Да      |         Нет         |         Да          |
|  TreeSet   |                 Set                  |      Да      |         Нет         |         Да          |

Далее на экзамене ожидается, что вы будете знать, какие структуры данных допускают null значения. Структуры данных, 
включающие сортировку, не допускают null значений.

Наконец, на экзамене ожидается, что вы сможете выбрать правильный тип коллекции с учетом описания проблемы. Мы 
рекомендуем сначала определить, о каком типе коллекции идет речь. Определите, ищете ли вы список, карту, очередь или 
набор. Это позволяет исключить ряд ответов. Затем вы сможете выяснить, какой из оставшихся вариантов является лучшим 
ответом.

**Старые коллекции**

Есть несколько коллекций, которые больше не используются на экзамене, но которые вы можете встретить в старом коде. Все 
три были ранними структурами данных Java, которые можно было использовать с потоками:

+ Vector: Реализует List.
+ Hashtable: Реализует Map.
+ Stack: Реализует Queue.

Эти классы сейчас используются редко, так как существуют гораздо лучшие параллельные альтернативы, которые мы рассмотрим 
в главе 13.

## Сортировка данных

Мы обсудили «порядок» для классов TreeSet и TreeMap. Для чисел порядок очевиден — это числовой порядок. Для объектов 
String порядок определяется в соответствии с сопоставлением символов Юникода.

_При работе со String помните, что числа сортируются перед буквами, а прописные буквы — перед строчными._

Во многих из этих примеров мы используем Collections.sort(). Он возвращает void, потому что сортируется именно параметр 
метода.

Вы также можете сортировать объекты, которые создаете сами. Java предоставляет интерфейс, называемый Comparable. Если 
ваш класс реализует Comparable, его можно использовать в структурах данных, требующих сравнения. Существует также класс 
под названием Comparator, который используется для указания того, что вы хотите использовать порядок, отличный от того, 
который предоставляет сам объект.

Comparable и Comparator достаточно похожи, чтобы быть сложными. На экзамене нужно проверить, удастся ли вам спутать эти 
два понятия. Не путайте! В этом разделе мы сначала обсудим Comparable. Затем, просматривая Comparator, мы указываем на 
все различия.

### Создание класса Comparable

Интерфейс Comparable имеет только один метод. Собственно, это весь интерфейс:

```
public interface Comparable<T> {    
   int compareTo(T o);
}
```

Универсальный T позволяет вам реализовать этот метод и указать тип вашего объекта. Это позволяет избежать приведения при 
реализации compareTo(). Любой объект может быть Comparable. Например, у нас есть куча уток, и мы хотим отсортировать их 
по именам. Сначала мы обновляем объявление класса, чтобы наследовать Comparable<Duck>, а затем реализуем метод 
compareTo():

```
import java.util.*;
public class Duck implements Comparable<Duck> {
   private String name;
   public Duck(String name) {
      this.name = name;
   }
   public String toString() {         // использовать читаемый вывод
      return name;
   }
    public int compareTo(Duck d) {
       return name.compareTo(d.name); // сортирует по возрастанию по имени
    }
    public static void main(String[] args) {
       var ducks = new ArrayList<Duck>();
        ducks.add(new Duck("Quack"));
        ducks.add(new Duck("Puddles"));
        Collections.sort(ducks);       // сортирует по возрастанию по имени
        System.out.println(ducks);     // [Puddles, Quack]
}}
```

Без реализации этого интерфейса все, что у нас есть, — это метод с именем compareTo(), но это не будет объект 
Comparable. Мы также могли бы реализовать Comparable<Object> или какой-либо другой класс для T, но это было бы не так 
полезно для сортировки группы объектов Duck.

_Класс Duck переопределяет метод toString() из Object, который мы описали в главе 8. Это переопределение обеспечивает 
полезный вывод при печати уток. Без этого переопределения выходные данные будут выглядеть примерно 
так: [Duck@70dea4e, Duck@5c647e05] — вряд ли это полезно для определения того, какое имя утки идет первым._

Наконец, класс Duck реализует функцию compareTo(). Поскольку Duck сравнивает объекты типа String, а в классе String уже 
есть метод compareTo(), он может просто делегировать.

Нам по-прежнему нужно знать, что возвращает метод CompareTo(), чтобы мы могли написать свой собственный. 
Необходимо знать три правила:

+ Число 0 возвращается, когда текущий объект эквивалентен аргументу метода compareTo().
+ Отрицательное число (меньше 0) возвращается, если текущий объект меньше аргумента метода compareTo().
+ Положительное число (больше 0) возвращается, когда текущий объект больше, чем аргумент метода compareTo().

Давайте посмотрим на реализацию метода compareTo(), которая сравнивает числа вместо объектов String:

```
1:  public class Animal implements Comparable<Animal> { 
2:     private int id; 
3:     public int compareTo(Animal a) { 
4:        return id - a.id;                       // sorts ascending by id 
5:     }
6:     public static void main(String[] args) { 
7:        var a1 = new Animal();
8:        var a2 = new Animal(); 
9:        a1.id = 5; 
10:       a2.id = 7; 
11:       System.out.println(a1.compareTo(a2));   // -2 
12:       System.out.println(a1.compareTo(a1));   // 0 
13:       System.out.println(a2.compareTo(a1));   // 2 
14:    } }
```

Строки 7 и 8 создают два объекта Animal. Строки 9 и 10 устанавливают значения своих id. Это не лучший способ установки 
переменных экземпляра. Было бы лучше использовать конструктор или метод сеттер. Поскольку на экзамене показан 
нетрадиционный код, чтобы убедиться, что вы понимаете правила, мы также добавляем нетрадиционный код.

В строках 3–5 показан один из способов сравнения двух int значений. Вместо этого мы могли бы использовать 
Integer.compare(id, a.id). Убедитесь, что вы понимаете оба подхода.

_Помните, что id-a.id сортирует в порядке возрастания, а a.id-id — в порядке убывания._

Строки 11–13 подтверждают, что мы правильно реализовали функцию compareTo(). Строка 11 сравнивает меньший id с большим и 
поэтому печатает отрицательное число. В строке 12 сравниваются животные с одинаковым id, поэтому выводится 0. Строка 13 
сравнивает больший id с меньшим и, следовательно, возвращает положительное число.

### Приведение аргумента compareTo()

При работе с устаревшим кодом или кодом, который не использует дженерики, метод compareTo() требует приведения типов, 
поскольку ему передается Object.

```
public class LegacyDuck implements Comparable {
   private String name;
   public int compareTo(Object obj) {
      LegacyDuck d = (LegacyDuck) obj; // кастинг, потому что нет дженериков
      return name.compareTo(d.name);
   }
}      
```

Поскольку мы не указываем общий тип для Comparable, Java предполагает, что нам нужен Object, а это означает, что нам 
нужно выполнить приведение к LegacyDuck, прежде чем получить доступ к переменным экземпляра на нем.

### Проверка на null

Работая с Comparable и Comparator в этой главе, мы склонны предполагать, что данные имеют значения, но это не всегда 
так. При написании собственных методов сравнения вам следует проверять данные перед их сравнением, если они не 
проверены заранее.

```
public class MissingDuck implements Comparable<MissingDuck> {
   private String name;
   public int compareTo(MissingDuck quack) {
       if (quack == null)
          throw new IllegalArgumentException("Poorly formed duck!");
       if (this.name == null && quack.name == null)
          return 0;
       else if (this.name == null) return -1;      
       else if (quack.name == null) return 1;      
       else return name.compareTo(quack.name);
   }
}       
```

### Сохранение согласованности compareTo() и equals()

Если вы пишете класс, реализующий Comparable, вы вводите новую бизнес-логику для определения равенства. Метод 
compareTo() возвращает 0, если два объекта равны, а метод equals() возвращает true, если два объекта равны. 
Говорят, что естественный порядок, использующий функцию compareTo(), соответствует принципу равенства тогда и только 
тогда, когда x.equals(y) true всякий раз, когда x.compareTo(y) равно 0.

Аналогично, x.equals(y) должен быть false, если x.compareTo(y) не равен 0. Настоятельно рекомендуется сделать ваши 
классы Comparable совместимыми с равными, поскольку не все классы коллекций ведут себя предсказуемо, если функции 
compareTo() и equals() методы не однозначны.

Например, следующий класс Product определяет метод compareTo(), который несовместим с методом равенства:

```
public class Product implements Comparable<Product> {
   private int id;   
   private String name;
   
   public int hashCode() { return id; }
   public boolean equals(Object obj) {
      if(!(obj instanceof Product)) return false;
      var other = (Product) obj;
      return this.id == other.id;
   }
   public int compareTo(Product obj) {
      return this.name.compareTo(obj.name);
   } 
}
```

Возможно, вы сортируете объекты Product по имени, но имена не уникальны. Метод compareTo() не обязательно должен быть 
согласован с равными. Один из способов исправить это — использовать компаратор для определения сортировки в другом 
месте.

Теперь, когда вы знаете, как реализовать объекты Comparable, вы можете взглянуть на Comparator и сосредоточиться на 
различиях.

### Сравнение данных с помощью Comparator

Иногда вам нужно отсортировать объект, который не реализовал Comparable, или вы хотите сортировать объекты разными 
способами в разное время. Предположим, мы добавим вес нашему классу Duck. Теперь у нас есть следующее:

```
1:  import java.util.ArrayList; 
2:  import java.util.Collections; 
3:  import java.util.Comparator; 
4:
5:  public class Duck implements Comparable<Duck> { 
6:     private String name; 
7:     private int weight; 
8:
9:     // Предположим, что имеются геттеры/сеттеры/конструкторы
10:
11:    public String toString() { return name; } 
12:
13:    public int compareTo(Duck d) { 
14:       return name.compareTo(d.name); 
15:    }
16:
17:    public static void main(String[] args) { 
18:       Comparator<Duck> byWeight = new Comparator<Duck>() { 
19:          public int compare(Duck d1, Duck d2) { 
20:             return d1.getWeight()-d2.getWeight(); 
21:          }
22:       };
23:       var ducks = new ArrayList<Duck>(); 
24:       ducks.add(new Duck("Quack", 7)); 
25:       ducks.add(new Duck("Puddles", 10)); 
26:       Collections.sort(ducks); 
27:       System.out.println(ducks); // [Puddles, Quack] 
28:       Collections.sort(ducks, byWeight);
29:       System.out.println(ducks); // [Quack, Puddles] 
30:    }
31: }
```

Во-первых, обратите внимание, что эта программа импортирует java.util.Comparator в строке 3. Мы не всегда показываем 
импорт, поскольку вы можете предположить, что он присутствует, если он не показан. Здесь мы показываем импорт, чтобы 
обратить внимание на тот факт, что Comparable и Comparator находятся в разных пакетах: java.lang и java.util 
соответственно. Это означает, что Comparable можно использовать без оператора импорта, а Comparator — нет.

Сам класс Duck может определить только один метод compareTo(). В данном случае было выбрано имя. Если мы хотим выполнить 
сортировку по чему-то другому, нам нужно определить этот порядок сортировки вне метода compareTo(), используя отдельный 
класс или лямбда-выражение.

Строки 18–22 метода main() показывают, как определить Comparator с использованием внутреннего класса. В строках 26–29 мы 
сортируем без использования Comparator, а затем с помощью Comparator, чтобы увидеть разницу в результатах.

Comparator — это функциональный интерфейс, поскольку необходимо реализовать только один абстрактный метод. Это означает, 
что мы можем переписать Comparator в строках 18–22, используя лямбда-выражение, как показано здесь:

```
Comparator<Duck> byWeight = (d1, d2) -> d1.getWeight()-d2.getWeight();
```

Альтернативно, мы можем использовать ссылку на метод и вспомогательный метод, чтобы указать, что мы хотим сортировать по 
весу.

```
Comparator<Duck> byWeight = Comparator.comparing(Duck::getWeight);
```

В этом примере Comparator.comparing() — это метод статического интерфейса, который создает Comparator с учетом 
лямбда-выражения или ссылки на метод. Удобно, не так ли?

**Является ли Comparable функциональным интерфейсом?**

Мы сказали, что Comparator — это функциональный интерфейс, поскольку он имеет единственный абстрактный метод. Comparable 
также является функциональным интерфейсом, поскольку он также имеет единственный абстрактный метод. Однако использовать 
лямбду для Comparable было бы глупо. Цель Comparable — реализовать его внутри сравниваемого объекта.

### Comparing Comparable and Comparator

