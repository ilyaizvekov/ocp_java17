# Коллекции и дженерики

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Работа с массивами и коллекциями

+ Создавайте массивы Java, коллекции List, Set, Map и Deque, а также добавляйте, удаляйте, обновляйте, извлекайте и 
сортируйте их элементы.

---

В этой главе мы представляем классы и интерфейсы Java Collections Framework, которые вам необходимо знать для сдачи 
экзамена. Потокобезопасные типы коллекций обсуждаются в главе 13 «Параллелизм». Как вы, возможно, помните из главы 8 
«Лямбды и функциональные интерфейсы», мы рассмотрели лямбды, ссылки на методы и встроенные функциональные интерфейсы. 
Многие из них используются в этой главе. Если функциональные интерфейсы вам незнакомы, вернитесь и просмотрите 
Таблицу 8.4. Далее мы подробно расскажем о Comparator и Comparable. Наконец, мы обсудим, как создавать собственные 
классы и методы, использующие дженерики, чтобы один и тот же класс можно было использовать со многими типами.

## Использование API общей коллекции

Коллекция — это группа объектов, содержащихся в одном объекте. Java Collections Framework — это набор классов в 
java.util для хранения коллекций. В Java Collections Framework имеется четыре основных интерфейса.

+ List (Список): Список представляет собой упорядоченный набор элементов, допускающий дублирование записей. Доступ к 
элементам списка возможен по индексу int.
+ Set (Набор): Set — это коллекция, в которой не допускается дублирование записей.
+ Queue (Очередь): Queue — это коллекция, которая упорядочивает свои элементы в определенном порядке для обработки. 
Deque — это подинтерфейс Queue, который обеспечивает доступ на обоих концах.
+ Map (Карта): Map — это коллекция, которая сопоставляет ключи со значениями, дублирование ключей не допускается. 
Элементы карты представляют собой пары ключ/значение.

На рисунке 9.1 показан интерфейс Collection, его подинтерфейсы и некоторые классы, реализующие интерфейсы, которые 
вам следует знать для экзамена. Интерфейсы показаны в прямоугольниках, а классы — в закругленных прямоугольниках.

Обратите внимание, что Map не реализует интерфейс Collection. Он считается частью Java Collections Framework, хотя 
технически он не является Collection. Однако это коллекция (обратите внимание на строчные буквы), поскольку она содержит 
группу объектов. Причина, по которой карты обрабатываются по-разному, заключается в том, что им нужны разные методы, 
поскольку они представляют собой пары ключ/значение.

#### Рис. 9.1 - Java Collections Framework

В этом разделе мы обсудим общие методы, которые API коллекций предоставляет реализующим классам. Многие из этих методов 
представляют собой _удобные методы_, которые можно реализовать другими способами, но которые упрощают написание и чтение 
кода. Именно поэтому они удобны.

В этом разделе мы используем ArrayList и HashSet в качестве классов реализации, но они могут применяться к любому 
классу, наследующему интерфейс Collection. В следующем разделе мы рассмотрим конкретные свойства каждого класса 
Collection.

### Использование diamond оператора

При создании Java Collections Framework вам необходимо указать тип, который будет входить внутрь. Мы могли бы написать 
код, используя дженерики, подобные следующему:

```
List<Integer> list = new ArrayList<Integer>();
```

У вас могут даже быть дженерики, содержащие другие дженерики, например этот:

```
Map<Long,List<Integer>> mapLists = new HashMap<Long,List<Integer>>();
```

Нужно написать много дублированного кода! К счастью, оператор ромба (diamond operator) (<>) — это сокращенная запись, 
позволяющая опустить общий тип в правой части оператора, когда тип можно вывести. Он называется оператором ромба, потому 
что <> выглядит как ромб. Сравните предыдущие объявления с этими новыми, гораздо более короткими версиями:

```
List<Integer> list = new ArrayList<>(); 
Map<Long,List<Integer>> mapOfLists = new HashMap<>();
```

Для компилятора оба этих объявления и наши предыдущие эквивалентны. Однако для нас последний вариант намного короче и 
его легче читать.

Оператор ромба нельзя использовать в качестве типа в объявлении переменной. Его можно использовать только в правой части 
операции присваивания. Например, ни одно из следующих действий не компилируется:

```
List<> list = new ArrayList<Integer>();      // НЕ КОМПИЛИРУЕТСЯ

class InvalidUse {
    void use(List<> data) {}                 // НЕ КОМПИЛИРУЕТСЯ
}
```

### Добавление данных

Метод add() вставляет новый элемент в коллекцию и возвращает информацию о том, был ли он успешным. Сигнатура метода 
следующая:

```
public boolean add(E element)
```

Помните, что Collections Framework использует дженерики. Вы будете часто видеть, как буква E появляется. Это означает
универсальный тип, который использовался для создания коллекции. Для некоторых типов коллекций add() всегда возвращает 
true. Для других типов существует логика определения того, был ли вызов add() успешным. Ниже показано, как использовать 
этот метод:

```
3: Collection<String> list = new ArrayList<>(); 
4: System.out.println(list.add("Sparrow")); // true 
5: System.out.println(list.add("Sparrow")); // true 
6:
7: Collection<String> set = new HashSet<>(); 
8: System.out.println(set.add("Sparrow")); // true 
9: System.out.println(set.add("Sparrow")); // false
```

List допускает дубликаты, каждый раз возвращая значение true. Set не допускает дубликатов. В строке 9 мы попытались 
добавить дубликат, чтобы Java возвращала false из метода add().

### Удаление данных

Метод remove() удаляет одно совпадающее значение в коллекции и возвращает информацию о том, было ли оно успешным. 
Сигнатура метода следующая:

```
public boolean remove(Object object)
```

На этот раз возвращаемое boolean значение сообщает нам, было ли удалено совпадение. Ниже показано, как использовать этот 
метод:

```
3: Collection<String> birds = new ArrayList<>();
4: birds.add("hawk");                            // [hawk]
5: birds.add("hawk");                            // [hawk, hawk] 
6: System.out.println(birds.remove("cardinal")); // false 
7: System.out.println(birds.remove("hawk"));     // true 
8: System.out.println(birds);                    // [hawk]
```

Строка 6 пытается удалить элемент, которого нет в birds. Он возвращает false, поскольку такой элемент не найден. Строка 
7 пытается удалить элемент, принадлежащий birds, поэтому возвращает true. Обратите внимание: удаляется только одно 
совпадение.

### Подсчет элементов

Методы isEmpty() и size() смотрят, сколько элементов содержится в коллекции. Сигнатуры методов такие:

```
public boolean isEmpty() 
public int size()
```

Ниже показано, как использовать эти методы:

```
Collection<String> birds = new ArrayList<>(); 
System.out.println(birds.isEmpty()); // true 
System.out.println(birds.size());    // 0 
birds.add("hawk");                   // [hawk] 
birds.add("hawk");                   // [hawk, hawk] 
System.out.println(birds.isEmpty()); // false 
System.out.println(birds.size());    // 2
```

В начале, birds имеет размер 0 и пуст. Его емкость больше 0. После того, как мы добавим элементы, размер станет 
положительным, и он больше не будет пустым.

### Очистка коллекции

Метод clear() предоставляет простой способ удалить все элементы коллекции. Сигнатура метода следующая:

```
public void clear()
```

Ниже показано, как использовать этот метод:

```
Collection<String> birds = new ArrayList<>(); 
birds.add("hawk");                   // [hawk] 
birds.add("hawk");                   // [hawk, hawk] 
System.out.println(birds.isEmpty()); // false 
System.out.println(birds.size());    // 2 
birds.clear();                       // []
System.out.println(birds.isEmpty()); // true
System.out.println(birds.size());    // 0
```

После вызова метода clear(), birds снова становится пустым ArrayList размером 0.

### Проверить содержимое

Метод contains() проверяет, присутствует ли определенное значение в коллекции. Сигнатура метода следующая:

```
public boolean contains(Object object)
```

Ниже показано, как использовать этот метод:

```
Collection<String> birds = new ArrayList<>(); 
birds.add("hawk"); // [hawk] 
System.out.println(birds.contains("hawk"));  // true 
System.out.println(birds.contains("robin")); // false
```

Метод contains() вызывает метод equals() для элементов ArrayList, чтобы проверить, есть ли совпадения.

### Удаление с условиями

Метод removeIf() удаляет все элементы, соответствующие условию. Мы можем указать, что следует удалить, используя блок 
кода или даже ссылку на метод.

Сигнатура метода выглядит следующим образом. (Мы объясним, что означает символ ? super, в разделе «Работа с дженериками» 
далее в этой главе.)

```
public boolean removeIf(Predicate<? super E> filter)
```

Он использует Predicate, который принимает один параметр и возвращает логическое значение. Давайте посмотрим на пример:

```
4: Collection<String> list = new ArrayList<>(); 
5: list.add("Magician"); 
6: list.add("Assistant"); 
7: System.out.println(list);     // [Magician, Assistant] 
8: list.removeIf(s -> s.startsWith("A")); 
9: System.out.println(list);     // [Magician]
```

В строке 8 показано, как удалить все String значения, начинающиеся с буквы A. Это позволяет нам исчезнуть с Assistant. 
Давайте попробуем пример со ссылкой на метод:

```
11: Collection<String> set = new HashSet<>(); 
12: set.add("Wand"); 
13: set.add("");
14: set.removeIf(String::isEmpty); // s -> s.isEmpty() 
15: System.out.println(set);       // [Wand]
```

В строке 14 мы удаляем из set все пустые объекты String. Комментарий к этой строке показывает лямбда-эквивалент ссылки 
на метод. В строке 15 показано, что метод removeIf() успешно удалил один элемент из list.

### Итерация (Iterating)

Существует метод forEach(), который вы можете вызывать для коллекции вместо написания цикла. Он использует Consumer, 
который принимает один параметр и ничего не возвращает. Сигнатура метода следующая:

```
public void forEach(Consumer<? super T> action)
```

Cats любят исследовать, поэтому давайте распечатаем два из них, используя как ссылки на методы, так и лямбда-выражения:

```
Collection<String> cats = List.of("Annie", "Ripley"); 
cats.forEach(System.out::println); 
cats.forEach(c -> System.out.println(c));
```

Cats научились писать свои имена. Теперь у них есть больше времени для игры (как и у нас)!

**Другие подходы к итерации**

Есть и другие способы перебирать коллекции. Например, в главе 3 «Принятие решений» вы видели, как перебирать список с 
помощью расширенного цикла for.

```
for (String element: coll)
  System.out.println(element);
```

Вы можете увидеть другой старый подход.

```
Iterator<String> iter = coll.iterator();
while(iter.hasNext()) {
   String string = iter.next();
   System.out.println(string);    
}
```

Обратите внимание на разницу между этими приемами. Метод hasNext() проверяет, существует ли следующее значение. Другими 
словами, он сообщает вам, будет ли выполняться функция next() без выдачи исключения. Метод next() фактически перемещает
Iterator к следующему элементу.

### Определение равенства

Существует специальная реализация метода equals(), поэтому вы можете сравнивать две коллекции, чтобы сравнить их тип и 
содержимое. Реализация будет разной. Например, ArrayList проверяет порядок, а HashSet — нет.

```
boolean equals(Object object)
```

Ниже приведен пример:

```
23: var list1 = List.of(1, 2); 
24: var list2 = List.of(2, 1); 
25: var set1 = Set.of(1, 2); 
26: var set2 = Set.of(2, 1);
27:
28: System.out.println(list1.equals(list2));  // false 
29: System.out.println(set1.equals(set2));    // true 
30: System.out.println(list1.equals(set1));   // false
```

В строке 28 выводится false, потому что элементы расположены в другом порядке, а List заботится о порядке. Напротив, 
строка 29 печатает true, потому что Set не чувствителен к порядку. Наконец, строка 30 выводит false, поскольку типы 
разные.

**Распаковка nulls**

Java защищает нас от многих проблем с коллекциями. Однако написать исключение NullPointerException все же можно:

```
3: var heights = new ArrayList<Integer>();
4: heights.add(null);
5: int h = heights.get(0);          // NullPointerException
```

В строке 4 мы добавляем в список null. Это законно, поскольку null ссылка может быть присвоена любой ссылочной 
переменной. В строке 5 мы пытаемся распаковать этот null в примитив int. Это проблема. Java пытается получить значение 
int, равное null. Поскольку вызов любого метода для значения null приводит к исключению NullPointerException, именно это 
мы и получаем. Будьте осторожны, когда вы видите значение null в отношении автобокса.

## Использование интерфейса List

Теперь, когда вы знакомы с некоторыми распространенными методами интерфейса Collection, давайте перейдем к конкретным 
интерфейсам. Список используется, если вам нужна упорядоченная коллекция, которая может содержать повторяющиеся записи. 
Например, список имен может содержать дубликаты, поскольку у двух животных может быть одно и то же имя. Элементы можно 
извлекать и вставлять в определенные позиции в списке на основе индекса int, аналогично массиву. Однако, в отличие от 
массива, многие реализации List могут изменяться в размере после их объявления.

Списки широко используются, потому что в программировании существует множество ситуаций, когда вам необходимо 
отслеживать список объектов. Например, вы можете составить список того, что вы хотите увидеть в зоопарке: во-первых, 
увидеть львов, потому что они рано ложатся спать; во-вторых, посмотрите на панд, потому что позже в тот же день 
выстраивается длинная очередь; и так далее.

На рис. 9.2 показано, как можно представить список. Каждый элемент списка имеет индекс, и индексы начинаются с нуля.

#### Рис. 9.2 - Пример List



Иногда вам не важен порядок элементов в списке. Список похож на тип данных «go to». Когда мы составляем список покупок 
перед походом в магазин, его порядок совпадает с порядком, в котором мы думали о товарах. Мы, вероятно, не привязаны к 
этому конкретному порядку, но это ничему не повредит.

Хотя классы, реализующие интерфейс List, имеют множество методов, вам необходимо знать только наиболее распространенные 
из них. Удобно, что эти методы одинаковы для всех реализаций, которые могут появиться на экзамене.

Главное, что объединяет все реализации List, — это то, что они упорядочены и допускают дублирование. Помимо этого, 
каждый из них предлагает разные функциональные возможности. Мы рассмотрим реализации, которые вам необходимо знать, и 
доступные методы.

_Обратите особое внимание на то, какие имена являются классами, а какие интерфейсами. На экзамене вас могут спросить, 
какой класс лучше или какой интерфейс лучше всего подходит для конкретного сценария._

### Сравнение реализаций List

ArrayList похож на массив с изменяемым размером. При добавлении элементов ArrayList автоматически увеличивается. Если вы 
не уверены, какую коллекцию использовать, используйте ArrayList.

Основное преимущество ArrayList заключается в том, что вы можете искать любой элемент за постоянное время. Добавление 
или удаление элемента происходит медленнее, чем доступ к элементу. Это делает ArrayList хорошим выбором, когда вы 
читаете чаще (или столько же), сколько записываете в ArrayList.

LinkedList особенный, поскольку он реализует как List, так и Deque. Он имеет все методы List. Он также имеет 
дополнительные методы для облегчения добавления или удаления из начала и/или конца списка.

Основные преимущества LinkedList заключаются в том, что вы можете получать доступ, добавлять и удалять элементы из 
начала и конца списка за постоянное время. Компромисс заключается в том, что работа с произвольным индексом занимает 
линейное время. Это делает LinkedList хорошим выбором, когда вы будете использовать его в качестве Deque. Как вы видели 
на рисунке 9.1, LinkedList реализует интерфейсы List и Deque.

### Создание List с помощью фабрики

Когда вы создаете список типа ArrayList или LinkedList, вы знаете его тип. Существует несколько специальных методов, с 
помощью которых вы возвращаете список, но не знаете его тип. Эти методы позволяют создать список, включающий данные в 
одну строку, используя фабричный метод. Это удобно, особенно при тестировании. Некоторые из этих методов возвращают 
неизменяемый объект. Как мы видели в главе 6 «Проектирование классов», неизменяемый объект нельзя изменить или 
модифицировать. В таблице 9.1 суммированы эти три списка.

#### Таблица 9.1 - Фабричные методы для создания List

|          Метод          |                                Описание                                | Можете добавить элементы? |   Можно ли заменить элементы?   |   Можно ли удалять элементы?   |  
|:-----------------------:|:----------------------------------------------------------------------:|:-------------------------:|:-------------------------------:|:------------------------------:|
| Arrays.asList(varargs)  | Возвращает список фиксированного <br/> размера, подкрепленный массивом |            Нет            |               Да                |              Нет               |
|    List.of(varargs)     |                     Возвращает неизменяемый список                     |            Нет            |               Нет               |              Нет               |                                     
| List.copyOf(collection) |  Возвращает неизменяемый список с копией значений исходной коллекции   |            Нет            |               Нет               |              Нет               |

Давайте рассмотрим пример этих трех методов:

```
16: String[] array = new String[] {"a", "b", "c"}; 
17: List<String> asList = Arrays.asList(array); // [a, b, c] 
18: List<String> of = List.of(array);           // [a, b, c] 
19: List<String> copy = List.copyOf(asList);    // [a, b, c]
20:
21: array[0] = "z";
22:
23: System.out.println(asList);                 // [z, b, c] 
24: System.out.println(of);                     // [a, b, c] 
25: System.out.println(copy);                   // [a, b, c]
26:
27: asList.set(0, "x"); 
28: System.out.println(Arrays.toString(array)); // [x, b, c]
29:
30: copy.add("y");            // UnsupportedOperationException
```

Строка 17 создает List, поддерживаемый массивом. Строка 21 изменяет массив, а строка 23 отражает это изменение. 
Строки 27 и 28 показывают другое направление, когда изменение List обновляет базовый массив. Строки 18 и 19 создают 
неизменяемый List. Строка 30 показывает, что он является неизменяемым, выдавая исключение при попытке добавить значение. 
Все три списка выдадут исключение при добавлении или удалении значения. Списки of и copy также выдают ошибку при попытке 
обновления элемента.

### Создание List с помощью конструктора

В большинстве коллекций есть два конструктора, которые вам необходимо знать для экзамена. Ниже показаны их для 
LinkedList:

```
var linked1 = new LinkedList<String>();
var linked2 = new LinkedList<String>(linked1);
```

Первый говорит о создании пустого LinkedList, содержащего все значения по умолчанию. Второй сообщает Java, что мы хотим 
сделать копию другого LinkedList. Конечно, в этом примере linked1 пуст, поэтому он не представляет особого интереса.

В ArrayList есть дополнительный конструктор, о котором вам нужно знать. Теперь мы покажем три конструктора:

```
var list1 = new ArrayList<String>();
var list2 = new ArrayList<String>(list1);
var list3 = new ArrayList<String>(10);
```

Первые два — это общие конструкторы, которые вам нужно знать для всех коллекций. В последнем примере говорится о 
создании ArrayList, содержащего определенное количество слотов, но опять же не назначать их. Вы можете думать об этом 
как о размере базового массива.

**Использование var с ArrayList**

Рассмотрим этот код, в котором сочетаются var и дженерики:

```
var strings = new ArrayList<String>();
strings.add("a");
for (String s: strings) {  }
```

Тип переменной — ArrayList<String>. Это означает, что вы можете добавить String или перебрать объекты String. Что, если 
мы используем diamond оператор с var?

```
var list = new ArrayList<>();
```

Хотите верьте, хотите нет, но это компилируется. Тип переменной var — ArrayList<Object>. Поскольку для универсального 
типа не указан тип, Java должен принять окончательный суперкласс. Это немного глупо и неожиданно, поэтому, пожалуйста, 
не пишите это. Но если вы увидите это на экзамене, вы будете знать, чего ожидать. Теперь вы можете понять, почему это не 
компилируется?

```
var list = new ArrayList<>();
list.add("a");
for (String s: list) { } // НЕ КОМПИЛИРУЕТСЯ
```

Тип переменной var — ArrayList<Object>. Поскольку daimond оператор не имеет типа, Java должен использовать самый общий 
вариант, какой только может. Поэтому он выбирает Object, высший суперкласс. Добавление String в список — это нормально. 
Вы можете добавить любой подкласс Object. Однако в цикле нам нужно использовать тип Object, а не String.

### Работа с методами List

Методы интерфейса List предназначены для работы с индексами. Помимо унаследованных методов Collection, сигнатуры 
методов, которые вам необходимо знать, приведены в таблице 9.2.

#### Таблица 9.2 - Методы List

|                        Метод                        |                                                          Опсиание                                                           | 
|:---------------------------------------------------:|:---------------------------------------------------------------------------------------------------------------------------:|
|            public boolean add(E element)            |                                 Добавляет элемент в конец (доступно во всех API коллекций).                                 |  
|        public void add(int index, E element)        |                             Добавляет элемент по индексу и перемещает оставшуюся часть в конец.                             |                                    
|               public E get(int index)               |                                               Возвращает элемент по индексу.                                                | 
|             public E remove(int index)              |                                  Удаляет элемент по индексу и перемещает остальные вперед.                                  | 
| public default void replaceAll(UnaryOperator<E> op) |                                   Заменяет каждый элемент в списке результатом оператора.                                   | 
|            public E set(int index, E e)             | Заменяет элемент по индексу и возвращает оригинал. Выдает исключение IndexOutOfBoundsException, если индекс недействителен. |
| public default void sort(Comparator<? super E> c)   |                     Сортирует список. Мы рассмотрим это позже в главе, в разделе «Сортировка данных».                       |

Следующие операторы демонстрируют большинство этих методов работы со списком:

```
3:  List<String> list = new ArrayList<>();
4:  list.add("SD");                  // [SD] 
5:  list.add(0, "NY");               // [NY,SD] 
6:  list.set(1, "FL");               // [NY,FL] 
7:  System.out.println(list.get(0)); // NY 
8:  list.remove("NY");               // [FL] 
9:  list.remove(0);                  // [] 
10: list.set(0, "?");                // IndexOutOfBoundsException
```

В строке 3 list начинается пустым. Строка 4 добавляет элемент в конец списка. В строке 5 добавляется элемент с индексом 
0, который увеличивает исходный индекс 0 до индекса 1. Обратите внимание, что ArrayList теперь автоматически 
увеличивается на единицу. В строке 6 элемент с индексом 1 заменяется новым значением.

В строке 7 используется метод get() для печати элемента по определенному индексу. Строка 8 удаляет элемент, 
соответствующий NY. Наконец, строка 9 удаляет элемент с индексом 0, и список снова становится пустым.

В строке 10 выбрасывается исключение IndexOutOfBoundsException, поскольку в List нет элементов. Поскольку элементов для 
замены нет, даже индекс 0 не допускается. Если строку 10 переместить вверх между строками 4 и 5, вызов будет успешным.

Результат будет таким же, если вы попробуете эти примеры с LinkedList. Хотя код будет менее эффективным, это не будет 
заметно, пока у вас не будут очень большие списки.

Теперь давайте взглянем на метод replaceAll(). Он использует UnaryOperator, который принимает один параметр и возвращает 
значение того же типа:

```
var numbers = Arrays.asList(1, 2, 3);
numbers.replaceAll(x -> x*2);
System.out.println(numbers);   // [2, 4, 6]
```

Эта лямбда удваивает значение каждого элемента в списке. Метод replaceAll() вызывает лямбду для каждого элемента списка 
и заменяет значение по этому индексу.

**Перегруженные методы remove()**

Мы рассмотрели два перегруженных метода remove(). Тот, что из коллекции, удаляет объект, соответствующий параметру. 
Напротив, элемент из List удаляет элемент по указанному индексу.

Это становится сложнее, если у вас есть тип Integer. Как вы думаете, что означают следующие печати?

```
31: var list = new LinkedList<Integer>(); 
32: list.add(3); 33: list.add(2); 
34: list.add(1); 35: list.remove(2); 
36: list.remove(Integer.valueOf(2)); 
37: System.out.println(list);
```

Правильный ответ: [3]. Давайте посмотрим, как мы туда попали. В конце строки 34 у нас есть [3, 2, 1]. В строке 35 
передается примитив, что означает, что мы запрашиваем удаление элемента с индексом 2. В результате у нас остается 
[3, 2]. Затем в строке 36 передается объект Integer, что означает, что мы удаляем значение 2. Это подводит нас к 
[3].

Поскольку вызов метода remove() с числом int использует индекс, несуществующий индекс вызовет/выбросит исключение. 
Например, list.remove(100) выдает исключение IndexOutOfBoundsException.

### Преобразование List в массив

Поскольку массив можно передать как vararg, в таблице 9.1 показано, как преобразовать массив в список. Вы также должны 
знать, как сделать обратное. Начнем с преобразования списка в массив:

```
13: List<String> list = new ArrayList<>(); 
14: list.add("hawk"); 
15: list.add("robin"); 
16: Object[] objectArray = list.toArray(); 
17: String[] stringArray = list.toArray(new String[0]); 
18: list.clear(); 
19: System.out.println(objectArray.length);     // 2 
20: System.out.println(stringArray.length);     // 2
```

Строка 16 показывает, что List знает, как преобразовать себя в массив. Единственная проблема заключается в том, что по 
умолчанию используется массив класса Object. Обычно это не то, чего вы хотите. Строка 17 определяет тип массива и делает 
то, что мы хотим. Преимущество указания размера 0 для параметра заключается в том, что Java создаст новый массив 
подходящего размера для возвращаемого значения. Если хотите, вы можете предложить вместо этого использовать больший 
массив. Если List помещается в этот массив, он будет возвращен. В противном случае будет создан новый массив.

Также обратите внимание, что строка 18 очищает исходный List. Это не влияет ни на один массив. Массив представляет собой 
недавно созданный объект, не имеющий отношения к исходному List. Это просто копия.

## Использование интерфейса Set

Вы используете Set, когда не хотите допускать дублирование записей. Например, вы можете отслеживать уникальных животных, 
которых хотите увидеть в зоопарке. Вас не волнует порядок, в котором вы видите этих животных, но у вас нет времени 
видеть их более одного раза. Вам просто нужно убедиться, что вы видите тех, которые важны для вас, и удалить их из 
набора выдающихся животных, чтобы увидеть их после того, как вы их увидите.

На рис. 9.3 показано, как можно представить Set. Главное, что объединяет все реализации Set, — это то, что они не 
допускают дублирования. Мы рассмотрим каждую реализацию, которую вам нужно знать для экзамена, и то, как писать код с 
использованием Set.

#### Рис. 9.3 - Пример Set


### Сравнение реализаций Set

HashSet хранит свои элементы в хеш-таблице, что означает, что ключи представляют собой хэш, а значения — объект. Это 
означает, что HashSet использует метод объектов hashCode() для более эффективного их извлечения. Помните, что 
действительный hashCode() не означает, что каждый объект получит уникальное значение, но метод часто пишется так, что 
хэш-значения распределяются по большому диапазону, чтобы уменьшить коллизии.

Основное преимущество заключается в том, что добавление элементов и проверка наличия элемента в наборе имеют 
постоянное время. Компромисс заключается в том, что вы теряете порядок вставки элементов. В большинстве случаев вас это 
не касается в Set, что делает HashSet наиболее распространенным набором.

TreeSet хранит свои элементы в отсортированной древовидной структуре. Основное преимущество заключается в том, что 
набор всегда находится в отсортированном порядке. Компромисс заключается в том, что добавление и проверка существования 
элемента занимает больше времени, чем при использовании HashSet, особенно по мере того, как дерево становится больше.

На рис. 9.4 показано, как можно представить себе хранение HashSet и TreeSet. На самом деле HashSet сложнее, но для целей 
экзамена этого вполне достаточно.

#### Рис. 9.4 - Примеры HashSet и TreeSet



Для экзамена вам не нужно знать, как создать хэш или набор деревьев (реализация может быть сложной). Уф! Вам просто 
нужно знать, как ими пользоваться!

### Работа с методами Set

Как и в случае с List, вы можете создать неизменяемый Set в одной строке или сделать копию существующего.

```
Set<Character> letters = Set.of('z', 'o', 'o');
Set<Character> copy = Set.copyOf(letters);
```

Это единственные дополнительные методы, которые вам нужно знать для интерфейса Set для экзамена! Вам нужно знать, как 
наборы ведут себя по отношению к традиционным методам Collection. Вы также должны знать различия между типами наборов. 
Начнем с HashSet:

```
3: Set<Integer> set = new HashSet<>(); 
4: boolean b1 = set.add(66);    // true 
5: boolean b2 = set.add(10);    // true 
6: boolean b3 = set.add(66);    // false 
7: boolean b4 = set.add(8);     // true 
8: set.forEach(System.out::println);
```

Этот код печатает три строки:

```
66
8
10
```

Методы add() должны быть понятны. Они возвращают true, если Integer еще не находится в set. Строка 6 возвращает false, 
поскольку в наборе уже есть 66 и набор должен сохранять уникальность. Строка 8 печатает элементы набора в произвольном 
порядке. В данном случае это не порядок сортировки или порядок, в котором мы добавили элементы.

Помните, что метод equals() используется для определения равенства. Метод hashCode() используется, чтобы узнать, в каком
сегменте искать, чтобы Java не приходилось просматривать весь set, чтобы выяснить, есть ли там объект. В лучшем случае 
хеш-коды уникальны, и Java должна вызывать метод equals() только для одного объекта. Худший случай заключается в том, 
что все реализации возвращают один и тот же hashCode(), и Java в любом случае должен вызывать мето eдquals() для каждого 
элемента set.

Теперь давайте посмотрим на тот же пример с TreeSet:

```
3: Set<Integer> set = new TreeSet<>(); 
4: boolean b1 = set.add(66);  // true 
5: boolean b2 = set.add(10);  // true 
6: boolean b3 = set.add(66);  // false 
7: boolean b4 = set.add(8);   // true 
8: set.forEach(System.out::println);
```

На этот раз код печатает следующее:

```
8
10
66
```

Элементы распечатываются в естественном отсортированном порядке. Numbers реализуют интерфейс Comparable в Java, который 
используется для сортировки. Далее в этой главе вы узнаете, как создавать собственные объекты Comparable.

## Использование интерфейсов Queue и Deque

Queue используется, когда элементы добавляются и удаляются в определенном порядке. Вы можете думать об очереди как о 
линии. Например, если вы хотите войти на стадион, а кто-то стоит в очереди, вы встаете в очередь позади этого человека. 
А если вы британец, вы встанете в очередь позади этого человека, и вам будет очень легко запомнить это! Это очередь FIFO 
(первым пришел — первым обслужен).

Deque (двусторонняя очередь), часто произносится как «колода», отличается от обычной очереди тем, что вы можете 
вставлять и удалять элементы как спереди (голова), так и сзади (хвост). Подумайте: «Доктор. Вуди Флауэрс, иди вперед! 
Вы единственный, кто пользуется таким особым отношением. Всем остальным придется начинать с конца очереди».

Вы можете представить двустороннюю очередь, как показано на рисунке 9.5.

#### Рис. 9.5 - Пример Deque


Предположим, мы используем это как очередь FIFO. Ровер первый, а это значит, что он прибыл первым. Белла идет последней, 
а это значит, что она пришла последней и ей осталось ждать дольше всех. У всех очередей есть особые требования к 
добавлению и удалению следующего элемента. Помимо этого, каждый из них предлагает разные функциональные возможности. Мы 
рассмотрим реализации, которые вам необходимо знать, и доступные методы.

### Сравнение реализаций Deque

Вы видели LinkedList ранее в разделе «List». Это не только список, но и Deque. Основное преимущество LinkedList 
заключается в том, что он реализует интерфейсы List и Deque. Компромисс в том, что он не так эффективен, как «чистая» 
очередь. Вы можете использовать класс ArrayDeque, если вам не нужны методы List.

### Работа с методами Queue и Deque

Интерфейс Queue содержит шесть методов, показанных в Таблице 9.3. Существует три части функциональности и версии 
методов, которые создают исключение или используют тип возвращаемого значения, например null, для всей информации. Мы 
выделили жирным шрифтом те, которые выдают исключение, когда что-то идет не так, например, при попытке чтения из пустой 
очереди.

#### Таблица 9.3 - Методы Queue

|                  Функциональность                   |                          Методы                          | 
|:---------------------------------------------------:|:--------------------------------------------------------:|
|                   Добавить назад                    | public boolean add(E e) <br/>  public boolean offer(E e) |  
|                   Читать спереди                    |        public E element () <br/> public E peek()         |                                    
|               Достать и снять спереди               |        public E remove() <br/>  public E poll()          | 

Давайте покажем простой пример очереди:

```
4: Queue<Integer> queue = new LinkedList<>(); 
5: queue.add(10); 
6: queue.add(4); 
7: System.out.println(queue.remove());   // 10 
8: System.out.println(queue.peek());     // 4
```

Строки 5 и 6 добавляют элементы в очередь. В строке 7 запрашивается первый элемент, ожидающий дольше всего, выйти из 
очереди. Строка 8 проверяет наличие следующей записи в очереди, оставляя ее на месте.

Далее переходим к интерфейсу Deque. Поскольку интерфейс Deque поддерживает двойные очереди, он наследует все методы 
Queue и добавляет новые, чтобы было понятно, работаем ли мы с передней или задней частью очереди. В таблице 9.4 показаны 
методы при использовании двусторонней очереди.

#### Таблица 9.4 - Методы Deque

|    Функциональность     |                              Методы                              | 
|:-----------------------:|:----------------------------------------------------------------:|
|     Добавить вперед     | public void addFirst(E e)  <br/>  public boolean offerFirst(E e) |  
|     Добавить назад      |  public void addLast(E e) <br/>  public boolean offerLast(E e)   |
|     Читать спереди      |         public E getFirst() <br/>  public E peekFirst()          |
|      Читать сзади       |           public E getLast() <br/> public E peekLast()           |                                    
| Достать и снять спереди |        public E removeFirst() <br/>  public E pollFirst()        | 
|  Достать и снять сзади  |         public E removeLast() <br/> public E pollLast()          |

Давайте попробуем пример, работающий с обоими концами очереди:

```
Deque<Integer> deque = new LinkedList<>();
```

Это сложнее, поэтому мы используем рисунок 9.6, чтобы показать, как выглядит очередь на каждом этапе кода.

Строки 13 и 14 успешно добавляют элемент в начало и конец очереди соответственно. Некоторые очереди ограничены по 
размеру, что может привести к сбою добавления элемента в очередь. На экзамене вы не встретите такого сценария. Строка 15 
просматривает первый элемент в очереди, но не удаляет его. Строки 16 и 17 удаляют элементы из очереди, по одному с 
каждого конца. В результате получается пустая очередь. Строки 18 и 19 пытаются просмотреть первый элемент очереди, что 
приводит к нулю.

#### Рис. 9.6 - Работа с Deque


Помимо очередей FIFO, существуют очереди LIFO (последний пришел — первый обслужен), которые обычно называют стеками. 
Представьте себе стопку тарелок. Вы всегда добавляете или удаляете сверху стека, чтобы избежать беспорядка. К счастью, 
мы можем использовать те же реализации двусторонних очередей. Для ясности используются разные методы, как показано в 
Таблице 9.5.

|     Функциональность     |        Методы         | 
|:------------------------:|:---------------------:|
| Добавить спереди/сверху  | public void push(E e) |  
|  Удалить спереди/сверху  |    public E pop()     |
| Получить первый элемент  |   public E peek()     |

Давайте попробуем еще один вариант, используя Deque в качестве стека:

```
Deque<Integer> stack = new ArrayDeque<>();
```

На этот раз на рисунке 9.7 показано, как выглядит стек на каждом шаге кода. Строки 13 и 14 успешно помещают элемент в 
начало/вершину стека. Оставшийся код также отображается спереди.

При использовании Deque действительно важно определить, используется ли он в качестве очереди FIFO, стека LIFO или 
двусторонней очереди. Для сравнения, очередь FIFO похожа на очередь людей. Ты садишься сзади и выходишь спереди. Стопка 
LIFO похожа на стопку тарелок. Вы ставите тарелку на столешницу и снимаете ее с нее. Двусторонняя очередь использует оба 
конца.

#### Рис. 9.7 - Работа со стеком


## Using the Map Interface


