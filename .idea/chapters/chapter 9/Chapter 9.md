# Коллекции и дженерики

---

### ЦЕЛИ ЭКЗАМЕНА OCP, ОПИСАННЫЕ В ЭТОЙ ГЛАВЕ:

#### Работа с массивами и коллекциями

+ Создавайте массивы Java, коллекции List, Set, Map и Deque, а также добавляйте, удаляйте, обновляйте, извлекайте и 
сортируйте их элементы.

---

В этой главе мы представляем классы и интерфейсы Java Collections Framework, которые вам необходимо знать для сдачи 
экзамена. Потокобезопасные типы коллекций обсуждаются в главе 13 «Параллелизм». Как вы, возможно, помните из главы 8 
«Лямбды и функциональные интерфейсы», мы рассмотрели лямбды, ссылки на методы и встроенные функциональные интерфейсы. 
Многие из них используются в этой главе. Если функциональные интерфейсы вам незнакомы, вернитесь и просмотрите 
Таблицу 8.4. Далее мы подробно расскажем о Comparator и Comparable. Наконец, мы обсудим, как создавать собственные 
классы и методы, использующие дженерики, чтобы один и тот же класс можно было использовать со многими типами.

## Использование API общей коллекции

Коллекция — это группа объектов, содержащихся в одном объекте. Java Collections Framework — это набор классов в 
java.util для хранения коллекций. В Java Collections Framework имеется четыре основных интерфейса.

+ List (Список): Список представляет собой упорядоченный набор элементов, допускающий дублирование записей. Доступ к 
элементам списка возможен по индексу int.
+ Set (Набор): Set — это коллекция, в которой не допускается дублирование записей.
+ Queue (Очередь): Queue — это коллекция, которая упорядочивает свои элементы в определенном порядке для обработки. 
Deque — это подинтерфейс Queue, который обеспечивает доступ на обоих концах.
+ Map (Карта): Map — это коллекция, которая сопоставляет ключи со значениями, дублирование ключей не допускается. 
Элементы карты представляют собой пары ключ/значение.

На рисунке 9.1 показан интерфейс Collection, его подинтерфейсы и некоторые классы, реализующие интерфейсы, которые 
вам следует знать для экзамена. Интерфейсы показаны в прямоугольниках, а классы — в закругленных прямоугольниках.

Обратите внимание, что Map не реализует интерфейс Collection. Он считается частью Java Collections Framework, хотя 
технически он не является Collection. Однако это коллекция (обратите внимание на строчные буквы), поскольку она содержит 
группу объектов. Причина, по которой карты обрабатываются по-разному, заключается в том, что им нужны разные методы, 
поскольку они представляют собой пары ключ/значение.

#### Рис. 9.1 - Java Collections Framework

В этом разделе мы обсудим общие методы, которые API коллекций предоставляет реализующим классам. Многие из этих методов 
представляют собой _удобные методы_, которые можно реализовать другими способами, но которые упрощают написание и чтение 
кода. Именно поэтому они удобны.

В этом разделе мы используем ArrayList и HashSet в качестве классов реализации, но они могут применяться к любому 
классу, наследующему интерфейс Collection. В следующем разделе мы рассмотрим конкретные свойства каждого класса 
Collection.

### Использование diamond оператора

При создании Java Collections Framework вам необходимо указать тип, который будет входить внутрь. Мы могли бы написать 
код, используя дженерики, подобные следующему:

```
List<Integer> list = new ArrayList<Integer>();
```

У вас могут даже быть дженерики, содержащие другие дженерики, например этот:

```
Map<Long,List<Integer>> mapLists = new HashMap<Long,List<Integer>>();
```

Нужно написать много дублированного кода! К счастью, оператор ромба (diamond operator) (<>) — это сокращенная запись, 
позволяющая опустить общий тип в правой части оператора, когда тип можно вывести. Он называется оператором ромба, потому 
что <> выглядит как ромб. Сравните предыдущие объявления с этими новыми, гораздо более короткими версиями:

```
List<Integer> list = new ArrayList<>(); 
Map<Long,List<Integer>> mapOfLists = new HashMap<>();
```

Для компилятора оба этих объявления и наши предыдущие эквивалентны. Однако для нас последний вариант намного короче и 
его легче читать.

Оператор ромба нельзя использовать в качестве типа в объявлении переменной. Его можно использовать только в правой части 
операции присваивания. Например, ни одно из следующих действий не компилируется:

```
List<> list = new ArrayList<Integer>();      // НЕ КОМПИЛИРУЕТСЯ

class InvalidUse {
    void use(List<> data) {}                 // НЕ КОМПИЛИРУЕТСЯ
}
```

### Добавление данных

Метод add() вставляет новый элемент в коллекцию и возвращает информацию о том, был ли он успешным. Сигнатура метода 
следующая:

```
public boolean add(E element)
```

Помните, что Collections Framework использует дженерики. Вы будете часто видеть, как буква E появляется. Это означает
универсальный тип, который использовался для создания коллекции. Для некоторых типов коллекций add() всегда возвращает 
true. Для других типов существует логика определения того, был ли вызов add() успешным. Ниже показано, как использовать 
этот метод:

```
3: Collection<String> list = new ArrayList<>(); 
4: System.out.println(list.add("Sparrow")); // true 
5: System.out.println(list.add("Sparrow")); // true 
6:
7: Collection<String> set = new HashSet<>(); 
8: System.out.println(set.add("Sparrow")); // true 
9: System.out.println(set.add("Sparrow")); // false
```

List допускает дубликаты, каждый раз возвращая значение true. Set не допускает дубликатов. В строке 9 мы попытались 
добавить дубликат, чтобы Java возвращала false из метода add().

### Удаление данных

Метод remove() удаляет одно совпадающее значение в коллекции и возвращает информацию о том, было ли оно успешным. 
Сигнатура метода следующая:

```
public boolean remove(Object object)
```

На этот раз возвращаемое boolean значение сообщает нам, было ли удалено совпадение. Ниже показано, как использовать этот 
метод:

```
3: Collection<String> birds = new ArrayList<>();
4: birds.add("hawk");                            // [hawk]
5: birds.add("hawk");                            // [hawk, hawk] 
6: System.out.println(birds.remove("cardinal")); // false 
7: System.out.println(birds.remove("hawk"));     // true 
8: System.out.println(birds);                    // [hawk]
```

Строка 6 пытается удалить элемент, которого нет в birds. Он возвращает false, поскольку такой элемент не найден. Строка 
7 пытается удалить элемент, принадлежащий birds, поэтому возвращает true. Обратите внимание: удаляется только одно 
совпадение.

### Подсчет элементов

Методы isEmpty() и size() смотрят, сколько элементов содержится в коллекции. Сигнатуры методов такие:

```
public boolean isEmpty() 
public int size()
```

Ниже показано, как использовать эти методы:

```
Collection<String> birds = new ArrayList<>(); 
System.out.println(birds.isEmpty()); // true 
System.out.println(birds.size());    // 0 
birds.add("hawk");                   // [hawk] 
birds.add("hawk");                   // [hawk, hawk] 
System.out.println(birds.isEmpty()); // false 
System.out.println(birds.size());    // 2
```

В начале, birds имеет размер 0 и пуст. Его емкость больше 0. После того, как мы добавим элементы, размер станет 
положительным, и он больше не будет пустым.

### Очистка коллекции

Метод clear() предоставляет простой способ удалить все элементы коллекции. Сигнатура метода следующая:

```
public void clear()
```

Ниже показано, как использовать этот метод:

```
Collection<String> birds = new ArrayList<>(); 
birds.add("hawk");                   // [hawk] 
birds.add("hawk");                   // [hawk, hawk] 
System.out.println(birds.isEmpty()); // false 
System.out.println(birds.size());    // 2 
birds.clear();                       // []
System.out.println(birds.isEmpty()); // true
System.out.println(birds.size());    // 0
```

После вызова метода clear(), birds снова становится пустым ArrayList размером 0.

### Проверить содержимое

Метод contains() проверяет, присутствует ли определенное значение в коллекции. Сигнатура метода следующая:

```
public boolean contains(Object object)
```

Ниже показано, как использовать этот метод:

```
Collection<String> birds = new ArrayList<>(); 
birds.add("hawk"); // [hawk] 
System.out.println(birds.contains("hawk"));  // true 
System.out.println(birds.contains("robin")); // false
```

Метод contains() вызывает метод equals() для элементов ArrayList, чтобы проверить, есть ли совпадения.

### Удаление с условиями

Метод removeIf() удаляет все элементы, соответствующие условию. Мы можем указать, что следует удалить, используя блок 
кода или даже ссылку на метод.

Сигнатура метода выглядит следующим образом. (Мы объясним, что означает символ ? super, в разделе «Работа с дженериками» 
далее в этой главе.)

```
public boolean removeIf(Predicate<? super E> filter)
```

Он использует Predicate, который принимает один параметр и возвращает логическое значение. Давайте посмотрим на пример:

```
4: Collection<String> list = new ArrayList<>(); 
5: list.add("Magician"); 
6: list.add("Assistant"); 
7: System.out.println(list);     // [Magician, Assistant] 
8: list.removeIf(s -> s.startsWith("A")); 
9: System.out.println(list);     // [Magician]
```

В строке 8 показано, как удалить все String значения, начинающиеся с буквы A. Это позволяет нам исчезнуть с Assistant. 
Давайте попробуем пример со ссылкой на метод:

```
11: Collection<String> set = new HashSet<>(); 
12: set.add("Wand"); 
13: set.add("");
14: set.removeIf(String::isEmpty); // s -> s.isEmpty() 
15: System.out.println(set);       // [Wand]
```

В строке 14 мы удаляем из set все пустые объекты String. Комментарий к этой строке показывает лямбда-эквивалент ссылки 
на метод. В строке 15 показано, что метод removeIf() успешно удалил один элемент из list.

### Итерация (Iterating)

Существует метод forEach(), который вы можете вызывать для коллекции вместо написания цикла. Он использует Consumer, 
который принимает один параметр и ничего не возвращает. Сигнатура метода следующая:

```
public void forEach(Consumer<? super T> action)
```

Cats любят исследовать, поэтому давайте распечатаем два из них, используя как ссылки на методы, так и лямбда-выражения:

```
Collection<String> cats = List.of("Annie", "Ripley"); 
cats.forEach(System.out::println); 
cats.forEach(c -> System.out.println(c));
```

Cats научились писать свои имена. Теперь у них есть больше времени для игры (как и у нас)!

**Другие подходы к итерации**

Есть и другие способы перебирать коллекции. Например, в главе 3 «Принятие решений» вы видели, как перебирать список с 
помощью расширенного цикла for.

```
for (String element: coll)
  System.out.println(element);
```

Вы можете увидеть другой старый подход.

```
Iterator<String> iter = coll.iterator();
while(iter.hasNext()) {
   String string = iter.next();
   System.out.println(string);    
}
```

Обратите внимание на разницу между этими приемами. Метод hasNext() проверяет, существует ли следующее значение. Другими 
словами, он сообщает вам, будет ли выполняться функция next() без выдачи исключения. Метод next() фактически перемещает
Iterator к следующему элементу.

### Определение равенства

Существует специальная реализация метода equals(), поэтому вы можете сравнивать две коллекции, чтобы сравнить их тип и 
содержимое. Реализация будет разной. Например, ArrayList проверяет порядок, а HashSet — нет.

```
boolean equals(Object object)
```

Ниже приведен пример:

```
23: var list1 = List.of(1, 2); 
24: var list2 = List.of(2, 1); 
25: var set1 = Set.of(1, 2); 
26: var set2 = Set.of(2, 1);
27:
28: System.out.println(list1.equals(list2));  // false 
29: System.out.println(set1.equals(set2));    // true 
30: System.out.println(list1.equals(set1));   // false
```

В строке 28 выводится false, потому что элементы расположены в другом порядке, а List заботится о порядке. Напротив, 
строка 29 печатает true, потому что Set не чувствителен к порядку. Наконец, строка 30 выводит false, поскольку типы 
разные.

**Распаковка nulls**

Java защищает нас от многих проблем с коллекциями. Однако написать исключение NullPointerException все же можно:

```
3: var heights = new ArrayList<Integer>();
4: heights.add(null);
5: int h = heights.get(0);          // NullPointerException
```

В строке 4 мы добавляем в список null. Это законно, поскольку null ссылка может быть присвоена любой ссылочной 
переменной. В строке 5 мы пытаемся распаковать этот null в примитив int. Это проблема. Java пытается получить значение 
int, равное null. Поскольку вызов любого метода для значения null приводит к исключению NullPointerException, именно это 
мы и получаем. Будьте осторожны, когда вы видите значение null в отношении автобокса.

## Использование интерфейса List

Теперь, когда вы знакомы с некоторыми распространенными методами интерфейса Collection, давайте перейдем к конкретным 
интерфейсам. Список используется, если вам нужна упорядоченная коллекция, которая может содержать повторяющиеся записи. 
Например, список имен может содержать дубликаты, поскольку у двух животных может быть одно и то же имя. Элементы можно 
извлекать и вставлять в определенные позиции в списке на основе индекса int, аналогично массиву. Однако, в отличие от 
массива, многие реализации List могут изменяться в размере после их объявления.

Списки широко используются, потому что в программировании существует множество ситуаций, когда вам необходимо 
отслеживать список объектов. Например, вы можете составить список того, что вы хотите увидеть в зоопарке: во-первых, 
увидеть львов, потому что они рано ложатся спать; во-вторых, посмотрите на панд, потому что позже в тот же день 
выстраивается длинная очередь; и так далее.

На рис. 9.2 показано, как можно представить список. Каждый элемент списка имеет индекс, и индексы начинаются с нуля.

#### Рис. 9.2 - Пример List



Иногда вам не важен порядок элементов в списке. Список похож на тип данных «go to». Когда мы составляем список покупок 
перед походом в магазин, его порядок совпадает с порядком, в котором мы думали о товарах. Мы, вероятно, не привязаны к 
этому конкретному порядку, но это ничему не повредит.

Хотя классы, реализующие интерфейс List, имеют множество методов, вам необходимо знать только наиболее распространенные 
из них. Удобно, что эти методы одинаковы для всех реализаций, которые могут появиться на экзамене.

Главное, что объединяет все реализации List, — это то, что они упорядочены и допускают дублирование. Помимо этого, 
каждый из них предлагает разные функциональные возможности. Мы рассмотрим реализации, которые вам необходимо знать, и 
доступные методы.

_Обратите особое внимание на то, какие имена являются классами, а какие интерфейсами. На экзамене вас могут спросить, 
какой класс лучше или какой интерфейс лучше всего подходит для конкретного сценария._

### Сравнение реализаций List

ArrayList похож на массив с изменяемым размером. При добавлении элементов ArrayList автоматически увеличивается. Если вы 
не уверены, какую коллекцию использовать, используйте ArrayList.

Основное преимущество ArrayList заключается в том, что вы можете искать любой элемент за постоянное время. Добавление 
или удаление элемента происходит медленнее, чем доступ к элементу. Это делает ArrayList хорошим выбором, когда вы 
читаете чаще (или столько же), сколько записываете в ArrayList.

LinkedList особенный, поскольку он реализует как List, так и Deque. Он имеет все методы List. Он также имеет 
дополнительные методы для облегчения добавления или удаления из начала и/или конца списка.

Основные преимущества LinkedList заключаются в том, что вы можете получать доступ, добавлять и удалять элементы из 
начала и конца списка за постоянное время. Компромисс заключается в том, что работа с произвольным индексом занимает 
линейное время. Это делает LinkedList хорошим выбором, когда вы будете использовать его в качестве Deque. Как вы видели 
на рисунке 9.1, LinkedList реализует интерфейсы List и Deque.

### Создание List с помощью фабрики

Когда вы создаете список типа ArrayList или LinkedList, вы знаете его тип. Существует несколько специальных методов, с 
помощью которых вы возвращаете список, но не знаете его тип. Эти методы позволяют создать список, включающий данные в 
одну строку, используя фабричный метод. Это удобно, особенно при тестировании. Некоторые из этих методов возвращают 
неизменяемый объект. Как мы видели в главе 6 «Проектирование классов», неизменяемый объект нельзя изменить или 
модифицировать. В таблице 9.1 суммированы эти три списка.

#### Таблица 9.1 - Фабричные методы для создания List

|          Метод          |                                Описание                                | Можете добавить элементы? |   Можно ли заменить элементы?   |   Можно ли удалять элементы?   |  
|:-----------------------:|:----------------------------------------------------------------------:|:-------------------------:|:-------------------------------:|:------------------------------:|
| Arrays.asList(varargs)  | Возвращает список фиксированного <br/> размера, подкрепленный массивом |            Нет            |               Да                |              Нет               |
|    List.of(varargs)     |                     Возвращает неизменяемый список                     |            Нет            |               Нет               |              Нет               |                                     
| List.copyOf(collection) |  Возвращает неизменяемый список с копией значений исходной коллекции   |            Нет            |               Нет               |              Нет               |

Давайте рассмотрим пример этих трех методов:

```
16: String[] array = new String[] {"a", "b", "c"}; 
17: List<String> asList = Arrays.asList(array); // [a, b, c] 
18: List<String> of = List.of(array);           // [a, b, c] 
19: List<String> copy = List.copyOf(asList);    // [a, b, c]
20:
21: array[0] = "z";
22:
23: System.out.println(asList);                 // [z, b, c] 
24: System.out.println(of);                     // [a, b, c] 
25: System.out.println(copy);                   // [a, b, c]
26:
27: asList.set(0, "x"); 
28: System.out.println(Arrays.toString(array)); // [x, b, c]
29:
30: copy.add("y");            // UnsupportedOperationException
```

Строка 17 создает List, поддерживаемый массивом. Строка 21 изменяет массив, а строка 23 отражает это изменение. 
Строки 27 и 28 показывают другое направление, когда изменение List обновляет базовый массив. Строки 18 и 19 создают 
неизменяемый List. Строка 30 показывает, что он является неизменяемым, выдавая исключение при попытке добавить значение. 
Все три списка выдадут исключение при добавлении или удалении значения. Списки of и copy также выдают ошибку при попытке 
обновления элемента.

### Создание List с помощью конструктора

В большинстве коллекций есть два конструктора, которые вам необходимо знать для экзамена. Ниже показаны их для 
LinkedList:

```
var linked1 = new LinkedList<String>();
var linked2 = new LinkedList<String>(linked1);
```

Первый говорит о создании пустого LinkedList, содержащего все значения по умолчанию. Второй сообщает Java, что мы хотим 
сделать копию другого LinkedList. Конечно, в этом примере linked1 пуст, поэтому он не представляет особого интереса.

В ArrayList есть дополнительный конструктор, о котором вам нужно знать. Теперь мы покажем три конструктора:

```
var list1 = new ArrayList<String>();
var list2 = new ArrayList<String>(list1);
var list3 = new ArrayList<String>(10);
```

Первые два — это общие конструкторы, которые вам нужно знать для всех коллекций. В последнем примере говорится о 
создании ArrayList, содержащего определенное количество слотов, но опять же не назначать их. Вы можете думать об этом 
как о размере базового массива.

**Использование var с ArrayList**

Рассмотрим этот код, в котором сочетаются var и дженерики:

```
var strings = new ArrayList<String>();
strings.add("a");
for (String s: strings) {  }
```

Тип переменной — ArrayList<String>. Это означает, что вы можете добавить String или перебрать объекты String. Что, если 
мы используем diamond оператор с var?

```
var list = new ArrayList<>();
```

Хотите верьте, хотите нет, но это компилируется. Тип переменной var — ArrayList<Object>. Поскольку для универсального 
типа не указан тип, Java должен принять окончательный суперкласс. Это немного глупо и неожиданно, поэтому, пожалуйста, 
не пишите это. Но если вы увидите это на экзамене, вы будете знать, чего ожидать. Теперь вы можете понять, почему это не 
компилируется?

```
var list = new ArrayList<>();
list.add("a");
for (String s: list) { } // НЕ КОМПИЛИРУЕТСЯ
```

Тип переменной var — ArrayList<Object>. Поскольку daimond оператор не имеет типа, Java должен использовать самый общий 
вариант, какой только может. Поэтому он выбирает Object, высший суперкласс. Добавление String в список — это нормально. 
Вы можете добавить любой подкласс Object. Однако в цикле нам нужно использовать тип Object, а не String.

### Работа с методами List

Методы интерфейса List предназначены для работы с индексами. Помимо унаследованных методов Collection, сигнатуры 
методов, которые вам необходимо знать, приведены в таблице 9.2.

#### Таблица 9.2 - Методы List

|                        Метод                        |                                                          Опсиание                                                           | 
|:---------------------------------------------------:|:---------------------------------------------------------------------------------------------------------------------------:|
|            public boolean add(E element)            |                                 Добавляет элемент в конец (доступно во всех API коллекций).                                 |  
|        public void add(int index, E element)        |                             Добавляет элемент по индексу и перемещает оставшуюся часть в конец.                             |                                    
|               public E get(int index)               |                                               Возвращает элемент по индексу.                                                | 
|             public E remove(int index)              |                                  Удаляет элемент по индексу и перемещает остальные вперед.                                  | 
| public default void replaceAll(UnaryOperator<E> op) |                                   Заменяет каждый элемент в списке результатом оператора.                                   | 
|            public E set(int index, E e)             | Заменяет элемент по индексу и возвращает оригинал. Выдает исключение IndexOutOfBoundsException, если индекс недействителен. |
| public default void sort(Comparator<? super E> c)   |                     Сортирует список. Мы рассмотрим это позже в главе, в разделе «Сортировка данных».                       |

Следующие операторы демонстрируют большинство этих методов работы со списком:

```
3:  List<String> list = new ArrayList<>();
4:  list.add("SD");                  // [SD] 
5:  list.add(0, "NY");               // [NY,SD] 
6:  list.set(1, "FL");               // [NY,FL] 
7:  System.out.println(list.get(0)); // NY 
8:  list.remove("NY");               // [FL] 
9:  list.remove(0);                  // [] 
10: list.set(0, "?");                // IndexOutOfBoundsException
```

В строке 3 list начинается пустым. Строка 4 добавляет элемент в конец списка. В строке 5 добавляется элемент с индексом 
0, который увеличивает исходный индекс 0 до индекса 1. Обратите внимание, что ArrayList теперь автоматически 
увеличивается на единицу. В строке 6 элемент с индексом 1 заменяется новым значением.

В строке 7 используется метод get() для печати элемента по определенному индексу. Строка 8 удаляет элемент, 
соответствующий NY. Наконец, строка 9 удаляет элемент с индексом 0, и список снова становится пустым.

В строке 10 выбрасывается исключение IndexOutOfBoundsException, поскольку в List нет элементов. Поскольку элементов для 
замены нет, даже индекс 0 не допускается. Если строку 10 переместить вверх между строками 4 и 5, вызов будет успешным.

Результат будет таким же, если вы попробуете эти примеры с LinkedList. Хотя код будет менее эффективным, это не будет 
заметно, пока у вас не будут очень большие списки.

Теперь давайте взглянем на метод replaceAll(). Он использует UnaryOperator, который принимает один параметр и возвращает 
значение того же типа:

```
var numbers = Arrays.asList(1, 2, 3);
numbers.replaceAll(x -> x*2);
System.out.println(numbers);   // [2, 4, 6]
```

Эта лямбда удваивает значение каждого элемента в списке. Метод replaceAll() вызывает лямбду для каждого элемента списка 
и заменяет значение по этому индексу.

**Перегруженные методы remove()**

Мы рассмотрели два перегруженных метода remove(). Тот, что из коллекции, удаляет объект, соответствующий параметру. 
Напротив, элемент из List удаляет элемент по указанному индексу.

Это становится сложнее, если у вас есть тип Integer. Как вы думаете, что означают следующие печати?

```
31: var list = new LinkedList<Integer>(); 
32: list.add(3); 33: list.add(2); 
34: list.add(1); 35: list.remove(2); 
36: list.remove(Integer.valueOf(2)); 
37: System.out.println(list);
```

Правильный ответ: [3]. Давайте посмотрим, как мы туда попали. В конце строки 34 у нас есть [3, 2, 1]. В строке 35 
передается примитив, что означает, что мы запрашиваем удаление элемента с индексом 2. В результате у нас остается 
[3, 2]. Затем в строке 36 передается объект Integer, что означает, что мы удаляем значение 2. Это подводит нас к 
[3].

Поскольку вызов метода remove() с числом int использует индекс, несуществующий индекс вызовет/выбросит исключение. 
Например, list.remove(100) выдает исключение IndexOutOfBoundsException.

### Преобразование List в массив

Поскольку массив можно передать как vararg, в таблице 9.1 показано, как преобразовать массив в список. Вы также должны 
знать, как сделать обратное. Начнем с преобразования списка в массив:

```
13: List<String> list = new ArrayList<>(); 
14: list.add("hawk"); 
15: list.add("robin"); 
16: Object[] objectArray = list.toArray(); 
17: String[] stringArray = list.toArray(new String[0]); 
18: list.clear(); 
19: System.out.println(objectArray.length);     // 2 
20: System.out.println(stringArray.length);     // 2
```

Строка 16 показывает, что List знает, как преобразовать себя в массив. Единственная проблема заключается в том, что по 
умолчанию используется массив класса Object. Обычно это не то, чего вы хотите. Строка 17 определяет тип массива и делает 
то, что мы хотим. Преимущество указания размера 0 для параметра заключается в том, что Java создаст новый массив 
подходящего размера для возвращаемого значения. Если хотите, вы можете предложить вместо этого использовать больший 
массив. Если List помещается в этот массив, он будет возвращен. В противном случае будет создан новый массив.

Также обратите внимание, что строка 18 очищает исходный List. Это не влияет ни на один массив. Массив представляет собой 
недавно созданный объект, не имеющий отношения к исходному List. Это просто копия.

## Использование интерфейса Set